# ash

## v3.5.33





# Table of contents

1. Home 
2. Start Here  
	1. Get Started 

3. About Ash  
	1. What is Ash? 
	2. Design Principles 
	3. Contributing to Ash 
	4. Alternatives 
	5. Changelog 

4. Development  
	1. Project Structure 
	2. Working with LLMs 
	3. Generators 
	4. Error Handling 
	5. Testing 
	6. Development Utilities 
	7. Backwards Compatibility Config 
	8. Upgrade 

5. Reference  
	1. Ash.Resource 
	2. Ash.Domain 
	3. Ash.Notifier.PubSub 
	4. Ash.Policy.Authorizer 
	5. Ash.DataLayer.Ets 
	6. Ash.DataLayer.Mnesia 
	7. Ash.Reactor 
	8. Glossary 
	9. Expressions 

6. Resources  
	1. Domains 
	2. Attributes 
	3. Relationships 
	4. Calculations 
	5. Aggregates 
	6. Validations 
	7. Changes 
	8. Preparations 
	9. Code Interface 
	10. Embedded Resources 
	11. Identities 
	12. Notifiers 

7. Actions  
	1. Actions 
	2. Read Actions 
	3. Create Actions 
	4. Update Actions 
	5. Destroy Actions 
	6. Generic Actions 
	7. Manual Actions 

8. Security  
	1. Actors & Authorization 
	2. Sensitive Data 
	3. Policies 

9. Advanced  
	1. Manual Installation 
	2. Multi-Step Actions 
	3. Reactor 
	4. Monitoring 
	5. Pagination 
	6. Combination Queries 
	7. Timeouts 
	8. Multitenancy 
	9. Writing Extensions 

10. How To  
	1. Write Queries 
	2. Define Polymorphic Relationships 
	3. Test Resources 
	4. Authorize Access to Resources 
	5. Encrypt Attributes 
	6. Prevent concurrent writes 
	7. Wrap External APIs 

11. Moved  
	1. Upgrade 

12.  Modules  
	1. Core API  
		1. Ash 
		2. Ash.ActionInput 
		3. Ash.Changeset 
		4. Ash.Query 

	2. Resources  
		1. Ash.CodeInterface 
		2. Ash.Domain 
		3. Ash.Notifier 
		4. Ash.Notifier.Notification 
		5. Ash.Resource.Calculation 
		6. Ash.Resource.Calculation.Builtins 
		7. Ash.Resource.ManualCreate 
		8. Ash.Resource.ManualDestroy 
		9. Ash.Resource.ManualRead 
		10. Ash.Resource.ManualRelationship 
		11. Ash.Resource.ManualUpdate 

	3. Queries  
		1. Ash.Query.Aggregate 
		2. Ash.Query.Calculation 
		3. Ash.Resource.Preparation 
		4. Ash.Resource.Preparation.Builtins 

	4. Changes  
		1. Ash.Resource.Change 
		2. Ash.Resource.Change.Builtins 

	5. Validations  
		1. Ash.Resource.Validation 
		2. Ash.Resource.Validation.Builtins 

	6. Authorization  
		1. Ash.Authorizer 
		2. Ash.Policy.Check 
		3. Ash.Policy.FilterCheck 
		4. Ash.Policy.SimpleCheck 
		5. Ash.Policy.Check.Builtins 

	7. Extensions  
		1. Ash.DataLayer.Ets 
		2. Ash.DataLayer.Mnesia 
		3. Ash.DataLayer.Simple 
		4. Ash.Notifier.PubSub 
		5. Ash.Policy.Authorizer 
		6. Ash.Reactor 
		7. Ash.Resource 

	8. Introspection  
		1. Ash.DataLayer.Ets.Info 
		2. Ash.DataLayer.Mnesia.Info 
		3. Ash.Domain.Info 
		4. Ash.Notifier.PubSub.Info 
		5. Ash.Policy.Info 
		6. Ash.Resource.Info 

	9. Visualizations  
		1. Ash.Domain.Info.Diagram 
		2. Ash.Domain.Info.Livebook 
		3. Ash.Policy.Chart.Mermaid 

	10. Testing  
		1. Ash.Generator 
		2. Ash.Seed 
		3. Ash.Test 

	11. Builtins  
		1. Ash.Policy.Check.AccessingFrom 
		2. Ash.Policy.Check.Action 
		3. Ash.Policy.Check.ActionType 
		4. Ash.Policy.Check.ActorAbsent 
		5. Ash.Policy.Check.ActorAttributeEquals 
		6. Ash.Policy.Check.ActorPresent 
		7. Ash.Policy.Check.ChangingAttributes 
		8. Ash.Policy.Check.ChangingRelationships 
		9. Ash.Policy.Check.ContextEquals 
		10. Ash.Policy.Check.Expression 
		11. Ash.Policy.Check.FilteringOn 
		12. Ash.Policy.Check.Loading 
		13. Ash.Policy.Check.Matches 
		14. Ash.Policy.Check.RelatesToActorVia 
		15. Ash.Policy.Check.RelatingToActor 
		16. Ash.Policy.Check.Resource 
		17. Ash.Policy.Check.Selecting 
		18. Ash.Policy.Check.Static 
		19. Ash.Resource.Change.CascadeDestroy 
		20. Ash.Resource.Change.CascadeUpdate 
		21. Ash.Resource.Change.Context 
		22. Ash.Resource.Change.GetAndLock 
		23. Ash.Resource.Change.GetAndLockForUpdate 
		24. Ash.Resource.Change.Increment 
		25. Ash.Resource.Change.OptimisticLock 
		26. Ash.Resource.Validation.ActionIs 
		27. Ash.Resource.Validation.Context 

	12. Tracing  
		1. Ash.Tracer 
		2. Ash.Tracer.Simple 
		3. Ash.Tracer.Simple.Span 

	13. Utilities  
		1. Ash.BulkResult 
		2. Ash.Changeset.ManagedRelationshipHelpers 
		3. Ash.CiString 
		4. Ash.Expr 
		5. Ash.Filter 
		6. Ash.Filter.Runtime 
		7. Ash.Filter.Simple 
		8. Ash.Filter.Simple.Not 
		9. Ash.ForbiddenField 
		10. Ash.Mix.Tasks.Helpers 
		11. Ash.NotLoaded 
		12. Ash.OptionsHelpers 
		13. Ash.Page 
		14. Ash.Page.Keyset 
		15. Ash.Page.Offset 
		16. Ash.PlugHelpers 
		17. Ash.ProcessHelpers 
		18. Ash.Resource.Builder 
		19. Ash.SatSolver 
		20. Ash.Sort 
		21. Ash.UUID 
		22. Ash.UUIDv7 
		23. Ash.Union 
		24. Ash.Vector 

	14. Types  
		1. Ash.Type 
		2. Ash.Type.Atom 
		3. Ash.Type.Binary 
		4. Ash.Type.Boolean 
		5. Ash.Type.CiString 
		6. Ash.Type.Comparable 
		7. Ash.Type.Date 
		8. Ash.Type.DateTime 
		9. Ash.Type.Decimal 
		10. Ash.Type.Duration 
		11. Ash.Type.DurationName 
		12. Ash.Type.Enum 
		13. Ash.Type.File 
		14. Ash.Type.File.Implementation 
		15. Ash.Type.File.Source 
		16. Ash.Type.Float 
		17. Ash.Type.Function 
		18. Ash.Type.Integer 
		19. Ash.Type.Keyword 
		20. Ash.Type.Map 
		21. Ash.Type.Module 
		22. Ash.Type.NaiveDatetime 
		23. Ash.Type.NewType 
		24. Ash.Type.String 
		25. Ash.Type.Struct 
		26. Ash.Type.Term 
		27. Ash.Type.Time 
		28. Ash.Type.TimeUsec 
		29. Ash.Type.Tuple 
		30. Ash.Type.UUID 
		31. Ash.Type.UUIDv7 
		32. Ash.Type.Union 
		33. Ash.Type.UrlEncodedBinary 
		34. Ash.Type.UtcDatetime 
		35. Ash.Type.UtcDatetimeUsec 
		36. Ash.Type.Vector 

	15. Errors  
		1. Ash.Error 
		2. Ash.Error.Action.InvalidArgument 
		3. Ash.Error.Changes.ActionRequiresActor 
		4. Ash.Error.Changes.InvalidArgument 
		5. Ash.Error.Changes.InvalidAttribute 
		6. Ash.Error.Changes.InvalidChanges 
		7. Ash.Error.Changes.InvalidRelationship 
		8. Ash.Error.Changes.NoSuchAttribute 
		9. Ash.Error.Changes.NoSuchRelationship 
		10. Ash.Error.Changes.Required 
		11. Ash.Error.Changes.StaleRecord 
		12. Ash.Error.Exception 
		13. Ash.Error.Forbidden 
		14. Ash.Error.Forbidden.CannotFilterCreates 
		15. Ash.Error.Forbidden.DomainRequiresActor 
		16. Ash.Error.Forbidden.DomainRequiresAuthorization 
		17. Ash.Error.Forbidden.ForbiddenField 
		18. Ash.Error.Forbidden.InitialDataRequired 
		19. Ash.Error.Forbidden.MustPassStrictCheck 
		20. Ash.Error.Forbidden.Placeholder 
		21. Ash.Error.Forbidden.Policy 
		22. Ash.Error.Framework 
		23. Ash.Error.Framework.AssumptionFailed 
		24. Ash.Error.Framework.CanNotBeAtomic 
		25. Ash.Error.Framework.FlagAssertionFailed 
		26. Ash.Error.Framework.InvalidReturnType 
		27. Ash.Error.Framework.MustBeAtomic 
		28. Ash.Error.Framework.PendingCodegen 
		29. Ash.Error.Framework.SynchronousEngineStuck 
		30. Ash.Error.Framework.UnsupportedSubject 
		31. Ash.Error.Invalid 
		32. Ash.Error.Invalid.ActionRequiresPagination 
		33. Ash.Error.Invalid.AtomicsNotSupported 
		34. Ash.Error.Invalid.InvalidActionType 
		35. Ash.Error.Invalid.InvalidCustomInput 
		36. Ash.Error.Invalid.InvalidPrimaryKey 
		37. Ash.Error.Invalid.LimitRequired 
		38. Ash.Error.Invalid.MultipleResults 
		39. Ash.Error.Invalid.NoIdentityFound 
		40. Ash.Error.Invalid.NoMatchingBulkStrategy 
		41. Ash.Error.Invalid.NoPrimaryAction 
		42. Ash.Error.Invalid.NoSuchAction 
		43. Ash.Error.Invalid.NoSuchInput 
		44. Ash.Error.Invalid.NoSuchResource 
		45. Ash.Error.Invalid.NonCountableAction 
		46. Ash.Error.Invalid.NonStreamableAction 
		47. Ash.Error.Invalid.PaginationRequired 
		48. Ash.Error.Invalid.ResourceNotAllowed 
		49. Ash.Error.Invalid.TenantRequired 
		50. Ash.Error.Invalid.Timeout 
		51. Ash.Error.Invalid.TimeoutNotSupported 
		52. Ash.Error.Invalid.Unavailable 
		53. Ash.Error.Load.InvalidQuery 
		54. Ash.Error.Load.NoSuchRelationship 
		55. Ash.Error.Page.InvalidKeyset 
		56. Ash.Error.Query.AggregatesNotSupported 
		57. Ash.Error.Query.CalculationRequiresPrimaryKey 
		58. Ash.Error.Query.CalculationsNotSupported 
		59. Ash.Error.Query.InvalidArgument 
		60. Ash.Error.Query.InvalidCalculationArgument 
		61. Ash.Error.Query.InvalidExpression 
		62. Ash.Error.Query.InvalidFilterReference 
		63. Ash.Error.Query.InvalidFilterValue 
		64. Ash.Error.Query.InvalidLimit 
		65. Ash.Error.Query.InvalidLoad 
		66. Ash.Error.Query.InvalidOffset 
		67. Ash.Error.Query.InvalidPage 
		68. Ash.Error.Query.InvalidQuery 
		69. Ash.Error.Query.InvalidSortOrder 
		70. Ash.Error.Query.LockNotSupported 
		71. Ash.Error.Query.NoComplexSortsWithKeysetPagination 
		72. Ash.Error.Query.NoReadAction 
		73. Ash.Error.Query.NoSuchAttribute 
		74. Ash.Error.Query.NoSuchField 
		75. Ash.Error.Query.NoSuchFilterPredicate 
		76. Ash.Error.Query.NoSuchFunction 
		77. Ash.Error.Query.NoSuchOperator 
		78. Ash.Error.Query.NoSuchRelationship 
		79. Ash.Error.Query.NotFound 
		80. Ash.Error.Query.ReadActionRequired 
		81. Ash.Error.Query.ReadActionRequiresActor 
		82. Ash.Error.Query.Required 
		83. Ash.Error.Query.UnsortableField 
		84. Ash.Error.Query.UnsupportedPredicate 
		85. Ash.Error.SimpleDataLayer.NoDataProvided 
		86. Ash.Error.Stacktrace 
		87. Ash.Error.Unknown 
		88. Ash.Error.Unknown.UnknownError 

	16. DSL Transformers  
		1. Ash.DataLayer.Verifiers.RequirePreCheckWith 
		2. Ash.Notifier.PubSub.Verifiers.VerifyActionNames 
		3. Ash.Domain.Verifiers.EnsureNoEmbeds 
		4. Ash.Domain.Verifiers.ValidateArgumentsToCodeInterface 
		5. Ash.Domain.Verifiers.ValidateRelatedResourceInclusion 
		6. Ash.Policy.Authorizer.Transformers.AddMissingFieldPolicies 
		7. Ash.Policy.Authorizer.Transformers.CacheFieldPolicies 
		8. Ash.Resource.Transformers.AttributesByName 
		9. Ash.Resource.Transformers.BelongsToAttribute 
		10. Ash.Resource.Transformers.CacheActionInputs 
		11. Ash.Resource.Transformers.CacheCalculations 
		12. Ash.Resource.Transformers.CachePrimaryKey 
		13. Ash.Resource.Transformers.CacheRelationships 
		14. Ash.Resource.Transformers.CacheUniqueKeys 
		15. Ash.Resource.Transformers.CreateJoinRelationship 
		16. Ash.Resource.Transformers.DefaultAccept 
		17. Ash.Resource.Transformers.GetByReadActions 
		18. Ash.Resource.Transformers.HasDestinationField 
		19. Ash.Resource.Transformers.ManyToManyDestinationAttributeOnJoinResource 
		20. Ash.Resource.Transformers.ManyToManySourceAttributeOnJoinResource 
		21. Ash.Resource.Transformers.RequireUniqueActionNames 
		22. Ash.Resource.Transformers.RequireUniqueFieldNames 
		23. Ash.Resource.Transformers.SetPrimaryActions 
		24. Ash.Resource.Transformers.SetRelationshipSource 
		25. Ash.Resource.Transformers.ValidationsAndChangesForType 
		26. Ash.Resource.Verifiers.EnsureAggregateFieldIsAttributeOrCalculation 
		27. Ash.Resource.Verifiers.NoReservedFieldNames 
		28. Ash.Resource.Verifiers.ValidateAccept 
		29. Ash.Resource.Verifiers.ValidateActionTypesSupported 
		30. Ash.Resource.Verifiers.ValidateAggregatesSupported 
		31. Ash.Resource.Verifiers.ValidateArgumentsToCodeInterface 
		32. Ash.Resource.Verifiers.ValidateEagerIdentities 
		33. Ash.Resource.Verifiers.ValidateManagedRelationshipOpts 
		34. Ash.Resource.Verifiers.ValidateMultitenancy 
		35. Ash.Resource.Verifiers.ValidatePrimaryKey 
		36. Ash.Resource.Verifiers.ValidateRelationshipAttributes 
		37. Ash.Resource.Verifiers.ValidateRelationshipAttributesMatch 
		38. Ash.Resource.Verifiers.VerifyActionsAtomic 
		39. Ash.Resource.Verifiers.VerifyGenericActionReactorInputs 
		40. Ash.Resource.Verifiers.VerifyIdentityFields 
		41. Ash.Resource.Verifiers.VerifyPrimaryKeyPresent 
		42. Ash.Resource.Verifiers.VerifyPrimaryReadActionHasNoArguments 
		43. Ash.Resource.Verifiers.VerifyReservedCalculationArguments 
		44. Ash.Resource.Verifiers.VerifySelectedByDefault 

	17. Expressions  
		1. Ash.Filter.Predicate 
		2. Ash.Query.BooleanExpression 
		3. Ash.Query.Call 
		4. Ash.Query.Exists 
		5. Ash.Query.Function 
		6. Ash.Query.Not 
		7. Ash.Query.Operator 
		8. Ash.Query.Parent 
		9. Ash.Query.Ref 
		10. Ash.Query.Function.Ago 
		11. Ash.Query.Function.At 
		12. Ash.Query.Function.CompositeType 
		13. Ash.Query.Function.Contains 
		14. Ash.Query.Function.CountNils 
		15. Ash.Query.Function.DateAdd 
		16. Ash.Query.Function.DateTimeAdd 
		17. Ash.Query.Function.Error 
		18. Ash.Query.Function.Fragment 
		19. Ash.Query.Function.FromNow 
		20. Ash.Query.Function.GetPath 
		21. Ash.Query.Function.If 
		22. Ash.Query.Function.IsNil 
		23. Ash.Query.Function.Lazy 
		24. Ash.Query.Function.Length 
		25. Ash.Query.Function.Minus 
		26. Ash.Query.Function.Now 
		27. Ash.Query.Function.Rem 
		28. Ash.Query.Function.Round 
		29. Ash.Query.Function.StartOfDay 
		30. Ash.Query.Function.StringDowncase 
		31. Ash.Query.Function.StringJoin 
		32. Ash.Query.Function.StringLength 
		33. Ash.Query.Function.StringPosition 
		34. Ash.Query.Function.StringSplit 
		35. Ash.Query.Function.StringTrim 
		36. Ash.Query.Function.Today 
		37. Ash.Query.Function.Type 
		38. Ash.Query.Operator.Eq 
		39. Ash.Query.Operator.GreaterThan 
		40. Ash.Query.Operator.GreaterThanOrEqual 
		41. Ash.Query.Operator.In 
		42. Ash.Query.Operator.IsNil 
		43. Ash.Query.Operator.LessThan 
		44. Ash.Query.Operator.LessThanOrEqual 
		45. Ash.Query.Operator.NotEq 

	18. DSL Structs  
		1. Ash.Notifier.PubSub.Publication 
		2. Ash.Policy.FieldPolicy 
		3. Ash.Policy.Policy 
		4. Ash.Resource.Actions 
		5. Ash.Resource.Actions.Action 
		6. Ash.Resource.Actions.Argument 
		7. Ash.Resource.Actions.Create 
		8. Ash.Resource.Actions.Destroy 
		9. Ash.Resource.Actions.Implementation 
		10. Ash.Resource.Actions.Implementation.Context 
		11. Ash.Resource.Actions.Metadata 
		12. Ash.Resource.Actions.Read 
		13. Ash.Resource.Actions.Read.Pagination 
		14. Ash.Resource.Actions.Update 
		15. Ash.Resource.Aggregate 
		16. Ash.Resource.Aggregate.CustomAggregate 
		17. Ash.Resource.Aggregate.JoinFilter 
		18. Ash.Resource.Attribute 
		19. Ash.Resource.Calculation.Argument 
		20. Ash.Resource.Calculation.Context 
		21. Ash.Resource.Calculation.LoadAttribute 
		22. Ash.Resource.Calculation.LoadRelationship 
		23. Ash.Resource.CalculationInterface 
		24. Ash.Resource.Identity 
		25. Ash.Resource.Interface 
		26. Ash.Resource.Interface.CustomInput 
		27. Ash.Resource.Interface.CustomInput.Transform 
		28. Ash.Resource.Relationships 
		29. Ash.Resource.Relationships.BelongsTo 
		30. Ash.Resource.Relationships.HasMany 
		31. Ash.Resource.Relationships.HasOne 
		32. Ash.Resource.Relationships.ManyToMany 

	19. Other  
		1. Ash.Actions.BulkManualActionHelpers 
		2. Ash.Actions.Read.AsyncLimiter 
		3. Ash.Can 
		4. Ash.Changeset.OriginalDataNotAvailable 
		5. Ash.Context 
		6. Ash.CustomExpression 
		7. Ash.DataLayer 
		8. Ash.Domain.Dsl.ResourceReference 
		9. Ash.Domain.Igniter 
		10. Ash.Extension 
		11. Ash.Igniter 
		12. Ash.Info 
		13. Ash.Policy.PolicyGroup 
		14. Ash.Query.Combination 
		15. Ash.Query.UpsertConflict 
		16. Ash.Reactor.ActionStep 
		17. Ash.Reactor.AshStep 
		18. Ash.Reactor.BulkCreateStep 
		19. Ash.Reactor.BulkUpdateStep 
		20. Ash.Reactor.ChangeStep 
		21. Ash.Reactor.CreateStep 
		22. Ash.Reactor.DestroyStep 
		23. Ash.Reactor.Dsl.Action 
		24. Ash.Reactor.Dsl.ActionLoad 
		25. Ash.Reactor.Dsl.ActionTransformer 
		26. Ash.Reactor.Dsl.Actor 
		27. Ash.Reactor.Dsl.AshStep 
		28. Ash.Reactor.Dsl.BulkCreate 
		29. Ash.Reactor.Dsl.BulkUpdate 
		30. Ash.Reactor.Dsl.Change 
		31. Ash.Reactor.Dsl.Context 
		32. Ash.Reactor.Dsl.Create 
		33. Ash.Reactor.Dsl.Destroy 
		34. Ash.Reactor.Dsl.Inputs 
		35. Ash.Reactor.Dsl.Load 
		36. Ash.Reactor.Dsl.MiddlewareTransformer 
		37. Ash.Reactor.Dsl.Read 
		38. Ash.Reactor.Dsl.ReadOne 
		39. Ash.Reactor.Dsl.Tenant 
		40. Ash.Reactor.Dsl.Transaction 
		41. Ash.Reactor.Dsl.Update 
		42. Ash.Reactor.LoadStep 
		43. Ash.Reactor.MergeInputsStep 
		44. Ash.Reactor.Notifications 
		45. Ash.Reactor.ReadOneStep 
		46. Ash.Reactor.ReadStep 
		47. Ash.Reactor.Tracer 
		48. Ash.Reactor.TransactionStep 
		49. Ash.Reactor.UpdateStep 
		50. Ash.Resource.Dsl.Filter 
		51. Ash.Resource.Igniter 
		52. Ash.Resource.ManualCreate.BulkContext 
		53. Ash.Resource.ManualCreate.Context 
		54. Ash.Resource.ManualDestroy.BulkContext 
		55. Ash.Resource.ManualDestroy.Context 
		56. Ash.Resource.ManualRelationship.Context 
		57. Ash.Resource.ManualUpdate.BulkContext 
		58. Ash.Resource.ManualUpdate.Context 
		59. Ash.Resource.Preparation.Context 
		60. Ash.Scope 
		61. Ash.Scope.ToOpts 
		62. Ash.Subject 
		63. Ash.ToTenant 
		64. Ash.TypedStruct 
		65. Comp 
		66. Comparable 
		67. Comparable.Type.Any.To.Any 
		68. Comparable.Type.Ash.CiString.To.Ash.CiString 
		69. Comparable.Type.Ash.CiString.To.BitString 
		70. Comparable.Type.Atom.To.BitString 
		71. Comparable.Type.BitString.To.Ash.CiString 
		72. Comparable.Type.BitString.To.Atom 
		73. Comparable.Type.BitString.To.Decimal 
		74. Comparable.Type.Date.To.Date 
		75. Comparable.Type.DateTime.To.DateTime 
		76. Comparable.Type.Decimal.To.BitString 
		77. Comparable.Type.Decimal.To.Decimal 
		78. Comparable.Type.Decimal.To.Float 
		79. Comparable.Type.Decimal.To.Integer 
		80. Comparable.Type.Float.To.Decimal 
		81. Comparable.Type.Integer.To.Decimal 
		82. Comparable.Type.List.To.List 
		83. Comparable.Type.Map.To.Map 
		84. Comparable.Type.NaiveDateTime.To.NaiveDateTime 
		85. Comparable.Type.Time.To.Time 
		86. Comparable.Type.Tuple.To.Tuple 


13.  Mix Tasks  
	1. mix ash 
	2. mix ash.codegen 
	3. mix ash.extend 
	4. mix ash.gen.base\_resource 
	5. mix ash.gen.change 
	6. mix ash.gen.custom\_expression 
	7. mix ash.gen.domain 
	8. mix ash.gen.enum 
	9. mix ash.gen.preparation 
	10. mix ash.gen.resource 
	11. mix ash.gen.validation 
	12. mix ash.generate\_livebook 
	13. mix ash.generate\_policy\_charts 
	14. mix ash.generate\_resource\_diagrams 
	15. mix ash.install 
	16. mix ash.migrate 
	17. mix ash.patch.extend 
	18. mix ash.reset 
	19. mix ash.rollback 
	20. mix ash.setup 
	21. mix ash.tear\_down 




# Home





# Ash Framework

Welcome\! Here you will find everything you need to know to get started with and use Ash. This documentation is best viewed on hexdocs.

## Dive In

+ What is Ash?
+ Getting Started Tutorial
+ See the roadmap

## About the Documentation

The Get Started Livebook **Tutorial** introduces you to the core concepts of Ash like resources, actions, and relationships. It’s a great place to start if you are a beginner.

* * *

**Topics** provide a high level overview of a specific concept or feature of Ash. These are **understanding-oriented**, and are perfect for discovering design patterns, features, and tools.

* * *

**How-to** guides are **goal-oriented** recipes for accomplishing specific popular tasks. Browse to get an idea of how Ash works and what is possible with it.

* * *

**Reference** documentation is **information-oriented**, covering every Ash module, function, expression, and DSL. It is produced automatically from our source code. Use the sidebar and the top search bar to find relevant reference information. Place the text `dsl` before your search to quickly jump to a particular DSL — e.g. try comparing the results of searching for `name` with the results for `dsl name`.

* * *

## Topics

### About Ash

+ What is Ash?
+ Our Design Principles
+ Contributing to Ash
+ Alternatives

### Development

+ Project Structure
+ Generators
+ Testing
+ Working with LLM Assistance
+ Development Utilities
+ Backwards Compatibility Config
+ Upgrading to 3.0
+ Error Handling

### Resources

+ Domains
+ Attributes
+ Relationships
+ Calculations
+ Aggregates
+ Code Interfaces
+ Identities
+ Validations
+ Changes
+ Preparations
+ Embedded Resources
+ Notifiers

### Actions

+ Actions
+ Read Actions
+ Create Actions
+ Update Actions
+ Destroy Actions
+ Generic Actions
+ Manual Actions

### Security

+ Actors & Authorization
+ Sensitive Data
+ Policies

### Advanced

+ Multi-step Actions
+ Monitoring
+ Multitenancy
+ Reactor
+ Combination Queries
+ Timeouts
+ Writing Extensions

* * *

## How-to

+ Write Queries
+ Test Resources
+ Authorize Access to Resources
+ Encrypt Attributes
+ Prevent Concurrent Writes
+ Wrap External APIs
+ Define Polymorphic Relationships

* * *

## Reference

+ Ash.Resource DSL
+ Ash.Domain DSL
+ Ash.Reactor DSL
+ Ash.Notifier.PubSub DSL
+ Ash.Policy.Authorizer DSL
+ Ash.DataLayer.Ets DSL
+ Ash.DataLayer.Mnesia DSL
+ Glossary
+ Expressions
+ For other reference documentation, see the sidebar & search bar

## Packages

The Ash ecosystem consists of numerous packages, all of which have their own documentation. If you can't find something in this documentation, don't forget to search in any potentially relevant package.

### Data Layers

+ 
AshPostgres | PostgreSQL data layer

+ 
AshSqlite | SQLite data layer

+ 
AshCsv | CSV data layer

+ 
AshCubdb | CubDB data layer


### API Extensions

+ 
AshJsonApi | JSON:API builder

+ 
AshGraphql | GraphQL builder


### AI

+ 
AshAI | Structured Outpus, MCP, Vectorization and more


### Web

+ 
AshPhoenix | Phoenix integrations

+ 
AshAuthentication | Authenticate users with password, OAuth, and more

+ 
AshAuthenticationPhoenix | Integrations for AshAuthentication and Phoenix


### Finance

+ 
AshMoney | A money data type for Ash

+ 
AshDoubleEntry | A double entry system backed by Ash Resources


### Resource Utilities

+ 
AshOban | Background jobs and scheduled jobs for Ash, backed by Oban

+ 
AshArchival | Archive resources instead of deleting them

+ 
AshStateMachine | Create state machines for resources

+ 
AshPaperTrail | Keep a history of changes to resources

+ 
AshCloak | Encrypt attributes of a resource


### Admin & Monitoring

+ 
AshAdmin | A push-button admin interface

+ 
AshAppsignal | Monitor your Ash resources with AppSignal


### Testing

+ 
Smokestack | Declarative test factories for Ash resources


### Examples & External Resources

+ 
Ash Real World | Ash \+ Phoenix LiveView codebase containing real world examples \(CRUD, auth, advanced patterns, etc\)




# Get Started

### Learn with Livebook

We have a basic step by step tutorial in Livebook that introduces you to Ash. No prior Ash knowledge is required. The Livebook tutorial is self contained and separate from the documentation below. 

## Goals

In this guide we will:

1. Create a new Elixir application and add Ash as a dependency
2. Create a simple set of resources and see how they can be used
3. Go over some core concepts of Ash
4. Find out what material might be good to visit next

## Requirements

If you want to follow along yourself, you will need the following things:

1. Elixir and Erlang installed
2. A text editor to make the changes that we make
3. A terminal to run the examples using `iex`

## Steps

For this tutorial, we'll use examples based around creating a Help Desk system.

We will make the following resources:

+ `Helpdesk.Support.Ticket`
+ `Helpdesk.Support.Representative`

The actions we will be able to take on these resources include:

+ Opening a new Ticket
+ Closing a Ticket
+ Assigning a Ticket to a representative

### Create a new project

This guide focuses on getting you introduced to Ash quickly. For that reason, we recommend starting a fresh project to explore the concepts. You can, however, add Ash to your existing project if desired. See the options below for more.

### What is igniter?

Igniter is a code generation and project setup tool that automates the installation and configuration of Elixir packages. Instead of manually adding dependencies and writing boilerplate code, Igniter handles this for you. When you run `mix igniter.install ash`, it automatically adds Ash to your project and sets up the necessary configuration files.

### New project

First, to use `mix igniter.new`, the archive must be installed.

    # install igniter.new    mix archive.install hex igniter_new        # create a new application with Ash in it    mix igniter.new helpdesk --install ash && cd helpdesk

### New Phoenix project

If you already know that you want to use Phoenix and Ash together, you can use

    # install the archive    mix archive.install hex phx_new    mix archive.install hex igniter_new        # use the `--with` flag to generate the project with phx.new and add Ash    mix igniter.new helpdesk --install ash,ash_phoenix --with phx.new && cd helpdesk

### Existing Project

You can use igniter to add Ash to your existing project as well.

    mix archive.install hex igniter_new    mix igniter.install ash

### Manual Installation Instructions

Finally, if you want to install Ash manually, step by step, follow the manual installation guide.

### Picosat installation issues?

If you have trouble compiling `picosat_elixir`, then alter your `mix.exs` file to replace `{:picosat_elixir, "~> 0.2"}` with `{:simple_sat, "~> 0.1"}` to use a simpler \(but mildly slower\) solver. You can always switch back to `picosat_elixir` later once you're done with the tutorial. Then, run `mix deps.get && mix deps.compile ash --force`

### Building your first Ash Domain

The basic building blocks of an Ash application are Ash resources. They are tied together by a domain module, which will allow you to interact with those resources.

### Creating our first resource

### Generators

We have CLI commands that will do this for you, for example `mix ash.gen.resource`. In this getting started guide, we will create the resources by hand. This is primarily because there are not actually very many steps, and we want you to be familiar with each moving piece. For more on the generators, run `mix help ash.gen.resource`.

Let's start by creating our first resource along with our first domain. We will create the following files:

+ The domain `Helpdesk.Support`, in `lib/helpdesk/support.ex`
+ Our Ticket resource `Helpdesk.Support.Ticket`, in `lib/helpdesk/support/ticket.ex`.

To create the required folders and files, you can use the following command in your terminal:

    mkdir -p lib/helpdesk/support && \      touch $_/ticket.ex && \      touch lib/helpdesk/support.ex

Your project structure should now include the following files:

    lib    /        ├    ─         helpdesk    /        │          ├    ─         support    /        │          │          ├    ─         ticket    .    ex        │          ├    ─         support    .    ex

Add the following contents to the files we created:

    # lib/helpdesk/support.ex    
        defmodule         Helpdesk.Support         do    
          use         Ash.Domain    

          resources         do    
            resource         Helpdesk.Support.Ticket    
          end        end

    # lib/helpdesk/support/ticket.ex    
        defmodule         Helpdesk.Support.Ticket         do    
          # This turns this module into a resource    
          use         Ash.Resource    ,         domain    :         Helpdesk.Support    

          actions         do    
            # Use the default implementation of the :read action    
            defaults         [    :read    ]    

            # and a create action, which we'll customize later    
            create         :create    
          end    

          # Attributes are the simple pieces of data that exist on your resource    
          attributes         do    
            # Add an autogenerated UUID primary key called `:id`.    
            uuid_primary_key         :id    

            # Add a string type attribute called `:subject`    
            attribute         :subject    ,         :string    
          end        end

Next, add your domain to your `config.exs`, and configure some backwards compatibility configuration.

Run the following commands to create your `config.exs` if it doesn't already exist:

    mkdir         -    p         config        touch         config    /    config    .    exs

And add the following contents to it.

    # in config/config.exs        import         Config    
        # This tells Ash about your domain, which is used to find        # available resource and actions        config         :helpdesk    ,         :ash_domains    ,         [    Helpdesk.Support    ]

### Try our first resource out

Run `iex -S mix` in your project's root directory and try out the following.

To create a ticket, we first make an `Ash.Changeset` for the `:create` action of the `Helpdesk.Support.Ticket` resource. Then we pass it to the `Ash.create!/1` function.

    Helpdesk.Support.Ticket        |>         Ash.Changeset    .    for_create    (    :create    )        |>         Ash    .    create!    (    )

This returns what we call a `record` which is an instance of a resource.

    #    Helpdesk.Support.Ticket    <    
          ...    ,    
          id    :         "c0f8dc32-a018-4eb4-8656-d5810118f4ea"    ,    
          subject    :         nil    ,    
          ...        >

Notice we are not persisting the record. The resource is simple returning the record back to us.

### Customizing our Actions

One thing you may have noticed earlier is that we created a ticket without providing any input, and as a result our ticket had a `subject` of `nil`. Additionally, we don't have any other data on the ticket. Lets add a `status` attribute, ensure that `subject` can't be `nil`, and provide a better interface by giving the `:create` action a better name, and accepting `:subject` as part of the action.

We'll start with the attribute changes:

    # lib/helpdesk/support/ticket.ex    
        attributes         do    
          ...    
          attribute         :subject    ,         :string         do    
            # Don't allow `nil` values    
            allow_nil?         false    

            # Allow this attribute to be public. By default, all attributes are private.    
            public?         true    
          end    

          # status is either `open` or `closed`. We can add more statuses later    
          attribute         :status    ,         :atom         do    
            # Constraints allow you to provide extra rules for the value.    
            # The available constraints depend on the type    
            # See the documentation for each type to know what constraints are available    
            # Since atoms are generally only used when we know all of the values    
            # it provides a `one_of` constraint, that only allows those values    
            constraints         [    one_of    :         [    :open    ,         :closed    ]    ]    

            # The status defaulting to open makes sense    
            default         :open    

            # We also don't want status to ever be `nil`    
            allow_nil?         false    
          end        end

And then replace the `:create` action with `:open`, and accept `:subject` as input.

    # lib/helpdesk/support/ticket.ex    
        actions         do    
          ...    
          create         :open         do    
            accept         [    :subject    ]    
          end        end

Let's try these changes in `iex`:

We use `create!` with an exclamation point here because that will raise the error which gives a nicer view of the error in `iex`

    # Use this to pick up changes you've made to your code, or restart your session        recompile    (    )    
        Helpdesk.Support.Ticket        |>         Ash.Changeset    .    for_create    (    :open    ,         %{    subject    :         "My mouse won't click!"    }    )        |>         Ash    .    create!    (    )

And we can see our newly created ticket with a subject and a status.

    #    Helpdesk.Support.Ticket    <    
          ...    
          id    :         "3c94d310-7b5e-41f0-9104-5b193b831a5d"    ,    
          status    :         :open    ,    
          subject    :         "My mouse won't click!"    ,    
          ...        >

If we didn't include a subject, or left off the arguments completely, we would see an error instead

    ** (Ash.Error.Invalid) Invalid Error

    * attribute subject is required

### Updates and validations

Now let's add some logic to close a ticket. This time we'll add an `update` action.

Here we will use a `change`. Changes allow you to customize how an action executes with very fine-grained control. There are built-in changes that are automatically available as functions, but you can define your own and pass it in as shown below. You can add multiple, and they will be run in order. See the `Ash.Changeset` module documentation for more.

    # lib/helpdesk/support/ticket.ex    
        actions         do    
          ...    
          update         :close         do    
            # We don't want to accept any input here    
            accept         [    ]    

            validate         attribute_does_not_equal    (    :status    ,         :closed    )         do    
              message         "Ticket is already closed"    
            end    

            change         set_attribute    (    :status    ,         :closed    )    
            # A custom change could be added like so:    
            #    
            # change MyCustomChange    
            # change {MyCustomChange, opt: :val}    
          end        end

Try out opening and closing a ticket in `iex`:

    # Use this to pick up changes you've made to your code, or restart your session        recompile    (    )    
        # parenthesis so you can paste into iex        ticket         =         (    
          Helpdesk.Support.Ticket    
          |>         Ash.Changeset    .    for_create    (    :open    ,         %{    subject    :         "My mouse won't click!"    }    )    
          |>         Ash    .    create!    (    )        )    
        ticket         =         (    
          ticket    
          |>         Ash.Changeset    .    for_update    (    :close    )    
          |>         Ash    .    update!    (    )        )    
        #    Helpdesk.Support.Ticket    <    
          ...    
          status    :         :closed    ,    
          subject    :         "My mouse won't click!"    ,    
          ...        >

What if we would try to close the ticket again?

    ticket        |>         Ash.Changeset    .    for_update    (    :close    )        |>         Ash    .    update!    (    )

The application would halt with an error:

    ...
    ** (Ash.Error.Invalid)
    Bread Crumbs:
      > Returned from bulk query update: Helpdesk.Support.Ticket.close

    Invalid Error

    * Invalid value provided for status: Ticket is already closed.
    ...

Note the 'Ticket is already closed' message that we have defined in the `attribute_does_not_equal` validation.

And if we'd use the non-bang version:

    ticket        |>         Ash.Changeset    .    for_update    (    :close    )        |>         Ash    .    update    (    )

we get an error tuple with a %Ash.Error.Invalid struct that contains the message:

    {:error,
     %Ash.Error.Invalid{
    ...
           message: "Ticket is already closed",
    ...

### Querying without persistence

So far we haven't used a data layer that does any persistence, like storing records in a database. All that this simple resource does is return the record back to us. You can see this lack of persistence by attempting to use a `read` action:

    Ash    .    read!    (    Helpdesk.Support.Ticket    )

Which will raise an error explaining that there is no data to be read for that resource.

In order to save our data somewhere, we need to add a data layer to our resources. Before we do that, however, let's go over how Ash allows us to work against many different data layers \(or even no data layer at all\).

Resources without a data layer will implicitly be using `Ash.DataLayer.Simple`. This data is not persisted anywhere, and must be provided when running queries. It provides a utility for just this purpose, `Ash.DataLayer.Simple.set_data/2`.

Try the following in `iex`. We will open some tickets, and close some of them, and then use `Ash.DataLayer.Simple.set_data/2` to use those tickets.

    # Ash.Query is a macro, so it must be required        require         Ash.Query    
        tickets         =    
          for         i         <-         0    ..    5         do    
            ticket         =    
              Helpdesk.Support.Ticket    
              |>         Ash.Changeset    .    for_create    (    :open    ,         %{    subject    :         "Issue     #{    i    }    "    }    )    
              |>         Ash    .    create!    (    )    

            if         rem    (    i    ,         2    )         ==         0         do    
              ticket    
              |>         Ash.Changeset    .    for_update    (    :close    )    
              |>         Ash    .    update!    (    )    
            else    
              ticket    
            end    
          end

Find the tickets where the subject contains `"2"`. Note that the we're setting the ticket data that we're querying using `set_data`.

    Helpdesk.Support.Ticket        |>         Ash.Query    .    filter    (    contains    (    subject    ,         "2"    )    )        |>         Ash.DataLayer.Simple    .    set_data    (    tickets    )        |>         Ash    .    read!    (    )

Find the tickets that are *closed* and their subject does *not* contain `"4"`

    Helpdesk.Support.Ticket        |>         Ash.Query    .    filter    (    status         ==         :closed         and         not    (    contains    (    subject    ,         "4"    )    )    )        |>         Ash.DataLayer.Simple    .    set_data    (    tickets    )        |>         Ash    .    read!    (    )

The examples above could be easily implemented with `Enum.filter`, but the real power here is to allow you to use the same tools when working with any data layer.

Even though it doesn't persist data in any way, `Ash.DataLayer.Simple` can be useful to model static data, or be used for resources where all the actions are manual and inject data from other sources.

### Adding basic persistence

Before we get into working with relationships, let's add some real persistence to our resource. This will let us add relationships and try out querying data.

There is a built in data layer that is useful for testing and prototyping, that uses ETS. ETS \(Erlang Term Storage\) is OTP's in-memory database, so the data won't actually stick around beyond the lifespan of your program, but it's a simple way to try things out.

To add it to your resource, modify it like so:

    # lib/helpdesk/support/ticket.ex    
        use         Ash.Resource    ,    
          domain    :         Helpdesk.Support    ,    
          data_layer    :         Ash.DataLayer.Ets

Now we can slightly modify our code above, by removing the `Ash.DataLayer.Simple.set_data/2` calls, and we can see our persistence in action. Remember, ETS is in-memory, meaning restarting your application/iex session will remove all of the data.

    # Use this to pick up changes you've made to your code, or restart your session        recompile    (    )    
        require         Ash.Query    
        for         i         <-         0    ..    5         do    
          ticket         =    
            Helpdesk.Support.Ticket    
            |>         Ash.Changeset    .    for_create    (    :open    ,         %{    subject    :         "Issue     #{    i    }    "    }    )    
            |>         Ash    .    create!    (    )    

          if         rem    (    i    ,         2    )         ==         0         do    
            ticket    
            |>         Ash.Changeset    .    for_update    (    :close    )    
            |>         Ash    .    update!    (    )    
          end        end    
        # Show the tickets where the subject contains "2"        Helpdesk.Support.Ticket        |>         Ash.Query    .    filter    (    contains    (    subject    ,         "2"    )    )        |>         Ash    .    read!    (    )    
        # Show the tickets that are closed and their subject does not contain "4"        Helpdesk.Support.Ticket        |>         Ash.Query    .    filter    (    status         ==         :closed         and         not    (    contains    (    subject    ,         "4"    )    )    )        |>         Ash    .    read!    (    )

### Adding relationships

Now we want to be able to assign a Ticket to a Representative. First, let's create the Representative resource:

    # lib/helpdesk/support/representative.ex    
        defmodule         Helpdesk.Support.Representative         do    
          # This turns this module into a resource using the in memory ETS data layer    
          use         Ash.Resource    ,    
            domain    :         Helpdesk.Support    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            # Add the default simple actions    
            defaults         [    :read    ]    

            create         :create         do    
              accept         [    :name    ]    
            end    
          end    

          # Attributes are the simple pieces of data that exist on your resource    
          attributes         do    
            # Add an autogenerated UUID primary key called `:id`.    
            uuid_primary_key         :id    

            # Add a string type attribute called `:name`    
            attribute         :name    ,         :string         do    
              # Make the attribute public in order to give a name when calling functions from `Ash.Changeset`.    
              public?         true    
            end    
          end    

          relationships         do    
            # `has_many` means that the destination attribute is not unique, therefore many related records could exist.    
            # We assume that the destination attribute is `representative_id` based    
            # on the module name of this resource and that the source attribute is `id`.    
            has_many         :tickets    ,         Helpdesk.Support.Ticket    
          end        end

Now let's modify our Ticket resource to have the inverse relationship to the Representative.

    # lib/helpdesk/support/ticket.ex    
        relationships         do    
          # belongs_to means that the destination attribute is unique, meaning only one related record could exist.    
          # We assume that the destination attribute is `representative_id` based    
          # on the name of this relationship and that the source attribute is `representative_id`.    
          # We create `representative_id` automatically.    
          belongs_to         :representative    ,         Helpdesk.Support.Representative        end

Finally, let's add our new Representative resource to our domain module

    # lib/helpdesk/support.ex    
        resources         do    
         ...    
         resource         Helpdesk.Support.Representative        end

You may notice that if you don't add the resource to your domain, or if you don't add the `belongs_to` relationship, that you'll get helpful errors at compile time. Helpful compile time validations are a core concept of Ash as we really want to ensure that your application is valid.

## Working with relationships

The simplest way to work with belongs to relationships is to allow directly editing the underlying id field.

### managing relationships

There are a wide array of options when managing relationships, and we won't cover all of them here. See the Managing Relationships guide for more.

Add the `assign` action to allow us to assign a Ticket to a Representative.

    # lib/helpdesk/support/ticket.ex    
        update         :assign         do    
          accept         [    :representative_id    ]        end

Let's try it out in our `iex` console\!

Use `recompile` to pick up changes you've made to your code, or just restart your session.

    recompile    (    )

### Open a Ticket

    ticket         =         (    
          Helpdesk.Support.Ticket    
          |>         Ash.Changeset    .    for_create    (    :open    ,         %{    subject    :         "I can't find my hand!"    }    )    
          |>         Ash    .    create!    (    )        )

### Create a Representative

    representative         =         (    
          Helpdesk.Support.Representative    
          |>         Ash.Changeset    .    for_create    (    :create    ,         %{    name    :         "Joe Armstrong"    }    )    
          |>         Ash    .    create!    (    )        )

### Assign that Representative to the Ticket

    ticket        |>         Ash.Changeset    .    for_update    (    :assign    ,         %{    representative_id    :         representative    .    id    }    )        |>         Ash    .    update!    (    )

### What next?

What you've seen above barely scratches the surface of what Ash can do. In a lot of ways, it will look very similar to other tools that you've seen. If all that you ever used was the above, then realistically you won't see much benefit to using Ash.

Where Ash shines however, is all of the tools that can work *with* your resources. You have the ability to extend the framework yourself, and apply consistent design patterns that enable unparalleled efficiency, power and flexibility as your application grows.

#### Get Help

+ Check out ElixirForum
+ Join our Discord server
+ Open a GitHub issue

#### Persist your data

See The AshPostgres getting started guide to see how to back your resources with Postgres. This is highly recommended, as the Postgres data layer provides tons of advanced capabilities.

#### Add a web API

Check out AshJsonApi and AshGraphql extensions to build APIs around your resource

#### Authorize access and work with users

See AshAuthentication for setting up users and allowing them to log in. It supports password, magic link, oauth \(google, github, apple etc.\) out of the box\!

See the Policies guide for information on how to authorize access to your resources using actors and policies.

#### Clean up your code that uses Ash?

Creating and using changesets manually can be verbose, and they all look very similar. Luckily, Ash has your back and can help you build high quality interfaces for you\!

Check out the Code Interface Guide to derive things like `Helpdesk.Support.Ticket.assign!(representative.id)`



# What is Ash?

Ash is an opinionated, declarative application framework that brings the batteries-included experience to Elixir. It shines when building web apps, APIs and services, but can be used for any kind of Elixir application. It integrates with the best that the Elixir ecoystem has to offer, often used with Phoenix and PostgreSQL, slotting directly into a standard Elixir codebase. Ash is built for velocity at day 1, but also for maintainability at year 5, a place where many frameworks and tools leave you high and dry.
> 
> Through its declarative extensibility, Ash delivers more than you'd expect: Powerful APIs with filtering/sorting/pagination/calculations/aggregations, pub/sub, authorization, rich introspection, GraphQL... It's what empowers this solo developer to build an ambitious ERP\!

> — Frank Dugan III, System Specialist, SunnyCor Inc.

At its heart, Ash is a framework for modeling your application's domain through **Resources** and their **Actions**. These are the fundamental abstractions that everything else builds upon.

## Why Ash?

If you've ever built software professionally, you've almost certainly experienced one or more of the following:

**The problem**:

+ **Repetitive work** - The same business logic scattered across our application
+ **Inconsistencies** - Different parts of your app handling the same data differently
+ **Maintenance burden** - Changing one thing requires updating five different places
+ **Knowledge silos** - Each developer builds everything slightly differently, leading to inconsistencies and inefficiencies.

**Ash's solution**: Model your application's **behavior** first, as data, and derive everything else automatically. Ash resources center around **actions** that represent domain logic. Instead of exposing raw data models, you define meaningful operations like `:publish_post`, `:approve_order`, or `:calculate_shipping_cost` that encapsulate your business logic, validation, and authorization rules. This is coupled with a rich suite of extensions to fill the most common needs of Elixir applications.
> 
> Ash fills the gap that brings Phoenix up to feature parity with a batteries included framework like Django. Ash Admin \(Django admin\), Ash Resource & Domain \(Django models & ORM\), AshJsonApi \(Django REST Framework\), Ash Authentication \(Django Allauth\), Ash Phoenix \(Django Forms\), Ash Policies \(Django Permissions\)

> But you aren't required to use Phoenix with an Ash project. Ash will happily work as a standalone CLI, terminal app or some other Elixir web framework that comes out tomorrow.

> Scott Woodall - Principal Software Engineer, Microsoft

## Built for Flexibility

Ash was born out of the battle-scars from inflexible abstractions that eventually paint you into a corner. That's why Ash is designed with **multi-tiered configurability** and **escape hatches all the way down**. Instead of deciding that abstraction was bad, we decided that it just needed to be done better. Elixir & the BEAM have our backs, providing a solid foundation upon which to build high quality applications.

**You're never locked out of custom behavior**. Need to customize how an action works? Use preparations, changes, and validations. Need to override how data is fetched? Implement a manual action. Need to completely bypass Ash for a specific operation? Drop down to Ecto or raw SQL. Need to extend Ash itself? Use the same extension toolkit that powers AshPostgres and AshGraphql.

This isn't accidental - it's core to Ash's design. We provide powerful defaults that work for 80% of cases, extensive configuration options for the next 15%, and escape hatches for the remaining 5%. Your Ash application is just an Elixir application, so when you need to do something completely custom, Ash won't get in your way.

The framework acts as a **spinal cord** for your application: providing structure and coordination while allowing complete customization at every level.

## Essential Context

### Elixir Developers

**Ash builds on the best of the Elixir ecosystem** rather than replacing it. Ash leverages Ecto for database operations, Phoenix for web interfaces, Oban for background jobs, Absinthe for GraphQL, etc. Ash unifies all of this tooling and significantly simplifies and enhances they way you use them together.

**Compile-time guarantees** come from Ash's declarative nature - many errors that would be runtime failures in other frameworks become compile-time checks in Ash.

**The ecosystem advantage**: Instead of learning entirely new patterns, Ash enhances familiar Elixir concepts. Your existing knowledge of pattern matching, process supervision, and OTP principles all apply - Ash just provides structure and automation on top, acting as a spinal cord for your application.

### Non-Elixir Developers

**Elixir** is a functional programming language built on the Erlang VM, known for fault-tolerance and concurrency. It's used by WhatsApp, Discord, and Pinterest for systems that need high availability. If you know Ruby or Python, think of Elixir as optimized specifically for distributed, concurrent systems.

**Functional vs Object-Oriented**: Unlike OOP frameworks, Elixir \(and Ash\) focus on transforming data through functions rather than encapsulating data in objects. This leads to more predictable, testable code.

**Immutability** means data doesn't change in-place - instead, you create new versions. This eliminates many common bugs around shared state and makes concurrent operations safer.

**Actor Model Concurrency**: Instead of threads and locks, Elixir uses lightweight processes \(actors\) that communicate via messages. This makes Ash naturally suited for high-concurrency applications.

**Modules** \(`defmodule`\) are Elixir's equivalent to classes/namespaces - they group related functions together. Unlike OOP classes, they don't hold state.

### New Programmers

**Programming languages** like Elixir are tools for writing instructions that computers can follow. Elixir is specifically designed for building web applications that can handle lots of users at once.

**Modules** \(the `defmodule` blocks you'll see\) are containers that group related code together. Think of them like chapters in a book - each chapter covers a specific topic.

### Business Leaders

**Ash reduces software development costs** by eliminating repetitive code. When your development team defines a business process once, Ash automatically generates the database structure, API endpoints, and user interfaces - work that normally requires separate specialists.

**Faster time-to-market** because features that typically take weeks can be built in days. Adding a new feature like "customer reviews" or "order tracking" requires defining the business rules once, rather than building separate systems for web, mobile, and internal tools.

**Lower maintenance costs** because changes to business rules automatically update all related systems. When you change how orders work, your database, APIs, and documentation stay synchronized without manual updates.

**Reduced technical risk** through built-in security, data validation, and error handling. Your team spends time building your competitive advantages instead of solving the same infrastructure problems every software company faces.

**Developer productivity** increases because the framework handles the "plumbing" while your team focuses on what makes your business unique. This means you need fewer developers to build the same functionality.

**Eliminates technical debt** through enforced consistency. When every part of your application follows the same patterns, there's no accumulation of "quick fixes" and inconsistent approaches that slow down future development and create maintenance headaches.

**Faster developer onboarding** because new team members learn one set of patterns that apply everywhere. Instead of each developer building things differently, Ash provides a shared vocabulary and approach that new hires can quickly understand and contribute to. Ash is still niche, so developers may not know it right out of the gate, but if you think of Ash as a replacement for your internal framework, which are universally poorly documented and hard to train on, you can see the benefit of Ash being an open source, well documented project with a strong community.

## Resources and Actions: The Core Abstractions

The foremost abstraction in Ash is **Actions** - the things you can do in your domain like `:create_user`, `:publish_post`, `:approve_order`, or `:calculate_shipping`. These actions are organized into **Resources** that group related behaviors around domain concepts like `User`, `Post`, `Order`, or `Invoice`. Using resources, you can easily model actions, alongside the state that they operate on, or just actions in isolation.

These actions are **introspectable** and **fully typed**. This means the rest of your application \(and **extensions** - add-on packages that enhance Ash\) can automatically understand and build functionality around them. When you define a `create` action that accepts a `:title` string and `:content` text, extensions like AshGraphql can automatically generate GraphQL mutations, AshJsonApi can create REST endpoints, and AshPostgres can handle database persistence - all without additional configuration.

This **declarative approach** means your resources become the single source of truth for your entire application. Database schemas, API endpoints, authorization rules, state machines, background jobs, and more all stem directly from your resource definitions.

## Beyond Simple CRUD

Ash is not a web framework, like Phoenix or Rails. It is a framework for building your application layer, independent of how it is exposed or consumed. It is not an **alternative** to frameworks like Phoenix, rather a **complement** to them.
> 
> Ash Framework enabled us to build a robust platform for delivering financial services using bitcoin. Ash proved itself to our team by handling innovative use cases with ease and it continues to evolve ahead of our growing list of needs.

> — Yousef Janajri, CTO & Co-Founder, Coinbits

The intent behind Ash is *not* to have you building simple CRUD-style applications, although we do provide conveniences for these cases. The real power comes from defining rich, domain-specific actions with meaningful names like `:publish_post`, `:approve_order`, or `:calculate_shipping`. These actions encapsulate your business logic and can be composed, validated, authorized, and extended in powerful ways.

#### Model your domain, derive the rest

Ash derives significant portions of your application directly from your resources, with little to no effort required. This allows you to focus on what matters most: your business logic. We leverage the best of the Elixir ecosystem under the hood, providing a single unified tool-chain for our users.

## Community

Ash has a vibrant community of developers who contribute to the project, provide support, and share knowledge. Join us on Discord, ElixirForum and GitHub to contribute, ask questions, and stay updated on the latest developments.

Our community is one of the best features of Ash and **you should use it**. Lots of folks using Ash in production, with a shared mission of making better software.
> 
> I'm constantly blown away with the quality of work and support the Ash community has put into this project. It's gotten to the point that I can't imagine starting a new Elixir project that doesn't use Ash.

> — Brett Kolodny, Full stack engineer, MEW

## An Example: From Simple to Sophisticated

### Introduction

If you're the "just show me the code" type, click through these tabs to see an example of evolving a blog post resource over time with Ash & its extensions to get a sense for how it works.

#### Don't worry about understanding all the code

You're not expected to understand every detail of the syntax - focus on the concepts and how it changes over time. If you want a gentler introduction, head over to the getting started guide.

### Actions

    # lib/my_blog/blog.ex        defmodule         MyBlog.Blog         do    
          use         Ash.Domain    

          resources         do    
            resource         MyBlog.Blog.Post         do    
              # Defines the `analyze_text/1` function which calls    
              # the action of the same name on the Post resource.    
              define         :analyze_text    ,         args    :         [    :text    ]    
            end    
          end        end    
        # lib/my_blog/blog/post.ex        defmodule         MyBlog.Blog.Post         do    
          use         Ash.Resource    

          actions         do    
            # Start with pure behavior - a simple action that processes text    
            action         :analyze_text    ,         :map         do    
              argument         :text    ,         :string    ,         allow_nil?    :         false    

              run         fn         input    ,         _context         ->    
                text         =         input    .    arguments    .    text    
                words         =         String    .    split    (    text    )    

                analysis         =         %{    
                  word_count    :         length    (    words    )    ,    
                  character_count    :         String    .    length    (    text    )    ,    
                  estimated_reading_time    :         div    (    length    (    words    )    ,         200    )         +         1    
                }    

                {    :ok    ,         analysis    }    
              end    
            end    
          end        end

Notice how we have not defined any "state" here. A common misconception is that the purpose of Ash is to abstract state. Ash provides tons of useful features around state, but those are features *on top of* the core concept, which centers around typed actions.

    {    :ok    ,         analysis    }         =         MyBlog.Blog    .    analyze_text    (    "This is some sample blog content to analyze."    )        # => {:ok, %{word_count: 9, character_count: 49, estimated_reading_time: 1}}

**Why not just write a regular function?** You could write `def analyze_text(text)` and get the same result. But here's what the Ash action gives you that a function doesn't:

+ **Type safety** - Arguments are automatically validated \(try passing a number instead of string\)
+ **Introspection** - Other tools can discover this action exists and what it does
+ **Extensibility** - You can add authorization, logging, or other behaviors later without changing callers
+ **API generation** - Extensions can automatically expose this as a REST endpoint or GraphQL query
+ **Consistent interface** - All actions work the same way, making your codebase predictable

The action is **typed** \(it knows it takes a string and returns a map\) and **introspectable** \(your application can examine it at runtime\). This means extensions can automatically understand and build on top of it.

### You could stop here

You could stop at this step and still derive significant value from Ash. You wouldn't be using it wrong. You can build your own custom state system under the hood, use Phoenix contexts, call directly into Ecto, totally up to you.

### Persistence

Now let's add state to support persistent storage, while keeping our existing behavior:

    # lib/my_blog/blog.ex        defmodule         MyBlog.Blog         do    
          use         Ash.Domain    

          resources         do    
            resource         MyBlog.Blog.Post         do    
              define         :analyze_text    ,         args    :         [    :text    ]    
              define         :create_post    ,         action    :         :create    ,         args    :         [    :title    ,         :content    ]    
            end    
          end        end    
        # lib/my_blog/blog/post.ex        defmodule         MyBlog.Blog.Post         do    
          use         Ash.Resource    ,    
            domain    :         MyBlog.Blog    ,    
            data_layer    :         AshPostgres.DataLayer         # data_layer tells Ash where to store data    

          postgres         do    
            table         "posts"    
            repo         MyBlog.Repo    
          end    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :title    ,         :string    ,         allow_nil?    :         false    ,         public?    :         true    
            attribute         :content    ,         :string    ,         public?    :         true    
            attribute         :status    ,         :atom    ,         constraints    :         [    one_of    :         [    :draft    ,         :published    ]    ]    ,         default    :         :draft    ,         public?    :         true    

            create_timestamp         :created_at    ,         public?    :         true    
            update_timestamp         :updated_at    ,         public?    :         true    
          end    

          actions         do    
            action         :analyze_text    ,         :map         do    
              argument         :text    ,         :string    ,         allow_nil?    :         false    

              run         fn         input    ,         _context         ->    
                text         =         input    .    arguments    .    text    
                words         =         String    .    split    (    text    )    

                analysis         =         %{    
                  word_count    :         length    (    words    )    ,    
                  character_count    :         String    .    length    (    text    )    ,    
                  estimated_reading_time    :         div    (    length    (    words    )    ,         200    )         +         1    
                }    

                {    :ok    ,         analysis    }    
              end    
            end    

            defaults         [    :read    ,         :destroy    ,         create    :         [    :title    ,         :content    ]    ,         update    :         [    :title    ,         :content    ,         :status    ]    ]    
          end        end

Now your resource combines behavior and state. The original `analyze_text` action still works, plus you can create and persist posts:

    # Behavior still works exactly the same        {    :ok    ,         analysis    }         =         MyBlog.Blog    .    analyze_text    (    "Some text to analyze"    )    
        # Now we can also persist state        {    :ok    ,         post    }         =         MyBlog.Blog    .    create_post    (    "My First Post"    ,         "This is some content"    )

### GraphQL

This is just one example of an API extension. We also have ash\_json\_api with more on the way. Ash also comes with all the tools you need to build *your own* API extension.

    # Add to your domain        defmodule         MyBlog.Blog         do    
          use         Ash.Domain    ,    
            extensions    :         [    AshGraphql.Domain    ]    

          graphql         do    
            queries         do    
              action         MyApp.Blog.Post    ,         :analyze_text    ,         :analyze_text    
            end    

            mutations         do    
              create         MyApp.Blog.Post    ,         :create_post    ,         :create    
            end    
          end    

          # ... resources        end    
        # Add to your resource        defmodule         MyBlog.Blog.Post         do    
          use         Ash.Resource    ,    
            domain    :         MyBlog.Blog    ,    
            data_layer    :         AshPostgres.DataLayer    ,    
            extensions    :         [    AshGraphql.Resource    ]    

          graphql         do    
            # you just tell us the name of the type    
            # we can take care of the rest    
            # there is deep configuration with plenty of escape hatches    
            # for when you need something bespoke    
            type         :post    
          end    

          # ... rest of resource definition        end

Now you have a full GraphQL API with queries, mutations, and custom actions automatically generated from your resource definition. That is actually all of the code you need to do it.
> 
> The ease of defining our domain model and configuring Ash to generate a powerful GraphQL API has been a game-changer. What used to be complex and time-consuming has become simplicity itself.

> — Alan Heywood, CTO, HereTask

### Encryption

Cloak is a powerful library for encrypting data at rest and in transit. Ash provides a first class extension that integrates with it directly.

    defmodule         MyBlog.Blog.Post         do    
          use         Ash.Resource    ,    
            domain    :         MyBlog.Blog    ,    
            data_layer    :         AshPostgres.DataLayer    ,    
            extensions    :         [    AshGraphql.Resource    ,         AshCloak.Resource    ]    

          cloak         do    
            vault         MyBlog.Vault    
            attributes         [    :content    ]          # Encrypt the content attribute    
          end    

          # ... rest of resource definition        end

Your post content is now automatically encrypted at rest and decrypted when read, with no changes to your existing API or business logic.

### State Machines

A state machine is a way to model the valid states for some piece of data. It allows you to define the states a record can be in, and the transitions between those states.

    defmodule         MyBlog.Blog.Post         do    
          use         Ash.Resource    ,    
            domain    :         MyBlog.Blog    ,    
            data_layer    :         AshPostgres.DataLayer    ,    
            extensions    :         [    AshGraphql.Resource    ,         AshCloak.Resource    ,         AshStateMachine    ]    

          state_machine         do    
            initial_states         [    :draft    ]    
            default_initial_state         :draft    

            transitions         do    
              transition         :publish    ,         from    :         :draft    ,         to    :         :published    
              transition         :unpublish    ,         from    :         :published    ,         to    :         :draft    
            end    
          end    

          actions         do    
            # ... same actions as before    
            update         :publish         do    
              change         transition_state    (    :published    )    
              # ... additional custom logic on publish    
            end    

            update         :unpublish         do    
              change         transition_state    (    :draft    )    
              # ... additional custom logic on publish    
            end    
          end    

          # ... rest of resource definition        end

Now your posts have a proper state machine with transition actions, state validation, and automatic GraphQL mutations for state changes.

## The Ash Advantage

This example demonstrates Ash's core philosophy: **Model your domain, derive the rest**. Notice how:

+ The resource definition remained largely unchanged as we added each extension
+ Each extension automatically understood and enhanced the existing actions
+ Complex functionality \(encryption, state machines, APIs\) required minimal configuration
+ Everything remains introspectable and type-safe
+ Your business logic stays focused on the domain, not infrastructure concerns
+ These extensions are built with the same suite of tools we provide *to the user* for extending Ash. Those using Ash will often end up crafting their own extensions, making the framework truly their own.

Extensions work together seamlessly because they all operate on the same well-defined resource and action abstractions. In the example above, we went from a single action to a full-featured system with database persistence, GraphQL API, encryption, and state management - by adding configuration, not writing code.

**The productivity gain is measurable**: What normally requires separate database migration files, API endpoint definitions, validation logic, GraphQL schema files, and state management code becomes a single, cohesive resource definition that stays automatically synchronized.



# Design Principles

The design principles behind Ash allows us to build an extremely flexible and powerful set of tools, without locking users into specific choices at any level. The framework acts as a spinal cord for your application, with extension points at every level to allow for custom behavior. What follows are the core tenets behind Ash Framework.

## Anything, not Everything

"Anything, not Everything" means building a framework capable of doing anything, not providing a framework that already does everything. The first is possible, the second is not. Our primary goal is to provide a framework that *unlocks* potential, and frees developers to work on the things that make their application special.

To this end, there are many prebuilt extensions to use, but there is also a rich suite of tools to build your *own* extensions. In this way, you can make the framework work for you, instead of struggling to fit your application to a strictly prescribed pattern. Use as much of Ash as you can, and leverage the amazing Elixir ecosystem for everything else.

## Declarative, Introspectable, Derivable

The real superpower behind Ash is the declarative design pattern. All behavior is driven by explicit, static declarations. A resource, for example, is really just a configuration file. On its own it does nothing. It is provided to code that reads that configuration and acts accordingly.

You can read more about some simple declarative design patterns outside of the context of Ash Framework in An Incremental Approach to Declarative Design.

## Configuration over Convention

While convention has value, we believe that explicit configuration ultimately leads to more discoverable, maintainable and flexible applications than a convention driven approach. This means that we never do things like assume that files with a given name are a certain type of thing, or that because a file is in a certain location, it should perform a specific function.

## Pragmatism First

While Ash does have lofty goals and a roadmap, the priority for development is always what the *current* users of Ash need or are having trouble with. We focus on simple, pragmatic, and integrated solutions that meld well with the rest of the framework.

A high priority is placed on ensuring that our users don't experience feature whip-lash due to poorly thought out implementations, and that any breaking changes \(a rare occurrence\) have a clean and simple upgrade path. This is something made much easier by the declarative pattern.

## Community

The Ash community comes together and collaborates to make sure that we can all build our software quickly, effectively and in a way that will age gracefully. We have a strict code of conduct, and love working with people of any experience level or background. To experience this first-hand, participate on ElixirForum or join our discord\!

### Domain Driven Design?

Ash is *not* a Domain Driven Design framework, if we're talking about "proper" Domain Driven Design as it is taught and discussed today. Domain Driven Design comes with a considerable amount of baggage and unnecessary complexity. While we identify with the *goals* of Domain Driven Design, we believe that a simpler approach is more effective, and that much of what DDD teaches are actually *implementation* details, and not *design* concepts. If the name wasn't taken, we would surely have claimed it for ourselves. If you must have a similar term for Ash, consider it a "Resource-oriented, Declarative Design Application Framework".



# Contributing to Ash

## Welcome\!

We are delighted to have anyone contribute to Ash, regardless of their skill level or background. We welcome contributions both large and small, from typos and documentation improvements, to bug fixes and features. There is a place for everyone's contribution here. Check the issue tracker or join the ElixirForum/discord server to see how you can help\! Make sure to read the rules below as well.

## Contributing to Documentation

Documentation contributions are one of the most valuable kinds of contributions you can make\! Good documentation helps everyone in the community understand and use Ash more effectively.

### Protocol for Documentation Improvements

**We prefer Pull Requests over issues for documentation improvements.** Here's why and how:

+ **Make a PR directly** - This is the preferred approach\! Even if you're not 100% sure about your changes, submitting a PR with your suggested improvement is much more helpful than opening an issue to discuss it.
+ **PRs represent tangible suggestions** - They're easy to review, approve, reject, or modify. We can see exactly what you're proposing and act on it quickly.
+ **Issues are okay too** - If you're really unsure or want to discuss a larger documentation restructuring, you can open an issue first. But for most cases, just make the PR\!
+ **Don't worry about rejection** - If a PR doesn't fit or needs changes, we'll provide feedback or close it with explanation. This is much more efficient than back-and-forth discussion in issues.

### Making Documentation Changes

The best way to contribute to documentation is often through GitHub's web interface, which allows you to make changes without having to clone the code locally:

**For Guides:**

+ While viewing any guide on the documentation website, look for the `</>` button in the top right of the page
+ Clicking this button will take you directly to GitHub's editing interface for that file



**For Module Documentation:**

+ When viewing module documentation, the `</>` button will also be in the top right of the page

**For Function Documentation:**

+ When viewing individual functions, you'll find the `</>` button next to the function header



Once you click the `</>` button, GitHub will:

1. Fork the repository for you \(if you haven't already\)
2. Open the file in GitHub's web editor
3. Allow you to make your changes directly in the browser
4. Help you create a pull request with your improvements

This workflow makes it incredibly easy to fix typos, clarify explanations, add examples, or improve any part of the documentation you encounter while using Ash.

### Important Note About DSL Documentation

**DSL documentation cannot be edited directly on GitHub.** The documentation you see for DSL options \(like those for `Ash.Resource`, `Ash.Domain`, etc.\) is generated from the source code of the DSL definition modules.

For example, if you want to improve documentation for `Ash.Resource` options, you need to edit the source code in the `Ash.Resource.Dsl` module, not the generated documentation files. The DSL documentation is automatically generated from the `@doc` attributes and option definitions in these modules.

To find the right module to edit:

+ For `Ash.Resource` DSL docs → edit `lib/ash/resource/dsl.ex`
+ For `Ash.Domain` DSL docs → edit `lib/ash/domain/dsl.ex`
+ And so on for other DSL modules

When making DSL documentation improvements, make sure to:

1. Edit the appropriate DSL definition module \(not generated docs\)
2. Test that your changes generate correctly by running `mix docs`

## Rules

+ We have a zero tolerance policy for failure to abide by our code of conduct. It is very standard, but please make sure you have read it.
+ Issues may be opened to propose new ideas, to ask questions, or to file bugs.
+ Before working on a feature, please talk to the core team/the rest of the community via a proposal. We are building something that needs to be cohesive and well thought out across all use cases. Our top priority is supporting real life use cases like yours, but we have to make sure that we do that in a sustainable way. The best compromise there is to make sure that discussions are centered around the *use case* for a feature, rather than the proposed feature itself.
+ Before starting work, please comment on the issue and/or ask in the discord if anyone is handling an issue. Be aware that if you've commented on an issue that you'd like to tackle it, but no one can reach you and/or demand/need arises sooner, it may still need to be done before you have a chance to finish. However, we will make all efforts to allow you to finish anything you claim.

## Local Development & Testing

### Setting Up Your Development Environment

1. 
**Fork and clone the repository:**

    git clone https://github.com/your-username/ash.git    cd ash

2. 
**Install dependencies:**

    mix deps.get

3. 
**Compile the project:**

    mix compile


### Running Tests and Checks

Before submitting any pull request, please run the full test suite and quality checks locally:

    mix check

This command runs a comprehensive suite of checks including:

+ Compilation
+ Tests
+ Code formatting \(via `spark.formatter`\)
+ Credo \(static code analysis\)
+ Dialyzer \(type checking\)
+ Documentation generation and validation
+ Sobelow \(security analysis\)
+ And other quality checks

You can also run individual checks:

+ `mix test` - Run the test suite
+ `mix format` - Format code
+ `mix credo` - Run static analysis
+ `mix dialyzer` - Run type checking
+ `mix docs` - Generate documentation

### Testing Ash with Your Application

If you want to test your Ash changes with your own application, you can use Ash as a local dependency. In your application's `mix.exs`, replace the hex dependency with a path dependency:

    defp         deps         do    
          [    
            # Replace this:    
            # {:ash, "~> 3.0"}    

            # With this (adjust path as needed):    
            {    :ash    ,         path    :         "../ash"    }    ,    

            # Your other dependencies...    
          ]        end

Then run:

    mix deps.get    mix compile

This allows you to:

+ Test your changes against real-world usage
+ Verify that your changes don't break existing functionality
+ Develop features iteratively with immediate feedback

Testing in your own application is not sufficient, you must also include automated tests.

### Development Workflow

1. 
**Create a feature branch:**

    git checkout -b feature/your-feature-name

2. 
**Make your changes** and write tests

3. 
**Run the full check suite:**

    mix check

4. 
**Commit your changes:**

    git add .    git commit -m "Add feature description"

5. 
**Push and create a pull request**


### Common Development Tasks

+ **Generate documentation:** `mix docs`
+ **Run tests in watch mode:** `mix test.watch`
+ **Check formatting:** `mix format --check-formatted`
+ **Run specific test file:** `mix test test/path/to/test_file.exs`
+ **Run tests with coverage:** `mix test --cover`



# Alternatives

There aren't really any alternatives to Ash that we are aware of that do all of the same things, but there are many different packages out there that do some of the things that Ash does.

This is a living document, and is not comprehensive. We are not *vouching* for any of these packages, but rather listing them here for your convenience to investigate on your own.

Want to add or edit this list? Open a pull request. Want a more comprehensive list? Check out the Awesome Elixir.

## Application Frameworks

These frameworks have similar overarching goals of helping you build your application layer.

+ Commanded - An event sourced application framework.
+ Sleeky - Billed as a lightweight alternative to Ash. Inspired by Ash, but more tightly built on top of ecto.

## Application Design

+ Boundary - A library for defining boundaries in your application.
+ Phoenix Contexts - Phoenix ships with a concept called "contexts", which provide some generators with application design guidance.

## Building APIs

+ Absinthe - A GraphQL toolkit for Elixir. This is what `AshGraphql` uses under the hood, but you can also use Absinthe directly.
+ Phoenix - Phoenix is a web framework for Elixir. It is not necessarily an API framework, but has all the tools you need to build APIs by hand.
+ JSONAPI Elixir - A library for building JSONAPI compliant APIs in Elixir on top of Ecto.
+ Open API Spex - A library for generating OpenAPI \(Swagger\) documentation for your API. We generate these for you in AshJsonApi, but you can use this library to build open api specifications of your hand-written API

## Working with Data

+ Ecto - Ecto is a database wrapper and query generator for Elixir. In many cases, Ash uses Ecto under the hood, but it is also available to build on top of directly.
+ Flop - A library designed to easily apply filtering, ordering, and pagination to Ecto queries.

## Authentication

+ mix phx.gen.auth - A mix task that generates authentication for a Phoenix application. Some folks prefer to use this over `AshAuthentication` even if they are using Ash.
+ Assent - Multi-provider authentication framework.

## Authorization

+ Bodyguard - A phoenix-context-based policy authorization framework.

## Validation

+ Ecto - Ecto can be used to validate data at the edge, using things like schema-less changesets.
+ Drops - a collection of small modules that provide useful extensions and functions that can be used to work with data effectively.
+ GuardedStruct - validation, sanitization, and construction of structs, supporting nested structs.



# Changelog

## **v3.5.33** \(2025-07-29\)

### Bug Fixes:

+ 
handle `nil` values properly in atomic changing validations by @zachdaniel

+ 
Application ER Mermaid Diagram \(\#2231\) by @maennchen

+ 
clear `nil` options in typed struct to constraints process by @zachdaniel

+ 
allow Ash @global\_opts authorize? to accept boolean or nil \(\#2225\) by @chazwatkins

+ 
Don't require permissions to read actor on non-atomic `relate_actor` \(\#2223\) by @chazwatkins

+ 
call underlying stream run instead of public interface by @zachdaniel


### Improvements:

+ 
`get_by_id` typo fix in usage rules \(\#2230\) by albinkc

+ 
Add array modifier to `ash.gen.resource` \(\#2228\) by Kenneth Kostrešević

+ 
Add prepend? opt to hooks and Ash.Subject transaction hooks \(\#2221\) by @chazwatkins

+ 
hooks: Add transaction hooks to Ash.Subject by @chazwatkins

+ 
Ash.Subject delegation and improvements by @chazwatkins

+ 
add `log?` option to `can` functions by @zachdaniel

+ 
add transaction hooks for read actions \(\#2219\) by ChristianAlexander


## **v3.5.32** \(2025-07-23\)

### Bug Fixes:

+ ensure that exists "at\_path" is returned as a relationship path by @zachdaniel

### Improvements:

+ add before/after/around transaction hooks to generic actions \(\#2218\) by ChristianAlexander

## **v3.5.31** \(2025-07-22\)

### Bug Fixes:

+ Catch invalid load \(\#2213\) by Kenneth Kostrešević

### Improvements:

+ 
Add Ash.Subject to abstract Changeset, Query, ActionInput common functions \(\#2212\) by @chazwatkins

+ 
support validations, preparations on generic actions by @zachdaniel

+ 
add before/after action hooks to generic actions by @zachdaniel


## **v3.5.30** \(2025-07-18\)

### Bug Fixes:

+ handle new return value from `kind_of_thing` in gen.resource by @zachdaniel

### Improvements:

+ support global validations being applied to reads by @zachdaniel

## **v3.5.29** \(2025-07-18\)

### Bug Fixes:

+ properly return `:error` when unable to determine type of module by @zachdaniel

## **v3.5.28** \(2025-07-17\)

### Bug Fixes:

+ 
accept composite types in typed struct types by @zachdaniel

+ 
keep descriptions from typed struct DSL by @zachdaniel


## **v3.5.27** \(2025-07-17\)

### Bug Fixes:

+ 
properly merge contexts from scope and opts by @zachdaniel

+ 
ensure that `modify_query` is honored on aggregates by @zachdaniel

+ 
read action: Tenant from before\_action will survive in metadata \(\#2189\) by @serpent213

+ 
set action on aggregate queries by @zachdaniel

+ 
cascade change action selection \(\#2193\) by @barnabasJ

+ 
try atomic\_upgrade\_with before falling back to primary action in cascade changes \(\#2191\) by @barnabasJ

+ 
ensure `cast_input` uses `new` callback on typed structs by @zachdaniel

+ 
use correct options in code interfaces in usage-rules.md by @zachdaniel

+ 
support single atoms in `sort_input` by @zachdaniel


### Improvements:

+ 
support where clauses on preparations by @zachdaniel

+ 
support `Ash.Query` for most builtin validations by @zachdaniel

+ 
support validations on read actions by @zachdaniel

+ 
introduce `Ash.TypedStruct` as a simpler struct type by @zachdaniel


## **v3.5.26** \(2025-07-09\)

### Bug Fixes:

+ 
don't dump values to native when building changesets by @zachdaniel

+ 
ensure that async limiter is properly cleared by @zachdaniel

+ 
when comparing embedded attributes, ignore metadata keys by @zachdaniel

+ 
clear async limiter on pagination query by @zachdaniel


### Improvements:

+ 
set `show_policy_breakdowns?` to `true` in dev/test by default by @zachdaniel

+ 
make `mix ash.gen.resource` merge existing resources by @zachdaniel

+ 
allow code\_interface default\_options to accept a function \(\#2183\) by scottwoodall

+ 
show optional code interface inputs in usage rules by @zachdaniel


## **v3.5.25** \(2025-07-02\)

### Bug Fixes:

+ 
handle additional cases in `Ash.Filter.flat_map` by @zachdaniel

+ 
handle overlapping type short-codes in app/dependencies by @zachdaniel

+ 
ensure that constraints are set on calculations by @zachdaniel

+ 
Upgrade strip\_metadata/1 to recurse on maps and handle additional metadata fields \(\#2169\) by Samuel Wrenn

+ 
ensure that atomic upgrades assume casted inputs by @zachdaniel

+ 
move length constraint checking to the end \(\#2155\) by kernel-io


### Improvements:

+ 
validate reserved constraint key names by @zachdaniel

+ 
Read Action multitenancy :bypass\_all \(\#2154\) by xantrac

+ 
add missing types to Ash.load typespec \(\#2167\) by @barnabasJ

+ 
allow pure-binary sigils in expr fragments \(\#2165\) by Frank Dugan III

+ 
add notifier trace/telemetry span type by @zachdaniel


## **v3.5.24** \(2025-06-25\)

### Bug Fixes:

+ 
restrict subset of context -> opts in embedded changesets by @zachdaniel

+ 
properly handle nested context for embeddable type by @zachdaniel

+ 
Use the same parent query timeout for the count query, for `read` actions \(\#2161\) by sevenseacat

+ 
ensure join query has shared context passed to it by @zachdaniel

+ 
ensure shared context is set on through queries when loading by @zachdaniel


### Improvements:

+ 
make usage-rules more clear about require Ash.Query by @zachdaniel

+ 
`require Ash.Query` in `Ash.Resource` by @zachdaniel


## **v3.5.23** \(2025-06-19\)

### Bug Fixes:

+ 
set proper metadata key for bulk destroy changes by @zachdaniel

+ 
don't override tenant if manually set by @zachdaniel


## **v3.5.22** \(2025-06-18\)

### Bug Fixes:

+ 
template opts in conditions in atomic changes by @zachdaniel

+ 
properly detect existing timestamp attributes in igniter tasks by @zachdaniel


### Improvements:

+ 
improve message for --dev migrations message by @zachdaniel

+ 
add `mix ash` command by @zachdaniel

+ 
handle changes to `nil` for unknown attribute values by @zachdaniel


## **v3.5.21** \(2025-06-16\)

### Bug Fixes:

+ 
support read actions and arguments in Ash.Generator.action\_input/3 \(\#2137\) by @barnabasJ

+ 
combination\_of typespec \(\#2135\) by @barnabasJ


### Improvements:

+ 
allow update\_query when `expr_error` is nto supported by @zachdaniel

+ 
only require atomicity when update\_query *and* expr\_error supported by @zachdaniel

+ 
make installer avoid protocol consolidation by @zachdaniel


## **v3.5.20** \(2025-06-13\)

### Bug Fixes:

+ support private\_arguments in code interface and bulk actions \(\#2133\) by @barnabasJ
+ combination\_of typespec \(\#2135\) by @barnabasJ

## **v3.5.19** \(2025-06-12\)

### Bug Fixes:

+ bad pattern match in query inspect logic by @zachdaniel

## **v3.5.18** \(2025-06-11\)

### Improvements:

+ support regexes in match constraint/validation again by @zachdaniel

## **v3.5.17** \(2025-06-10\)

### Bug Fixes:

+ set\_tenant on combination query \(\#2123\) by @barnabasJ

## **v3.5.16** \(2025-06-10\)

### Bug Fixes:

+ 
ensure context is properly threaded through bulk update/atomic upgrades by @zachdaniel

+ 
ensure `actor: nil` key is retained on scope to opts by @zachdaniel

+ 
ensure stream\_batch\_size is properly set to batch\_size on stream by @zachdaniel

+ 
set batch size option when streaming by @zachdaniel

+ 
keep union types in order by @zachdaniel

+ 
resolve accidentally backwards incompatible inspect implementation by @zachdaniel

+ 
better error message on mismatch action types in changesets by @zachdaniel

+ 
add clause in Ash.Type.String.match/1 to handle the OTP 28 regex tuples \(\#2119\) by Simon Bergström

+ 
underlying ecto type casting should use coercion, not cast\_input by @zachdaniel

+ 
make decimal type less strict by @zachdaniel

+ 
Fix typespecs for Ash.get\! and Ash.load\! \(\#2117\) by Moxley Stratton

+ 
implement Scope.to\_opts for policy authorizer by @zachdaniel

+ 
simplify relationship loading, to prevent losing set query info by @zachdaniel

+ 
typo in Ash.Error.Framework module \(\#2108\) by Samuel Wrenn

+ 
ash.gen.validation generates invalid callback \(\#2103\) by KasparKipp


### Improvements:

+ 
show action when inspecting query by @zachdaniel

+ 
add assert\_stripped test helper \(\#2107\) by Samuel Wrenn

+ 
fix misleading value in invalid attribute error by @zachdaniel

+ 
better error message on unexpected argument inputs to code interfaces \(\#2102\) by Abhishek Tripathi


## **v3.5.15** \(2025-06-04\)

### Bug Fixes:

+ 
only override bulk options if method is `:id` in code interfaces

+ 
handle missing primary keys more explicitly, and gracefully

+ 
Omit nil values in Ash.Scope.to\_opts/2 \(\#2088\)

+ 
Correct error message, example and doc for match constraint. \(\#2086\)

+ 
handle context opt in Ash.calculate/2 \(\#2083\)


### Improvements:

+ 
put **meta** and relationships at the end when inspecting \(\#2096\)

+ 
usage-rules: Add more guidance around codegen. \(\#2100\)

+ 
update usage rules \(\#2095\)


## **v3.5.14** \(2025-06-01\)

### Bug Fixes:

+ 
ensure the proper dependency on igniter

+ 
ensure map module loaded when calling it

+ 
raise if integer primary key is not supplied in ETS \(\#2079\)


## **v3.5.13** \(2025-05-30\)

### OTP 28 Compatibility

`Ash.Type.String`, `Ash.Type.CiString` and the built in `match` validation all now warn on the use of regexes. OTP 28 no longer supports building regexes at compile time. The warning will explain.

## Notable Features

+ 
`:shared` context key is now automatically passed down to child actions. See the actions guide for more information.

+ 
add `Ash.Scope`, mirroring the Phoenix pattern, and extend that to all Ash callback contexts. See `Ash.Scope` for more. \(\#2050\)


### Bug Fixes:

+ 
\[`Ash.Query`\] Allow non-list input to skip\_unknown\_inputs opt of query \(\#2074\)

+ 
\[`Ash.Query`\] handle single tuple & string values in sort

+ 
\[`Ash.Query`\] use proper read action calls when building aggregates

+ 
\[`Ash.Generator`\] don't generate values for attributes that are `writable?: false` and `generated?: true`

+ 
\[`:embedded` resources\] ensure we detect all cases where embedded attributes can't be atomically updated

+ 
\[`Ash.Type.NewType`\] fix issue with expanding constraints for lazy initialized new types

+ 
\[`Ash.Changeset`\] properly pass tenant in bulk\_update to managed\_relationships \(\#2061\)


### Improvements:

+ 
\[`mix ash.codegen`\] add `Ash.Error.Framework.PendingCodegen` error, used for the new `AshPhoenix.Plug.CheckCodegenStatus` plug

+ 
\[`Ash.Generator`\] support upsert/upsert\_identity in changeset generator

+ 
\[`usage-rules.md`\] Improve LLM rules in `usage-rules.md`. See usage\_rules for more.

+ 
\[`Ash.Type.Decimal`\] - Add `precision` and `scale` constraints.


## **v3.5.12** \(2025-05-22\)

### Features:

+ add duration type, functions and operator support \(\#2036\)

### Bug Fixes:

+ 
properly split lazy & non-lazy new type initialization

+ 
Ash.Reactor: Don't import `Ash.Expr` in the bulk update DSL. \(\#2055\)

+ 
don't lift query info to aggregate info on aggregation

+ 
ensure managed relationship context is kept for belongs\_to relationships


### Improvements:

+ 
Support manage relationship debug \(\#2021\)

+ 
add `strict_load` key to `Ash.Query.build`

+ 
Add an Ash.OptionsHelpers.calculation\_type/0 \(\#2051\)


## **v3.5.11** \(2025-05-20\)

### Bug Fixes:

+ 
ensure we fully initialize new types

+ 
Tuple loader and serializer \(\#2049\)

+ 
make sure after\_action is called in generate\_many \(\#2047\)

+ 
properly pass `select` into combinations

+ 
add\_new\_code\_interface/5 when do block occurs after resource \(\#2020\)


### Improvements:

+ add experimental new tool `Ash.data_layer_query`

## **v3.5.10** \(2025-05-15\)

### Bug Fixes:

+ 
ensure field policies are logged on success

+ 
various additional fixes for bulk action input ordering

+ 
Fix batch order of bulk\_create \(\#2027\)

+ 
make `lazy_init?` a callback so it can be checked on new types

+ 
don't raise error when no policies apply to request

+ 
ensure tenant is set on bulk created records.

+ 
don't try to cast input before cast atomic

+ 
properly prevent embedded attribute updates in atomics

+ 
preserve validation messages in non-atomic-bulk-update validations

+ 
add types for times operator

+ 
properly handle pre-expanded newtype constraints

+ 
shortcircuit queries properly

+ 
only print topic if present \(\#2013\)


### Improvements:

+ 
support :time\_usec \(\#2023\)

+ 
support `limit` on has\_many relationships \(\#2016\)


## **v3.5.9** \(2025-05-06\)

### Bug Fixes:

+ 
shortcircuit queries properly

+ 
ensure that context is set on authorizers in nested field policies

+ 
accept `private_arguments` option in the same way as `defaults` in generators

+ 
handle case where atomic change isn't cleared when converted to static

+ 
handle case where atomic condition isn't applied to generated validations


### Improvements:

+ 
normalize authorizer context in more locations

+ 
aggressively prune ets logs while retaining important info

+ 
combination queries \(\#2009\)


## **v3.5.8** \(2025-04-30\)

### Bug Fixes:

+ 
handle `nil` type or invalid types more gracefully in type determination

+ 
properly type expressions based on return values


### Improvements:

+ 
add rem/2 expr \(\#2004\)

+ 
add `Ash.Info` for general application information


## **v3.5.7** \(2025-04-29\)

### Bug Fixes:

+ 
Accept field opt in query aggregate \(\#2001\)

+ 
only return the changeset \(\#2003\)

+ 
expand types when typing expressions

+ 
Allow soft-deleting of many-to-many relationships \(\#1999\)

+ 
properly show timeout errors on read transactions

+ 
handle values that generate as `nil` in map generators

+ 
sort lazy loaded records post-linking

+ 
properly attach nested transient calculation dependencies

+ 
be more lax with lazy\_init? newtypes

+ 
properly return subtype constraints on constraint call

+ 
handle error cases in atomic changesets better

+ 
CodeInterface: logic error in `get_by` code interfaces. \(\#1961\)

+ 
CodeInterface: logic error in `get_by` code interfaces.

+ 
crash when sorting by aggregates with non-attribute field \(\#1986\)

+ 
handle atomic conditions on `{:atomic, ...}` changes

+ 
ensure data layer is loaded before using `function_exported?/3`

+ 
ensure that bulk callbacks are only called when appropriate

+ 
properly update belongs\_to records on `relate_and_update`


### Improvements:

+ 
Skip reading query for filter false \(\#2002\)

+ 
generator for union types

+ 
Add various DSL options for inspecting resources

+ 
hide calculations and aggregates when empty

+ 
hide calculation dep calculations while inspecting

+ 
Raise an `ArgumentError` when generating a changeset using a non-existent action \(\#1992\)

+ 
add `:tuple` builtin type

+ 
set changeset.load on bulk destroy actions

+ 
return the error when atomically cascade destroying

+ 
add a description to map/keyword/struct types

+ 
Remove duplicate impl of default policy functions \(\#1985\)

+ 
eagerly expand aggregates in `Ash.aggregate`

+ 
accept `context` option in generic action code interfaces


## **v3.5.6** \(2025-04-15\)

### Bug Fixes:

+ 
properly deduplicate on lazy relationship loading

+ 
use correct exceptions and add missing fields to them \(\#1960\)

+ 
undo incorrect change to trimmed string casting


### Improvements:

+ 
add `:__skip__` value to seed

+ 
Allow update action types in Ash.Generator.generate \(\#1967\)


## **v3.5.5** \(2025-04-14\)

### Bug Fixes:

+ 
don't trim strings when `trim?: false` is set

+ 
remove flawed optimization about `is_nil: false`

+ 
properly evaluate ci\_string concatenation in Elixir

+ 
don't validate types in gen.resource task.


### Improvements:

+ 
add calculation tools to `Ash.Resource.Igniter`

+ 
support a `load` option on changeset building


## **v3.5.4** \(2025-04-10\)

### Bug Fixes:

+ 
ensure after hooks force return\_records on bulk update/destroy

+ 
add action to changeset for opts fetching in bulk create

+ 
avoid coercion of datetime to date in start\_of\_day function \(\#1958\)

+ 
incorrect start\_of\_day value when timezone specified


## **v3.5.3** \(2025-04-09\)

### Bug Fixes:

+ 
avoid defining default actions when actions w/ that name exist

+ 
use the notification logic from bulk update in create \(\#1951\)

+ 
honor stream\_options in read code interfaces

+ 
Fix filtering with aggregates refers calculation error \(\#1954\)

+ 
properly provide the changeset to after action hooks

+ 
set calculation context in `Ash.can`

+ 
honor `:*` in skip\_unknown\_inputs in generic actions

+ 
honor action's `skip_unknown_inputs` in generic actions

+ 
set access*from in cascade*<update/destroy> \(\#1948\)

+ 
maintain order of enum values \(\#1942\)

+ 
carry context around to nested calculations better

+ 
fill templates in more necessary places

+ 
set tenant when building query in managed\_relationships


### Improvements:

+ 
optimize args handling in code interfaces

+ 
tasks for generating custom modules \(\#1940\)


## **v3.5.2** \(2025-03-31\)

### Bug Fixes:

+ 
match errors on cascade destroy/update

+ 
handle templated opts in bulk update after batch results

+ 
support `refs` and `args` option for `define_calculation`

+ 
don't cast arbitrary maps to structs in struct type


### Improvements:

+ 
add `default_sort` on relationships and queries \(\#1928\)

+ 
new type recursive validation \(\#1913\)

+ 
task for generating custom changes module \(\#1926\)

+ 
better error on `case` in ash expressions \(\#1927\)

+ 
helpful error on incorrectly implemented change modules

+ 
support `custom_input`s in code interfaces

+ 
Ash.Type.Enum - Add optional description and label value â¦ \(\#1925\)

+ 
support `exclude_inputs` for `define_calculation`

+ 
add `exclude_inputs` to code interface definitions

+ 
fix hint for read/generic actions in `NoSuchInput`


## **v3.5.1** \(2025-03-27\)

### Bug Fixes:

+ 
when reading a record to simulate an update, merge with data

+ 
more consistent error messaging from present validation

+ 
can't atomically update a query w/ after\_action hooks


### Improvements:

+ 
add `Ash.transaction(resources, func, opts)` \(\#1914\)

+ 
set `query_for` context on queries


## **v3.5.0** \(2025-03-26\)

### Bug Fixes:

+ don't set `accessing_from` on lookups for managed relationships

This *may* be a breaking change for some cases, but ultimately we felt it was too confusing to leave as it was. The semantics of `accessing_from` meant that "all actions done as part of `manage_relationship` were allowed to be performed. This was the intended design, but made it easy to implement an authorization related bug. Specifcaly, the `on_lookup` behavior would set that context as well, potentially allowing a user to relate something to a resource that you did not intend them to be able to see.

### Improvements:

+ 
add `tenant()` filter template expression \(\#1909\)

+ 
`Ash.Domain.Igniter.add_new_code_interface/5`

+ 
add `unsafe_to_atom?` constraint for `Ash.Type.Atom`

+ 
support `expr(exists(relation))` \(\#1912\)


## **v3.4.73** \(2025-03-25\)

### Bug Fixes:

+ 
use attribute names, not structs, for retaining ets update attrs

+ 
supply reactor with `nil` values for non-supplied arguments


## **v3.4.72** \(2025-03-25\)

### Bug Fixes:

+ 
retain loaded fields on ETS data layer update

+ 
Fixes processing of manual bulk actions, with tests. \(\#1903\)

+ 
Ensure batch\_size is correctly set, return values are nil if not requested.

+ 
batch\_size cond statement, fix batch -> changeset typo.

+ 
ensure consistent bulk result for `return_records?` and `return_errors?` types.

+ 
add action to base query if not present

+ 
update spark to get missing builders in `spark.formatter`

+ 
handle tenancy for built query in cascade destroy/update

+ 
Improve processing of manual actions during bulk operations \(\#1883\)


### Improvements:

+ 
attach a limit to related queries if `from_many?: true`

+ 
support atomic actions in `can_` code interfaces

+ 
import the `:reactor` dep in `.formatter.exs` on install

+ 
maps,structs,keywords can be atomically updated

+ 
support anonymous functions in `error_handler` option


## **v3.4.71** \(2025-03-21\)

### Bug Fixes:

+ 
prefer new loads when loading relationships

+ 
put notifications in process context when inside an action

+ 
consider query tenant when validating aggregate multitenancy

+ 
update Validations.ActionIs to accept atom or list\(atom\) \(\#1893\)


### Improvements:

+ set `bulk_actions_default_to_errors?` to `true` in installer

## **v3.4.70** \(2025-03-20\)

### Bug Fixes:

+ 
compose get\_by and action filters properly

+ 
`fields` could be nil on exceptions

+ 
apply runtime supplied loads over top of action loads

+ 
return records from bulk soft destroy if requested \(\#1884\)

+ 
ensure error classes are used in code interfaces


### Improvements:

+ 
validate multitenancy earlier in bulk actions

+ 
initialize all types properly at compile time


## **v3.4.69** \(2025-03-18\)

### Bug Fixes:

+ 
apply strict load in `Ash.get` properly \(\#1881\)

+ 
honor tenant in `Ash.Seed.update!`

+ 
pattern match error in bulk result

+ 
match on `{:not_atomic` pattern in update actions

+ 
fix typo: `atomcis` -> `atomics`

+ 
properly evaluate `Exists{}` expressions in runtime filter

+ 
Fix upsert identity type error \(\#1872\)

+ 
Fix bulk\_create for manual create actions with bulk\_create/3 \(\#1869\)

+ 
ensure loading maps & structs properly load as keyword

+ 
make the --example installer flag idempotent

+ 
don't add tenant attribute for `all_tenant?` identities upsert keys

+ 
handle case clause error in `Ash.Filter`

+ 
validate return type of `Ash.Resource.Calculation.init/1`

+ 
make `lazy_init` work on `NewTypes`

+ 
properly parse maps with tuple values in filter parser

+ 
dump values to native storage type when doing atomic upgrades

+ 
fix required error deduplication logic

+ 
undo breaking change, use primary read action loads in `Ash.load!`

+ 
don't derive fields for resources in map types

+ 
make sequence unshrinkable in generators

+ 
properly handle bulk soft destroy \(\#1854\)


### Improvements:

+ 
support a resource & attrs tuple in `seed_generator`

+ 
allow is\_equal and is\_not\_equal for compare validation \(\#1853\)

+ 
return errors and stop on errors by default in bulk actions

+ 
add config to do read after\_action hooks in order

+ 
add compile flag requiring atomic for default actions

+ 
types support atomic update by default for non-expr values

+ 
add `actions.read.pagination.stable_sort` customization

+ 
support inferring struct types from a resource

+ 
show value in match validation errors

+ 
disambiguation message on NoSuchFunction


## **v3.4.68** \(2025-03-11\)

### Bug Fixes:

+ 
init nested types in map/keyword/struct types

+ 
properly handle change with `where` validations in bulk \(\#1843\)

+ 
properly construct `parent_stack` for loaded relationships

+ 
update context tenant from changeset for each change \(\#1837\)


### Improvements:

+ 
allow manual reads return `full_count` for pagination

+ 
validate action types in `Ash` functions


## **v3.4.67** \(2025-03-04\)

### Bug Fixes:

+ Pass tenant option when seeding resource given by the generator \(\#1834\)

## **v3.4.66** \(2025-03-03\)

### Bug Fixes:

+ 
handle unparseable relationship sorts & single atom sorts

+ 
don't allow modifying changeset with atomic conditions

+ 
don't prevent changing values to `nil` when original data is not available

+ 
propagate invalid reference error when adding calc context to sort \(\#1827\)

+ 
ensure that we don't try to compare not loaded or forbidden values

+ 
use `filter` not `filters` in stale record error


### Improvements:

+ 
add `touching?` option to changing validation

+ 
don't show required errors for fields with other errors

+ 
validate aggregate multitenancy

+ 
ignore action-defined loads when using `Ash.load`


## **v3.4.65** \(2025-02-25\)

### Bug Fixes:

+ 
properly enumerate `:_pkey` in notifier

+ 
Always rollback input.resource when running generic actions. \(\#1817\)

+ 
fix case where batch before/after action callbacks could be skipped

+ 
return NotFound error in proper cases on bulk interfaces

+ 
don't eagerly return records on bulk update/destroys

+ 
ensure actor templates are hydrated for aggregates

+ 
properly use operator overloads for evaluating operators at runtime

+ 
Missing case clause for bulk update/destroy with `get?: true` in interface \(\#1806\)

+ 
always run update filter on skipped updates

+ 
don't change update defaults unless something changes


### Improvements:

+ 
better parent resource tracking in expressions

+ 
Generic actions to raise if they don't have return type but have an return value \(\#1805\)


## **v3.4.64** \(2025-02-17\)

### Bug Fixes:

+ 
use undo action in generic action undo

+ 
handle generic actions with no return

+ 
ensure atomic `set_attribute` behaves the same as non-atomic

+ 
Missing actor on aggregate resource call \(\#1796\)

+ 
Missing actor on aggregate call \(\#1793\)


### Improvements:

+ 
support receiving the inputs when undoing generic actions

+ 
simplify & unify sort/sort\_input logic

+ 
support related sorts everywhere \(not just sort\_input\)

+ 
add field names to identities \(\#1786\)


## **v3.4.63** \(2025-02-11\)

### Bug Fixes:

+ 
set `read_after_writes` to true if generated

+ 
type cast errors w/ floats & vectors

+ 
handle case clause error in filters

+ 
don't return invalid type from vector type

+ 
don't double process string interpolation expressions

+ 
Include warning for arguments only when 'things' are arguments \(\#1785\)

+ 
empty bulk create inputs must still return a stream

+ 
don't use `authorize_with: :error` on data layers that can't do it

+ 
pass tenant to load in cascade destroy \(\#1775\)

+ 
add tenant to load in cascade update \(\#1773\)

+ 
raise errors on partial\_success results in bulk actions

+ 
add `reuse_values?` opt to `Ash.can` and disable it automatically

+ 
compile `Ash.PlugHelpers` even without `Plug` available

+ 
expand `opts` when using `calculate/3`

+ 
handle base resources in `ash.extend`

+ 
type system warning on apps w/o solvers

+ 
Fix no read action exception for through relationship \(\#1750\)

+ 
always recompile domain on resource changes

+ 
fix handling of generic action returns with transaction enabled \(\#1758\)

+ 
type struct handle instance of return error tuple \(\#1756\)

+ 
Compilation failure when using the `ash_step` Reactor DSL. \(\#1753\)

+ 
pass `authorize?` option to `bulk_create` in `Ash.Generator.generate_many/2`


### Improvements:

+ 
Add string\_position expression \(\#1782\)

+ 
add `dimensions` to vector type

+ 
add filter & transform options for pubsub notifier

+ 
verify pub\_sub actions at compile time

+ 
more clean boolean filter optimization for `or ==`

+ 
add `reuse_values?` option for calculate\!

+ 
prefer `calculate/3` when reusing values

+ 
add `Ash.Type.coerce/2` callback


## **v3.4.62** \(2025-01-31\)

### Bug Fixes:

+ 
\[`Ash.Changeset`\] always start transactions when managing relationships

+ 
\[`Ash.Changeset`\] handle parent in rel in managed belongs to \(\#1746\)


## **v3.4.61** \(2025-01-31\)

### Bug Fixes:

+ 
\[`Ash.Generator`\] don't prevent setting manage\_relationship inputs in generators

+ 
\[`Ash.Reactor`\] Fix referring to outer steps and inputs in `transaction` steps. \(\#1741\)

+ 
\[`Ash.Expr`\] always return utc timestamp as result of `start_of_day`

+ 
\[`Ash.Resource.Change.CascadeDestroy`\] support `after_action?` option on cascade destroys & better error when it should be used \(\#1734\)


### Improvements:

+ 
\[`Ash.Resource`\] warning on args, preparations or filters on primary reads

+ 
\[`Ash.Reactor`\] Support guards in `Ash.Reactor` steps. \(\#1739\)

+ 
\[`mix ash.extend`\] use `ash.extend` and use it instead of `ash.patch.extend`


## **v3.4.60** \(2025-01-27\)

### Bug Fixes:

+ \[`Ash.Expr`\] traverse custom expressions when listing refs

## **v3.4.59** \(2025-01-27\)

### Bug Fixes:

+ \[`Ash.Query`\] better placed validations of aggregate support for data layers

## **v3.4.58** \(2025-01-26\)

### Bug Fixes:

+ \[`Ash.Query.Aggregate`\] properly check query aggregate support

### Improvements:

+ \[`Ash`\] support `authorize_with` option in `Ash.get` \(\#1732\)

## **v3.4.57** \(2025-01-23\)

### Bug Fixes:

+ \[`Ash.Resource.Validation.Compare`\] ensure compare validation doesn't put functions in exceptions

## **3.4.56** \(2025-01-21\)

### Bug Fixes:

+ 
\[`Ash`\] don't use `JSON` due to library compatibility issues

+ 
\[`Ash.Changeset`\] matching in managed\_relationships handle\_update \(\#1719\)

+ 
\[`Ash.Query.Calculation`\] properly load doubly nested calculation's explicit dependencies

+ 
\[`Ash.Query.Calculation`\] handle related non-expr calculations referenced from expr calcs

+ 
\[`Ash.Query.Calculation`\] simplify and fix path generation for nested relationship path deps

+ 
\[`Ash`\] don't require multitenancy attribute in `get` \(\#1716\)


### Improvements:

+ 
\[`Ash.Changeset`\] make atomics work even if expr err is not supported \(\#1718\)

+ 
\[`Ash.Query`\] support error shorthand for `Ash.Query.add_error/2-3`

+ 
\[`Ash.Generator`\] add `uses` option for `changeset_generator`

+ 
\[`Ash.Generator`\] add `uses` option for `seed_generator`

+ 
\[`Ash.Changeset`\] Use clearer error message for match validation atomic errors \(\#1721\)

+ 
\[`Ash.Type`\] Add autogenerate\_enabled? to Ash.Type for Ecto compatibility \(\#1715\)

+ 
\[`Ash.Policy.Authorizer`\] warn when domain policies would be ignored by resources

+ 
\[`Ash.Domain`\] allow policy authorizer to be in authorizers key in domains


## **v3.4.55** \(2025-01-13\)

### Bug Fixes:

+ 
\[code interfaces\] ensure can\_\* code interfaces pass arguments to actions

+ 
\[`Ash`\] case clause error in `Ash.can?`

+ 
\[`Ash`\] reset `ash_started_transaction?` on bulk create

+ 
\[`Ash.Generator`\] handle embedded attributes in attribute generator

+ 
\[`Ash.Generator`\] Fix typo in skipped import name \(\#1704\)

+ 
\[`Ash.Generator`\] set max\_concurrency to 0 for generate\_many

+ 
\[`Ash.Generator`\] ensure that `once` and `sequence` behave predictably across tests


### Improvements:

+ 
\[`Ash.Changeset`\] destroy missing records first in `manage_relationship`

+ 
\[`Ash.Expr`\] add start\_of\_day function

+ 
\[`Ash.Type.DateTime`\] add `cast_dates_as` constraint to `Ash.Type.DateTime`


## **v3.4.54** \(2025-01-09\)

### Bug Fixes:

+ 
\[`Ash.Generator`\] Fix issues in `Ash.Generator.generate_many/2` \(\#1703\)

+ 
\[`Ash.Generator`\] Don't error if no `after_action` is provided to `generate_many`

+ 
\[`Ash.Generator`\] Reuse the changeset actor when calling `bulk_create`


### Improvements:

+ 
\[`Ash.Generator`\] run notifications for generators

+ 
\[`Ash.Changeset`\] `order_is_key` option for sorted relationships


## **v3.4.53** \(2025-01-08\)

### Bug Fixes:

+ 
\[`Ash.Generator`\] properly delegate and handle conflicts in `Ash.Generator`

+ 
\[`Ash.Generator`\] Replace calls to `create` and `create_many` with `generate` and `generate_many` \(\#1701\)

+ 
\[calculations\] use nested calculation dependencies from expr if not in expression

+ 
\[`Ash.Changeset`\] pattern match error on expression parse failure

+ 
\[`Ash.Test.Resource.Validation.StringLengthTest`\] handle `string_length` on arguments when atomic


## **v3.4.52** \(2025-01-06\)

### Bug Fixes:

+ 
\[`Ash.Type.Map`\] handle keyword errors from map field type casting

+ 
\[`mix ash.gen.resource`\] ensure extensions & subjects args are unique


### Improvements:

+ 
\[`ash.gen.resource`\] validate that names given to `ash.gen.resource`

+ 
\[`Ash.Generator`\] add `Ash.Generator.changeset_generator/3`

+ 
\[`Ash.Generator`\] add `Ash.Generator.seed_generator/2`

+ 
\[`Ash.Generator`\] only use known keys in generators in `Ash.Generator`

+ 
\[`Ash`\] support `after_action` option to `Ash.bulk_create`

+ 
\[`mix ash.install`\] set `yes_to_deps` when fetching dependencies

+ 
\[`Ash.Query`\] better error message on non-resource in `Ash.Query.new/2`

+ 
\[`Ash.bulk_destroy`\] handle limited bulk destroys from streams

+ 
\[Code interfaces\] bulk actions use `full_read` from code interfaces given ids

+ 
\[Code Interfaces\] set `limit` in code interface to update or destroy one thing


## **v3.4.51** \(2025-01-03\)

### Bug Fixes:

+ 
\[`Ash.Resource`\] handle ambiguous case of empty params in code interfaces \(\#1694\)

+ 
\[`Ash.Changeset`\] discard manage\_relationships added inside changes on atomic upgrade


## **v3.4.50** \(2025-01-01\)

### Bug Fixes:

+ 
\[`Ash.DataLayer.Ets`, `Ash.DataLayer.Mnesia`\] properly handle aggregate defaults in ets/mnesia \(\#1684\)

+ 
\[`Ash.Resource.Validation.Changing`\] use context message instead of default if provided in changing validation \(\#1677\)

+ 
\[`Ash.Changeset`\] ensure that `changed?` context is set to true for atomics

+ 
\[`Ash`\] properly match on `return_query?` option, avoid raised pattern match error

+ 
\[`Ash.Policy.Authorizer`\] ensure that old config applies all aggregate policies


### Improvements:

+ 
\[`Ash.Generator`\] add `Ash.Generator.once/2`

+ 
\[`Ash.Type.Map`, `Ash.Type.Keyword`, `Ash.Type.Struct`\] define `generate/1` callback for maps, structs, keywords

+ 
\[`Ash`\] add `data_layer?` option to `Ash.calculate/3`

+ 
\[`Ash.Resource`\] Add default code interface options \(\#1681\)

+ 
\[`Ash.Resource`\] add `allow_forbidden_field?` option to relationships

+ 
\[`Ash.Resource`\] add `authorize_read_with` option to relationships

+ 
\[`Ash`\] support `default` option in `Ash.first` \(\#1683\)

+ 
\[`Ash.Notifier.PubSub`\] allow exclusion of certain actions from publish\_all \(\#1680\)

+ 
\[`mix igniter.install ash`\] no prompt about SAT solver unless user is on windows

+ 
\[`Ash.Domain`\] add otp\_app option to use Ash.Domain

+ 
	+ \[`Ash`\] add support for `strict?` in read options \(\#1669\)


## **v3.4.49** \(2024-12-22\)

### Improvements:

+ \[read actions\] - add support for `strict?` in `Ash.read` options. \(\#1669\)

### Bug Fixes:

+ \[`Ash.Policy.Authorizer`\] ensure that old config applies all aggregate policies

If you've upgraded to the following configuration this does not affect you:

    config         :ash    ,         :policies    ,         no_filter_static_forbidden_reads?    :         false

You should upgrade regardless, and adopt that new configuration.

## **v3.4.48** \(2024-12-20\)

### Bug Fixes:

+ 
\[calculations\] properly update sort calculation expressions

+ 
\[`Ash.Type.Module`\] handle nil values in `Ash.Type.Module`

+ 
\[`Ash.Resource`\] ensure that `select_by_default?` is honored on loads

+ 
\[`Ash.Type.Union`\] Verify union types constraint on init

+ 
\[loading data\] ensure tenant is set on reselection query


### Improvements:

+ 
\[Igniter\] handle igniter not being compiled, and make it optional

+ 
\[`Ash.Generator`\] add `Ash.Generator.next_in_sequence/3`

+ 
\[performance\] don't reselect unnecessary attributes

+ 
\[pagination\] add `show_keysets_for_all_actions?` configuration

Set `config :ash, show_keysets_for_all_actions?, false` for significant performance improvements when reading resources that support keyset pagination. This causes keysets to only be shown for actions that are actively being paginated with keyset pagination.


## **v3.4.47** \(2024-12-17\)

### Bug Fixes:

+ 
\[`Ash.Query`\] handle indexed maps and string keys in calculation arguments

+ 
\[`Ash.Changeset`\] throw validation error when trying to set public arguments in private\_arguments \(\#1663\)

+ 
\[`Ash.Policy.Authorizer`\] include `changeset` in preflight authorization context

+ 
\[embedded resources\] include presence of authorizers in embedded resource optimization

+ 
\[`Ash.DataLayer`\] don't check data layer compatibility for manual actions


### Improvements:

+ \[`Ash.Reactor`\]: Always add the notification middleware any time the extension is added. \(\#1657\)

## **v3.4.46** \(2024-12-12\)

### Bug Fixes:

+ 
\[`Ash.Tracer`\] use proper telemetry name for actions

+ 
\[`Ash.Sort`\] use atoms for paths in related sorts


## **v3.4.45** \(2024-12-10\)

### Bug Fixes:

+ \[`Ash`\] don't ignore tenant when calling aggregate functions

### Improvements:

+ \[`Ash.Policy.Authorizer`\] don't log field policies unless logging successful policy breakdowns

## **v3.4.44** \(2024-12-06\)

### Bug Fixes:

+ 
\[`Ash.Changeset`\] use `Ash.read` when eager validating relationships

+ 
\[`Ash.Expr`\] allow strings in `get_path/2`

+ 
\[`Ash.Sort`\] don't expand calculations until after authorization is complete

+ 
\[`Ash.Resource.Change.GetAndLock`\] don't automatically skip `get_and_lock` changes

+ 
\[`Ash.Filter`\] handle indexed maps in filter map syntax

+ 
\[`Ash.Filter`\] handle case where `%{or` is composing a single map

+ 
\[`Ash.Policy.Authorizer`\] ensure that `subject` is properly set when running field policies

+ 
\[`Ash.Type`\] fix logic errors in matches\_type?/list logic

+ 
\[pagination\] add tenant to Aggregate opts when building count query \(\#1630\)

+ 
\[notifications\] some notifications not being sent for bulk create actions

+ 
\[validations\] negate atomic validation expressions when used as `where` conditions \(\#1624\)

+ 
\[`Ash.Policy.Authorizer`\] don't double apply action-filters when attaching policy filters \(optimization\)

+ 
\[`Ash.read`\] Fix not working skip\_unknown\_inputs opt of read action \(\#1596\)

+ 
\[`Ash.read`\] Fix warning when actions.read.argument constraint is violated \(\#1607\)

+ 
\[aggregates\] use last relationship's read action properly in aggregate queries

+ 
\[`Ash.Changeset`\] finish conversion from `append?` to `prepend?` option \(\#1601\)


### Improvements:

+ 
\[`Ash.Type.NewType`\] add `lazy_init?` option. Allows for recursive embedded types.

+ 
\[`mix ash.gen.resource`\] More Descriptive Error Messages for ash.gen.resource \(\#1645\)

+ 
\[`Ash.Expr`\] better type signatures for division

+ 
\[`Ash.Expr`\] converge on known types better

+ 
\[`Ash.Changeset`\] add `Ash.Changeset.force_delete_argument/2`

+ 
\[`Ash.Policy.Check.Builtins`\] add `actor_absent` builtin check

+ 
\[`Ash.Changeset`\] Warn when `manage_relationship` is called without opts \(\#1408\)

+ 
\[`Ash.Resource.Validation.Builtins`\] use Comp with attribute\_equals and attribute\_does\_not\_equal \(\#1623\)


## **v3.4.43** \(2024-11-20\)

### Bug Fixes:

+ \[generic actions\] store notifications from simple results \(\#1591\)

## **v3.4.42** \(2024-11-07\)

### Bug Fixes:

+ 
\[`mix ash.generate_livebook`\] Allow multi-line descriptions to be rendered in Livebook without error \(\#1590\)

+ 
\[`Ash.Policy.Check.ChangingAttributes`\] properly handle `changing_attributes` check with `from` in create \(\#1584\)


### Improvements:

+ \[`Ash.Type.Union`\] support map w/ keys `_union_type` and `_union_value` for union inputs

## **v3.4.41** \(2024-11-05\)

### Bug Fixes:

+ 
\[`Ash.Type.Struct`\] don't double wrap casted struct instances in `{:ok, {:ok, ...}}`

+ 
\[`Ash.Type.Struct`\] support mixed key types in input maps for structs


## **v3.4.40** \(2024-11-04\)

### Bug Fixes:

+ 
\[`Ash.Actions.Read`\] don't call `.name` on a potentially `nil` action

+ 
\[`Ash.Expr`\] properly detect `Ash.CustomExpression` as an expr

+ 
\[`Ash.Expr`\] accept fragments pointing at non-aliases

+ 
\[`Ash.Expr`\] smarter type detection, preferring more concrete types


## **v3.4.39** \(2024-11-01\)

### Bug Fixes:

+ 
\[`Ash.Changeset`\] emit warnings about already validated actions in before\_action hooks too

+ 
\[`Ash.Changeset`\] add missing case clause for `Changeset.atomic_update` type cast \(\#1569\)

+ 
\[`Ash.Type.Map`\] handle case of invalid map/keyword key when type casting

+ 
\[`Ash.Type.Keyword`\] handle case of invalid map/keyword key when type casting


### Improvements:

+ \[error messages\] more better error bread crumbs

## **v3.4.38** \(2024-10-31\)

### Bug Fixes:

+ 
\[`Ash.Changeset`\] detect transaction hooks added by around\_transaction and before\_transaction & manual actions

+ 
\[`Ash.Changeset`\] don't special case `nil` change on `force_change_attribute`


### Improvements:

+ 
\[`Ash.Domain`\] default backwards compatible interface to false for domains

+ 
\[`Ash.Changeset`, create actions\] more and better bread crumbs for changesets & create actions


## **v3.4.37** \(2024-10-30\)

### Bug Fixes:

+ 
\[`Ash.Type.Union`\] handle nil union changing to nil

+ 
\[multitenancy\] enforce multitenancy on bulk creation

+ 
\[`Ash.Changeset`\] force\_change\_attribute no longer cares what the old value is


### Improvements:

+ 
\[`Ash.Changeset`\] allow specifying `return_skipped_upsert?` as an option to changeset

+ 
\[`Ash.DataLayer`\] add `prefer_transaction_for_atomic_updates?` data layer callback

+ 
\[`Ash.DataLayer`\] support `prefer_transaction?` on DataLayer

+ 
\[loading data\] allow data loading when no primary read action exists


## **v3.4.36** \(2024-10-24\)

### Bug Fixes:

+ \[`Ash.stream!`\] ensure opts are passed through to constructed query in stream

### Improvements:

+ \[`Ash.Policy.Check.Builtins`\] add `just_created_with_action/1` check

## **v3.4.35** \(2024-10-22\)

### Bug Fixes:

+ 
\[code interfaces\] allow optional code interface args for fields with defaults

+ 
\[atomic updates\] write all attributes to atomics list before dispatching to data layer on update query

+ 
\[`mix ash.gen.resource`\] remove multichar aliases from `mix ash.gen.resource`

+ 
\[`Ash.Type.Decimal`\] check nil before calling Decimal.eq? in Type.Decimal.equal? \(\#1538\)


## **v3.4.34** \(2024-10-21\)

### Bug Fixes:

+ \[`mix ash.gen.resource`\] properly accept options for `ash.gen.resource` in installer

## **v3.4.33** \(2024-10-18\)

### Bug Fixes:

+ 
\[bulk updates\] apply attribute multitenancy on bulk update queries

+ 
\[`Ash.Type.Decimal`\] use Decimal.eq? in Ash.Type.Decimal \(\#1532\)

+ 
\[`Ash.Reactor`\]: Don't validate `inputs` keys when being transformed. \(\#1527\)

+ 
\[atomic updates\] set argument defaults in fully atomic changesets

+ 
\[`Ash.Changeset`\] ensure that default values are included in attribute changes

+ 
\[manage\_relationship\] properly unrelate belongs\_to relationships

+ 
\[manage\_relationship\] ensure unrelated records are removed from the current records list


### Improvements:

+ 
\[`Ash.Resource`\] Conditionally enable transactions on default actions. \(\#1525\)

+ 
\[`Ash.Seed`\] ash seed upsert\! function \(\#1522\)

+ 
\[code interfaces\] Add compile-time checks for `code_interface` arguments in Resource and Domain \(\#1523\)


## **v3.4.32** \(2024-10-14\)

### Improvements:

+ \[`mix ash.gen.resource`\] use new `:csv` option type from igniter

## **v3.4.31** \(2024-10-14\)

### Bug Fixes:

+ \[all actions\] allow strings in generic action skip\_unknown\_inputs

## **v3.4.30** \(2024-10-14\)

### Bug Fixes:

+ \[all actions\] add `tracer` option to generic action opts

## **v3.4.29** \(2024-10-13\)

### Bug Fixes:

+ 
\[`Ash.Changeset`\] clear change from atomics as well

+ 
\[read actions\] properly invoke notify callback in read actions


### Improvements:

+ 
\[`Ash.Changeset`\] better ergonomics for atomic updates

+ 
\[changeset, action inputs, queries\] add `private_arguments` option

+ 
\[`Ash.ActionInput`\] validate `Ash.ActionInput.for_action` opts

+ 
\[`Ash.Type.NewType`\] allow additional callbacks in `Ash.Type.NewType`


## **v3.4.28** \(2024-10-10\)

### Improvements:

+ \[upserts\] support lazy evaluation of skipped upsert records

## **v3.4.27** \(2024-10-10\)

### Improvements:

+ \[upserts\] emit StaleRecordError on skipped upsert

## **v3.4.26** \(2024-10-08\)

### Bug Fixes:

+ 
\[query building\] properly hydrate sort with parent context

+ 
\[query building\] handle nested parent references in runtime expression logic

+ 
\[query building\] set parent stack when hydrating references in related queries


## **v3.4.25** \(2024-10-07\)

### Bug Fixes:

+ 
\[igniter\] honor --yes or -y option when adding a satsolver

+ 
\[query building\] don't error on type casting against expressions


## **v3.4.24** \(2024-10-07\)

### Bug Fixes:

+ 
\[policies\] short-circuit policy condition evaluation when checking all conditions

+ 
\[query building\] properly hydrate aggregate calculations & fields


### Improvements:

+ \[policies\] re-introduce removed behavior to short circuit policy conditions

## **v3.4.23** \(2024-10-03\)

### Bug Fixes:

+ 
\[loading data\] don't rewrite calculation dependencies through not loaded/forbidden fields

+ 
\[loading data\] honor `reuse_values?` when lazy loading relationships


## **v03.4.22** \(2024-10-01\)

### Features:

+ \[`Ash.Reactor`\] Add the ability to specify action context in steps. \(\#1477\)

### Bug Fixes:

+ 
\[`Ash.Query`\] properly merge query calculations when one side is empty

+ 
\[`Ash.Query`\] remove expensive calculation reification step that is no longer necessary

+ 
\[`Ash.Sort`\] handle expression calculations that reference fields in input sorting

+ 
\[`Ash.Sort`\] properly apply field policies to all filter expressions

+ 
\[`Ash.Type.Struct`\] better error message on missing `instance_of` constraint on load-through

+ 
\[authorization\] select minimal data in authorization queries

+ 
\[`Ash.Query`\] calling `for_read/2..4` should raise an `ArgumentError` when the specified action doesn't exist. \(\#1479\)

+ 
\[`Ash.Changeset`\] detect non-changing but setting attributes to honor `require_attributes` on update

+ 
\[`Ash.Changeset`\] set right defaults for `action_select` \(\#1476\)

+ 
\[`Ash.Expr`\] don't resolve references when falling back to elixir handling for expressions


### Improvements:

+ 
\[`Ash.Policy.Authorizer`\] disallow 2-tuple expression checks, to resolve ambiguity

+ 
\[`Ash.Policy.Authorizer`\] rewrite and drastically simplify policy -> solver expression logic

+ 
\[`Ash.Changeset`\] properly handle bypasses of atomic constraint casting

+ 
\[`Ash.Changeset`\] ensure that action\_select sets attributes to `%Ash.NotLoaded{}`

+ 
\[`Ash.Query.Calculation`\] add `Ash.Query.Calculation.from_resource_calculation`

+ 
\[`Ash.Query.Calculation`\] fallback to runtime calculations when expressions aren't supported

+ 
\[`Ash.Type.DateTime`\] handle iso8601 dates in datetime cast

+ 
\[`Ash.DataLayer`\] add data layer capability for action select

+ 
\[`Ash.Query.Calculation`\] inspect calculations in queries more fluidly

+ 
\[`Ash.Resource.Igniter`\] add\_identity for `Ash.Resource.Igniter`


## **v3.4.21** \(2024-09-24\)

### Bug Fixes:

+ 
\[`Ash`\] handle `nil` result in `Ash.first`

+ 
\[bulk actions\] add checks for `around_transaction` and `around_action` in bulk \(\#1474\)

+ 
\[`Ash.Query.Aggregate`\] include distinct from queries in aggregate query

+ 
\[read actions\] reselect required attributes unless `reuse_values?` is `true`

+ 
\[`Ash.Changeset`\] properly return `{:not_atomic` while applying atomic changes


### Improvements:

+ \[`Ash.Query.Aggregate`\] proper error on unsupported aggregates

## **v3.4.20** \(2024-09-23\)

### Bug Fixes:

+ \[read actions\] don't double-load data on bulk update reads

### Improvements:

+ 
\[`Ash`\] support more formats in `Ash.can`

+ 
\[`Ash`\] add `validate?` option to `Ash.can`/`Ash.can?`


## **v3.4.19** \(2024-09-21\)

### Bug Fixes:

+ \[`Ash.Resource`\] properly generate bypasses with `Ash.Resource.Igniter.add_bypass/2`

### Improvements:

+ 
\[`Ash.Sort`\] support nested fields in input sorts

+ 
\[optimization\] optimize the reselection of necessary attributes on lazy loading

+ 
\[`Ash.Resource`, optimization\] optimize `Ash.Resource.selected?/2` in light of 3.0 changes


## **v3.4.18** \(2024-09-20\)

### Bug Fixes:

+ 
\[`Ash.Resource.Change.OptimisticLock`\] properly increment version in optimist lock's non-atomic branch

+ 
\[`Ash.Policy.Authorizer`\] ensure that policy group compile time validations are enforced

+ 
\[bulk updates\] ensure that around\_transaction and around\_action hooks incur simple updates


## **v3.4.17** \(2024-09-19\)

### Bug Fixes:

+ 
\[`Ash.Query`\] handle more types in `Ash.Query.unload`

+ 
\[`Ash.Changeset`\] properly escape changeset.select in `Ash.Changeset.ensure_selected` \(\#1466\)


### Improvements:

+ 
\[`Ash.Tracer`\] add span & telemetry events for running calculations

+ 
\[`Ash.Policy.Check.Builtins`\] validate action types in `action_type` check


## **v3.4.16** \(2024-09-18\)

### Bug Fixes:

+ \[`Ash.Seed`\] ensure Ash.Seed always sets action\_select

### Improvements:

+ 
\[`Ash.Policy.Authorizer`\] properly log successful policy breakdowns with extra info

+ 
\[`Ash.Filter`\] add `Ash.Filter.fetch_simple_equality_predicate`


## **v3.4.15** \(2024-09-17\)

### Improvements:

+ \[`Ash.Query`\] add `load` option to `Ash.Query.for_read`

## **v3.4.14** \(2024-09-17\)

### Bug Fixes:

+ \[`mix ash.gen.domain`\] properly detect domains that don't exist yet in `ash.gen.domain`

## **v3.4.13** \(2024-09-17\)

### Bug Fixes:

+ 
\[`Ash.Changeset`\] honor `skip_global_validations?` on fully atomic changesets

+ 
\[`Ash.Sort`\] ensure calculation context is fully propagated to sort statements

+ 
\[`Ash.Policy.Authorizer`\] ensure that `resource` context is set for expanding filter descriptions


## **v3.4.12** \(2024-09-16\)

### Bug Fixes:

+ \[`Ash.Seed`\] ensure that action\_select is set on seeding data

### Improvements:

+ 
\[`Ash.Resource.Igniter`\] add more resource updating logic

+ 
\[`Ash.Resource.Igniter`\] add `_new` options for Ash.Resource.Igniter


## **v3.4.11** \(2024-09-13\)

### Improvements:

+ \[igniter\] update igniter and fix deprecation warnings

## **v3.4.10** \(2024-09-13\)

### Bug Fixes:

+ \[`mix ash.patch.extend`\] properly add all types of extensions in `mix ash.patch.extend`

## **v3.4.9** \(2024-09-13\)

### Bug Fixes:

+ 
\[field policies\] ensure that field policies don't interfere with relationship loading

+ 
\[bulk actions\] properly merge provided context in atomic bulk actions

+ 
\[managed relationships\] properly handle rollbacks from `DBConnection` failures for belongs to relationships

+ 
\[`Ash.Resource.Igniter`\] don't generate doubly nested policies when adding policies in igniter

+ 
\[`Ash.Changeset`\] fix Ash.Changeset.manage\_relationships/4 for list primary keys \(\#1455\)

+ 
\[`Ash.Filter`\] Handle Ash.Query.filter for array values \(\#1452\)

+ 
\[`Ash.Type.Time`\] cast embedded time properly \(\#1451\)

+ 
\[create actions\] require private/non-accepted attributes *after* before action hooks instead of *before*

+ 
\[built in after\_action change\] we cannot assume that `after_action/1` can be done atomically

Previously, when you did `change after_action/3` in a resource, we would assume it was safe to be done atomically. But because we cannot guarantee that your hook does not access `changeset.data`, it is not safe to make that assumption.

Instead, you must define a module change, and explicitly define `atomic/3`.


### Improvements:

+ 
\[`Ash.Error.Forbidden.Policy`\] small improvements for policy breakdown formatting

+ 
\[`Ash.Type.Union`\] honor a `_union_type` type param when casting unions

+ 
\[create/update/destroy actions\] add system for `action_select`, which can limit selects from mutations

Callers can `select` when calling create/update/destroy actions, but those selects were not previously honored by data layers. The reason for this is that often actions will require more fields than the fields that the caller requests. Now, you can specify `action_select` in the action, and the data layer will honor that.

Additionally, the new `select_by_default?` flag on attributes causes the attribute to automatically not be selected for update actions.

+ 
\[attributes\] support `select_by_default?` flag on attributes. This defaults to `true`.


## **v3.4.8** \(2024-09-09\)

### Bug Fixes:

+ 
\[`Ash.Policy.Authorizer`\] support passing a forbidden error for policy breakdowns per the docs

+ 
\[`Ash.Policy.Authorizer`\] don't report the action as the actor for policy breakdowns

+ 
\[`Ash.Changeset`\] check `changeset.action` before raising a required primary action error

+ 
\[bulk actions\] ensure proper return types for `:stream` strategy bulk update/destroys


## **v3.4.7** \(2024-09-06\)

### Improvements:

+ \[`Ash.Resource.Igniter`\] add `add_bypass` and `add_policy` igniter utilities

## **v3.4.6** \(2024-09-06\)

### Bug Fixes:

+ 
\[loading relationships\] don't select destination attributes that don't exist

+ 
\[`Ash.Filter.Runtime`\] properly pass actor when running filters at runtime

+ 
\[`Ash.Type.Struct`\] misplaced curly bracket when handling struct type casting

+ 
\[bulk/atomic updates\] properly leverage atomic upgrade read action for an update action


### Improvements:

+ 
\[`Ash.Policy.Authorizer`\] show informative error explaining the use of filter checks with create actions

+ 
\[`Ash.Policy.Authorizer`\] show the actor's primary key in policy breakdowns

+ 
\[`Ash.Policy.Authorizer`\] add an expanded description option to checks

+ 
\[`Ash.Policy.Authorizer`\] use expanded description to display filled in filter templates in policy breakdowns

+ 
\[`Ash.Changeset` \] Add `Ash.Changeset.is_valid/1` guard. \(\#1437\)


## **v3.4.5** \(2024-09-05\)

### Bug Fixes:

+ \[update actions\] fix type definition for `atomic_upgrade_with`

## **v3.4.4** \(2024-09-05\)

## **v3.4.3** \(2024-09-04\)

### Bug Fixes:

+ \[loading relationships\] properly await tasks from lazy loading multiple relationships

## **v3.4.2** \(2024-09-04\)

### Bug Fixes:

+ 
\[soft destroys\] honor `return_destroyed?` in soft destroy actions

+ 
\[`Ash.Resource.Change`\] correctly handle return values of batch callbacks \(\#1424\)

+ 
\[read actions\] ensure that async limiter is cleared up front

+ 
\[bulk creates\] honor bulk upsert condition \(\#1432\)

+ 
\[bulk updates\] ensure that update\_defaults are set on streaming updates

+ 
\[bulk actions\] honor `skip_global_validations?` in bulk actions

+ 
\[pagination\] honor the `countable` option in pagination

+ 
\[read actions\] return proper data shape when doing a read in a transaction

+ 
\[notifications\] ensure that `from` is properly set on all notifications

+ 
\[notifications\] fix typo in bulk destroy not clearing ash\_started\_transaction state

+ 
\[calculations\] traverse calculated relationships when rewriting transient calculation values

+ 
\[calculations\] don't unload calculation dependencies when `lazy?` is set

+ 
\[`Ash.DataLayer.Ets`\] handle no\_attributes when joining lateral join relationship data

+ 
\[`Ash.DataLayer.Ets`\] fix ets lateral join source field usage

+ 
\[`Ash.DataLayer.Ets`\] properly apply distinct in ets


### Improvements with backwards compatibility configurations

These configurations default to the current behavior, but in 4.0 \(someday\) will be removed, and the new option will be the only option.

+ \[pagination\] make default page type configurable, defaulting to `:offset`.

    # set this configuration to adopt the new preferred behavior        config         :ash    ,    
          default_page_type    :         :keyset

+ \[`Ash.Policy.Authorizer`\] make read policies more consistent, always preferring to filter over raise

Currently, some read actions can still return a `Forbidden` error, even though policies are meant to filter out records by default. Now, it will always filter, unless you set `access_type :strict` in the policy.

    # set this configuration to adopt the new preferred behavior        config         :ash    ,         :policies    ,    
          no_filter_static_forbidden_reads?    :         false

### Improvements:

+ 
\[`Ash.Policy.Authorizer`\] show an explanation when a forbidden is because no policies applied

+ 
\[`Ash.Policy.Authorizer`\] error at compile for bypasses that will have no effect

+ 
\[`Ash.Resource.ManualRead`\] add `load_relationships/5` callback to manual reads

+ 
\[`mix ash.gen.resource`\] add `uuid-v7-primary-key` option to `mix ash.gen.resource`

+ 
\[`Ash.Resource.Change.CascadeUpdate`\] add cascade update built in change \(\#1398\)

+ 
\[`Ash.Resource.Change.CascadeDestroy`\] add `read_action` option to `cascade_destroy`

+ 
\[inline aggregates\] support `expr` and `expr_type` options when building aggregates

+ 
\[create actions\] Implement condition for upsert \(\#1386\)

+ 
\[optimization\] do not add relationship filter when building relationship authorization

+ 
\[optimization\] don't list telemetry handlers if app is compiling

+ 
\[optimization\] do not call tracer `set_metadata` with span type that it ignores \(\#1400\)

+ 
\[optimization\] optimize filter expr traversal

+ 
\[optimization\] Add a case for handling mapsets in Filter.map \(\#1427\)

+ 
\[optimization\] Cache always selected fields and use mapsets for building select list \(\#1428\)

+ 
\[optimization\] add pattern for Ash.Query.Call in Filter.map \(\#1416\)

+ 
\[optimization\] prevent unnecessary calls to `Ash.load`

+ 
\[optimization\] cache action known inputs individually

+ 
\[optimization\] cache action required inputs all together

+ 
\[optimization\] optimize to avoid inspects in changesets

+ 
\[optimization\] optimize to avoid expensive `String.valid?` check in uuid type

+ 
\[optimization\] add `async?` option to calculations, default to false

+ 
\[optimization\] optimize field checking for loading fields in query

+ 
\[optimization\] allow functions in tracers for lazy loading metadata

+ 
\[optimization\] don't start processes for single items in list

+ 
\[optimization\] Optimize option validation with compile time validators \(\#1387\)


## **v3.4.1** \(2024-08-13\)

### Bug Fixes:

+ \[authorization\] properly pass actor, action, tenant etc. to lazy loaded relationships

## **v3.4.0** \(2024-08-12\)

### Features:

+ 
\[`Ash.Policy.Authorizer`\] add policy groups

+ 
\[authorization\] support `authorize_with` option on `Ash.read`, allowing to error if any forbidden matching data exists

+ 
\[`Ash.Resource`\] Add `@type t` typespec to resource if it doesn't exist


### Bug Fixes:

+ 
\[calculations\] remove pattern match error when exceptions come from calculations

+ 
\[calculations\] resolve nested expression calculation references in runtime filters

+ 
\[arrays\] Fix error with nil value on structure types \(\#1380\)

+ 
\[bulk actions\] Pass options without :templated tuple to after\_batch \(\#1376\)

+ 
\[bulk actions\] `after_batch` arguments for `bulk_create` with `return_records?` disabled \(\#1371\)

+ 
\[bulk actions\] set `upsert?` option when managing relationships in bulk creation

+ 
\[`Ash.Resource`\] check for `nil` resource\_calculation in `Ash.Resource.loaded?/2`

+ 
\[`Ash.Expr`\] properly consider not-loaded record calculations as `:unknown`

+ 
\[atomic updates\] handle `nil` in atomic array casting

+ 
\[aggregates\] respect previously validated-for-action query for aggregates

+ 
\[`mix ash.gen.resource`\] use `timestamps()` instead of `timestamps`

+ 
\[belongs\_to relationships\] prefer `source_attribute` is required, instead of relationship name


### Improvements:

+ 
\[performance\] optimizations around allocating strings

+ 
\[performance\] optimizations around list operations for embedded resources

+ 
\[performance\] prune calculations made unnecessary by field policies

+ 
\[performance\] add optimized path for casting embeds when they are simple

+ 
\[performance\] add `include_embedded_source_by_default?` config to optimize embeds

+ 
\[error messages\] show proper error message when trying to accept non-writable attributes

+ 
\[error messages\] add "hints" to `NoSuchInput` errors to make any errors clearer

+ 
\[`Ash.Expr`\] warn on usage of `== nil`

+ 
\[`Ash.Expr`\] implement `Comp` for atoms & strings, comparing atoms as strings

+ 
\[embedded resources\] increase cases where embedded attribute can be updated atomically

+ 
\[`Ash.Type.Struct`\] support `:fields` constraint on `:struct` type, enabling persistence

+ 
\[bulk actions\] Warn on bulk action `return_stream?` without any other `return_*?` options enabled. \(\#1370\)

+ 
\[calculations\] ensure the called calculation function is always in the stacktrace

+ 
\[dependencies\] remove `:comparable` as a dependency

+ 
\[`Ash.Resource`\] Add default values to resulting Resource struct \(\#1364\)


## **v3.3.3** \(2024-08-01\)

### Bug Fixes:

+ delete ash\_notifications from pdict after reading

## **v3.3.2** \(2024-08-01\)

### Bug Fixes:

+ 
\[`Ash.Igniter`\] properly parse multiple occurrences of :keep arguments

+ 
\[calculations\] properly key nested calculations and add additional tests

+ 
\[calculations\] pass relationship path down when merging query loads

+ 
\[`mix ash.codegen`\] don't set `--name nil` when calling codegen tasks

+ 
\[`Ash.Filter`\] fix behavior of synthesized joins across data layers


### Improvements:

+ \[`mix ash.gen.resource`\] add `--timestamps` argument to add timestamps to the resource

## **v3.3.1** \(2024-07-30\)

### Bug Fixes:

+ 
\[`mix ash.gen.domain`\] properly parse domain module in `mix ash.gen.domain`

+ 
\[`Ash.Resource.Change`, `Ash.Resource.Validation`\] properly handle mixed atomic & non-atomic validations/changes

+ 
\[`Ash.Filter`\] properly find data layer predicates when name is provided as a string

+ 
\[relationships\] set `accessing_from` and join read action for many\_to\_many relationships correctly \(\#1355\)


### Improvements:

+ \[`Ash.Resource.Change`\] implement `change/3` automatically if batch callbacks are defined

## **v3.3.0** \(2024-07-27\)

### Features:

+ \[`Ash.Type.File`\] Add Ash.Type.File \(\#1337\)

### Bug Fixes:

+ 
\[bulk actions\] ensure that statuses are set correctly on bulk actions

+ 
\[bulk actions\] properly transfer process context\(tracers\) for bulk actions

+ 
\[embedded resources\] properly display identity/primary key mismatch error on lists of embeds

+ 
\[`Ash.Type.NewType`\] apply constraints to NewType even when casting an array \(\#1341\)

+ 
\[`Ash.Query`\] pass reuse\_values? true when loading in Ash.Query.apply\_to/2 \(\#1346\)

+ 
\[code interfaces\] honor `skip_unknown_inputs` in code interfaces

+ 
\[notifications\] don't gather notifications except for in the top level transaction starter

+ 
\[generic actions\] support `skip_unknown_inputs` on generic actions

+ 
\[atomic updates\] ensure `changed?` context is set on atomic changesets \(we assume it is `true`, its up to extensions to handle\)

+ 
\[`Ash.Type.CiString`, `Ash.Type.String`\] Update string/ci\_string generators to ensure min\_length \(\#1335\)

+ 
\[`Ash`\] handle `{record, action, input}` types in `Ash.can?`

+ 
\[bulk actions\] only call `batch_change` if it is defined, never `change` in bulk create


### Improvements:

+ 
\[`mix ash.gen.resource`\] better positional argument handling with igniter

+ 
\[`Ash.Expr`\] use `:utc_datetime_usec` for `now()` return type

+ 
\[`mix ash.install`\] don't install sat solver in initial installation

+ 
\[`Ash.Policy.Authorizer`\] validate that a solver exists at compile time when using policies

+ 
\[`Ash.Type.Enum`\] Expose type t\(\) on Ash.Type.Enum implementations \(\#1338\)

+ 
\[`Ash.Resource`\] add :\* as a valid value in `skip_unknown_inputs`

+ 
\[`Ash.Resource`\] add `skip_unknown_inputs` to individual actions

+ 
\[embedded resources\] add `skip_unknown_inputs` constraint to embedded resources

+ 
\[embedded resources\] automatically fall back to a default domain when working with embeds

+ 
\[`Ash`\] handle 3 tuple in `Ash.can?`

+ 
\[`Ash.Error`\] add `Ash.Error.error_descriptions`


## **v3.2.6** \(2024-07-22\)

### Bug Fixes:

+ 
\[bulk actions\] fallback to `authorize_with` when authorizing bulk destroy actions

+ 
\[bulk actions\] don't refer to non-existent `batch_change/4`


### Improvements:

+ \[bulk actions\] Replace incorrect function\_exported?-checks in bulk-actions, add has-defs for change modules \(\#1330\)

## **v3.2.5** \(2024-07-22\)

### Bug Fixes:

+ 
\[destroy actions\] apply atomic validations on non-bulk destroy actions

+ 
\[`Ash.Policy.Info`\] add default to private\_fields\_policy in Ash.Policy.Info \(\#1329\)

+ 
\[relating\_to\_actor\] make `relating_to_actor` built-in-check aware of atomics

+ 
\[`Ash.Expr`\] remove redundant overload of `Ash.Expr.get_path` \(\#1328\)

+ 
\[`Ash.Type.NewType`\] cast\_input/2 of Ash.Type.NewType returning :ok \(\#1324\)

+ 
\[`Ash.Reactor`\] warnings emitted by removed reactor behaviour function. \(\#1325\)


### Improvements:

+ 
\[bulk actions\] add `authorize_with` fallback option to bulk actions

+ 
\[`Ash.Policy.Authorizer`\] allow policy conditions to be applied inside their block


## **v3.2.4** \(2024-07-18\)

### Bug Fixes:

+ \[transaction hooks\] fix warning on transaction hooks violating their semantics

## **v3.2.3** \(2024-07-18\)

### Bug Fixes:

+ 
\[`mix ash.patch.extend`\] properly convert extension string into a module

+ 
\[`mix ash.patch.extend`\] only display available to extend

+ 
\[`mix ash.install`\] mix igniter.install ash --example case clause error \(\#1317\)

+ 
\[multitenancy\] only use attribute for filtering when multitenancy strategy == :attribute


### Improvements:

+ \[`Ash.Resource.Igniter`\] Add `Ash.Resource.Igniter.domain` to get the domain of a resource

## **v3.2.2** \(2024-07-17\)

### Features:

+ \[`Ash.Reactor`\] Add ash\_step wrapper \(\#1311\)

### Bug Fixes:

+ 
\[bulk destroys\] honor atomic validations in destroy actions using `filter`

+ 
\[Ash.Type.Vector\] handle casting nil vectors \(\#1316\)

+ 
\[Ash.Type\] don't override `nil` handling in `Ash.Type.cast_input/3`


## **v3.2.1** \(2024-07-17\)

### Bug Fixes:

+ 
properly honor the `include_nil?` option

+ 
store after\_action hooks added outside of changes for atomic upgrade

+ 
don't use `type/3` in string interpolation

+ 
properly pass `include_nil?` from when building query aggregates


### Improvements:

+ allow skipping initialization of types in unions

## **v3.2.0** \(2024-07-15\)

### Features:

+ \[field policies\] Allow field policies to hide private fields \(\#1289\)

Use the `private_fields :include | :show | :hide` option in the `field_policies` section of your resource to control how private fields are handled by field policies.

For example:

    # hide all private fields when authorizing        field_policies         :hide    
        # the current behavior. Private fields are ignored by field policies        field_policies         :show    
        # private fields can have field policies like any other field        field_policies         :include

### Improvements:

+ 
\[`Ash.Domain.Igniter`\] add `Ash.Domain.Igniter.list_domains/1`

+ 
\[`Ash.Resource.Igniter`\] add `Ash.Resource.Igniter.list_resources/1`


## **v3.1.8** \(2024-07-14\)

### Bug Fixes:

+ \[bulk actions\] use `unpaginated_read` when simulating streaming for low limit queries

## **v3.1.7** \(2024-07-14\)

### Bug Fixes:

+ 
\[Ash.Query\] don't use `:same` return type for most operators

+ 
\[Ash.Query\] don't use returns as basis type unless explicitly allowed


## **v3.1.6** \(2024-07-14\)

### Bug Fixes:

+ 
\[Ash.Query\] ensure `today` has properly configured returns type

+ 
\[Ash.Type\] module type apply\_constraints for nil fix \(\#1313\)


## **v3.1.5** \(2024-07-14\)

### Bug Fixes:

+ \[Ash.Type\] don't specify that `get_path` is a predicate function

### Improvements:

+ 
\[Ash.Expr\] add `Ash.Expr.determine_type(mod, children)`

+ 
\[Ash.Query\] add return typing to functions


## **v3.1.4** \(2024-07-13\)

### Bug Fixes:

+ 
\[code interface\] properly omit destroyed result in code interfaces

+ 
\[Ash.Type.Integer\] properly compare `expr` to `min` with `min` integer constraint

+ 
\[Ash.Reactor\] Make action ctx-values from reactor-ctx take precedence if set. \(\#1308\)


### Improvements:

+ 
\[Ash.Resource.Change\] support returning a list of atomics from atomic change callbacks

+ 
\[Ash.Type\] add `cast_atomic_constraints` callback and use it in core types

+ 
\[Ash.Expr\] improve type signature for `if/3`

+ 
\[Ash.Expr\] simpler and/or short circuiting


## **v3.1.3** \(2024-07-11\)

### Bug Fixes:

+ 
\[bulk actions\] ensure that errors in queries do not raise in atomic upgrades/single atomics

+ 
\[Ash.Type.Integer\] use correct constraint when validating min int \(\#1298\)

+ 
\[Ash.Filter\] don't refer to private attributes when parsing filter inputs that refer to relationships \(\#1280\)


### Improvements:

+ \[Ash.Query\] add `strict?` option to `Ash.Query.load` \(\#1302\)

## **v3.1.2** \(2024-07-10\)

### Bug Fixes:

+ \[bulk actions\] ensure that manual action configurations are honored for bulk actions

## **v3.1.1** \(2024-07-10\)

### Bug Fixes:

+ \[ash.install\] installer doesn't need to add spark as a dependency, just run its installer

## **v3.1.0** \(2024-07-09\)

### Features:

+ 
\[Generators\] add `mix ash.install` \(call with `mix igniter.install ash`\)

+ 
\[Generators\] add `mix ash.gen.resource`

+ 
\[Generators\] add `mix ash.gen.base_resource`

+ 
\[Generators\] add `mix ash.gen.domain`

+ 
\[Generators\] add `mix ash.extend`

+ 
\[Ash.Type.UUIDv7\] Add built in `Ash.Type.UUIDv7` type, and `uuid_v7_primary_key` builder


### Bug Fixes:

+ 
\[atomics\] sort primary key changes ahead of others in atomic changes

+ 
\[Ash.Changeet\] fix typespec for Changeset.around\_transaction/2 \(\#1292\)

+ 
\[multitenancy\] ensure tenancy is always enforced on create/update/destroy actions

+ 
\[loading relationships\] lateral join on `from_many? true` relationships

+ 
\[calculations\] don't reuse calculations/aggregates if `authorize?` is true

+ 
\[aggregates\] ensure aggregate context is fully configured in `Ash.aggregate`

+ 
\[bulk actions\] properly transfer changeset.context on streamed batch changesets

+ 
\[bulk actions\] ensure notifications are dispatched from bulk actions

+ 
\[lazy loading\] lazy-loading logic for calculations/aggregates was inversed \(\#1275\)

+ 
\[error handling\] properly match on async task exceptions

+ 
\[policies\] ensure `context` is available in policy template expressions

+ 
\[policies\] ensure forbidden errors behave the same when using implicit bulk version of code interface functions

+ 
\[manual relationships\] compare keys in manual relationships when using 'complex' types \(\#1270\)

+ 
\[Ash.Filter\] cover more cases in filter input parsing \(\#1261\)

+ 
\[has\_one relationships\] automatically set `from_many?` if a `has_one` has a `sort` applied

+ 
\[Ash.Filter\] fix match error when synthesizing joins across data layers

+ 
\[Ash.DataLayer.Ets\] properly support multitenancy when referencing relationships

+ 
\[Ash.Type.Union\] initialize & validate each subtype of a union


### Improvements:

+ 
\[Ash.Type.Enum\] allow overriding `cast_stored/2` and `dump_to_native/2`

+ 
\[Ash.DataLayer.Simple\] support offset in the simple data layer

+ 
\[Ash.Changeset\] allow after\_action hooks in fully atomic changesets


## **v3.0.16** \(2024-06-21\)

### Bug Fixes:

+ 
\[bulk updates\] use the proper opts when calling manual updates in bulk updates

+ 
\[pagination\] apply pagination at runtime for non lateral join queries

+ 
\[multitenancy\] consider multitenancy when checking if through-join is unique

+ 
\[Ash.Changeset\] don't run any `before_action` hooks if changeset is invalidated in prior hook

+ 
\[atomic upgrade\] only prevent atomic upgrade when hooks were explicitly added


### Improvements:

+ \[Ash.Error\] retain error context on overridden messages

## **v3.0.15** \(2024-06-18\)

### Improvements:

+ 
\[Ash.Type\] add optional `matches_type?/2` callback to `Ash.Type`

+ 
\[Ash.Domain\] add `backwards_compatible_interface?` option to `use Ash.Domain`


## **v3.0.14** \(2024-06-18\)

### Bug Fixes:

+ 
\[many-to-many relationships\] apply join relationship filter when loading many\_to\_many relationships

+ 
\[Ash.Query\] ensure we honor any computed select changes when loading through attributes


### Improvements:

+ \[Ash.Policy.Authorier\] add `subject` and `context` keys to policy context

## **v3.0.13** \(2024-06-17\)

### Bug Fixes:

+ 
\[parallelism\] don't start async limiter tasks if async is disabled

+ 
\[Ash.Domain\] properly set default timeout to `:infinity`

+ 
\[upserts\] pass down `identity` when doing upserts, for new feature support

+ 
\[Ash.Changeset\] ensure that `before_transaction` hook errors fail the operation

+ 
\[Ash.Changeset\] ensure that `before_transaction` hook errors still trigger `after_transaction` hooks

+ 
\[bulk updates\] abort bulk updates on before transaction hook errors


## **v3.0.12** \(2024-06-14\)

### Bug Fixes:

+ 
\[atomic updates\] fix expression interpolation for cast\_atomic for integer, decimal, float

+ 
\[generic actions\] set default argument values on generic actions

+ 
\[generic actions\] support `^arg/1` and similar constructions in filter policies on generic actions


### Improvements:

+ \[Ash.Resource\] set a `module` when validating accepts

## **v3.0.11** \(2024-06-11\)

### Bug Fixes:

+ 
\[loading through attributes\] only apply load through for attributes that are being selected directly

+ 
\[relationship loading\] ensure we lateral join with `from_many?: true` or any `:many` cardinality relationships

+ 
\[create/update/destroy actions\] correctly load paginated relationships after create, update, delete \(\#1229\)

+ 
\[bulk create/update/destroy\] load relationships on bulk operations \(\#1234\)

+ 
\[Ash.Type.Atom\] return proper `{:ok, value}` from `Ash.Type.Atom.apply_constraints/2`

+ 
\[Ash.Filter\] fix the compare/2 implementations \(\#1232\)

+ 
\[Ash.Filter\] return proper value from short-circuit filter hydration

+ 
\[Ash.Seed\] fix seed not working when :**keep\_nil** is generated using seed\_input \(\#1228\)

+ 
\[Ash.Generator\] pass resource to Ash.Seed.seed\! in Ash.Generator.seed\! \(\#1227\)


### Improvements:

+ 
\[Ash.Resource\] validate `require_attributes` \(error\) and `allow_nil_input` \(warning\) at compile time

+ 
\[Ash.Seed\] add tenant option to Ash.Seed.seed\! \(\#1230\)


## **v3.0.10** \(2024-06-06\)

### Bug Fixes:

+ 
\[Ash.Union\] ensure that union types w/ explicit tags have constraints applied

+ 
\[multitenancy\] don't update tenant on update, instead enforce it

+ 
\[compare/2 validation\] Do not compare nil values in `compare` validation \(\#1223\)

+ 
\[bulk actions\] ensure context is properly set on bulk manual action invocations


### Improvements:

+ 
\[Ash.Resource\] detect invalid resources placed in relationships on domains verifier

+ 
\[Ash.Resource\] warn at compile time on types that don't define `atomic_update/2`


## **v3.0.9** \(2024-05-31\)

### Bug Fixes:

+ 
\[Ash.Filter\] use correct boolean operation names in Filter.find/4 \(\#1214\)

+ 
\[aggregates\] when hydrating nested aggregates, use correct related resource/path pair

+ 
\[aggregates\] retain `ref_path` when authorizing aggregates

+ 
\[relationship loading\] ensure that belongs\_to relationships are properly not reloaded with `lazy?: true`

+ 
\[bulk actions\] implement rollback on after hooks for bulk actions

+ 
\[bulk actions\] check if in transaction before trying to roll it back


### Improvements:

+ compatibility with elixir 1.17

## **v3.0.8** \(2024-05-28\)

### Bug Fixes:

+ 
\[bulk updates\] missing `else` caused manual updates not to work with `bulk_update`

+ 
\[Ash.Policy.Authorizer\] properly compose multiple filter-checks in policy conditions

+ 
\[Ash.Policy.Authorizer\] properly honor trailing policies that are constantly false


### Improvements:

+ \[Ash.Notifier\] verify notifiers all use the `Ash.Notifier` behaviour

## **v3.0.7** \(2024-05-24\)

### Improvements:

+ 
\[identities\] support `nils_distinct?` on identities

+ 
\[identities\] support `where` option on `identities`

+ 
\[identities\] allow calculations in identity keys


## **v3.0.6** \(2024-05-23\)

### Bug Fixes:

+ 
\[policies\] don't raise an error when authorizing against previous values without atomic upgrades

+ 
\[calculations\] handle subquery-requiring calculations in `calculate/2`, ensuring we have a primary key

+ 
\[Ash.DataLayer\] resolve mixup between atomic upsert vs update capability of datalayers \(\#1198\)


## **v3.0.5** \(2024-05-23\)

### Bug Fixes:

+ \[mix ash.\*\] only use `Mix.deps_tree` if defined \(its only defined for elixir 1.15\+\)

### Improvements:

+ 
\[atomic upgrade\] add `atomic_upgrade?` flag to update/destroy actions

+ 
\[atomic upgrade\] do not do atomic upgrade by default unless `require_atomic?` is `true`

+ 
\[atomic upgrade\] allow configuring the read action used by atomic upgrades


## **v3.0.4** \(2024-05-22\)

### Bug Fixes:

+ \[bulk update/destroy\] ensure that all notifications are sent

## **3.0.3** \(2024-05-22\)

### Features:

+ 
\[relationship pagination\] allow retrieving the count of paginated relationships \(\#1183\)

+ 
\[Ash.Reactor\] Add `bulk_create` step type.

+ 
\[Ash.Reactor\] Add `bulk_update` step type. \(\#1185\)


### Bug Fixes:

+ 
\[Ash.Actions.Read\] properly hydrate and scope sorts with query context

+ 
\[Ash.Changeset\] handle list of atomic conditions coming from atomic validation implementation \(\#1194\) \(\#1195\)

+ 
\[embedded resources\] handle nil value for old\_values when casting arrays \(\#1191\)

+ 
\[Ash.Query\] use `Ash.Sort.parse_input/3` in `Ash.Query.sort_input/2`

+ 
\[Ash.Resource.Validation.Changing\] works correctly in atomics, and can eagerly detect changing \(\#1178\)

+ 
\[atomic updates\] check the where condition before checking validation atomicity \(\#1177\)

+ 
\[bulk actions\] don't emit after batch notifications if `notify?: false`

+ 
\[Ash.Resource\] prefer resource domain over option domain \(\#1176\)

+ 
\[bulk update/destroy\] don't require domain for empty stream bulk update and destroy \(\#1175\)

+ 
\[Ash.Generator\] only return valid non nil values items from generator \(\#1121\)

+ 
\[bulk destroy\] properly validate action when calling bulk destroy

+ 
\[code interface\] allow all strategies for bulk actions in code interfaces by default

+ 
\[code interfaces\] honor `get?` for bulk update/bulk destroy


### Improvements:

+ 
\[Ash.Query\] support anonymous aggregates and calculations in sorts

+ 
\[sensitive fields\] Implement `show_sensitive?` config \(\#1180\)

+ 
\[Ash.Query\] support `filter_input` and `sort_input` in `Ash.Query.build/2`

+ 
\[Ash.Changeset\] add `template_requires_actor` check for changesets

+ 
\[bulk update/destroy\] don't use queries for streaming if they have hooks

+ 
\[Ash.Policy.Check.ChangingAttributes\] consider `from: nil` in `changing_attributes/1` check


## **v3.0.2** \(2024-05-15\)

### Improvements:

+ 
\[Ash.Expr\] add pattern matching for clarity on values accepted by `ref/1` and `ref/2`

+ 
\[Ash.Expr\] add `can_return_nil?/1` callback to Ash expressions, allowing for various optimizations

+ 
\[Ash.Type.NewType\] raise argument error on unknown options in `Ash.Type.NewType`. Helps with typos & misunderstandings

+ 
\[embedded resources\] use the `source` configuration for attributes in embedded resources \(it was previously just ignored\)

+ 
\[Ash.Policy.Authorizer\] better type specification for checks, to get better autocomplete and compile time validation

+ 
\[Ash.Error.Invalid.NoSuchInput\] added a `did_you_mean` field and used it in the error message


### Bug Fixes:

+ 
\[Ash.Resource\] properly persist simple\_notifiers \(they were being ignored before\)

+ 
\[code interface\] accept single ids in code interface as subject for destroy/update

+ 
\[bulk update\] ensure that the `changed?` context is set in after action hooks on batches

+ 
\[relationships\] allow for inferred domains when authorizing join queries

+ 
\[Ash.Expr\] don't treat `nil` as not a valid value when type casting lists

+ 
\[atomic upgrade\] keep data's metadata in atomic upgraded update \(\#1165\)


## **v3.0.1** \(2024-05-14\)

### Features:

+ \[Ash.Resource.Change.Builtins\] Add `cascade_destroy` to builtin changes.

### Bug Fixes:

+ 
\[calculations\] calculation eager evaluation bug caused `exists` to eager evaluate when we didn't actually have the related data

+ 
\[field policies\] fix field policy rewrite errors on non-success cases \(\#1163\)

+ 
\[embedded resources\] fix embedded resource authorization \(\#1159\) \(\#1160\)

+ 
infinite recursion if query is empty \(\#1158\)

+ 
\[Ash.DataLayer.Ets\] ensure that changeset filters are honored in ETS destroy/update\_query

+ 
\[update/destroy actions\] don't rollback transactions on stale records, ignore stale records in bulk actions

+ 
\[bulk creates\] don't check required belongs to fields until after setting them in bulk creation

+ 
\[code interface\] check require\_reference? when generating update code interface \(\#1152\)


## **v3.0.0**

## 3.0

We are starting the changelog fresh. See `documentation/2.0-CHANGELOG.md` in GitHub for the old changelogs.

### Breaking Changes:

For a guide on adjusting to these breaking changes, see the upgrade guide

+ \[Ash.Api\] has been renamed to `Ash.Domain`, and references to the concept have been renamed as well, i.e in options and in the DSL
+ \[Ash\] we now call functions on this, instead of the domain. i.e `Ash.create` and `Ash.read`. The generated functions are now marked as deprecated
+ \[Ash\] remove process context functionality. You can no longer store the actor/tenant in the context with `Ash.set_actor` and so on
+ \[private?\] deprecate `private?: false` in favor of the more explicit `public?: true`
+ \[default\_accept\] default `default_accept` is now `[]`
+ \[action lifecycle\] after transaction hooks cannot be added from inside of other lifecycle hooks
+ \[Ash.NotLoaded\] use `%Ash.NotLoaded{}` for unselected values, instead of `nil`
+ \[require\_atomic?\] now defaults to `true`, requiring opt-out of atomic behavior
+ \[authorization\] default `api.authorization.authorize` to `:by_default`
+ \[Ash.Registry\] has been removed
+ \[actions\] `domain` must always be known when constructing changesets
+ \[Ash.Notifier\] `requires_original_data?/2` callback defaults to `false`
+ \[Ash.Notifier.PubSub\] default to `previous_values?: false`, allowing notifications to be sent for atomic updates
+ \[unknown inputs\] all action invocations now use `UnknownInput` errors when given an input they don't accept
+ \[policies\] `requires_original_data?/2` callback on checks defaults to `false`
+ \[Ash.Calculation\] has been renamed to `Ash.Resource.Calculation`
+ \[Ash.Resource.Calculation\] "strict mode" has been added and defaults to `true`. This causes only explicitly requested fields from relationships to be loaded
+ \[Ash.Query.Calculation\] positional arguments are now an options list
+ \[calculations\] anonymous function calculations in a resource now take lists and return lists, instead of a single record \(like standard calculations do\)
+ \[context\] The context argument passed to many different callbacks is now a struct, tailored to that specific context. For example, in a calculation you will receive an `Ash.Resource.Calculation.Context`
+ \[after\_action/before\_action\] These builtin changes now accept a 3rd context argument
+ \[picosat\_elixir\] is now optional \(`simple_sat` is now an alternative\)
+ \[Ash.Changeset\] `Ash.Changeset.new!` has been removed
+ \[Ash.Changeset\] `Ash.Changeset.new/2` has been removed \(`Ash.Changeset.new/1` is still available\)
+ \[Ash.Changeset\] `changeset.filters` is now `changeset.filter`
+ \[Ash.Changeset\] reverse order of before action & before transaction hooks. They now run in the action they are added. They used to run in reverse order.
+ \[Ash.CiString\] `Ash.CiString.new/1` returns `nil` on `nil` input
+ \[belongs\_to.attribute\_writable?\] add `attribute_public?` for controlling publicity, and default `attribute_writable?` to `true`.
+ \[Ash.Filter.TemplateHelpers\] removed, all functions needed for expressions are now defined in `Ash.Expr`
+ \[Ash.Expr\] keyword lists are no longer special cased in ash expressions, and requiring pinning like any other value.
+ \[Ash.Resource\] default read actions are now paginatable with keyset and offset pagination \(but pagination is not required\)
+ \[Ash.Resource\] default actions require explicit accept lists \(or will use `default_accept`\). i.e `defaults [:read, create: [:first_name, :last_name]]`
+ \[Ash.Resource\] `simple_notifiers` is now an option to `use Ash.Resource`, instead of being in the DSL at `resource.simple_notifiers`
+ \[Ash.Flow\] has been removed and put in its own package `ash_flow`. It is being deprecated in favor of `Reactor`
+ \[Ash.Error\] the implementation has been extracted out to `Splode`. Defining new `Ash.Error`s is now done by defining a new `Splode.Error`
+ \[Ash.Query\] swap position of sort order and arguments in calculation sorting, i.e instead of `calculation: {:asc, %{...args}}` it is now `calculation: {%{...args}, :asc}`
+ \[Ash.Resource.Aggregate\] add `include_nil?` aggregate option, and default it to `false` \(so `list` and `first` aggregates do not consider `nil` values by default\)
+ \[Ash.Policy.FilterCheck\] now accepts `context` arguments, like `Ash.Policy.FilterCheckWithContext`
+ \[Ash.Policy.FilterCheckWithContext\] has been removed, use `Ash.Policy.FilterCheck`

### Features:

+ \[Ash.Type\] add new remove\_nil\_items? array type constraint \(\#1116\)
+ \[Ash.Query\] Paginatable relationships \(\#1050\)
+ \[Ash.DataLayer\] new `calculate/3` callback that allows for data layers to compute the result of expressions outside the context of a query. Used to power `Ash.calculate/3`.
+ \[validations\] new builtin validations, `attributes_present/2` and `attributes_absent/2`
+ \[multitenancy\] configurable multitenancy behaviour on read actions \(\#1030\)
+ \[Ash.Reactor\] Add new `change` step type which can be used to modify changesets.
+ \[Ash.Changeset\] add `Ash.Changeset.update_change/2` function and builtin change \(\#976\)
+ \[Ash.Domain\] code interfaces can now be defined on the domain
+ \[Ash.Domain\] policies can now be defined on the domain, and will run before resource policies
+ \[Ash.ToTenant\] add `Ash.ToTenant`, allowing for passing arbitrary values as tenants
+ \[Ash\] add `Ash.read_first` \(like `Ash.read_one`, but applies a limit automatically\)
+ \[Ash\] support a second optional `input` option for `create`, `update` and `destroy`, allowing for things like `Ash.create!(Post, %{text: "text"}, opts)`
+ \[sensitive?\] support `sensitive?` option in query aggregate/calculation \(\#963\)
+ \[Ash.Resource\] support `require_reference?: false` on code interfaces, for when an update or destroy action uniquely identifies a record \(or for bulk update/destroy\)
+ \[Ash.Resource\] notifiers can now be specified for specific actions, using the `notifiers` option
+ \[mix ash.rollback\] delegates to extensions to trigger their rollback tasks
+ \[Ash.Query\] add `Ash.Query.apply_to/3`, to "apply" the query to a set of records \(i.e filter, sort, distinct, etc.\)
+ \[Ash.CustomExpression\] Use `Ash.CustomExpression` to extend Ash's expression syntax in a data-layer agnostic way
+ \[code interface\] Code interface functions now support bulk actions, in a "do what I mean" way. For example: `Domain.deactive(post)` can also be `Post |> Ash.Query.filter(active == true) |> Domain.deactive()`

### Improvements:

+ \[Ash.Actions.Sort\] allow providing a stream of records to sort, and performance improvements
+ \[bulk actions\] add `read_action` option to bulk actions \(\#1088\)
+ \[Ash.stream\] support streaming with offset, or even *no* pagination
+ \[Ash.DataLayer.Ets\] add debug logging, similar to ecto query debug logging
+ \[Ash.DataLayer.Ets\] support update\_query, destroy\_query and `Ash.Changeset.filter/2`
+ \[Embedded resources\] don't add `autogenerated_id` to embeds if they don't have a primary key
+ \[Ash.Resource\] you can now omit the return type of generic actions, indicating it either succeeds or fails, returning `:ok` or `{:error, error}`
+ \[Ash.Resource\] Generic actions can now accept a Reactor module, running it directly. \(\#993\)
+ \[Ash.Resource\] support `allow_nil_input` dsl option in update/destroy actions \(\#964\)
+ \[Ash.Resource\] The `filter` option can now be supplied multiple times in read actions and in relationships. They will be combined with `and`
+ \[Ash.Resource\] private attributes can now be accepted as action inputs
+ \[Ash.Expr\] is now imported automatically into places you will likely use it, like changes, validations, checks and calculations.
+ \[Ash.Query\] is now required automatically in places you will likely use it, as above
+ \[sortable?\] fields may mark themselves as unusable in sorts by using `sortable? false`
+ \[sensitive?\] calculations and aggregates may now also be marked as `sensitive?`

### Bug Fixes:

+ \[Ash.Type\] apply array type `nil_items?` constraint after item constraints are applied \(\#1115\)
+ \[Ash.DataLayer.Ets\] fix ETS data layer's support for lateral joining
+ \[bulk actions\] ensure transaction is rolled back on data layer errors during streaming
+ \[bulk actions\] set `notify?: true` when `return_notifications?: true` is set
+ \[Ash.Changeset\] `attributes_present?/2` -> `attribute_present?/2`
+ \[Ash.Filter\] don't eager evaluate `type/3` because data layers require type information
+ \[Ash.Changeset\] when comparing identities for `manage_relationship`, we now properly cast the values. Before, `"1"` and `1` were not considered equal for integer primary keys/identity fields
+ Many more bug fixes were added, but few are relevant enough to list here



# Project Structure

In this guide we'll discuss some best practices for how to structure your project. These recommendations align well with Elixir conventions around file and module naming. These conventions allow for a logical coupling of module and file names, and help keep your project organized and easy to navigate.

### These are recommendations

None of the things we show you here are *requirements*, only recommendations. Feel free to plot your own course here. Ash avoids any pattern that requires you to name a file or module in a specific way, or put them in a specific place. This ensures that all connections between one module and another module are *explicit* rather than *implicit*.

These recommendations all correspond to standard practice in most Elixir/Phoenix applications

    lib    /        ├    ─    ─         my_app    /                            # Your application's main namespace        │           ├    ─    ─         accounts    .    ex                    # Accounts domain module        │           ├    ─    ─         helpdesk    .    ex                    # Helpdesk domain module        │           │        │           ├    ─    ─         accounts    /                       # Accounts context        │           │           ├    ─    ─         user    .    ex                     # User resource        │           │           ├    ─    ─         user    /                       # User resource files        │           │           ├    ─    ─         token    .    ex                    # Token resource        │           │           └    ─    ─         password_helper    .    ex          # Support module        │           │        │           └    ─    ─         helpdesk    /                    # Helpdesk context        │               ├    ─    ─         ticket    .    ex                # Ticket resource        │               ├    ─    ─         notification    .    ex          # Notification resource        │               ├    ─    ─         other_file    .    ex            # Support module        │               └    ─    ─         ticket    /                  # Ticket resource files        │                   ├    ─    ─         preparations    /        │                   ├    ─    ─         changes    /        │                   └    ─    ─         checks    /

Place your Ash application in the standard Elixir application directory `lib/my_app`. Your `Ash.Domain` modules should be at the root level of this directory. Each domain should have a directory named after it, containing the domain's `Ash.Resource` modules and any of the domain's supporting modules. All resource interaction ultimately goes through a domain module.

For resources that require additional files, create a dedicated folder in the domain context named after the resource. We suggest organizing these supplementary files into subdirectories by type \(like `changes/`, `preparations/`, etc.\), though this organization is optional.

# Where do I put X thing

The purpose of Ash is to be both the model of and the interface to your domain logic \(A.K.A business logic\). Applying this generally looks like building as much of your domain logic "behind" your resources. This does not mean, however, that everything has to go *inside of* your resources. For example, if you have a `Purchase` resource, and you want to be able to display a list of purchases that were taxable, and also calculate the percentage of the purchase that was taxable. You might have an action called `:taxable` and a calculation called `:percentage_tax`.

## Example 1: Reads & Calculations

    actions         do    
          ...    

          read         :taxable         do    
            filter         expr    (    taxable         ==         true    )    
          end        end    
        calculations         do    
          calculate         :percentage_tax    ,         :decimal    ,         expr    (    
            sum    (    line_items    ,         field    :         :amount    ,         query    :         [    filter    :         tax         ==         true    ]    )         /    
            sum    (    line_items    ,         field    :         :amount    )    
          )        end

In practice, you may not need the `taxable` action, i.e perhaps you simply want a "taxable" checkbox on a list view in your application, in which case you may use the primary read, or some other read like `:transaction_report`. You would then, on the consumer, provide the filter for `taxable == true`, and load the `:percentage_tax` calculation.

## Example 2: Using external data in create actions

Lets say you want the user to fill in a github issue id, and you will fetch information from that github issue to use as part of creating a "ticket" in your system.. You might be tempted to do something like this in a LiveView:

    def         handle_event    (    "link_ticket"    ,         %{    "issue_id"         =>         issue_id    }    ,         socket    )         do    
          issue_info         =         GithubApi    .    get_issue    (    issue_id    )    

          MyApp.Support    .    update_ticket    (    socket    .    assigns    .    ticket_id    ,         %{    issue_info    :         %{    
            title    :         issue_info    .    title    ,    
            body    :         issue_info    .    body    
          }    }    )        end

But this is putting business logic inside of your UI/representation layer. Instead, you should write an action and put this logic inside of it.

    defmodule         MyApp.Ticket.FetchIssueInfo         do    
          use         Ash.Resource.Change    

          def         change    (    changeset    ,         _    ,         _    )         do    
            Ash.Changeset    .    before_transaction    (    changeset    ,         fn         changeset         ->    
              issue_info         =         GithubApi    .    get_issue    (    changeset    .    arguments    .    issue_id    )    

              Ash.Changeset    .    force_change_attributes    (    changeset    ,         %{    
                issue_info    :         %{    
                  title    :         issue_info    .    title    ,    
                  body    :         issue_info    .    body    
                }    
              }    )    
            end    )    
          end        end

Then you'd have an action like this:

    update         :link_ticket         do    
          argument         :issue_id    ,         :string    ,         allow_nil?    :         false    

          change         MyApp.Ticket.FetchIssueInfo        end

This cleanly encapsulates the operation behind the resource, even while the code for fetching the github issue still lives in a `GitHubApi` module.



# Working with LLMs

LLMs are a new technology, and the patterns on how best to leverage them evolve every day. It is also *quite* debatable whether it is a good idea to use them at all. Nothing in Ash will ever be predicated on the usage of these tools, but we do want to provide at least some level of base guidance on what we think are the best practices for those that do. This is also to help those who are interested in trying these tools but don't yet know where to start.

This guide is about working with LLM dev assistants, not about building LLM-related features or integrating them into your application. For that, see Ash AI.

### Getting Support with LLM generated code

Please note that LLMs often hallucinate despite our best intentions. If you need help with something, and you come to our support channels, you *must* make it clear when the code you are asking for help with was generated by an LLM. You *must* first understand the code you've written yourself, and provide a detailed explanation of the code and the issue you are facing when requesting help. The discord and forums are not a place for others to debug LLM hallucinations.

## What to know

To take advantage of LLMs, you will want to explore the following. You will have to make up your own mind on which avenues to explore and leverage in the following areas. This is essentially a "big list of stuff you should research on your own".

+ Language models - OpenAI, Anthropic, Gemini, etc. Choice of language model will make the most difference in your experience.
+ Agentic editors - Zed, Windsurf, Cursor
+ Agentic assistants - Claude Code, Aider, Codex
+ Rules files - The name of these files are often specific to the editor, but they essentially boil down to "stuff to put in the system prompt" to guide the LLM's behavior.

## Tools

We suggest setting up, where applicable, the following tools:

+ Tidewave: Tidewave gives your LLMs the ability to interact with your running application. This can significantly improve the quality of the code generated by LLMs, and allows them to observe and interact with the running application, like reading logs and working with processes.
+ Ash AI: Ash AI contains tools for building AI enabled applications, but it also comes with a dev MCP server where we will experiment with tools similar to what tidewave offers, but tailored to Ash and the way we work.

## Rules

We are working on establishing a pattern whereby packages can provide a `usage-rules.md` which you can then combine into your own rules file. The idea here is to democratize the process of building rules, allowing you to adopt well vetted and quality rules files from the maintainers of projects. This has only been done for a few packages so far.

To leverage these rules files, you can simply copy them yourself if you'd prefer something more manual, or you can use a new mix task provided by the `usage_rules` package to combine them into your own rules file.

### Combine all of your \(direct\) dependencies usage rules

    mix         usage_rules    .    sync         .    rules         --    all

### Pick specific dependencies

    mix         usage_rules    .    sync         .    rules         \    
          ash         ash_postgres         ash_phoenix         ash_graphql         ash_json_api         ash_ai

You can replace the `.rules` file with your own current rules file, and it will be appended to the contents. Repeated calls will only replace the package rules contents of the file, not the whole file contents.

Only dependencies of your current project will be added, and any dependencies that don't have rules are skipped.



# Generators

Ash comes with multiple generators, packages as mix tasks, to help you generate and make modifications to your applications.

See the documentation for each mix task for more information. What is presented here is merely an overview.

## Installer

Ash can be installed into a project using `igniter`. Some examples of how this can work:

+ 
Install Ash & AshPostgres into your current project

    mix         igniter    .    install         ash         ash_postgres

+ 
Create a new mix project with Ash & AshPostgres installed

    mix         archive    .    install         hex         igniter_new        mix         igniter    .    new         my_project         --    install         ash    ,    ash_postgres

+ 
Create a new phoenix project with Ash & AshPostgres installed

    mix         igniter    .    new         my_project         --    install         ash    ,    ash_postgres    ,    ash_phoenix         --    with         phx    .    new

### install hex archives

The archives have to be installed to use them. This only needs to be done once, until you change elixir versions.

    mix         archive    .    install         hex         igniter_new        mix         archive    .    install         hex         phx_new


## Generators

+ `mix ash.gen.resource` - Generates a new `Ash.Resource`.
+ `mix ash.gen.domain` - Generates a new `Ash.Domain`.
+ `mix ash.gen.enum` - Generates a new `Ash.Type.Enum`.
+ `mix ash.gen.base_resource` - Generates a new base resource.
+ `mix ash.gen.change` - Generates a new `Ash.Resource.Change`.
+ `mix ash.gen.validation` - Generates a new `Ash.Resource.Validation`.
+ `mix ash.gen.preparation` - Generates a new `Ash.Resource.Preparation`.
+ `mix ash.gen.custom_expression` - Generates a new `Ash.CustomExpression`.

## Patchers

+ `mix ash.extend` - Adds an extension or extensions to a domain or resource.



# Error Handling

As of 3.0, Ash uses `Splode` to as our basis for errors. The documentation below still applies, but it is powered by `Splode` under the hood.

There is a difficult balance to cut between informative errors and enabling simple reactions to those errors. Since many extensions may need to work with and/or adapt their behavior based on errors coming from Ash, we need rich error messages. However, when you have a hundred different exceptions to represent the various kinds of errors a system can produce, it becomes difficult to say something like "try this code, and if it is invalid, do x, if it is forbidden, do y. To this effect, exceptions in Ash have one of four classes mapping to the top level exceptions.

## Error Classes

+ forbidden - `Ash.Error.Forbidden`
+ invalid - `Ash.Error.Invalid`
+ framework - `Ash.Error.Framework`
+ unknown - `Ash.Error.Unknown`

Since many actions can be happening at once, we want to support the presence of multiple errors as a result of a request to Ash. We do this by grouping up the errors into one before returning or raising. We choose an exception based on the order of the exceptions listed above. If there is a single forbidden, we choose `Ash.Error.Forbidden`, if there is a single invalid, we choose `Ash.Error.Invalid` and so on. The actual errors will be included in the `errors` key on the exception. The exception's message will contain a bulleted list of all the underlying exceptions that occurred. This makes it easy to react to specific kinds of errors, as well as to react to *any/all* of the errors present.

An example of a single error being raised, representing multiple underlying errors:

    AshExample.Representative        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    employee_id    :         "the best"    }    )        |>         Ash    .    create!    (    )    
         ** (Ash.Error.Invalid) Invalid Error    
         *         employee_id    :         must         be         absent    .    
         *         first_name    ,         last_name    :         at         least         1         must         be         present    .

This allows easy rescuing of the major error classes, as well as inspection of the underlying cases

    try         do    
          AshExample.Representative    
          |>         Ash.Changeset    .    for_create    (    :create    ,         %{    employee_id    :         "dabes"    }    )    
          |>         Ash    .    create!    (    )        rescue    
          e         in         Ash.Error.Invalid         ->    
            "Encountered     #{    Enum    .    count    (    e    .    errors    )    }     errors"        end    
        "Encountered 2 errors"

This pattern does add some additional overhead when you want to rescue specific kinds of errors. For example, you may need to do something like this:

    try         do    
          AshExample.Representative    
          |>         Ash.Changeset    .    for_create    (    :create    ,         %{    employee_id    :         "dabes"    }    )    
          |>         Ash    .    create!    (    )        rescue    
          e         in         Ash.Error.Invalid         ->    
            case         Enum    .    find    (    e    .    errors    ,         &    (    &1    .    __struct__         ==         A.Specific.Error    )    )         do    
              nil         ->    
                ...    handle         errors    
              error         ->    
                ...    handle         specific         error         you         found    
            end        end

## Error Handlers

Create, update and destroy actions can be provided with an `error_handler`, which can be used to modify the errors before they are returned. This is not an error *recovery* mechanism, rather a way to control the shape of errors that are returned. For more information on the callback itself, see `Ash.Changeset.handle_errors/2`.

Example usage:

    create         :upsert_article_by_slug         do    
          upsert?         true    
          accept         [    :slug    ,         :title    ,         :body    ]    
          upsert_identity         :unique_slug    
          upsert_condition         expr    (    user_id         ==         ^    actor    (    :id    )    )    
          error_handler         fn     
            _changeset    ,         %    Ash.Error.Changes.StaleRecord    {    }         ->    
              Ash.Error.Changes.InvalidChanges    .    exception    (    field    :         :slug    ,         message    :         "has already been taken"    )    

            _         changeset    ,         other         ->    
              # leave other errors untouched    
              other    
          end        end

## Generating Errors

When returning errors from behaviors or adding errors to a changeset/query/action input, multiple formats are supported. You can return a simple String, which will be converted into an `Ash.Error.Unknown` exception. You can also return a keyword list containing `field` or `fields` and `message`, which will be used to construct an `Ash.Error.Invalid.InvalidChanges` error. Finally, you can pass an exception directly, which will be used as is if it is an Ash error, or wrapped in an `Ash.Error.Unknown` if it is not.

Technically *any* value can be used as an error, but will be wrapped in an `Ash.Error.Unknown` accordingly.

### Use exception modules

You should prefer to use the exception modules provided by Ash, or ones that you have defined manually. This allows you to document your error types, and to show those errors over API interfaces. See the section on APIs below for more.

## Examples of using non standard errors

### Keyword list \(**`Ash.Error.Changes.InvalidChanges`**\)

    def         change    (    changeset    ,         _    ,         _    )         do    
          if         under_21?    (    changeset    )         do    
            Ash.Changeset    .    add_error    (    changeset    ,         field    :         :age    ,         message    :         "must be 21 or older"    )    
          else    
            changeset    
          end        end

### String \(**`Ash.Error.Unknown.UnknownError`**\)

    def         change    (    changeset    ,         _    ,         _    )         do    
          if         under_21?    (    changeset    )         do    
            Ash.Changeset    .    add_error    (    changeset    ,         "must be 21 or older"    )    
          else    
            changeset    
          end        end

## Using an exception module

These are all modules under `Ash.Error.*`. You can create a new one with `error.exception(options)`, and the options are documented in each exception. This documentation is missing in some cases. Go to the source code of the exception to see its special options. All of them support the `vars` option, which are values to be interpolated into the message, useful for things like translation.

For example:

    def         change    (    changeset    ,         _    ,         _    )         do    
          if         under_21?    (    changeset    )         do    
            error         =         Ash.Error.Changes.Required    .    exception    (    
              field    :         :foo    ,    
              type    :         :attribute    ,    
              resource    :         changeset    .    resource    
            )    

            Ash.Changeset    .    add_error    (    changeset    ,         error    )    
          else    
            changeset    
          end        end

### Using a Custom Exception

You can create a custom exception like so. This is an example of a builtin exception that you could mirror to build your own

    defmodule         MyApp.Errors.Invalid.TooYoung         do    
          @moduledoc         "Used when a user who is too young is attempted to be created"    
          use         Splode.Error    ,         fields    :         [    :age    ]    ,         class    :         :invalid    

          def         message    (    error    )         do    
            """
        Must be 21 or older, got:     #{    error    .    age    }    .
        """    
          end        end    
        def         change    (    changeset    ,         _    ,         _    )         do    
          if         under_21?    (    changeset    )         do    
            error         =         MyApp.Errors.Invalid.TooYoung    .    exception    (    
              age    :         Ash.Changeset    .    get_attribute    (    changeset    ,         :age    )    
            )    

            Ash.Changeset    .    add_error    (    changeset    ,         error    )    
          else    
            changeset    
          end        end

## Showing errors over APIs

AshJsonApi and AshGraphql both use a special protocol to determine how \(and if\) a raised or returned error should be displayed.

See the relevant docs:

+ handling errors in AshGraphql
+ AshJsonApi.ToJsonApiError



# Testing

Take a look at the how-to guide for a practical look at writing tests

The configuration you likely want to add to your `config/test.exs` is:

    # config/test.exs        config         :ash    ,         :disable_async?    ,         true        config         :ash    ,         :missed_notifications    ,         :ignore

Each option is explained in more detail below.

## Async tests

The first thing you will likely want to do, especially if you are using `AshPostgres`, is to add the following config to your `config/test.exs`.

    # config/test.exs        config         :ash    ,         :disable_async?    ,         true

This ensures that Ash does not spawn tasks when executing your requests, which is necessary for doing transactional tests with `AshPostgres`.

## Missed notifications

If you are using Ecto's transactional features to ensure that your tests all run in a transaction, Ash will detect that it had notifications to send \(if you have any notifiers set up\) but couldn't because it was still in a transaction. The default behavior when notifications are missed is to warn. However, this can get pretty noisy in tests. So we suggest adding the following config to your `config/test.exs`.

    # config/test.exs        config         :ash    ,         :missed_notifications    ,         :ignore



# Development Utilities

## Formatting DSLs

All Ash packages that ship with extensions provide exports in their `.formatter.exs`. This prevents the formatter from turning, for example, `attribute :name, :string` into `attribute(:name, :string)`. To enable this, add `:ash` \(and any other Ash libraries you are using\) to your `.formatter.exs` file:

    [    
          # ...    
          import_deps    :         [    ...    ,         :ash    ]    ,    
          # ...        ]

## ElixirSense Plugin

Ash uses Spark to build all of our DSLs \(like `Ash.Resource` and `Ash.Domain`\) and to validate options lists to functions. `Spark` ships with an extension that is automatically picked up by ElixirLS to provide autocomplete for all of our DSLs, and options list. You don't need to do anything to enable this, but it only works with ElixirLS \(not other language server tools\).

## Formatter plugin

`Spark` also ships with a formatter plugin that can help you keep your resources formatted consistently. This plugin can sort the sections of your DSL to make your resources more consistent, and it can remove any accidentally added parentheses around DSL code.

### Adding the plugin

Add the following to your `.formatter.exs`

    [    
          plugins    :         [    Spark.Formatter    ]    ,         # <- add the plugin here    
          inputs    :         ...        ]

### Configuration

#### Minimal config for your Ash Resources

    config         :spark    ,         :formatter    ,    
          remove_parens?    :         true    ,    
          "Ash.Domain"    :         [    ]    ,    
          "Ash.Resource"    :         [    
            section_order    :         [    
              # any section not in this list is left where it is    
              # but these sections will always appear in this order in a resource    
              :actions    ,    
              :attributes    ,    
              :relationships    ,    
              :identities    
            ]    
          ]

#### If you **`use`** a different module than Ash.Resource

    config         :spark    ,         :formatter    ,    
          [    
            "Ash.Resource"    :         [    
              section_order    :         [    
                :resource    ,    
                :identities    ,    
                :attributes    ,    
                :relationships    ,    
                ...    
              ]    
            ]    ,    
            # If you use a different module than Ash.Resource    
            "MyApp.Resource"    :         [    
              type    :         Ash.Resource    ,    
              # What extensions might be added by your base module    
              extensions    :         [    ...    ]    ,    
              section_order    :         [    
                :resource    ,    
                :identities    ,    
                :attributes    ,    
                :relationships    ,    
                ...    
              ]    
            ]    
          ]



# Backwards Compatibility Config

All of these configurations are potentially breaking changes when applied to your application. However, we *highly* encourage setting as many of them as possible. In 4.0, some will be removed entirely, and any that remain will have their defaults changed to the new value.

The ash installer automatically sets all of these.

## allow\_forbidden\_field\_for\_relationships\_by\_default?

    config         :ash    ,         allow_forbidden_field_for_relationships_by_default?    :         true

### Old Behavior

Loaded relationships that produced a `Forbidden` error would fail the entire request. i.e in `Ash.load(post, [:comments, :author])`, if `author` returned a `Forbidden` error, the entire request would fail with a forbidden error.

### New Behavior

Now the relationships that produced a forbidden error are instead populated with `%Ash.ForbiddenField{}`.

## include\_embedded\_source\_by\_default?

    config         :ash    ,         include_embedded_source_by_default?    :         false

### Old Behavior

When working with embedded types, the `__source__` constraint is populated with the original changeset. This can be very costly in terms of memory when working with large sets of embedded resources.

### New Behavior

Now, the source is only included when you say `constraints: [include_source?: true]` on the embedded resource's usage.

## show\_keysets\_for\_all\_actions?

    config         :ash    ,         show_keysets_for_all_actions?    :         false

### Old Behavior

For all actions, the records would be returned with `__metadata__.keyset` populated with a keyset computed for the `sort` that was used to produce those records. This is expensive as it requires loading all things that are used by the sort.

### New Behavior

Only when actually performing keyset pagination will the `__metadata__.keyset` be computed.

## default\_page\_type

    config         :ash    ,         default_page_type    :         :keyset

### Old Behavior

When an action supports both `offset` and `keyset` pagination, and a page is requested with only `limit` set \(i.e., `page: [limit: 10]`\), Ash defaulted to offset pagination and returned an `%Ash.Page.Offset{}`.

### New Behavior

With the current default configuration, Ash will now return an `%Ash.Page.Keyset{}` when the pagination type is ambiguous \(only `limit` is provided\).

For detailed pagination behavior documentation, see the pagination guide.

## policies.no\_filter\_static\_forbidden\_reads?

    config         :ash    ,         policies    :         [    no_filter_static_forbidden_reads?    :         false    ]

### Old Behavior

On read action policies, we can often tell statically that they cannot pass, for example:

    policy         action_type    (    :read    )         do    
          authorize_if         actor_attribute_equals    (    :active    ,         true    )        end

In these cases, you would get an `Ash.Error.Forbidden`, despite the fact that the default `access_type` for a policy is `:filter`. If you instead had:

    policy         action_type    (    :read    )         do    
          authorize_if         expr    (    private         ==         false    )        end

You would get a filter. This made it difficult to predict when you would get a forbidden error and when the query results would be filtered.

### New Behavior

Now, we always filter the query even if we know statically that the request would be forbidden. For example the following policy:

    policy         action_type    (    :read    )         do    
          authorize_if         actor_attribute_equals    (    :active    ,         true    )        end

would yield `filter: false`. This makes the behavior consistent and predictable. You can always annotate that a given policy should result in a forbidden error by setting `access_type :strict` in the policy.

## keep\_read\_action\_loads\_when\_loading?

    config         :ash    ,         keep_read_action_loads_when_loading?    :         false

### Old Behavior

If you had an action with a preparation, or a global preparation that loaded data, i.e

    prepare         build    (    load    :         :comments    )

this wold be applied when using `Ash.load`, because we build a query for the primary read action as a basis for loading data. This could be expensive because now you are always loading `:comments` even if you only intended to load something else, and could also be unpredictable because it could "overwrite" the already loaded `comments` on the data you passed in.

### New Behavior

When using `Ash.load` *only* the explicitly provided load statement is applied.

## default\_actions\_require\_atomic?

    config         :ash    ,         default_actions_require_atomic?    :         true

### Old Behavior

When building actions like so: `defaults [:read, create: :*, update: :*]` the default action is generated with `require_atomic? false`. This could make it difficult to spot actions that cannot safely be done asynchronously.

### New Behavior

The default generated actions are generated with `require_atomic? true`

## read\_action\_after\_action\_hooks\_in\_order?

    config         :ash    ,         read_action_after_action_hooks_in_order?    :         true

### Old Behavior

In 3.0, we modified hooks on changesets to always be added in order instead of in reverse order. This was missed for `Ash.Query`. Meaning if you had something like this:

    read         :read         do    
          prepare         fn         query    ,         _         ->    
            Ash.Query    .    after_action    (    query    ,         fn         query    ,         results         ->    
              IO    .    puts    (    "hook 1"    )    
              {    :ok    ,         results    }    
            end    )    
          end    

          prepare         fn         query    ,         _         ->    
            Ash.Query    .    after_action    (    query    ,         fn         query    ,         results         ->    
              IO    .    puts    (    "hook 2"    )    
              {    :ok    ,         results    }    
            end    )    
          end        end

running that action would print `hook 2` before `hook 1`.

### New Behavior

Read action hooks are now run in the order they were added

## bulk\_actions\_default\_to\_errors?

    config         :ash    ,         bulk_actions_default_to_errors?    :         true

### Old Behavior

Bulk action options defaulted to `return_errors?: false`, and `stop_on_error?: false`, which was often a footgun for users unfamiliar to bulk actions, wondering "why did I not get an error even though nothing was created?"

### New Behavior

Now, `return_errors?` and `stop_on_error?` default to `true`



# Upgrade

## Other Packages

Other packages have had a major version bump in addition to Ash core. While *all packages* have been changed to refer to `domain` instead of `api`, they did not receive a major version bump because there were no special breaking changes to account for when using that package. You will also need to factor in the following upgrade guides, if you use those packages.

+ AshPostgres
+ AshJsonApi
+ AshGraphql

## Upgrading to 3.0

This section contains each breaking change, and the steps required to address it in your application

### Dependency Changes

#### Ash.Flow

If you use `Ash.Flow`, include `{:ash_flow, "~> 0.1.0"}` in your application.

#### Picosat Elixir

In 2.0, Ash had a dependency on `picosat_elixir`. In 3.0, this is an optional dependency, to help folks handle certain compatibility issues. To upgrade, add `{:picosat_elixir, "~> 0.2"}` to your `mix.exs`.

### Ash.Api is now Ash.Domain

The previous name was often confusing as this is an overloaded term for many. To that end, `Ash.Api` has been renamed to `Ash.Domain`, which better fits our usage and concepts.

#### What you'll need to change

To make this change you will need to do two things:

1. replace `Ash.Api` with `Ash.Domain` in your application
2. replace places where an `:api` option is passed to a function with the `:domain` option. For example, `AshPhoenix.Form.for_create(..., api: MyApp.SomeApi)` should now be `AshPhoenix.Form.for_create(..., domain: MyApp.SomeDomain)`
3. Update your application config to define `ash_domains` instead of `ash_apis`, eg. `config :my_app, ash_domains: [MyApp.MyDomain]`

### DSL Changes

+ 
`code_interface.define_for` is now `code_interface.domain`. Additionally, it is set automatically if the `domain` option is specified on `use Ash.Resource`.

+ 
`domain.execution.timeout` used to default to 30 seconds, but now it defaults to `:infinity`. This is because a timeout requires copying memory across process boundaries, and is an unnecessary expense a *vast* majority of the time. We recommend putting timeouts on specific actions that may need them.

+ 
`actions.create.reject`, `actions.update.reject` and `actions.destroy.reject` have been removed. Blacklisting inputs makes it too easy to make mistakes. Instead, specify an explicit `accept` list.

+ 
`relationships.belongs_to.attribute_writable?` no longer makes the underlying attribute both public and writable. It defaults to the value of `writable?` on the relationship \(which itself defaults to `true`\), and only controls the generated attributes `writable? true` property. So now, by default, it will be `true`, which is safe when coupled with changes to the `default_accept`, discussed below. Generally, this means you should be safe to remove any occurrences of `attribute_writable? true`.

+ 
`relationships.belongs_to.attribute_public?` has been added, which controls the underlying attribute's `public?` value. This, similar to `attribute_writable?` defaults to the `public?` attribute of the relationship.

+ 
`resource.simple_notifiers` has been removed, in favor of specifying non-DSL notifiers in the `simple_notifiers` option to `use Ash.Resource`.

+ 
`resource.actions.read.filter` can now be specified multiple times. Multiple filters will be combined with `and`.


### **`Ash.Registry`** has been removed

`Ash.Registry` is no longer needed. Place each resource in the domain instead.

    resources         do    
          resource         Resource1    
          resource         Resource2        end

### Expression changes

When calling a calculation with arguments, this is done via passing a keyword list to the calculation, for example: `full_name(separator: "")`. In 2.0, keyword lists were not evaluated as part of the expression in the same way as other values, meaning two things:

1. 
You did not have to pin usage of template functions, i.e `full_name(separator: arg(:separator))`. Now, you will need to do so: `full_name(separator: ^arg(:separator))`

2. 
You had to use `expr` to pass an expression to a calculation argument \(this only works if `allow_expr? true` is configured on the calculation argument\). For example: `full_name(separator: expr(sep_1 <> sep_2))` would now be `full_name(separator: sep_1 <> sep_2)`


If you do not have any expression calculations that accept arguments, you likely need to do nothing. To make these changes, you will need to look at each place you build an expression that you may be calling a calculation w/ arguments, i.e `Ash.Query.filter`, and the `expression` callback in `Ash.Calculation`, and see if they must be modified as described above.

### Module/function changes

#### Ash.Policy.FilterCheck and Ash.Policy.FilterCheckWithContext are combined

`Ash.Policy.FilterCheck` and `Ash.Policy.FilterCheckWithContext` have been combined into `Ash.Policy.FilterCheck`. If you have any usages of `FilterCheckWithContext`, you'll need to change that to `FilterCheck`. If you have usages of `FilterCheck`, you will need to add the `context` arguments to the callbacks. Compiler warnings will show you what callbacks mismatch.

#### Ash.Filter

`Ash.Filter.parse/5` is now `Ash.Filter.parse/3`. `Ash.Filter.parse_input/5` is now `Ash.Filter.parse_input/2` The third and fourth optional arguments are unnecessary and were previously ignored, and the fifth argument is not necessary for `parse_input`.

`Ash.Filter.used_aggregates/3` no longer accepts `:all` as a relationship path, instead using `:*`. Its very unlikely that this is used in your application.

#### Ash.Filter.TemplateHelpers

Tools for templating expressions were previously in `Ash.Filter.TemplateHelpers`. This often led to confusion because it was a hard to remember module name, and didn't really make sense to be separate from the rest of our utilities. Now, all the functions/macros you need for expressions are in `Ash.Expr`. This means that in any given file where you want to work with expressions, you only need to do `import Ash.Expr`. Additionally, this `import Ash.Expr` has been added to changes, preparations, validations and calculations automatically.

#### Ash.CiString

+ `Ash.CiString.new(nil)` now returns `nil` instead of `%Ash.CiString{value: nil}`

#### Ash.Resource.Validation

`validate/2` is now `validate/3`, with the third argument being the context of the validation.

#### Ash.Query.Calculation

The function signature of `Ash.Query.Calculation.new` has been changed. We use an options list over optional arguments, and now require constraints to be provided. You will need to adjust your calls to this function.

#### Ash.Calculation

This module has been renamed to `Ash.Resource.Calculation`. You will need to rename your references to it.

#### Ash.Query

Ash.Query.to\_query has been removed. Use `Ash.Query.new` instead.

Ash.Query.expr has been removed. Use `Ash.Expr.expr` instead.

#### Aggregates

`first` and `list` aggregates have a new option called `include_nil?`, which *defaults to false*. You may need to add `include_nil?: true` to your resource aggregates if you wish to retain the old behavior.



##### New format for sorting on calculations with arguments



The format for sorting on calculations that take input has been swapped. Previously, you would use `sort(calculation: {:desc, %{arg: :value}})`, but for the sake of consistency, you now use `sort(calculation: {%{arg: :value}, :desc})`.

#### Ash.Changeset

`Ash.Changeset.new/2` has been removed. `Ash.Changeset.new/1` is still available for creating a new changeset, but attributes and arguments should, with few exceptions, be passed to the relevant `Ash.Changeset.for_<action_type>` functions, *not* to `Ash.Changeset.new/2`. Removing the second argument helps clarify the purpose of `Ash.Changeset.new/1`.

`Ash.Changeset.after_transaction/2` can no longer be called from within other lifecycle hooks. We need to know whether or not an after action hook, before we start processing any hooks.

`Ash.Changeset.manage_relationship/4` no longer uses `:all` to signal that all changes will be sent to the join relationship. Instead, use `:*`.

`Ash.Changeset.filter` now accepts expressions. The value of the filter is no longer a simple equality map, but rather a regular Ash expression. We add to it on successive calls to `Ash.Changeset.filter`. Additionally, this value is stored in `changeset.filter` instead of `changeset.filters`.

#### Ash.Policy.FilterCheckWithContext

`Ash.Policy.FilterCheck` and `Ash.Policy.FilterCheckWithContext` have been combined. The name is `Ash.Policy.FilterCheck`, but the callbacks take the extra arguments present in `Ash.Policy.FilterCheckWithContext`.

#### Builtin Changes & Preparations

The functions provided to `after_action/1`, `after_transaction/1`, `before_transaction/1` and `before_action/1` must all now take an additional argument, which is the change context.

For example,

    change         after_action    (    fn         changeset    ,         result         ->         ...         end    )

is now

    change         after_action    (    fn         changeset    ,         result    ,         context         ->         ...         end    )

This is true for both preparations and changes.

#### Expressions

Previously, in expressions, you could say `expr(ref(^some_atom))`. This is a tool for building dynamic references, but it was an exception to the standard pattern of prefixing "external" things in an expression, i.e `arg` with `^`. Now, you must do the same with `ref/1` and `ref/2`. You will need to search for `ref(` in your application, and ensure that if it is inside of an expression you have prefixed it with `^`. The original example becomes: `expr(^ref(some_atom))`.

#### Exception changes



##### Ash exceptions have been simplified and are now backed by **`Splode`**



Usage of `def_ash_error/2` will show you what to change in its warnings.

Instead of combining `def_ash_error` with `defimpl Ash.ErrorKind`, you create a custom error like so:

    defmodule         MyCustomError         do    
          use         Splode.Error    ,         class    :         :invalid    ,         fields    :         [    :foo    ,         :bar    ]    

          def         message    (    error    )         do    
            "Message:     #{    error    .    foo    }     -     #{    error    .    bar    }    "    
          end        end



##### Ash exception changes



When sorting or filtering, if a field is not found, an `Ash.Query.Error.NoSuchField` is used, where it would have previously been an `Ash.Query.Error.NoSuchAttribute`. This was wrong as sometimes the field reference was not an attribute. Places that would previously return `Ash.Query.Error.NoSuchAttributeOrRelationship` now return `Ash.Query.Error.NoSuchField` as well.

Additionally, the following exceptions have had keys remapped:

`NoSuchAttribute`: `name` -> `attribute` `NoSuchRelationship`: `name` -> `relationship` `NoSuchFunction`: `name` -> `function` `NoSuchOperator`: `name` -> `operator`

* * *

## Significant Changes

### **`Ash.set_*`** functions have been removed

In 2.0, a set of features allowed storing the actor, tenant and context in the process dictionary. There were fundamental issues with this pattern that manifested in subtle bugs. We suggest making this change *before* you upgrade, as this change can be made and verified without upgrading to 3.0.

#### What you'll need to change

You need to manually thread through your tenant, actor, and context values wherever you were using `Ash.set_*`. For example:

    Ash    .    set_actor    (    current_user    )        Ash    .    set_tenant    (    current_tenant    )    
        Ash.Changeset    .    for_create!    (    ..    )        Ash.Query    .    for_read    (    ..    )

would become

    Ash.Changeset    .    for_create!    (    ..    ,         tenant    :         current_tenant    ,         actor    :         current_user    )        Ash.Query    .    for_read    (    ..    ,         tenant    :         current_tenant    ,         actor    :         current_user    )

### The **`Domain`** of a resource must now be known when constructing a changeset, query or action input

In order to honor rules on the `Domain` module about authorization and timeouts, we have to know the `Domain` when building the changeset.

#### What you'll need to change



##### Embedded Resources



The domain for the calls to embedded resources is gotten from the parent changeset. No need to change them at all. a `domain` constraint has been added in case you wish to make a given embedded resource use a specific domain always.

For example:

    attribute         :bio    ,         MyApp.Bio         do    
          constraints         domain    :         MyApp.SomeDomain        end



##### Single Domain resources



While it is possible for resources to be used with multiple domains, it almost never happens in practice. Any resources that are only used from a single domain only \(*not* including embedded resources\) should be modified to have a `domain` option specified in their call to `use Ash.Resource`. For example:

    use         Ash.Resource    ,    
          domain    :         MyApp.MyDomain



###### Using **`Ash.*`** to interact with your resources



Calling functions on the domain has been deprecated. You must now use the functions defined in the `Ash` module to interact with your resources. They are the same as what was previously available in your domain module. For example:

    MyDomain1    .    create!    (    changeset    )        MyDomain2    .    read!    (    query    )        MyDomain3    .    calculate!    (    ...    )

can now be written as

    Ash    .    create!    (    changeset    )        Ash    .    read!    (    query    )        Ash    .    calculate!    (    query    )

This makes refactoring resources easier, as you no longer need to change the call site, it remains the same regardless of what Domain a resource is in.



##### Multi Domain resources



For these, you will need to include the `domain` option when you construct a changeset.

For example:

    MyResource        |>         Ash.Changeset    .    for_create    (    :create    ,         input    ,         domain    :         MyApp.MyDomain    )

* * *

### Actions no longer default to accepting all public writable attributes

For more context, see the original discussion: https://github.com/ash-project/ash/issues/512

In 2.0, all public, writable attributes were accepted by each action by default. This made it very easy to accidentally expose writing to an attribute in an action where that was not the intent. Additionally, new attributes added were automatically writable across a wide array of actions, which was error prone for the same reason.

In 2.0, as well as 3.0, there is an option called `default_accept`, which modifies all actions that do not have an `accept` list. In 2.0, the default value for `default_accept` was "all public, writable attributes". In 3.0, the default value for `default_accept` is `[]`. This encourages a pattern of explicitly listing inputs to actions, and is safer and less error prone.

#### What you'll need to change

For those who want to upgrade, you would use the new `:*` option to `default_accept` \(also usable in an action's `accept` option\) to accept all public attributes. Go to each resource and, inside the actions block, add:

    actions         do    
          default_accept         :*    
          ...        end

Then mark the attributes and relationships you want to accept as `public?: true` \(see this section for more information on this change\).

For those who want to be more explicit, or after your upgrade has complete if you wish to refactor existing resources and actions, the general best path forward is to copy the `default_accept` into each action \(or put it in a module attribute and reference it\) as the `accept` option. This way when a new action is added, it does not "inherit" some list of accepted attributes.

### :\* private attributes can now be accepted

In 2.0, accepting a private attribute as a change required adding an argument with the same name, and using `change set_attribute(...)`. Now that we require explicit accept lists, you can place private attributes in that list, which will allow them to be written to \(but not read back\).

### :\* includes belongs\_to attributes\!

The change to explicit accepts also included a change that defaults belongs\_to attributes to `writable?: true` and `public?: false`. You may want to add `attribute_writable?: false` to your belongs\_to relationships if you are adding `default_accept :*` and don't currently have `attribute_writable?: true` on them currently.

* * *

### Default actions **`:create`** and **`:update`** can now have an accept list

For example:

    defaults         [    :read    ,         :destroy    ,         create    :         :*    ,         update    :         :*    ]

### Default read actions are now paginatable

In 2.0, if you have `:read` in your default actions list, it would generate an action like this:

    read         :read         do    
          primary?         true        end

Now, it generates an action like this:

    read         :read         do    
          primary?         true    
          pagination         [    keyset?    :         true    ,         offset?    :         true    ,         countable    :         true    ,         required?    :         false    ]        end

* * *

### What you will need to change

For most cases, this won't affect you. However, if you are using `AshGraphql`, and have any queries connected to a default `:read` action, it will default to making those queries paginatable with keyset pagination. To keep the old behavior, you will need to add `paginate_with nil` to the query, for example:

    graphql         do    
          queries         do    
            list         :list_things    ,         :read    ,         paginate_with    :         nil    
          end        end

* * *

### Before action and before transaction hooks order has been reversed

In Ash 2.0, `before_action` and `before_transaction` hooks that were added to a changeset were prepended to the list of hooks by default. These hooks were then run in order. What this meant is that, given an action like the following:

    create         :foo         do    
          change         before_action    (    fn         changeset    ,         _context         ->    
            IO    .    puts    (    "first"    )    
            changeset    
          end    )    

          change         before_action    (    fn         changeset    ,         _context         ->    
            IO    .    puts    (    "second"    )    
            changeset    
          end    )        end

You would see `second` printed *before* `first`.

#### What you'll need to change

In many cases, this won't matter to you. However, if you have a situation where the order of your before action/transaction hooks matters, you can do one of two things:

1. reorder the changes that add those before action/transaction hooks
2. use the `:prepend` option to `Ash.Changeset.before_action/2` and `Ash.Changeset.before_transaction/2` to explicitly prepend the hook to the list of hooks

* * *

### Context in changes, preparations, validations, calculations are now structs

To help make it clear what keys are available in the context provided to callbacks on these modules, they have been adjusted to provide a *struct* instead of a `map`. This helps avoid potential ambiguity, and acts as documentation.

#### What you'll need to change

If you are using something like `Keyword.new(context)` to generate options to pass into an action, change that to `Ash.Context.to_opts(context)`.

* * *

### Calculation arguments are now in **`context.arguments`**

Per the above change, we have specified the values available in the context of a calculation, with `Ash.Resource.Calculation.Context`. In Ash 2.0, context was merged with arguments, which was problematic in various ways. Now, arguments are in `context.arguments`.

#### What you'll need to change

You will need to update your module-backed calculations to account for this.

    def         calculate    (    records    ,         _opts    ,         context    )         do    
          Enum    .    map    (    records    ,         fn         record         ->    
            record    .    first_name         <>         context    .    delimiter         <>         record    .    last_name    
          end    )        end

would need to be adjusted to access arguments in the context:

    def         calculate    (    records    ,         _opts    ,         %{    arguments    :         arguments    }    )         do    
          Enum    .    map    (    records    ,         fn         record         ->    
            record    .    first_name         <>         arguments    .    delimiter         <>         record    .    last_name    
          end    )        end

* * *

### **`private?: true`** -> **`public?: true`**

There is no longer a `private?` option for attributes, relationships, calculations and aggregates. Instead of attributes defaulting to `private?: false`, they now default to `public?: false`. It was too easy to add an attribute and not realize that you had exposed it over your api.

#### What you'll need to change

If you are using api extensions \(i.e `AshGraphql` and `AshJsonApi`\), you will need to go to your resources and "invert" the definitions. i.e *remove* `private?: true` and *add* `public?: true` to *every other* attribute, *relationship* and *calculation*. Don't forget the relationships and calculations\!
> 
> ### Embedded resources too\!

> The above includes embedded resources as well\! Don't forget to make sure that all fields on your embedded resources are also marked as `public?: true` \(if applicable\). The goal here is to have a clear visual indicator of what in your application can be shown publicly.

* * *

### Anonymous calculations now operate on a list, just like module calculations

Previously, anonymous function calculations were special cased to operate on a single record. For consistency, these anonymous functions now take the list of records.

#### What you'll need to change

Update any anonymous function calculations to take and return a list, for example:

    calculate         :full_name    ,         :string    ,         fn         record    ,         _context         ->    
          record    .    first_name         <>         " "         <>         record    .    last_name        end

would become

    calculate         :full_name    ,         :string    ,         fn         records    ,         _context         ->    
          # note, you can also return `{:ok, list}` or `{:error, error}`    
          Enum    .    map    (    records    ,         fn         record         ->    
            record    .    first_name         <>         " "         <>         record    .    last_name    
          end    )        end

* * *

### Calculation loads do not select all related fields by default

In 2.0 relationship loads from the `load/3` callback in a calculation will select *all* fields of that relationship and make them available to the calculation.

For example, the following calculation `load/3` callback expresses a dependency on *all* fields of the relationship `:relationship`.

    def         load    (    _    ,         _    ,         _    )         do    
          [    :relationship    ]        end

#### What you'll need to change



##### Refactor



In 3.0, relationship dependencies alone will only make the related primary keys available. You now need to select explicit fields that you want to use in your calculation, for example:

    def         load    (    _    ,         _    ,         _    )         do    
          [    relationship    :         [    :field1    ,         :field2    ]    ]        end

#### Keep the old behavior

Each calculation can still opt into the old behavior by adding the callback `strict_loads/0` and returning `false`.

    def         load    (    _    ,         _    ,         _    )         do    
          [    :relationship    ]        end    
        def         strict_loads    ,         do    :         false

* * *

### Calculations do not have a **`select/3`** callback any more

In 2.0 calculations had a `select/3` callback, but `load/3` is now a superset of `select/3` and so the former is no longer needed.

#### What you'll need to change

If you have a `select/3` callback in your calculations, you will need to remove the `select/3` callback. You must then add those fields to the `load/3` callback.

For example:

    def         select    (    _    ,         _    ,         _    )    ,         do    :         [    :some_attribute    ]        def         load    (    _    ,         _    ,         _    )    ,         do    :         [    :some_calculation    ,         some_relationship    :         [    :some_field1    ,         :some_field2    ]    ]

can now be written more simply as:

    def         load    (    _    ,         _    ,         _    )    ,         do    :         [    :some_attribute    ,         :some_calculation    ,         some_relationship    :         [    :some_field1    ,         :some_field2    ]    ]

* * *

### Embedded resources no longer have **`autogenerated_id`**

A private primary key called `autogenerated_id` was added to embedded resources if no primary key was added manually.

This should have no real effect on your application, except for the fact that your embedded attributes will have `autogenerated_id` in the database which won't be reflected by an attribute any more. If it is updated, then the `autogenerated_id` field will go away.

This is listed as a breaking change in case someone is depending on this feature, but that should be very uncommon/unlikely.

* * *

### PubSub notifier no longer publishes events for previous values by default

Previously, the Ash notifier would publish a message containing both the old *and* new values for changing attributes. Typically, we use things like IDs in notification topics, that do not change, so for most this will not have an impact.

If you wish to send a notification for the old value and the new value, then an action cannot be done atomically. Bulk actions must update each record in turn, and atomic updates can't be leveraged.

If you're comfortable with the performance implications, you can restore the previous behavior by adding `previous_values?: true` to your publications in your pub\_sub notifier

    publish         :update    ,         [    "user:updated"    ,         :email    ]    ,         previous_values?    :         true

* * *

### Custom checks and notifiers will not have access to the original data by default

In your notifiers and policy checks, when you get a changeset you currently have access to the `data` field, which is the original record prior to being updated or destroyed. However, this is not compatible with atomic/bulk updates/destroys, where we may be given a query and told to destroy it. In those cases, `changeset.data` will be `%Ash.Changeset.OriginalDataNotAvailable{}`. When you write a custom check or a custom notifier, if you need access to the original data, you must add the following function:

    # in custom checks        def         requires_original_data?    (    _authorizer    ,         _opts    )    ,         do    :         true    
        # in notifiers        def         requires_original_data?    (    _resource    ,         _action    )    ,         do    :         true

Keep in mind, this will prevent the usage of these checks/notifiers with atomic actions.

* * *

### **`Domain.authorization.authorize`** now defaults to **`:by_default`**

Previously, the default was `:when_requested`. This meant that, unless you said `actor: some_actor` or `authorize?: true`, authorization was skipped. This has the obvious drawback of making it easy to accidentally bypass authorization unintentionally. In 3.0, this now defaults to `:by_default`.

#### What you'll need to change



##### Keep old behavior



To avoid making a significant refactor, and to keep your current behavior, you can go to your domain and set the configuration below. Otherwise skip to the refactor steps below. We advise that you take this route to start, but we *highly suggest* that you change your domains to `authorize :by_default` in the future. `authorize :when_requested` will not be deprecated, so there is no time constraint.

    authorization         do    
          authorize         :when_requested        end



##### Refactor



For each domain that has the old configuration, after setting it to the new config, you'll need to revisit each call to that domain that doesn't set an actor or the `authorize?` option, and add `authorize?: false`.

This may be a good time to do the refactor from `YourDomain.func` to `Ash.func`, if you want to. See the section about domains being required when building changesets.

* * *

### **`require_atomic?`** defaults to **`true`**

On `:update` actions, and `:destroy` actions, they now default to `require_atomic? true`. This means that the following things will cause errors when attempting to run the action:

1. changes or validations exist that do not have the `atomic` callback. *This includes anonymous function changes/validations*.
2. attributes are being changed that do not support atomic updates. This most notably includes \(for now\) embedded resources.
3. the action has a manual implementation
4. the action has applicable notifiers that require the original data.

Updates and destroys that can be made fully atomic are always safe to do concurrently, and as such we now require that actions meet this criteria, or that it is explicitly stated that they do not have to. See the update actions guide for more.

#### Upgrade config

You can set the following configuration, which *will be removed in Ash 3.1*. This configuration will retain the 2.0 default behavior of `require_atomic?` defaulting to `false`. You can then safely do the rest of the upgrade. Then, you can perform this one change after confirming that your system works as expected.

    config         :ash    ,         :require_atomic_by_default?    ,         false

#### What you'll need to change

The vast majority of cases will be caught by warnings emitted at compile time.



##### Anonymous function changes



Anonymous function changes can never be made atomic, because we don't know what they contain. You will either need to transfer it to a module change and then follow the next section, or set `require_atomic? false`



##### Module changes



If you have a module change, you can make it atomic by defining the `atomic/3` callback. This callback can replace the `change/3` callback, but it is very important to keep in mind that *later changes* will no longer have access to the value. For example, if you have

    def         change    (    changeset    ,         _    ,         _    )         do    
          # this is not concurrency safe    
          Ash.Changeset    .    change_attribute    (    changeset    ,         :value    ,         changeset    .    data    .    value         +         1    )        end

If you have a subsequent change that does something like `Ash.Changeset.get_attribute(changeset, :value)` it will get the new value \(i.e old value \+ 1\). With atomics, `Ash.Changeset.get_attribute(changeset, :value)` would return the *old value*. This is because atomics are scheduling an update that happens when call the data layer. For example:

    def         atomic    (    changeset    ,         _    ,         _    )         do    
          {    :atomic    ,         %{    value    :         expr    (    value         +         1    )    }    }        end

This should not typically matter unless you have complex actions w/ multiple changes where subsequent changes need to know the results of previous steps. In those cases, if you can't make them all atomic, then its best just not to worry about it and set `require_atomic? false`



##### Non-atomic castable types



If you are using `change atomic_update/2` or `Ash.Changeset.atomic_update/2` or `Ash.Changeset.atomic_update/3`, and the type does not support atomic updates, you will get an error unless you do one of the following:

1. for `change atomic_update/2` add the `cast_atomic?: false` option.
2. for `Ash.Changeset.atomic_update`, pass the value as `{:atomic, expr}`, i.e `Ash.Changeset.atomic_update(changeset, :value, {:atomic, expr(value + 1)})`

For builtin types, the above applies to `:union`, `:map`, `:keyword`, embedded types. It also applies to `:string`, but only if the `match?` constraint is present.

* * *

### **`Ash.Error.Invalid.NoSuchInput`** errors on unknown action inputs

In 2.0, inputs to actions that don't match an accepted attribute or argument were silently ignored. This made it very easy to make certain kinds of mistakes, like assuming that an input is being used by an action when it actually is not. Now, unknown action inputs will cause an `Ash.Error.Invalid.NoSuchInput`.

#### What you'll need to change

If you have action calls that are erroneously passing in extra values, you will need to do remove them.

A logic error was fixed in this behavior for embedded resources. If you are using embedded resources in `{:array, _}` types, and are relying on including the primary key of that embedded resource to match records up for updating/destroy behavior, you will need to make sure that you do one of the following

1. add the `writable?: true` flag to the uuid of the embedded resource \(probably what you want\)
2. modify the actions to accept an `id` argument and set the argument to the provided value

* * *

### **`%Ash.NotLoaded{}`** for attributes

In 2.0, attributes that were not selected were replaced with `nil` values. This could lead to confusion when dealing with records that didn't have all attributes selected. If you passed these records to a function it might see that an attribute is `nil` when actually it just wasn't selected. To find out if it was selected, you could look into `record.__metadata__.selected`, but you'd have to know to do that. To alleviate these issues, attributes that are not selected are now filled in with `%Ash.NotLoaded{}`, just like calculations and aggregates.

#### What you'll need to change

If you have logic that was looking at attribute values that may not be selected, you may have been accidentally working with non selected values. For example:

    if         record    .    attribute         do    
          handle_present_attribute    (    ...    )        else    
          # unselected attributes would have ended up in this branch    
          handle_not_present_attribute    (    ...    )        end

Now, if it is possible for that attribute to have not been selected, you'll want to do something like this instead:

    case         record    .    attribute         do    
          %    Ash.NotLoaded    {    }         ->    
            handle_not_selected    (    ...    )    
          nil         ->    
            handle_not_present_attribute    (    ...    )    
          value         ->    
            handle_present_attribute    (    ...    )        end

* * *

### Calculations do not reuse values by default

When loading data in 2.0 the option `reselect_all?` defaulted to `false`. What this would mean is that existing values for attributes would be reused, instead of visiting the data layer, by default. This can be an extremely valuable piece of behavior, but *defaulting* to it often means accidentally using data as a cache that you did not intent to use as a cache. Take the following example:

    user         =         %    User    {    first_name    :         "fred"    ,         last_name    :         "weasley"    }    
        Ash    .    update!    (    user    ,         first_name    :         "george"    )    
        user         |>         Ash    .    load!    (    :full_name    )        # in 2.0 -> fred weasley        # in 3.0 -> george weasley

To opt into the old behavior, which we recommend doing on a case-by-case basis, you can pass `reuse_values?: true`. For example:

    user         |>         Ash    .    load!    (    :full_name    ,         reuse_values?    :         true    )

* * *

### Resources are not interchangeable with **`Ash.Type`** anymore

In 2.0 it was possible to pass an Ash resource in all places where some instance of `Ash.Type` was supported. In 3.0 resources \(except for embedded resources\) don't implement the `Ash.Type` behaviour anymore.

#### What you'll need to change

If you were using a resource in one of the places that accept an `Ash.Type` \(arguments, calculation return values or fields of a union\) you have to refactor your code to use the `:struct` type together with an `instance_of` constraint

    calculation         :random_post    ,         :struct         do    
          constraints         instance_of    :         Post    
          calculate         Calculations.RandomPost        end



# Ash.Resource

## attributes

A section for declaring attributes on the resource.

### Nested DSLs

+ attribute
+ create\_timestamp
+ update\_timestamp
+ integer\_primary\_key
+ uuid\_primary\_key
+ uuid\_v7\_primary\_key

### Examples

    attributes         do    
          uuid_primary_key         :id    

          attribute         :first_name    ,         :string         do    
            allow_nil?         false    
          end    

          attribute         :last_name    ,         :string         do    
            allow_nil?         false    
          end    

          attribute         :email    ,         :string         do    
            allow_nil?         false    

            constraints         [    
              match    :         ~r/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+$/    
            ]    
          end    

          attribute         :type    ,         :atom         do    
            constraints         [    
              one_of    :         [    :admin    ,         :teacher    ,         :student    ]    
            ]    
          end    

          create_timestamp         :inserted_at    
          update_timestamp         :updated_at        end    

### attributes.attribute

    attribute         name    ,         type

Declares an attribute on the resource.

### Examples

    attribute         :name    ,         :string         do    
          allow_nil?         false        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the attribute.`type``module`The type of the attribute. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`constraints``keyword`Constraints to provide to the type when casting the value. For more, see `Ash.Type`.`description``String.t`An optional description for the attribute.`sensitive?``boolean``false`Whether or not the attribute value contains sensitive information, like PII\(Personally Identifiable Information\). See the Sensitive Data guide for more.`source``atom`If the field should be mapped to a different name in the data layer. Support varies by data layer.`select_by_default?``boolean``true`Whether or not the attribute is selected by default.`always_select?``boolean``false`Whether or not to ensure this attribute is always selected when reading from the database, regardless of applied select statements.`primary_key?``boolean``false`Whether the attribute is the primary key. Composite primary key is also possible by using `primary_key? true` in more than one attribute. If primary\_key? is true, allow\_nil? must be false.`allow_nil?``boolean``true`Whether or not the attribute can be set to nil. If nil value is given error is raised.`generated?``boolean``false`Whether or not the value may be generated by the data layer.`writable?``boolean``true`Whether or not the value can be written to. Non-writable attributes can still be written with `Ash.Changeset.force_change_attribute/3`.`public?``boolean``false`Whether or not the attribute should be shown over public interfaces. See the sensitive data guide for more.`default``(-> any) | mfa | any`A value to be set on all creates, unless a value is being provided already. Note: The default value is casted according to the type's `Ash.Type.*` module, before it is saved. For `:string`, for example, if `constraints: [allow_empty?: _]` is false, the value `""` will be cast to `nil`. See the `:constraints` option, the `:allow_nil?` option, and the relevant `Ash.Type.*` documentation.`update_default``(-> any) | mfa | any`A value to be set on all updates, unless a value is being provided already.`filterable?``boolean | :simple_equality``true`Whether or not the attribute can be referenced in filters.`sortable?``boolean``true`Whether or not the attribute can be referenced in sorts.`match_other_defaults?``boolean``false`Ensures that other attributes that use the same "lazy" default \(a function or an mfa\), use the same default value. Has no effect unless `default` is a zero argument function.
### Introspection

Target: `Ash.Resource.Attribute`

### attributes.create\_timestamp

    create_timestamp         name

Declares a non-writable attribute with a create default of `&DateTime.utc_now/0`

Accepts all the same options as `d:Ash.Resource.Dsl.attributes.attribute`, except it sets the following different defaults:

    writable?         false        default         &    DateTime    .    utc_now    /    0        match_other_defaults?         true        type         Ash.Type.UTCDatetimeUsec        allow_nil?         false

### Examples

    create_timestamp         :inserted_at

### Arguments
NameTypeDefaultDocs`name``atom`The name of the attribute.
### Introspection

Target: `Ash.Resource.Attribute`

### attributes.update\_timestamp

    update_timestamp         name

Declares a non-writable attribute with a create and update default of `&DateTime.utc_now/0`

Accepts all the same options as `d:Ash.Resource.Dsl.attributes.attribute`, except it sets the following different defaults:

    writable?         false        default         &    DateTime    .    utc_now    /    0        match_other_defaults?         true        update_default         &    DateTime    .    utc_now    /    0        type         Ash.Type.UTCDatetimeUsec        allow_nil?         false

### Examples

    update_timestamp         :updated_at

### Arguments
NameTypeDefaultDocs`name``atom`The name of the attribute.
### Introspection

Target: `Ash.Resource.Attribute`

### attributes.integer\_primary\_key

    integer_primary_key         name

Declares a generated, non writable, non-nil, primary key column of type integer.

Generated integer primary keys must be supported by the data layer.

Accepts all the same options as `d:Ash.Resource.Dsl.attributes.attribute`, except for `allow_nil?`, but it sets the following different defaults:

    public?         true        writable?         false        primary_key?         true        generated?         true        type         :integer

### Examples

    integer_primary_key         :id

### Arguments
NameTypeDefaultDocs`name``atom`The name of the attribute.
### Introspection

Target: `Ash.Resource.Attribute`

### attributes.uuid\_primary\_key

    uuid_primary_key         name

Declares a non writable, non-nil, primary key column of type `uuid`, which defaults to `Ash.UUID.generate/0`.

Accepts all the same options as `d:Ash.Resource.Dsl.attributes.attribute`, except for `allow_nil?`, but it sets the following different defaults:

    writable?         false        public?         true        default         &    Ash.UUID    .    generate    /    0        primary_key?         true        type         :uuid

### Examples

    uuid_primary_key         :id

### Arguments
NameTypeDefaultDocs`name``atom`The name of the attribute.
### Introspection

Target: `Ash.Resource.Attribute`

### attributes.uuid\_v7\_primary\_key

    uuid_v7_primary_key         name

Declares a non writable, non-nil, primary key column of type `uuid_v7`, which defaults to `Ash.UUIDv7.generate/0`.

Accepts all the same options as `d:Ash.Resource.Dsl.attributes.attribute`, except for `allow_nil?`, but it sets the following different defaults:

    writable?         false        public?         true        default         &    Ash.UUIDv7    .    generate    /    0        primary_key?         true        type         :uuid_v7

### Examples

    uuid_v7_primary_key         :id

### Arguments
NameTypeDefaultDocs`name``atom`The name of the attribute.
### Introspection

Target: `Ash.Resource.Attribute`

## relationships

A section for declaring relationships on the resource.

Relationships are a core component of resource oriented design. Many components of Ash will use these relationships. A simple use case is loading relationships \(done via the `Ash.Query.load/2`\).

See the relationships guide for more.

### Nested DSLs

+ has\_one
	+ filter

+ has\_many
	+ filter

+ many\_to\_many
	+ filter

+ belongs\_to
	+ filter


### Examples

    relationships         do    
          belongs_to         :post    ,         MyApp.Post         do    
            primary_key?         true    
          end    

          belongs_to         :category    ,         MyApp.Category         do    
            primary_key?         true    
          end        end    

    relationships         do    
          belongs_to         :author    ,         MyApp.Author    

          many_to_many         :categories    ,         MyApp.Category         do    
            through         MyApp.PostCategory    
            destination_attribute_on_join_resource         :category_id    
            source_attribute_on_join_resource         :post_id    
          end        end    

    relationships         do    
          has_many         :posts    ,         MyApp.Post         do    
            destination_attribute         :author_id    
          end    

          has_many         :composite_key_posts    ,         MyApp.CompositeKeyPost         do    
            destination_attribute         :author_id    
          end        end    

### relationships.has\_one

    has_one         name    ,         destination

Declares a `has_one` relationship. In a relational database, the foreign key would be on the *other* table.

Generally speaking, a `has_one` also implies that the destination table is unique on that foreign key.

See the relationships guide for more.

### Nested DSLs

+ filter

### Examples

    # In a resource called `Word`        has_one         :dictionary_entry    ,         DictionaryEntry         do    
          source_attribute         :text    
          destination_attribute         :word_text        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the relationship`destination``module`The destination resource
### Options
NameTypeDefaultDocs`manual``(any, any -> any) | module`A module that implements `Ash.Resource.ManualRelationship`. Also accepts a 2 argument function that takes the source records and the context.`no_attributes?``boolean`All existing entities are considered related, i.e this relationship is not based on any fields, and `source_attribute` and `destination_attribute` are ignored. See the See the relationships guide for more.`allow_nil?``boolean``true`Marks the relationship as required. Has no effect on validations, but can inform extensions that there will always be a related entity.`from_many?``boolean``false`Signal that this relationship is actually a `has_many` where the first record is given via the `sort`. This will allow data layers to properly deduplicate when necessary.`description``String.t`An optional description for the relationship`destination_attribute``atom`The attribute on the related resource that should match the `source_attribute` configured on this resource.`validate_destination_attribute?``boolean``true`Whether or not to validate that the destination field exists on the destination resource`source_attribute``atom``:id`The field on this resource that should match the `destination_attribute` on the related resource.`relationship_context``any`Context to be set on any queries or changesets generated for managing or querying this relationship.`public?``boolean``false`Whether or not the relationship will appear in public interfaces`not_found_message``String.t`A message to show if there is a conflict with this relationship in the database on update or create, or when managing relationships.`writable?``boolean``true`Whether or not the relationship may be managed.`read_action``atom`The read action on the destination resource to use when loading data and filtering.`domain``atom`The domain module to use when working with the related entity.`filterable?``boolean``true`If set to `false`, the relationship will not be usable in filters.`sortable?``boolean``true`If set to `false`, the relationship will not be usable in sorts.`sort``any`A sort statement to be applied when loading the relationship.`default_sort``any`A default sort statement to be applied when loading the relationship.`could_be_related_at_creation?``boolean``false`Whether or not related values may exist for this relationship at creation.`violation_message``String.t`A message to show if there is a conflict with this relationship in the database on destroy.`authorize_read_with``:error | :filter`If set to `:error`, any authorization filter added to the relationship will result in an error if any record matches the filter in the database.`allow_forbidden_field?``boolean``false`If set to `true`, the relationship will be set to `%Ash.ForbiddenField{}` if its query produces a forbidden error.
### relationships.has\_one.filter

    filter         filter

Applies a filter. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.

### Examples

    filter         expr    (    first_name         ==         "fred"    )        filter         expr    (    last_name         ==         "weasley"         and         magician         ==         true    )    

### Arguments
NameTypeDefaultDocs`filter``any`The filter to apply. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.
### Introspection

Target: `Ash.Resource.Dsl.Filter`

### Introspection

Target: `Ash.Resource.Relationships.HasOne`

### relationships.has\_many

    has_many         name    ,         destination

Declares a `has_many` relationship. There can be any number of related entities.

See the relationships guide for more.

### Nested DSLs

+ filter

### Examples

    # In a resource called `Word`        has_many         :definitions    ,         DictionaryDefinition         do    
          source_attribute         :text    
          destination_attribute         :word_text        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the relationship`destination``module`The destination resource
### Options
NameTypeDefaultDocs`manual``(any, any -> any) | module`A module that implements `Ash.Resource.ManualRelationship`. Also accepts a 2 argument function that takes the source records and the context.`no_attributes?``boolean`All existing entities are considered related, i.e this relationship is not based on any fields, and `source_attribute` and `destination_attribute` are ignored. See the See the relationships guide for more.`limit``integer`An integer to limit entries from loaded relationship.`description``String.t`An optional description for the relationship`destination_attribute``atom`The attribute on the related resource that should match the `source_attribute` configured on this resource.`validate_destination_attribute?``boolean``true`Whether or not to validate that the destination field exists on the destination resource`source_attribute``atom``:id`The field on this resource that should match the `destination_attribute` on the related resource.`relationship_context``any`Context to be set on any queries or changesets generated for managing or querying this relationship.`public?``boolean``false`Whether or not the relationship will appear in public interfaces`not_found_message``String.t`A message to show if there is a conflict with this relationship in the database on update or create, or when managing relationships.`writable?``boolean``true`Whether or not the relationship may be managed.`read_action``atom`The read action on the destination resource to use when loading data and filtering.`domain``atom`The domain module to use when working with the related entity.`filterable?``boolean``true`If set to `false`, the relationship will not be usable in filters.`sortable?``boolean``true`If set to `false`, the relationship will not be usable in sorts.`sort``any`A sort statement to be applied when loading the relationship.`default_sort``any`A default sort statement to be applied when loading the relationship.`could_be_related_at_creation?``boolean``false`Whether or not related values may exist for this relationship at creation.`violation_message``String.t`A message to show if there is a conflict with this relationship in the database on destroy.`authorize_read_with``:error | :filter`If set to `:error`, any authorization filter added to the relationship will result in an error if any record matches the filter in the database.`allow_forbidden_field?``boolean``false`If set to `true`, the relationship will be set to `%Ash.ForbiddenField{}` if its query produces a forbidden error.
### relationships.has\_many.filter

    filter         filter

Applies a filter. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.

### Examples

    filter         expr    (    first_name         ==         "fred"    )        filter         expr    (    last_name         ==         "weasley"         and         magician         ==         true    )    

### Arguments
NameTypeDefaultDocs`filter``any`The filter to apply. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.
### Introspection

Target: `Ash.Resource.Dsl.Filter`

### Introspection

Target: `Ash.Resource.Relationships.HasMany`

### relationships.many\_to\_many

    many_to_many         name    ,         destination

Declares a `many_to_many` relationship. Many to many relationships require a join resource.

A join resource is a resource that consists of a relationship to the source and destination of the many to many.

See the relationships guide for more.

### Nested DSLs

+ filter

### Examples

    # In a resource called `Word`        many_to_many         :books    ,         Book         do    
          through         BookWord    
          source_attribute         :text    
          source_attribute_on_join_resource         :word_text    
          destination_attribute         :id    
          destination_attribute_on_join_resource         :book_id        end    
        # And in `BookWord` (the join resource)        belongs_to         :book    ,         Book    ,         primary_key?    :         true    ,         allow_nil?    :         false        belongs_to         :word    ,         Word    ,         primary_key?    :         true    ,         allow_nil?    :         false    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the relationship`destination``module`The destination resource
### Options
NameTypeDefaultDocs`source_attribute_on_join_resource``atom`The attribute on the join resource that should line up with `source_attribute` on this resource. Defaults to `<snake_cased_last_part_of_source_module_name>_id`.`destination_attribute_on_join_resource``atom`The attribute on the join resource that should line up with `destination_attribute` on the related resource. Defaults to `<snake_cased_last_part_of_destination_module_name>_id`.`through``module`The resource to use as the join resource.`join_relationship``atom`The has\_many relationship to the join resource. Defaults to `<relationship_name>_join_assoc`.`description``String.t`An optional description for the relationship`destination_attribute``atom``:id`The attribute on the related resource that should match the `source_attribute` configured on this resource.`validate_destination_attribute?``boolean``true`Whether or not to validate that the destination field exists on the destination resource`source_attribute``atom``:id`The field on this resource that should match the `destination_attribute` on the related resource.`relationship_context``any`Context to be set on any queries or changesets generated for managing or querying this relationship.`public?``boolean``false`Whether or not the relationship will appear in public interfaces`not_found_message``String.t`A message to show if there is a conflict with this relationship in the database on update or create, or when managing relationships.`writable?``boolean``true`Whether or not the relationship may be managed.`read_action``atom`The read action on the destination resource to use when loading data and filtering.`domain``atom`The domain module to use when working with the related entity.`filterable?``boolean``true`If set to `false`, the relationship will not be usable in filters.`sortable?``boolean``true`If set to `false`, the relationship will not be usable in sorts.`sort``any`A sort statement to be applied when loading the relationship.`default_sort``any`A default sort statement to be applied when loading the relationship.`could_be_related_at_creation?``boolean``false`Whether or not related values may exist for this relationship at creation.`violation_message``String.t`A message to show if there is a conflict with this relationship in the database on destroy.`authorize_read_with``:error | :filter`If set to `:error`, any authorization filter added to the relationship will result in an error if any record matches the filter in the database.`allow_forbidden_field?``boolean``false`If set to `true`, the relationship will be set to `%Ash.ForbiddenField{}` if its query produces a forbidden error.
### relationships.many\_to\_many.filter

    filter         filter

Applies a filter. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.

### Examples

    filter         expr    (    first_name         ==         "fred"    )        filter         expr    (    last_name         ==         "weasley"         and         magician         ==         true    )    

### Arguments
NameTypeDefaultDocs`filter``any`The filter to apply. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.
### Introspection

Target: `Ash.Resource.Dsl.Filter`

### Introspection

Target: `Ash.Resource.Relationships.ManyToMany`

### relationships.belongs\_to

    belongs_to         name    ,         destination

Declares a `belongs_to` relationship. In a relational database, the foreign key would be on the *source* table.

This creates a field on the resource with the corresponding name and type, unless `define_attribute?: false` is provided.

See the relationships guide for more.

### Nested DSLs

+ filter

### Examples

    # In a resource called `Word`        belongs_to         :dictionary_entry    ,         DictionaryEntry         do    
          source_attribute         :text    ,    
          destination_attribute         :word_text        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the relationship`destination``module`The destination resource
### Options
NameTypeDefaultDocs`primary_key?``boolean``false`Whether the generated attribute is, or is part of, the primary key of a resource.`allow_nil?``boolean``true`Whether this relationship must always be present, e.g: must be included on creation, and never removed \(it may be modified\). The generated attribute will not allow nil values.`attribute_writable?``boolean`Whether the generated attribute will be marked as writable. If not set, it will default to the relationship's `writable?` setting.`attribute_public?``boolean`Whether or not the generated attribute will be public. If not set, it will default to the relationship's `public?` setting.`define_attribute?``boolean``true`If set to `false` an attribute is not created on the resource for this relationship, and one must be manually added in `attributes`, invalidating many other options.`attribute_type``any``:uuid`The type of the generated created attribute. See `Ash.Type` for more.`description``String.t`An optional description for the relationship`destination_attribute``atom``:id`The attribute on the related resource that should match the `source_attribute` configured on this resource.`validate_destination_attribute?``boolean``true`Whether or not to validate that the destination field exists on the destination resource`source_attribute``atom`The field on this resource that should match the `destination_attribute` on the related resource. - Defaults to <name>\_id`relationship_context``any`Context to be set on any queries or changesets generated for managing or querying this relationship.`public?``boolean``false`Whether or not the relationship will appear in public interfaces`not_found_message``String.t`A message to show if there is a conflict with this relationship in the database on update or create, or when managing relationships.`writable?``boolean``true`Whether or not the relationship may be managed.`read_action``atom`The read action on the destination resource to use when loading data and filtering.`domain``atom`The domain module to use when working with the related entity.`filterable?``boolean``true`If set to `false`, the relationship will not be usable in filters.`sortable?``boolean``true`If set to `false`, the relationship will not be usable in sorts.`sort``any`A sort statement to be applied when loading the relationship.`default_sort``any`A default sort statement to be applied when loading the relationship.`violation_message``String.t`A message to show if there is a conflict with this relationship in the database on destroy.`authorize_read_with``:error | :filter`If set to `:error`, any authorization filter added to the relationship will result in an error if any record matches the filter in the database.`allow_forbidden_field?``boolean``false`If set to `true`, the relationship will be set to `%Ash.ForbiddenField{}` if its query produces a forbidden error.
### relationships.belongs\_to.filter

    filter         filter

Applies a filter. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.

### Examples

    filter         expr    (    first_name         ==         "fred"    )        filter         expr    (    last_name         ==         "weasley"         and         magician         ==         true    )    

### Arguments
NameTypeDefaultDocs`filter``any`The filter to apply. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.
### Introspection

Target: `Ash.Resource.Dsl.Filter`

### Introspection

Target: `Ash.Resource.Relationships.BelongsTo`

## actions

A section for declaring resource actions.

All manipulation of data through the underlying data layer happens through actions. There are four types of action: `create`, `read`, `update`, and `destroy`. You may recognize these from the acronym `CRUD`. You can have multiple actions of the same type, as long as they have different names. This is the primary mechanism for customizing your resources to conform to your business logic. It is normal and expected to have multiple actions of each type in a large application.

### Nested DSLs

+ action
	+ argument
	+ prepare
	+ validate

+ create
	+ change
	+ validate
	+ argument
	+ metadata

+ read
	+ argument
	+ prepare
	+ validate
	+ pagination
	+ metadata
	+ filter

+ update
	+ change
	+ validate
	+ metadata
	+ argument

+ destroy
	+ change
	+ validate
	+ metadata
	+ argument


### Examples

    actions         do    
          create         :signup         do    
            argument         :password    ,         :string    
            argument         :password_confirmation    ,         :string    
            validate         confirm    (    :password    ,         :password_confirmation    )    
            change         {    MyApp.HashPassword    ,         [    ]    }         # A custom implemented Change    
          end    

          read         :me         do    
            # An action that auto filters to only return the user for the current user    
            filter         [    id    :         actor    (    :id    )    ]    
          end    

          update         :update         do    
            accept         [    :first_name    ,         :last_name    ]    
          end    

          destroy         do    
            change         set_attribute    (    :deleted_at    ,         &    DateTime    .    utc_now    /    0    )    
            # This tells it that even though this is a delete action, it    
            # should be treated like an update because `deleted_at` is set.    
            # This should be coupled with a `base_filter` on the resource    
            # or with the read actions having a `filter` for `is_nil: :deleted_at`    
            soft?         true    
          end        end    

### Options
NameTypeDefaultDocs`defaults``list(:create | :read | :update | :destroy | {atom, atom | list(atom)})`Creates a simple action of each specified type, with the same name as the type. These will be `primary?` unless one already exists for that type. Embedded resources, however, have a default of all resource types.`default_accept``list(atom) | :*`A default value for the `accept` option for each action. Use `:*` to accept all public attributes.
### actions.action

    action         name    ,         returns         \\         nil

Declares a generic action. A combination of arguments, a return type and a run function.

For calling this action, see the `Ash.Domain` documentation.

### Nested DSLs

+ argument
+ prepare
+ validate

### Examples

    action         :top_user_emails    ,         {    :array    ,         :string    }         do    
          argument         :limit    ,         :integer    ,         default    :         10    ,         allow_nil?    :         false    
          run         fn         input    ,         context         ->    
            with         {    :ok    ,         top_users    }         <-         top_users    (    input    .    arguments    .    limit    )         do    
              {    :ok    ,         Enum    .    map    (    top_users    ,         &    (    &1    .    email    )    )    }    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the action`returns``module`The return type of the action. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`constraints``keyword`Constraints for the return type. See `Ash.Type` for more.`allow_nil?``boolean``false`Whether or not the action can return nil. Unlike attributes & arguments, this defaults to `false`.`run``(any, any -> any) | module | module`Module may be an `Ash.Resource.Actions.Implementation` or `Reactor`.`primary?``boolean``false`Whether or not this action should be used when no action is specified by the caller.`description``String.t`An optional description for the action`transaction?``boolean`Whether or not the action should be run in transactions. Reads default to false, while create/update/destroy actions default to `true`.`touches_resources``list(atom)`A list of resources that the action may touch, used when building transactions.`skip_unknown_inputs``atom | String.t | list(atom | String.t)``[]`A list of unknown fields to skip, or `:*` to skip all unknown fields.
### actions.action.argument

    argument         name    ,         type

Declares an argument on the action

### Examples

    argument         :password_confirmation    ,         :string

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`public?``boolean``true`Whether or not the argument should appear in public interfaces`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Argument`

### actions.action.prepare

    prepare         preparation

Declares a preparation, which can be used to prepare a query for a read action.

### Examples

    prepare         build    (    sort    :         [    :foo    ,         :bar    ]    )    

### Arguments
NameTypeDefaultDocs`preparation``(any, any -> any) | module`The module and options for a preparation. Also accepts functions take the query and the context.
### Options
NameTypeDefaultDocs`on``:read | :action | list(:read | :action)``[:read]`The action types the preparation should run on. By default, preparations only run on read actions. Use `:action` to run on generic actions.`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this preparation to apply. Any of these validations failing will result in this preparation being ignored.`only_when_valid?``boolean``false`If the preparation should only run on valid queries.
### Introspection

Target: `Ash.Resource.Preparation`

### actions.action.validate

    validate         validation

Declares a validation for creates and updates.

See `Ash.Resource.Validation.Builtins` or `Ash.Resource.Validation` for more.

### Examples

    validate         {    Mod    ,         [    foo    :         :bar    ]    }

    validate         present    (    [    :first_name    ,         :last_name    ]    ,         at_least    :         1    )

### Arguments
NameTypeDefaultDocs`validation``(any, any -> any) | module`The module \(or module and opts\) that implements the `Ash.Resource.Validation` behaviour. Also accepts a function that receives the changeset and its context.
### Options
NameTypeDefaultDocs`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this validation to apply. Any of these validations failing will result in this validation being ignored.`only_when_valid?``boolean``false`If the validation should only run on valid changesets. Useful for expensive validations or validations that depend on valid data.`message``String.t`If provided, overrides any message set by the validation error`description``String.t`An optional description for the validation`before_action?``boolean``false`If set to `true`, the validation will be run in a before\_action hook
### Introspection

Target: `Ash.Resource.Validation`

### Introspection

Target: `Ash.Resource.Actions.Action`

### actions.create

    create         name

Declares a `create` action. For calling this action, see the `Ash.Domain` documentation.

### Nested DSLs

+ change
+ validate
+ argument
+ metadata

### Examples

    create         :register         do    
          primary?         true        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the action
### Options
NameTypeDefaultDocs`manual``(any, any -> any) | module`Override the creation behavior. Accepts a module or module and opts, or a function that takes the changeset and context. See the manual actions guide for more.`upsert?``boolean``false`Forces all uses of this action to be treated as an upsert.`upsert_identity``atom`The identity to use for the upsert. Cannot be overridden by the caller. Ignored if `upsert?` is not set to `true`.`upsert_fields``:replace_all | {:replace, atom | list(atom)} | {:replace_all_except, atom | list(atom)} | atom | list(atom)`The fields to overwrite in the case of an upsert. If not provided, all fields except for fields set by defaults will be overwritten.`upsert_condition``any`An expression to check if the record should be updated when there's a conflict.`return_skipped_upsert?``boolean`Returns the record that would have been upserted against but was skipped due to a filter or no fields being changed. How this works depends on the data layer. Keep in mind that read policies *are not applied* to the read of the record in question.`primary?``boolean``false`Whether or not this action should be used when no action is specified by the caller.`description``String.t`An optional description for the action`transaction?``boolean`Whether or not the action should be run in transactions. Reads default to false, while create/update/destroy actions default to `true`.`touches_resources``list(atom)`A list of resources that the action may touch, used when building transactions.`skip_unknown_inputs``atom | String.t | list(atom | String.t)``[]`A list of unknown fields to skip, or `:*` to skip all unknown fields.`accept``atom | list(atom) | :*`The list of attributes to accept. Use `:*` to accept all public attributes.`action_select``list(atom)`A list of attributes that the action requires to do its work. Defaults to all attributes except those with `select_by_default? false`. On actions with no changes/notifiers, it defaults to the externally selected attributes. Keep in mind that action\_select is applied *before* notifiers.`require_attributes``list(atom)`A list of attributes that would normally `allow_nil?`, to require for this action. No need to include attributes that already do not allow nil?`allow_nil_input``list(atom)`A list of attributes that would normally be required, but should not be for this action. They will still be validated just before the data layer step.`delay_global_validations?``boolean``false`If true, global validations will be done in a `before_action` hook, regardless of their configuration on the resource.`skip_global_validations?``boolean``false`If true, global validations will be skipped. Useful for manual actions.`error_handler``mfa | (any, any -> any)`Sets the error handler on the changeset. See `Ash.Changeset.handle_errors/2` for more`notifiers``list(module)`Notifiers that will be called specifically for this action.`manual?``boolean`Instructs Ash to *skip* the actual update/create/destroy step at the data layer. See the manual actions guide for more.
### actions.create.change

    change         change

A change to be applied to the changeset.

See `Ash.Resource.Change` for more.

### Examples

    change         relate_actor    (    :reporter    )

    change         {    MyCustomChange    ,         :foo    }

### Arguments
NameTypeDefaultDocs`change``(any, any -> any) | module`The module and options for a change. Also accepts a function that takes the changeset and the context. See `Ash.Resource.Change.Builtins` for builtin changes.
### Options
NameTypeDefaultDocs`only_when_valid?``boolean``false`If the change should only be run on valid changes. By default, all changes are run unless stated otherwise here.`description``String.t`An optional description for the change`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this change to apply. These validations failing will result in this change being ignored.`always_atomic?``boolean``false`By default, changes are only run atomically if all changes will be run atomically or if there is no `change/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Change`

### actions.create.validate

    validate         validation

Declares a validation to be applied to the changeset.

See `Ash.Resource.Validation.Builtins` or `Ash.Resource.Validation` for more.

### Examples

    validate         changing    (    :email    )

### Arguments
NameTypeDefaultDocs`validation``(any, any -> any) | module`The module \(or module and opts\) that implements the `Ash.Resource.Validation` behaviour. Also accepts a function that receives the changeset and its context.
### Options
NameTypeDefaultDocs`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this validation to apply. Any of these validations failing will result in this validation being ignored.`only_when_valid?``boolean``false`If the validation should only run on valid changesets. Useful for expensive validations or validations that depend on valid data.`message``String.t`If provided, overrides any message set by the validation error`description``String.t`An optional description for the validation`before_action?``boolean``false`If set to `true`, the validation will be run in a before\_action hook`always_atomic?``boolean``false`By default, validations are only run atomically if all changes will be run atomically or if there is no `validate/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Validation`

### actions.create.argument

    argument         name    ,         type

Declares an argument on the action

### Examples

    argument         :password_confirmation    ,         :string

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`public?``boolean``true`Whether or not the argument should appear in public interfaces`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Argument`

### actions.create.metadata

    metadata         name    ,         type

A special kind of attribute that is only added to specific actions. Nothing sets this value, it must be set in a custom change after\_action hook via `Ash.Resource.put_metadata/3`.

### Examples

    metadata         :api_token    ,         :string    ,         allow_nil?    :         false    

    metadata         :operation_id    ,         :string    ,         allow_nil?    :         false    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the metadata`type``any`The type of the metadata. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`constraints``keyword``[]`Type constraints on the metadata`description``String.t`An optional description for the metadata.`allow_nil?``boolean``true`Whether or not the metadata may return `nil``default``any`The default value for the metadata to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Metadata`

### Introspection

Target: `Ash.Resource.Actions.Create`

### actions.read

    read         name

Declares a `read` action. For calling this action, see the `Ash.Domain` documentation.

### Nested DSLs

+ argument
+ prepare
+ validate
+ pagination
+ metadata
+ filter

### Examples

    read         :read_all         do    
          primary?         true        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the action
### Options
NameTypeDefaultDocs`manual``(any, any, any -> any) | module`Delegates running of the query to the provided module. Accepts a module or module and opts, or a function that takes the ash query, the data layer query, and context. See the manual actions guide for more.`get?``boolean``false`Expresses that this action innately only returns a single result. Used by extensions to validate and/or modify behavior. Causes code interfaces to return a single value instead of a list. See the code interface guide for more.`modify_query``mfa | (any, any -> any)`Allows direct manipulation of the data layer query via an MFA. The ash query and the data layer query will be provided as additional arguments. The result must be `{:ok, new_data_layer_query} | {:error, error}`.`get_by``atom | list(atom)`A helper to automatically generate a "get by X" action. Sets `get?` to true, add args for each of the specified fields, and adds a filter for each of the arguments.`timeout``pos_integer`The maximum amount of time, in milliseconds, that the action is allowed to run for. Ignored if the data layer doesn't support transactions *and* async is disabled.`multitenancy``:enforce | :allow_global | :bypass | :bypass_all``:enforce`This setting defines how this action handles multitenancy. `:enforce` requires a tenant to be set \(the default behavior\), `:allow_global` allows using this action both with and without a tenant, `:bypass` completely ignores the tenant even if it's set, `:bypass_all` like `:bypass` but also bypasses the tenancy requirement for the nested resources. This is useful to change the behaviour of selected read action without the need of marking the whole resource with `global? true`.`skip_global_validations?``boolean``false`If true, global validations will be skipped. Useful for manual actions.`primary?``boolean``false`Whether or not this action should be used when no action is specified by the caller.`description``String.t`An optional description for the action`transaction?``boolean`Whether or not the action should be run in transactions. Reads default to false, while create/update/destroy actions default to `true`.`touches_resources``list(atom)`A list of resources that the action may touch, used when building transactions.`skip_unknown_inputs``atom | String.t | list(atom | String.t)``[]`A list of unknown fields to skip, or `:*` to skip all unknown fields.
### actions.read.argument

    argument         name    ,         type

Declares an argument on the action

### Examples

    argument         :password_confirmation    ,         :string

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`public?``boolean``true`Whether or not the argument should appear in public interfaces`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Argument`

### actions.read.prepare

    prepare         preparation

Declares a preparation, which can be used to prepare a query for a read action.

### Examples

    prepare         build    (    sort    :         [    :foo    ,         :bar    ]    )    

### Arguments
NameTypeDefaultDocs`preparation``(any, any -> any) | module`The module and options for a preparation. Also accepts functions take the query and the context.
### Options
NameTypeDefaultDocs`on``:read | :action | list(:read | :action)``[:read]`The action types the preparation should run on. By default, preparations only run on read actions. Use `:action` to run on generic actions.`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this preparation to apply. Any of these validations failing will result in this preparation being ignored.`only_when_valid?``boolean``false`If the preparation should only run on valid queries.
### Introspection

Target: `Ash.Resource.Preparation`

### actions.read.validate

    validate         validation

Declares a validation for creates and updates.

See `Ash.Resource.Validation.Builtins` or `Ash.Resource.Validation` for more.

### Examples

    validate         {    Mod    ,         [    foo    :         :bar    ]    }

    validate         present    (    [    :first_name    ,         :last_name    ]    ,         at_least    :         1    )

### Arguments
NameTypeDefaultDocs`validation``(any, any -> any) | module`The module \(or module and opts\) that implements the `Ash.Resource.Validation` behaviour. Also accepts a function that receives the changeset and its context.
### Options
NameTypeDefaultDocs`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this validation to apply. Any of these validations failing will result in this validation being ignored.`only_when_valid?``boolean``false`If the validation should only run on valid changesets. Useful for expensive validations or validations that depend on valid data.`message``String.t`If provided, overrides any message set by the validation error`description``String.t`An optional description for the validation`before_action?``boolean``false`If set to `true`, the validation will be run in a before\_action hook
### Introspection

Target: `Ash.Resource.Validation`

### actions.read.pagination

Adds pagination options to a resource

### Options
NameTypeDefaultDocs`keyset?``boolean``false`Whether or not keyset based pagination is supported`offset?``boolean``false`Whether or not offset based pagination is supported`default_limit``pos_integer`The default page size to apply, if one is not supplied`countable``true | false | :by_default``true`Whether not a returned page will have a full count of all records. Use `:by_default` to do it automatically.`max_page_size``pos_integer``250`The maximum amount of records that can be requested in a single page`stable_sort``any`A stable sort statement to add to a query \(after any existing sorts\). Only added if the sort does not already contain a stable sort \(sorting on fields that uniquely identify a record\). Defaults to the primary key.`required?``boolean``true`Whether or not pagination can be disabled \(by passing `page: false` to `Ash.Api.read!/2`, or by having `required?: false, default_limit: nil` set\). Only relevant if some pagination configuration is supplied.
### Introspection

Target: `Ash.Resource.Actions.Read.Pagination`

### actions.read.metadata

    metadata         name    ,         type

A special kind of attribute that is only added to specific actions. Nothing sets this value, it must be set in a custom change after\_action hook via `Ash.Resource.put_metadata/3`.

### Examples

    metadata         :api_token    ,         :string    ,         allow_nil?    :         false    

    metadata         :operation_id    ,         :string    ,         allow_nil?    :         false    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the metadata`type``any`The type of the metadata. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`constraints``keyword``[]`Type constraints on the metadata`description``String.t`An optional description for the metadata.`allow_nil?``boolean``true`Whether or not the metadata may return `nil``default``any`The default value for the metadata to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Metadata`

### actions.read.filter

    filter         filter

Applies a filter. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.

### Examples

    filter         expr    (    first_name         ==         "fred"    )        filter         expr    (    last_name         ==         "weasley"         and         magician         ==         true    )    

### Arguments
NameTypeDefaultDocs`filter``any`The filter to apply. Can use `^arg/1`, `^context/1` and `^actor/1` templates. Multiple filters are combined with *and*.
### Introspection

Target: `Ash.Resource.Dsl.Filter`

### Introspection

Target: `Ash.Resource.Actions.Read`

### actions.update

    update         name

Declares a `update` action. For calling this action, see the `Ash.Domain` documentation.

### Nested DSLs

+ change
+ validate
+ metadata
+ argument

### Examples

    update         :flag_for_review    ,         primary?    :         true

### Arguments
NameTypeDefaultDocs`name``atom`The name of the action
### Options
NameTypeDefaultDocs`manual``(any, any -> any) | module`Override the update behavior. Accepts a module or module and opts, or a function that takes the changeset and context. See the manual actions guide for more.`require_atomic?``boolean``true`Require that the update be atomic. This means that all changes and validations implement the `atomic` callback. See the guide on atomic updates for more.`atomic_upgrade?``boolean``false`If set to `true`, atomic upgrades will be performed. Ignored if `required_atomic?` is `true`. See the update actions guide for more.`atomic_upgrade_with``atom | nil`Configure the read action used when performing atomic upgrades. Defaults to the primary read action.`primary?``boolean``false`Whether or not this action should be used when no action is specified by the caller.`description``String.t`An optional description for the action`transaction?``boolean`Whether or not the action should be run in transactions. Reads default to false, while create/update/destroy actions default to `true`.`touches_resources``list(atom)`A list of resources that the action may touch, used when building transactions.`skip_unknown_inputs``atom | String.t | list(atom | String.t)``[]`A list of unknown fields to skip, or `:*` to skip all unknown fields.`accept``atom | list(atom) | :*`The list of attributes to accept. Use `:*` to accept all public attributes.`action_select``list(atom)`A list of attributes that the action requires to do its work. Defaults to all attributes except those with `select_by_default? false`. On actions with no changes/notifiers, it defaults to the externally selected attributes. Keep in mind that action\_select is applied *before* notifiers.`require_attributes``list(atom)`A list of attributes that would normally `allow_nil?`, to require for this action. No need to include attributes that already do not allow nil?`allow_nil_input``list(atom)`A list of attributes that would normally be required, but should not be for this action. They will still be validated just before the data layer step.`delay_global_validations?``boolean``false`If true, global validations will be done in a `before_action` hook, regardless of their configuration on the resource.`skip_global_validations?``boolean``false`If true, global validations will be skipped. Useful for manual actions.`error_handler``mfa | (any, any -> any)`Sets the error handler on the changeset. See `Ash.Changeset.handle_errors/2` for more`notifiers``list(module)`Notifiers that will be called specifically for this action.`manual?``boolean`Instructs Ash to *skip* the actual update/create/destroy step at the data layer. See the manual actions guide for more.
### actions.update.change

    change         change

A change to be applied to the changeset.

See `Ash.Resource.Change` for more.

### Examples

    change         relate_actor    (    :reporter    )

    change         {    MyCustomChange    ,         :foo    }

### Arguments
NameTypeDefaultDocs`change``(any, any -> any) | module`The module and options for a change. Also accepts a function that takes the changeset and the context. See `Ash.Resource.Change.Builtins` for builtin changes.
### Options
NameTypeDefaultDocs`only_when_valid?``boolean``false`If the change should only be run on valid changes. By default, all changes are run unless stated otherwise here.`description``String.t`An optional description for the change`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this change to apply. These validations failing will result in this change being ignored.`always_atomic?``boolean``false`By default, changes are only run atomically if all changes will be run atomically or if there is no `change/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Change`

### actions.update.validate

    validate         validation

Declares a validation to be applied to the changeset.

See `Ash.Resource.Validation.Builtins` or `Ash.Resource.Validation` for more.

### Examples

    validate         changing    (    :email    )

### Arguments
NameTypeDefaultDocs`validation``(any, any -> any) | module`The module \(or module and opts\) that implements the `Ash.Resource.Validation` behaviour. Also accepts a function that receives the changeset and its context.
### Options
NameTypeDefaultDocs`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this validation to apply. Any of these validations failing will result in this validation being ignored.`only_when_valid?``boolean``false`If the validation should only run on valid changesets. Useful for expensive validations or validations that depend on valid data.`message``String.t`If provided, overrides any message set by the validation error`description``String.t`An optional description for the validation`before_action?``boolean``false`If set to `true`, the validation will be run in a before\_action hook`always_atomic?``boolean``false`By default, validations are only run atomically if all changes will be run atomically or if there is no `validate/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Validation`

### actions.update.metadata

    metadata         name    ,         type

A special kind of attribute that is only added to specific actions. Nothing sets this value, it must be set in a custom change after\_action hook via `Ash.Resource.put_metadata/3`.

### Examples

    metadata         :api_token    ,         :string    ,         allow_nil?    :         false    

    metadata         :operation_id    ,         :string    ,         allow_nil?    :         false    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the metadata`type``any`The type of the metadata. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`constraints``keyword``[]`Type constraints on the metadata`description``String.t`An optional description for the metadata.`allow_nil?``boolean``true`Whether or not the metadata may return `nil``default``any`The default value for the metadata to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Metadata`

### actions.update.argument

    argument         name    ,         type

Declares an argument on the action

### Examples

    argument         :password_confirmation    ,         :string

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`public?``boolean``true`Whether or not the argument should appear in public interfaces`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Argument`

### Introspection

Target: `Ash.Resource.Actions.Update`

### actions.destroy

    destroy         name

Declares a `destroy` action. For calling this action, see the `Ash.Domain` documentation.

See `Ash.Resource.Change.Builtins.cascade_destroy/2` for cascading destroy operations.

### Nested DSLs

+ change
+ validate
+ metadata
+ argument

### Examples

    destroy         :destroy         do    
          primary?         true        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the action
### Options
NameTypeDefaultDocs`soft?``boolean``false`If specified, the destroy action behaves as an update internally`manual``(any, any -> any) | module`Override the update behavior. Accepts a module or module and opts, or a function that takes the changeset and context. See the manual actions guide for more.`require_atomic?``boolean``true`Require that the update be atomic. Only relevant if `soft?` is set to `true`. This means that all changes and validations implement the `atomic` callback. See the guide on atomic updates for more.`atomic_upgrade?``boolean``false`If set to `true`, atomic upgrades will be performed. See the update actions guide for more.`atomic_upgrade_with``atom | nil`Configure the read action used when performing atomic upgrades. Defaults to the primary read action.`primary?``boolean``false`Whether or not this action should be used when no action is specified by the caller.`description``String.t`An optional description for the action`transaction?``boolean`Whether or not the action should be run in transactions. Reads default to false, while create/update/destroy actions default to `true`.`touches_resources``list(atom)`A list of resources that the action may touch, used when building transactions.`skip_unknown_inputs``atom | String.t | list(atom | String.t)``[]`A list of unknown fields to skip, or `:*` to skip all unknown fields.`accept``atom | list(atom) | :*`The list of attributes to accept. Use `:*` to accept all public attributes.`action_select``list(atom)`A list of attributes that the action requires to do its work. Defaults to all attributes except those with `select_by_default? false`. On actions with no changes/notifiers, it defaults to the externally selected attributes. Keep in mind that action\_select is applied *before* notifiers.`require_attributes``list(atom)`A list of attributes that would normally `allow_nil?`, to require for this action. No need to include attributes that already do not allow nil?`allow_nil_input``list(atom)`A list of attributes that would normally be required, but should not be for this action. They will still be validated just before the data layer step.`delay_global_validations?``boolean``false`If true, global validations will be done in a `before_action` hook, regardless of their configuration on the resource.`skip_global_validations?``boolean``false`If true, global validations will be skipped. Useful for manual actions.`error_handler``mfa | (any, any -> any)`Sets the error handler on the changeset. See `Ash.Changeset.handle_errors/2` for more`notifiers``list(module)`Notifiers that will be called specifically for this action.`manual?``boolean`Instructs Ash to *skip* the actual update/create/destroy step at the data layer. See the manual actions guide for more.
### actions.destroy.change

    change         change

A change to be applied to the changeset.

See `Ash.Resource.Change` for more.

### Examples

    change         relate_actor    (    :reporter    )

    change         {    MyCustomChange    ,         :foo    }

### Arguments
NameTypeDefaultDocs`change``(any, any -> any) | module`The module and options for a change. Also accepts a function that takes the changeset and the context. See `Ash.Resource.Change.Builtins` for builtin changes.
### Options
NameTypeDefaultDocs`only_when_valid?``boolean``false`If the change should only be run on valid changes. By default, all changes are run unless stated otherwise here.`description``String.t`An optional description for the change`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this change to apply. These validations failing will result in this change being ignored.`always_atomic?``boolean``false`By default, changes are only run atomically if all changes will be run atomically or if there is no `change/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Change`

### actions.destroy.validate

    validate         validation

Declares a validation to be applied to the changeset.

See `Ash.Resource.Validation.Builtins` or `Ash.Resource.Validation` for more.

### Examples

    validate         changing    (    :email    )

### Arguments
NameTypeDefaultDocs`validation``(any, any -> any) | module`The module \(or module and opts\) that implements the `Ash.Resource.Validation` behaviour. Also accepts a function that receives the changeset and its context.
### Options
NameTypeDefaultDocs`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this validation to apply. Any of these validations failing will result in this validation being ignored.`only_when_valid?``boolean``false`If the validation should only run on valid changesets. Useful for expensive validations or validations that depend on valid data.`message``String.t`If provided, overrides any message set by the validation error`description``String.t`An optional description for the validation`before_action?``boolean``false`If set to `true`, the validation will be run in a before\_action hook`always_atomic?``boolean``false`By default, validations are only run atomically if all changes will be run atomically or if there is no `validate/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Validation`

### actions.destroy.metadata

    metadata         name    ,         type

A special kind of attribute that is only added to specific actions. Nothing sets this value, it must be set in a custom change after\_action hook via `Ash.Resource.put_metadata/3`.

### Examples

    metadata         :api_token    ,         :string    ,         allow_nil?    :         false    

    metadata         :operation_id    ,         :string    ,         allow_nil?    :         false    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the metadata`type``any`The type of the metadata. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`constraints``keyword``[]`Type constraints on the metadata`description``String.t`An optional description for the metadata.`allow_nil?``boolean``true`Whether or not the metadata may return `nil``default``any`The default value for the metadata to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Metadata`

### actions.destroy.argument

    argument         name    ,         type

Declares an argument on the action

### Examples

    argument         :password_confirmation    ,         :string

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`public?``boolean``true`Whether or not the argument should appear in public interfaces`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### Introspection

Target: `Ash.Resource.Actions.Argument`

### Introspection

Target: `Ash.Resource.Actions.Destroy`

## code\_interface

Functions that will be defined on the resource. See the code interface guide for more.

### Nested DSLs

+ define
	+ custom\_input
		+ transform


+ define\_calculation
	+ custom\_input
		+ transform



### Examples

    code_interface         do    
          define         :create_user    ,         action    :         :create    
          define         :get_user_by_id    ,         action    :         :get_by_id    ,         args    :         [    :id    ]    ,         get?    :         true        end    

### Options
NameTypeDefaultDocs`domain``module``false`Use the provided Domain instead of the resources configured domain when calling actions.`define?``boolean`Whether or not to define the code interface in the resource.
### code\_interface.define

    define         name

Defines a function with the corresponding name and arguments. See the code interface guide for more.

### Nested DSLs

+ custom\_input
	+ transform


### Examples

    define         :get_user_by_id    ,         action    :         :get_by_id    ,         args    :         [    :id    ]    ,         get?    :         true

### Arguments
NameTypeDefaultDocs`name``atom`The name of the function that will be defined
### Options
NameTypeDefaultDocs`action``atom`The name of the action that will be called. Defaults to the same name as the function.`args``list(atom | {:optional, atom})`Map specific arguments to named inputs. Can provide any argument/attributes that the action allows.`not_found_error?``boolean``true`If the action or interface is configured with `get?: true`, this determines whether or not an error is raised or `nil` is returned.`require_reference?``boolean``true`For update and destroy actions, require a resource or identifier to be passed in as the first argument. Not relevant for other action types.`exclude_inputs``list(atom)``[]`A list of action inputs to not accept in the defined interface`get?``boolean``false`Expects to only receive a single result from a read action or a bulk update/destroy, and returns a single result instead of a list. Sets `require_reference?` to false automatically.`get_by``atom | list(atom)`Takes a list of fields and adds those fields as arguments, which will then be used to filter. Sets `get?` to true and `require_reference?` to false automatically. Adds filters for read, update and destroy actions, replacing the `record` first argument.`get_by_identity``atom`Takes an identity, gets its field list, and performs the same logic as `get_by` with those fields. Adds filters for read, update and destroy actions, replacing the `record` first argument.`default_options``keyword | (-> any)``[]`Default options to be merged with client-provided options. These can override domain or action defaults. `:load`, `:bulk_options`, and `:page` options will be deep merged. Can be a keyword list or a zero-arity function that returns a keyword list.
### code\_interface.define.custom\_input

    custom_input         name    ,         type

Define or customize an input to the action.

See the code interface guide for more.

### Nested DSLs

+ transform

### Examples

    custom_input         :artist    ,         :struct         do    
          transform         to    :         :artist_id    ,         using    :         &    (    &1    .    id    )    

          constraints         instance_of    :         Artist        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### code\_interface.define.custom\_input.transform

A transformation to be applied to the custom input.

### Examples

    transform         do    
          to         :artist_id    
          using         &    (    &1    .    id    )        end    

    transform         do    
          to         :points    
          using         &    try_parse_integer    /    1        end    

### Options
NameTypeDefaultDocs`to``atom`A key to rewrite the argument to. If the custom input is also a required positional argument, then the `to` is automatically added to the `exclude_inputs` list.`using``(any -> any)`A function to use to transform the value. Must return `value` or `nil`
### Introspection

Target: `Ash.Resource.Interface.CustomInput.Transform`

### Introspection

Target: `Ash.Resource.Interface.CustomInput`

### Introspection

Target: `Ash.Resource.Interface`

### code\_interface.define\_calculation

    define_calculation         name

Defines a function with the corresponding name and arguments, that evaluates a calculation. Use `:_record` to take an instance of a record. See the code interface guide for more.

### Nested DSLs

+ custom\_input
	+ transform


### Examples

    define_calculation         :referral_link    ,         args    :         [    :id    ]

    define_calculation         :referral_link    ,         args    :         [    {    :arg    ,         :id    }    ,         {    :ref    ,         :id    }    ]

### Arguments
NameTypeDefaultDocs`name``atom`The name of the function that will be defined
### Options
NameTypeDefaultDocs`calculation``atom`The name of the calculation that will be evaluated. Defaults to the same name as the function.`exclude_inputs``list(atom)``[]`A list of calculation inputs to not accept in the defined interface`args``any``[]`Supply field or argument values referenced by the calculation, in the form of :name, `{:arg, :name}` and/or `{:ref, :name}`. See the code interface guide for more.
### code\_interface.define\_calculation.custom\_input

    custom_input         name    ,         type

Define or customize an input to the action.

See the code interface guide for more.

### Nested DSLs

+ transform

### Examples

    custom_input         :artist    ,         :struct         do    
          transform         to    :         :artist_id    ,         using    :         &    (    &1    .    id    )    

          constraints         instance_of    :         Artist        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### code\_interface.define\_calculation.custom\_input.transform

A transformation to be applied to the custom input.

### Examples

    transform         do    
          to         :artist_id    
          using         &    (    &1    .    id    )        end    

    transform         do    
          to         :points    
          using         &    try_parse_integer    /    1        end    

### Options
NameTypeDefaultDocs`to``atom`A key to rewrite the argument to. If the custom input is also a required positional argument, then the `to` is automatically added to the `exclude_inputs` list.`using``(any -> any)`A function to use to transform the value. Must return `value` or `nil`
### Introspection

Target: `Ash.Resource.Interface.CustomInput.Transform`

### Introspection

Target: `Ash.Resource.Interface.CustomInput`

### Introspection

Target: `Ash.Resource.CalculationInterface`

## resource

General resource configuration

### Examples

    resource         do    
          description         "A description of this resource"    
          base_filter         [    is_nil    :         :deleted_at    ]        end    

### Options
NameTypeDefaultDocs`description``String.t`A human readable description of the resource, to be used in generated documentation`base_filter``any`A filter statement to be applied to any queries on the resource`default_context``any`Default context to apply to any queries/changesets generated for this resource.`trace_name``String.t`The name to use in traces. Defaults to the short\_name stringified. See the monitoring guide for more.`short_name``atom`A short identifier for the resource, which should be unique. See the monitoring guide for more.`inspect_private_fields?``boolean``true`Whether to include private fields in the inspect output. `show_inspect_fields` takes precedence over this option.`hide_inspect_fields``list(atom)``[]`A deny-list of fields to hide from the inspect output. Takes precedence over `show_inspect_fields`.`show_inspect_fields``list(atom)`An allow-list of fields to show in the inspect output. Sensitive fields are *always* hidden.`plural_name``atom`A pluralized version of the resource short\_name. May be used by generators or automated tooling.`require_primary_key?``boolean``true`Allow the resource to be used without any primary key fields. Warning: this option is experimental, and should not be used unless you know what you're doing.
## identities

Unique identifiers for the resource

### Nested DSLs

+ identity

### Examples

    identities         do    
          identity         :full_name    ,         [    :first_name    ,         :last_name    ]    
          identity         :email    ,         [    :email    ]        end    

### identities.identity

    identity         name    ,         keys

Represents a unique constraint on the resource.

See the identities guide for more.

### Examples

    identity         :name    ,         [    :name    ]

    identity         :full_name    ,         [    :first_name    ,         :last_name    ]

### Arguments
NameTypeDefaultDocs`name``atom`The name of the identity.`keys``atom | list(atom)`The names of the attributes that uniquely identify this resource.
### Options
NameTypeDefaultDocs`where``any`A filter that expresses only matching records are unique on the provided keys. Ignored on embedded resources.`nils_distinct?``boolean``true`Whether or not `nil` values are considered always distinct from eachother. `nil` values won't conflict with eachother unless you set this option to `false`.`eager_check?``boolean``false`Whether or not this identity is validated to be unique at validation time.`eager_check_with``module`Validates that the unique identity provided is unique at validation time, outside of any transactions, using the domain module provided. Will default to resource's domain.`pre_check?``boolean``false`Whether or not this identity is validated to be unique in a before\_action hook.`pre_check_with``module`Validates that the unique identity provided is unique in a before\_action hook.`description``String.t`An optional description for the identity`field_names``atom | list(atom)`The field names to hold errors when unique identity is violated.`message``String.t`An error message to use when the unique identity would be violated`all_tenants?``boolean``false`Whether or not this identity is unique across all tenants. If the resource is not multitenant, has no effect.
### Introspection

Target: `Ash.Resource.Identity`

## changes

Declare changes that occur on create/update/destroy actions against the resource

See `Ash.Resource.Change` for more.

### Nested DSLs

+ change

### Examples

    changes         do    
          change         {    Mod    ,         [    foo    :         :bar    ]    }    
          change         set_context    (    %{    some    :         :context    }    )        end    

### changes.change

    change         change

A change to be applied to the changeset.

See `Ash.Resource.Change` for more.

### Examples

    change         relate_actor    (    :reporter    )

    change         {    MyCustomChange    ,         :foo    }

### Arguments
NameTypeDefaultDocs`change``(any, any -> any) | module`The module and options for a change. Also accepts a function that takes the changeset and the context. See `Ash.Resource.Change.Builtins` for builtin changes.
### Options
NameTypeDefaultDocs`on``:create | :update | :destroy | list(:create | :update | :destroy)``[:create, :update]`The action types the change should run on. Destroy actions are omitted by default as most changes don't make sense for a destroy.`only_when_valid?``boolean``false`If the change should only be run on valid changes. By default, all changes are run unless stated otherwise here.`description``String.t`An optional description for the change`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this change to apply. These validations failing will result in this change being ignored.`always_atomic?``boolean``false`By default, changes are only run atomically if all changes will be run atomically or if there is no `change/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Change`

## preparations

Declare preparations that occur on all read actions for a given resource

### Nested DSLs

+ prepare

### Examples

    preparations         do    
          prepare         {    Mod    ,         [    foo    :         :bar    ]    }    
          prepare         set_context    (    %{    some    :         :context    }    )        end    

### preparations.prepare

    prepare         preparation

Declares a preparation, which can be used to prepare a query for a read action.

### Examples

    prepare         build    (    sort    :         [    :foo    ,         :bar    ]    )    

### Arguments
NameTypeDefaultDocs`preparation``(any, any -> any) | module`The module and options for a preparation. Also accepts functions take the query and the context.
### Options
NameTypeDefaultDocs`on``:read | :action | list(:read | :action)``[:read]`The action types the preparation should run on. By default, preparations only run on read actions. Use `:action` to run on generic actions.`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this preparation to apply. Any of these validations failing will result in this preparation being ignored.`only_when_valid?``boolean``false`If the preparation should only run on valid queries.
### Introspection

Target: `Ash.Resource.Preparation`

## validations

Declare validations prior to performing actions against the resource

### Nested DSLs

+ validate

### Examples

    validations         do    
          validate         {    Mod    ,         [    foo    :         :bar    ]    }    
          validate         present    (    [    :first_name    ,         :last_name    ]    ,         at_least    :         1    )        end    

### validations.validate

    validate         validation

Declares a validation for creates and updates.

See `Ash.Resource.Validation.Builtins` or `Ash.Resource.Validation` for more.

### Examples

    validate         {    Mod    ,         [    foo    :         :bar    ]    }

    validate         present    (    [    :first_name    ,         :last_name    ]    ,         at_least    :         1    )

### Arguments
NameTypeDefaultDocs`validation``(any, any -> any) | module`The module \(or module and opts\) that implements the `Ash.Resource.Validation` behaviour. Also accepts a function that receives the changeset and its context.
### Options
NameTypeDefaultDocs`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this validation to apply. Any of these validations failing will result in this validation being ignored.`on``:create | :update | :destroy | :read | :action | list(:create | :update | :destroy | :read | :action)``[:create, :update]`The action types the validation should run on. Many validations don't make sense in the context of destroy, read, or generic actions, so by default they are not included.`only_when_valid?``boolean``false`If the validation should only run on valid changesets. Useful for expensive validations or validations that depend on valid data.`message``String.t`If provided, overrides any message set by the validation error`description``String.t`An optional description for the validation`before_action?``boolean``false`If set to `true`, the validation will be run in a before\_action hook`always_atomic?``boolean``false`By default, validations are only run atomically if all changes will be run atomically or if there is no `validate/3` callback defined. Set this to `true` to run it atomically always.
### Introspection

Target: `Ash.Resource.Validation`

## aggregates

Declare named aggregates on the resource.

These are aggregates that can be loaded only by name using `Ash.Query.load/2`. They are also available as top level fields on the resource.

See the aggregates guide for more.

### Nested DSLs

+ count
	+ join\_filter

+ exists
	+ join\_filter

+ first
	+ join\_filter

+ sum
	+ join\_filter

+ list
	+ join\_filter

+ max
	+ join\_filter

+ min
	+ join\_filter

+ avg
	+ join\_filter

+ custom
	+ join\_filter


### Examples

    aggregates         do    
          count         :assigned_ticket_count    ,         :reported_tickets         do    
            filter         [    active    :         true    ]    
          end        end    

### aggregates.count

    count         name    ,         relationship_path

Declares a named count aggregate on the resource

Supports `filter`, but not `sort` \(because that wouldn't affect the count\)

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    count         :assigned_ticket_count    ,         :assigned_tickets         do    
          filter         [    active    :         true    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate
### Options
NameTypeDefaultDocs`uniq?``boolean``false`Whether or not to count unique values only`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource`filter``any``[]`A filter to apply to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.count.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.exists

    exists         name    ,         relationship_path

Declares a named `exists` aggregate on the resource

Supports `filter`, but not `sort` \(because that wouldn't affect if something exists\)

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    exists         :has_ticket    ,         :assigned_tickets    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate
### Options
NameTypeDefaultDocs`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.exists.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.first

    first         name    ,         relationship_path    ,         field

Declares a named `first` aggregate on the resource

First aggregates return the first value of the related record that matches. Supports both `filter` and `sort`.

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    first         :first_assigned_ticket_subject    ,         :assigned_tickets    ,         :subject         do    
          filter         [    active    :         true    ]    
          sort         [    :subject    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource
### Options
NameTypeDefaultDocs`include_nil?``boolean``false`Whether or not to include `nil` values in the aggregate. Only relevant for `list` and `first` aggregates.`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`sort``any`A sort to be applied to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.first.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.sum

    sum         name    ,         relationship_path    ,         field

Declares a named `sum` aggregate on the resource

Supports `filter`, but not `sort` \(because that wouldn't affect the sum\)

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    sum         :assigned_ticket_price_sum    ,         :assigned_tickets    ,         :price         do    
          filter         [    active    :         true    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource
### Options
NameTypeDefaultDocs`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.sum.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.list

    list         name    ,         relationship_path    ,         field

Declares a named `list` aggregate on the resource.

A list aggregate selects the list of all values for the given field and relationship combination.

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    list         :assigned_ticket_prices    ,         :assigned_tickets    ,         :price         do    
          filter         [    active    :         true    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource
### Options
NameTypeDefaultDocs`include_nil?``boolean``false`Whether or not to include `nil` values in the aggregate. Only relevant for `list` and `first` aggregates.`uniq?``boolean``false`Whether or not to count unique values only`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`sort``any`A sort to be applied to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.list.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.max

    max         name    ,         relationship_path    ,         field

Declares a named `max` aggregate on the resource

Supports `filter`, but not `sort` \(because that wouldn't affect the max\)

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    max         :first_assigned_ticket_subject    ,         :assigned_tickets    ,         :severity         do    
          filter         [    active    :         true    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource
### Options
NameTypeDefaultDocs`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.max.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.min

    min         name    ,         relationship_path    ,         field

Declares a named `min` aggregate on the resource

Supports `filter`, but not `sort` \(because that wouldn't affect the min\)

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    min         :first_assigned_ticket_subject    ,         :assigned_tickets    ,         :severity         do    
          filter         [    active    :         true    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource
### Options
NameTypeDefaultDocs`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.min.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.avg

    avg         name    ,         relationship_path    ,         field

Declares a named `avg` aggregate on the resource

Supports `filter`, but not `sort` \(because that wouldn't affect the avg\)

See the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    avg         :assigned_ticket_price_sum    ,         :assigned_tickets    ,         :price         do    
          filter         [    active    :         true    ]        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource
### Options
NameTypeDefaultDocs`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`filter``any``[]`A filter to apply to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.avg.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

### aggregates.custom

    custom         name    ,         relationship_path    ,         type

Declares a named `custom` aggregate on the resource

Supports `filter` and `sort`.

Custom aggregates provide an `implementation` which must implement data layer specific callbacks.

See the relevant data layer documentation and the aggregates guide for more.

### Nested DSLs

+ join\_filter

### Examples

    custom         :author_names    ,         :authors    ,         :string         do    
          implementation         {    StringAgg    ,         delimiter    :         ","    }        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field to place the aggregate in`relationship_path``atom | list(atom)`The relationship or relationship path to use for the aggregate`type``module`The type of the value returned by the aggregate
### Options
NameTypeDefaultDocs`implementation``module`The module that implements the relevant data layer callbacks`read_action``atom`The read action to use when building the aggregate. Defaults to the primary read action. Keep in mind this action must not have any required arguments.`field``atom`The field to aggregate. Defaults to the first field in the primary key of the resource`filter``any``[]`A filter to apply to the aggregate`sort``any`A sort to be applied to the aggregate`description``String.t`An optional description for the aggregate`default``any`A default value to use in cases where nil would be used. Count defaults to `0`.`public?``boolean``false`Whether or not the aggregate will appear in public interfaces`filterable?``boolean | :simple_equality``true`Whether or not the aggregate should be usable in filters.`sortable?``boolean``true`Whether or not the aggregate should be usable in sorts.`sensitive?``boolean``false`Whether or not the aggregate should be considered sensitive.`authorize?``boolean``true`Whether or not the aggregate query should authorize based on the target action, if the parent query is authorized. Requires filter checks on the target action.
### aggregates.custom.join\_filter

    join_filter         relationship_path    ,         filter

Declares a join filter on an aggregate. See the aggregates guide for more.

### Examples

    join_filter         [    :comments    ,         :author    ]    ,         expr    (    active         ==         true    )    

### Arguments
NameTypeDefaultDocs`relationship_path``atom | list(atom)`The relationship path on which to apply the join filter`filter``any`The filter to apply. Can be an expression or a filter template.
### Introspection

Target: `Ash.Resource.Aggregate.JoinFilter`

### Introspection

Target: `Ash.Resource.Aggregate`

## calculations

Declare named calculations on the resource.

These are calculations that can be loaded only by name using `Ash.Query.load/2`. They are also available as top level fields on the resource.

See the calculations guide for more.

### Nested DSLs

+ calculate
	+ argument


### Examples

    calculations         do    
          calculate         :full_name    ,         :string    ,         MyApp.MyResource.FullName        end    

### calculations.calculate

    calculate         name    ,         type    ,         calculation         \\         nil

Declares a named calculation on the resource.

Takes a module that must adopt the `Ash.Resource.Calculation` behaviour. See that module for more information.

To ensure that the necessary fields are loaded:

1.\) Specifying the `load` option on a calculation in the resource. 2.\) Define a `load/3` callback in the calculation module 3.\) Set `always_select?` on the attribute in question

See the calculations guide for more.

### Nested DSLs

+ argument

### Examples

`Ash.Resource.Calculation` implementation example:

    calculate         :full_name    ,         :string    ,         {    MyApp.FullName    ,         keys    :         [    :first_name    ,         :last_name    ]    }    ,         load    :         [    :first_name    ,         :last_name    ]

`expr/1` example:

    calculate         :full_name    ,         :string    ,         expr    (    first_name         <>         " "         <>         last_name    )

Example with options:

    calculate         :full_name    ,         :string    ,         expr    (    first_name         <>         " "         <>         last_name    )    ,         allow_nil?    :         false

Example with options in `do` block:

    calculate         :full_name    ,         :string    ,         expr    (    first_name         <>         " "         <>         last_name    )         do    
          allow_nil?         false    
          public?         true        end    

### Arguments
NameTypeDefaultDocs`name``atom`The field name to use for the calculation value`type``any`The type of the calculation. See `Ash.Type` for more.`calculation``(any, any -> any) | module | any`The `module`, `{module, opts}` or `expr(...)` to use for the calculation. Also accepts a function that takes *a list of records* and the context, and produces a result for each record.
### Options
NameTypeDefaultDocs`async?``boolean``false``constraints``keyword``[]`Constraints to provide to the type. See `Ash.Type` for more.`description``String.t`An optional description for the calculation`public?``boolean``false`Whether or not the calculation will appear in public interfaces.`sensitive?``boolean``false`Whether or not references to the calculation will be considered sensitive.`load``any``[]`A load statement to be applied if the calculation is used.`allow_nil?``boolean``true`Whether or not the calculation can return nil.`filterable?``boolean | :simple_equality``true`Whether or not the calculation should be usable in filters.`sortable?``boolean``true`Whether or not the calculation can be referenced in sorts.
### calculations.calculate.argument

    argument         name    ,         type

An argument to be passed into the calculation's arguments map

See the calculations guide for more.

### Examples

    argument         :params    ,         :map         do    
          default         %{    }        end    

    argument         :retries    ,         :integer         do    
          allow_nil?         false        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`default``(-> any) | mfa | any`A default value to use for the argument if not provided`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\)`allow_expr?``boolean``false`Allow passing expressions as argument values. Expressions cannot be type validated.`constraints``keyword``[]`Constraints to provide to the type when casting the value. See the type's documentation and `Ash.Type` for more.
### Introspection

Target: `Ash.Resource.Calculation.Argument`

### Introspection

Target: `Ash.Resource.Calculation`

## multitenancy

Options for configuring the multitenancy behavior of a resource.

To specify a tenant, use `Ash.Query.set_tenant/2` or `Ash.Changeset.set_tenant/2` before passing it to an operation.

See the multitenancy guide

### Examples

    multitenancy         do    
          strategy         :attribute    
          attribute         :organization_id    
          global?         true        end    

### Options
NameTypeDefaultDocs`strategy``:context | :attribute``:context`Determine if multitenancy is performed with attribute filters or using data layer features.`attribute``atom`If using the `attribute` strategy, the attribute to use, e.g `org_id``global?``boolean``false`Whether or not the data may be accessed without setting a tenant. For example, with attribute multitenancy, this allows accessing without filtering by the tenant attribute.`parse_attribute``mfa``{Ash.Resource.Dsl, :identity, []}`An mfa \(\{module, function, args\}\) pointing to a function that takes a tenant and returns the attribute value 


# Ash.Domain

## domain

General domain configuration

### Examples

    domain         do    
          description         """
      Resources related to the flux capacitor.
      """        end    

### Options
NameTypeDefaultDocs`description``String.t`A description for the domain.
## resources

List the resources of this domain

### Nested DSLs

+ resource
	+ define
		+ custom\_input
			+ transform


	+ define\_calculation
		+ custom\_input
			+ transform




### Examples

    resources         do    
          resource         MyApp.Tweet    
          resource         MyApp.Comment        end    

### Options
NameTypeDefaultDocs`allow``mfa`Support a dynamic resource list by providing a callback that checks whether or not the resource should be allowed.`allow_unregistered?``boolean``false`Whether the domain will support only registered entries or not.
### resources.resource

    resource         resource

A resource present in the domain

### Nested DSLs

+ define
	+ custom\_input
		+ transform


+ define\_calculation
	+ custom\_input
		+ transform



### Examples

    resource         Foo

### Arguments
NameTypeDefaultDocs`resource``module`
### resources.resource.define

    define         name

Defines a function with the corresponding name and arguments. See the code interface guide for more.

### Nested DSLs

+ custom\_input
	+ transform


### Examples

    define         :get_user_by_id    ,         action    :         :get_by_id    ,         args    :         [    :id    ]    ,         get?    :         true

### Arguments
NameTypeDefaultDocs`name``atom`The name of the function that will be defined
### Options
NameTypeDefaultDocs`action``atom`The name of the action that will be called. Defaults to the same name as the function.`args``list(atom | {:optional, atom})`Map specific arguments to named inputs. Can provide any argument/attributes that the action allows.`not_found_error?``boolean``true`If the action or interface is configured with `get?: true`, this determines whether or not an error is raised or `nil` is returned.`require_reference?``boolean``true`For update and destroy actions, require a resource or identifier to be passed in as the first argument. Not relevant for other action types.`exclude_inputs``list(atom)``[]`A list of action inputs to not accept in the defined interface`get?``boolean``false`Expects to only receive a single result from a read action or a bulk update/destroy, and returns a single result instead of a list. Sets `require_reference?` to false automatically.`get_by``atom | list(atom)`Takes a list of fields and adds those fields as arguments, which will then be used to filter. Sets `get?` to true and `require_reference?` to false automatically. Adds filters for read, update and destroy actions, replacing the `record` first argument.`get_by_identity``atom`Takes an identity, gets its field list, and performs the same logic as `get_by` with those fields. Adds filters for read, update and destroy actions, replacing the `record` first argument.`default_options``keyword | (-> any)``[]`Default options to be merged with client-provided options. These can override domain or action defaults. `:load`, `:bulk_options`, and `:page` options will be deep merged. Can be a keyword list or a zero-arity function that returns a keyword list.
### resources.resource.define.custom\_input

    custom_input         name    ,         type

Define or customize an input to the action.

See the code interface guide for more.

### Nested DSLs

+ transform

### Examples

    custom_input         :artist    ,         :struct         do    
          transform         to    :         :artist_id    ,         using    :         &    (    &1    .    id    )    

          constraints         instance_of    :         Artist        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### resources.resource.define.custom\_input.transform

A transformation to be applied to the custom input.

### Examples

    transform         do    
          to         :artist_id    
          using         &    (    &1    .    id    )        end    

    transform         do    
          to         :points    
          using         &    try_parse_integer    /    1        end    

### Options
NameTypeDefaultDocs`to``atom`A key to rewrite the argument to. If the custom input is also a required positional argument, then the `to` is automatically added to the `exclude_inputs` list.`using``(any -> any)`A function to use to transform the value. Must return `value` or `nil`
### Introspection

Target: `Ash.Resource.Interface.CustomInput.Transform`

### Introspection

Target: `Ash.Resource.Interface.CustomInput`

### Introspection

Target: `Ash.Resource.Interface`

### resources.resource.define\_calculation

    define_calculation         name

Defines a function with the corresponding name and arguments, that evaluates a calculation. Use `:_record` to take an instance of a record. See the code interface guide for more.

### Nested DSLs

+ custom\_input
	+ transform


### Examples

    define_calculation         :referral_link    ,         User    ,         args    :         [    :id    ]

    define_calculation         :referral_link    ,         User    ,         args    :         [    {    :arg    ,         :id    }    ,         {    :ref    ,         :id    }    ]

### Arguments
NameTypeDefaultDocs`name``atom`The name of the function that will be defined
### Options
NameTypeDefaultDocs`calculation``atom`The name of the calculation that will be evaluated. Defaults to the same name as the function.`exclude_inputs``list(atom)``[]`A list of calculation inputs to not accept in the defined interface`args``any``[]`Supply field or argument values referenced by the calculation, in the form of :name, `{:arg, :name}` and/or `{:ref, :name}`. See the code interface guide for more.
### resources.resource.define\_calculation.custom\_input

    custom_input         name    ,         type

Define or customize an input to the action.

See the code interface guide for more.

### Nested DSLs

+ transform

### Examples

    custom_input         :artist    ,         :struct         do    
          transform         to    :         :artist_id    ,         using    :         &    (    &1    .    id    )    

          constraints         instance_of    :         Artist        end    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument`type``module`The type of the argument. See `Ash.Type` for more.
### Options
NameTypeDefaultDocs`description``String.t`An optional description for the argument.`constraints``keyword``[]`Constraints to provide to the type when casting the value. For more information, see `Ash.Type`.`allow_nil?``boolean``true`Whether or not the argument value may be nil \(or may be not provided\). If nil value is given error is raised.`sensitive?``boolean``false`Whether or not the argument value contains sensitive information, like PII\(Personally Identifiable Information\). See the security guide for more.`default``any`The default value for the argument to take. It can be a zero argument function e.g `&MyMod.my_fun/0` or a value
### resources.resource.define\_calculation.custom\_input.transform

A transformation to be applied to the custom input.

### Examples

    transform         do    
          to         :artist_id    
          using         &    (    &1    .    id    )        end    

    transform         do    
          to         :points    
          using         &    try_parse_integer    /    1        end    

### Options
NameTypeDefaultDocs`to``atom`A key to rewrite the argument to. If the custom input is also a required positional argument, then the `to` is automatically added to the `exclude_inputs` list.`using``(any -> any)`A function to use to transform the value. Must return `value` or `nil`
### Introspection

Target: `Ash.Resource.Interface.CustomInput.Transform`

### Introspection

Target: `Ash.Resource.Interface.CustomInput`

### Introspection

Target: `Ash.Resource.CalculationInterface`

### Introspection

Target: `Ash.Domain.Dsl.ResourceReference`

## execution

Options for how requests are executed using this domain

### Examples

    execution         do    
          timeout         :timer    .    seconds    (    30    )        end    

### Options
NameTypeDefaultDocs`timeout``timeout``:infinity`The default timeout in milliseconds to use for requests using this domain. See the timeouts guide for more.`trace_name``String.t`The name to use in traces. Defaults to the last part of the module. See the monitoring guide for more
## authorization

Options for how requests are authorized using this domain. See the Sensitive Data guide for more.

### Examples

    authorization         do    
          authorize         :always        end    

### Options
NameTypeDefaultDocs`require_actor?``boolean``false`Requires that an actor has been supplied.`authorize``:always | :by_default | :when_requested``:by_default`When to run authorization for a given request. 


# Ash.Notifier.PubSub

A builtin notifier to help you publish events over any kind of pub-sub tooling.

This is plug and play with `Phoenix.PubSub`, but could be used with any pubsub system.

You configure a module that defines a `broadcast/3` function, and then add some "publications" which configure under what conditions an event should be sent and what the topic should be.

## Example

    defmodule         MyApp.User         do    
          use         Ash.Resource    ,    
            # ...    
            notifiers    :         [    Ash.Notifier.PubSub    ]    

          # ...    

          pub_sub         do    
            module         MyAppWeb.Endpoint    

            prefix         "user"    
            publish         :update    ,         [    "updated"    ,         :_pkey    ]    
          end        end

## Debugging PubSub

It can be quite frustrating when setting up pub\_sub when everything appears to be set up properly, but you aren't receiving events. This usually means some kind of mismatch between the event names produced by the resource/config of your publications, and you can use the following flag to display debug information about all pub sub events.

    config         :ash    ,         :pub_sub    ,         debug?    :         true

## Topic Templates

Often you want to include some piece of data in the thing being changed, like the `:id` attribute. This is done by providing a list as the topic, and using atoms which will be replaced by their corresponding values. They will ultimately be joined with `:`.

For example:

    prefix         "user"    
        publish         :create    ,         [    "created"    ,         :user_id    ]

This might publish a message to "user:created:1" for example.

For updates, if the field in the template is being changed, a message is sent to *both* values. So if you change `user 1` to `user 2`, the same message would be published to `user:updated:1` and `user:updated:2`. If there are multiple attributes in the template, and they are all being changed, a message is sent for every combination of substitutions.

## Important

If the previous value was `nil` or the field was not selected on the data passed into the action, then a notification is not sent for the previous value.

If the new value is `nil` then a notification is not sent for the new value.

## Template parts

Templates may contain lists, in which case all combinations of values in the list will be used. Add `nil` to the list if you want to produce a pattern where that entry is omitted.

The atom `:_tenant` may be used. If the changeset has a tenant set on it, that value will be used, otherwise that combination of values is ignored.

The atom `:_pkey` may be used. It will be a stringified, concatenation of the primary key fields, or just the primary key if there is only one primary key field.

The atom `nil` may be used. It only makes sense to use it in the context of a list of alternatives, and adds a pattern where that part is skipped.

    publish         :updated    ,         [    [    :team_id    ,         :_tenant    ]    ,         "updated"    ,         [    :id    ,         nil    ]    ]

Would produce the following messages, given a `team_id` of 1, a `tenant` of `org_1`, and an `id` of `50`:

    "1:updated:50"        "1:updated"        "org_1:updated:50"        "org_1:updated"

## Custom Delimiters

It's possible to change the default delimiter used when generating topics. This is useful when working with message brokers like RabbitMQ, which rely on a different set of delimiters for routing.

    pub_sub         do    
          delimiter         "."        end

## Named Pubsub modules

If you are using a phoenix `Endpoint` module for pubsub then this is unnecessary. If you want to use a custom pub sub started with something like `{Phoenix.PubSub, name: MyName}`, then you can provide `MyName` to here.

## Broadcast Types

Configured with `broadcast_type`.

+ `:notification` just sends the notification
+ `:phoenix_broadcast` sends a `%Phoenix.Socket.Broadcast{}` \(see above\)
+ `:broadcast` sends `%{topic: (topic), event: (event), payload: (notification)}`

## pub\_sub

A section for configuring how resource actions are published over pubsub

### Nested DSLs

+ publish
+ publish\_all

### Examples

    pub_sub         do    
          module         MyEndpoint    
          prefix         "post"    

          publish         :destroy    ,         [    "destroyed"    ,         :id    ]    
          publish         :update    ,         [    "updated"    ,         :name    ]    ,         event    :         "name_change"    
          publish_all         :create    ,         "created"        end    

### Options
NameTypeDefaultDocs`module``atom`The module to call `broadcast/3` on e.g module.broadcast\(topic, event, message\).`prefix``String.t`A prefix for all pubsub messages, e.g `users`. A message with `created` would be published as `users:created``delimiter``String.t`A delimiter for building topics. Default is a colon \(:\)`filter``(any -> any)`A filter for notifications. Receives a notification, and ignores it if the function returns a falsy value. Both this and filters on specific publications must return a truthy value for a notification to be emitted.`transform``(any -> any)`A transformer for notifications. Specific transformers on each publication *override* this option`broadcast_type``:notification | :phoenix_broadcast | :broadcast``:notification`What shape the event payloads will be in. See`name``atom`A named pub sub to pass as the first argument to broadcast.
### pub\_sub.publish

    publish         action    ,         topic

Configure a given action to publish its results over a given topic.

### Examples

    publish         :create    ,         "created"

    publish         :assign    ,         "assigned"    

### Arguments
NameTypeDefaultDocs`action``atom`The name of the action that should be published`topic``any`The topic to publish
### Options
NameTypeDefaultDocs`previous_values?``boolean``false`Whether or not to publish messages with both the new values and the old values for referencing changed attributes`filter``(any -> any)`A filter for notifications. Receives a notification, and ignores it if the function returns a falsy value.`transform``(any -> any)`A transformer for notifications. Receives a notification, and returns a new value to be broadcasted.`event``String.t`The name of the event to publish. Defaults to the action name`dispatcher``atom`The module to use as a dispatcher. If none is set, the pubsub module provided is used.
### Introspection

Target: `Ash.Notifier.PubSub.Publication`

### pub\_sub.publish\_all

    publish_all         type    ,         topic

Works the same as `publish`, except that it takes a type and publishes all actions of that type.

### Examples

    publish_all         :create    ,         "created"

### Arguments
NameTypeDefaultDocs`type``:create | :update | :destroy`Publish on all actions of a given type`topic``any`The topic to publish
### Options
NameTypeDefaultDocs`except``list(atom)``[]`Exclude these actions from notifications`action``atom`The name of the action that should be published`previous_values?``boolean``false`Whether or not to publish messages with both the new values and the old values for referencing changed attributes`filter``(any -> any)`A filter for notifications. Receives a notification, and ignores it if the function returns a falsy value.`transform``(any -> any)`A transformer for notifications. Receives a notification, and returns a new value to be broadcasted.`event``String.t`The name of the event to publish. Defaults to the action name`dispatcher``atom`The module to use as a dispatcher. If none is set, the pubsub module provided is used.
### Introspection

Target: `Ash.Notifier.PubSub.Publication`



# Ash.Policy.Authorizer

An authorization extension for ash resources.

To add this extension to a resource, add it to the list of `authorizers` like so:

    use         Ash.Resource    ,    
          ...    ,    
          authorizers    :         [    
            Ash.Policy.Authorizer    
          ]

A resource can be given a set of policies, which are enforced on each call to a resource action.

For reads, policies can be configured to filter out data that the actor shouldn't see, as opposed to resulting in a forbidden error.

See the policies guide for practical examples.

Policies are solved/managed via a boolean satisfiability solver. To read more about boolean satisfiability, see this page: https://en.wikipedia.org/wiki/Boolean\_satisfiability\_problem. At the end of the day, however, it is not necessary to understand exactly how Ash takes your authorization requirements and determines if a request is allowed. The important thing to understand is that Ash may or may not run any/all of your authorization rules as they may be deemed unnecessary. As such, authorization checks should have no side effects. Ideally, the checks built-in to ash should cover the bulk of your needs.

## policies

A section for declaring authorization policies.

Each policy that applies must pass independently in order for the request to be authorized.

See the policies guide for more.

### Nested DSLs

+ policy
	+ authorize\_if
	+ forbid\_if
	+ authorize\_unless
	+ forbid\_unless

+ policy\_group
	+ policy
		+ authorize\_if
		+ forbid\_if
		+ authorize\_unless
		+ forbid\_unless


+ bypass
	+ authorize\_if
	+ forbid\_if
	+ authorize\_unless
	+ forbid\_unless


### Examples

    policies         do    
          # Anything you can use in a condition, you can use in a check, and vice-versa    
          # This policy applies if the actor is a super_user    
          # Additionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without    
          # failing the whole request, and that if this check *passes*, the entire request passes.    
          bypass         actor_attribute_equals    (    :super_user    ,         true    )         do    
            authorize_if         always    (    )    
          end    

          # This will likely be a common occurrence. Specifically, policies that apply to all read actions    
          policy         action_type    (    :read    )         do    
            # unless the actor is an active user, forbid their request    
            forbid_unless         actor_attribute_equals    (    :active    ,         true    )    
            # if the record is marked as public, authorize the request    
            authorize_if         attribute    (    :public    ,         true    )    
            # if the actor is related to the data via that data's `owner` relationship, authorize the request    
            authorize_if         relates_to_actor_via    (    :owner    )    
          end        end    

### Options
NameTypeDefaultDocs`default_access_type``:strict | :filter | :runtime``:filter`The default access type of policies for this resource.
### policies.policy

    policy         condition         \\         nil

A policy has a name, a condition, and a list of checks.

Checks apply logically in the order they are specified, from top to bottom. If no check explicitly authorizes the request, then the request is forbidden. This means that, if you want to "blacklist" instead of "whitelist", you likely want to add an `authorize_if always()` at the bottom of your policy, like so:

    policy         action_type    (    :read    )         do        forbid_if         not_logged_in    (    )        forbid_if         user_is_denylisted    (    )        forbid_if         user_is_in_denylisted_group    (    )    
        authorize_if         always    (    )        end

If the policy should always run, use the `always()` check, like so:

    policy         always    (    )         do        ...        end

See the policies guide for more.

### Nested DSLs

+ authorize\_if
+ forbid\_if
+ authorize\_unless
+ forbid\_unless

### Arguments
NameTypeDefaultDocs`condition``any`A check or list of checks that must be true in order for this policy to apply.
### Options
NameTypeDefaultDocs`description``String.t`A description for the policy, used when explaining authorization results`access_type``:strict | :filter | :runtime`Determines how the policy is applied. See the guide for more.
### policies.policy.authorize\_if

    authorize_if         check

If the check is true, the request is authorized, otherwise run remaining checks.

### Examples

    authorize_if         logged_in    (    )

    authorize_if         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.policy.forbid\_if

    forbid_if         check

If the check is true, the request is forbidden, otherwise run remaining checks.

### Examples

    forbid_if         not_logged_in    (    )

    forbid_if         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.policy.authorize\_unless

    authorize_unless         check

If the check is true, run remaining checks, otherwise the request is authorized.

### Examples

    authorize_unless         not_logged_in    (    )

    authorize_unless         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.policy.forbid\_unless

    forbid_unless         check

If the check is true, run remaining checks, otherwise the request is forbidden.

### Examples

    forbid_unless         logged_in    (    )

    forbid_unless         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### Introspection

Target: `Ash.Policy.Policy`

### policies.policy\_group

    policy_group         condition

Groups a set of policies together by some condition.

If the condition on the policy group does not apply, then none of the policies within it apply.

This is primarily syntactic sugar. At compile time, the conditions from the policy group are added to each policy it contains, and the list is flattened out. This exists primarily to make it easier to reason about and write policies.

The following are equivalent:

    policy_group         condition1         do        policy         condition2         do        ...        end    
        policy         condition3         do        ...        end        end

and

    policy         [    condition1    ,         condition2    ]         do        ...        end    
        policy         [    condition1    ,         condition3    ]         do        ...        end

### Nested DSLs

+ policy
	+ authorize\_if
	+ forbid\_if
	+ authorize\_unless
	+ forbid\_unless


### Arguments
NameTypeDefaultDocs`condition``any`A check or list of checks that must be true in order for this policy to apply.
### policies.policy\_group.policy

    policy         condition         \\         nil

A policy has a name, a condition, and a list of checks.

Checks apply logically in the order they are specified, from top to bottom. If no check explicitly authorizes the request, then the request is forbidden. This means that, if you want to "blacklist" instead of "whitelist", you likely want to add an `authorize_if always()` at the bottom of your policy, like so:

    policy         action_type    (    :read    )         do        forbid_if         not_logged_in    (    )        forbid_if         user_is_denylisted    (    )        forbid_if         user_is_in_denylisted_group    (    )    
        authorize_if         always    (    )        end

If the policy should always run, use the `always()` check, like so:

    policy         always    (    )         do        ...        end

See the policies guide for more.

### Nested DSLs

+ authorize\_if
+ forbid\_if
+ authorize\_unless
+ forbid\_unless

### Arguments
NameTypeDefaultDocs`condition``any`A check or list of checks that must be true in order for this policy to apply.
### Options
NameTypeDefaultDocs`description``String.t`A description for the policy, used when explaining authorization results`access_type``:strict | :filter | :runtime`Determines how the policy is applied. See the guide for more.
### policies.policy\_group.policy.authorize\_if

    authorize_if         check

If the check is true, the request is authorized, otherwise run remaining checks.

### Examples

    authorize_if         logged_in    (    )

    authorize_if         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.policy\_group.policy.forbid\_if

    forbid_if         check

If the check is true, the request is forbidden, otherwise run remaining checks.

### Examples

    forbid_if         not_logged_in    (    )

    forbid_if         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.policy\_group.policy.authorize\_unless

    authorize_unless         check

If the check is true, run remaining checks, otherwise the request is authorized.

### Examples

    authorize_unless         not_logged_in    (    )

    authorize_unless         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.policy\_group.policy.forbid\_unless

    forbid_unless         check

If the check is true, run remaining checks, otherwise the request is forbidden.

### Examples

    forbid_unless         logged_in    (    )

    forbid_unless         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### Introspection

Target: `Ash.Policy.Policy`

### Introspection

Target: `Ash.Policy.PolicyGroup`

### policies.bypass

    bypass         condition         \\         nil

A policy that, if passed, will skip all following policies. If failed, authorization moves on to the next policy

### Nested DSLs

+ authorize\_if
+ forbid\_if
+ authorize\_unless
+ forbid\_unless

### Arguments
NameTypeDefaultDocs`condition``any`A check or list of checks that must be true in order for this policy to apply.
### Options
NameTypeDefaultDocs`description``String.t`A description for the policy, used when explaining authorization results`access_type``:strict | :filter | :runtime`Determines how the policy is applied. See the guide for more.
### policies.bypass.authorize\_if

    authorize_if         check

If the check is true, the request is authorized, otherwise run remaining checks.

### Examples

    authorize_if         logged_in    (    )

    authorize_if         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.bypass.forbid\_if

    forbid_if         check

If the check is true, the request is forbidden, otherwise run remaining checks.

### Examples

    forbid_if         not_logged_in    (    )

    forbid_if         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.bypass.authorize\_unless

    authorize_unless         check

If the check is true, run remaining checks, otherwise the request is authorized.

### Examples

    authorize_unless         not_logged_in    (    )

    authorize_unless         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### policies.bypass.forbid\_unless

    forbid_unless         check

If the check is true, run remaining checks, otherwise the request is forbidden.

### Examples

    forbid_unless         logged_in    (    )

    forbid_unless         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### Introspection

Target: `Ash.Policy.Policy`

## field\_policies

Authorize access to specific fields via policies scoped to fields.

If *any* field policies exist then *all* fields must be authorized by a field policy. If you want a "deny-list" style, then you can add policies for specific fields and add a catch-all policy using the special field name `:*`. All policies that apply to a field must be authorized.

The only exception to the above behavior is primary keys, which can always be read by everyone.

Additionally, keep in mind that adding `Ash.Policy.Authorizer` will require that all actions pass policies. If you want to just add field policies, you will need to add a policy that allows all access explicitly, i.e

    policies         do        policy         always    (    )         do        authorize_if         always    (    )        end        end

Using expressions: unlike in regular policies, expressions in field policies cannot refer to related entities currently. Instead, you will need to create aggregates or expression calculations that return the results you want to reference.

In results, forbidden fields will be replaced with a special value: `%Ash.ForbiddenField{}`.

When these fields are referred to in filters, they will be replaced with an expression that evaluates to `nil`. To support this behavior, only expression/filter checks are allowed in field policies.

### Nested DSLs

+ field\_policy\_bypass
	+ authorize\_if
	+ forbid\_if
	+ authorize\_unless
	+ forbid\_unless

+ field\_policy
	+ authorize\_if
	+ forbid\_if
	+ authorize\_unless
	+ forbid\_unless


### Examples

    field_policies         do    
          field_policy         :admin_only_field         do    
            authorize_if         actor_attribute_equals    (    :admin    ,         true    )    
          end        end    

    # Example of denylist style        field_policies         do    
          field_policy         [    :sensitive    ,         :fields    ]         do    
            authorize_if         actor_attribute_equals    (    :admin    ,         true    )    
          end    

          field_policy         :*         do    
            authorize_if         always    (    )    
          end        end    

### Options
NameTypeDefaultDocs`private_fields``:show | :hide | :include``:show`How private fields should be handled by field policies in internal functions. See the Policies guide for more.
### field\_policies.field\_policy\_bypass

    field_policy_bypass         fields    ,         condition         \\         nil

A field policy that, if passed, will skip all following field policies for that field or fields. If failed, field authorization moves on to the next policy

### Nested DSLs

+ authorize\_if
+ forbid\_if
+ authorize\_unless
+ forbid\_unless

### Arguments
NameTypeDefaultDocs`fields``atom | list(atom)`The field or fields that the policy applies to.`condition``any`A check or list of checks that must be true in order for this field policy to apply. If not specified, it always applies.
### Options
NameTypeDefaultDocs`description``String.t`A description for the policy, used when explaining authorization results
### field\_policies.field\_policy\_bypass.authorize\_if

    authorize_if         check

If the check is true, the request is authorized, otherwise run remaining checks.

### Examples

    authorize_if         logged_in    (    )

    authorize_if         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### field\_policies.field\_policy\_bypass.forbid\_if

    forbid_if         check

If the check is true, the request is forbidden, otherwise run remaining checks.

### Examples

    forbid_if         not_logged_in    (    )

    forbid_if         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### field\_policies.field\_policy\_bypass.authorize\_unless

    authorize_unless         check

If the check is true, run remaining checks, otherwise the request is authorized.

### Examples

    authorize_unless         not_logged_in    (    )

    authorize_unless         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### field\_policies.field\_policy\_bypass.forbid\_unless

    forbid_unless         check

If the check is true, run remaining checks, otherwise the request is forbidden.

### Examples

    forbid_unless         logged_in    (    )

    forbid_unless         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### Introspection

Target: `Ash.Policy.FieldPolicy`

### field\_policies.field\_policy

    field_policy         fields    ,         condition         \\         nil

Field policies behave similarly to policies. See `d:Ash.Policy.Authorizer.field_policies` for more.

### Nested DSLs

+ authorize\_if
+ forbid\_if
+ authorize\_unless
+ forbid\_unless

### Arguments
NameTypeDefaultDocs`fields``atom | list(atom)`The field or fields that the policy applies to.`condition``any`A check or list of checks that must be true in order for this field policy to apply. If not specified, it always applies.
### Options
NameTypeDefaultDocs`description``String.t`A description for the policy, used when explaining authorization results
### field\_policies.field\_policy.authorize\_if

    authorize_if         check

If the check is true, the request is authorized, otherwise run remaining checks.

### Examples

    authorize_if         logged_in    (    )

    authorize_if         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### field\_policies.field\_policy.forbid\_if

    forbid_if         check

If the check is true, the request is forbidden, otherwise run remaining checks.

### Examples

    forbid_if         not_logged_in    (    )

    forbid_if         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### field\_policies.field\_policy.authorize\_unless

    authorize_unless         check

If the check is true, run remaining checks, otherwise the request is authorized.

### Examples

    authorize_unless         not_logged_in    (    )

    authorize_unless         actor_attribute_matches_record    (    :group    ,         :blacklisted_groups    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### field\_policies.field\_policy.forbid\_unless

    forbid_unless         check

If the check is true, run remaining checks, otherwise the request is forbidden.

### Examples

    forbid_unless         logged_in    (    )

    forbid_unless         actor_attribute_matches_record    (    :group    ,         :group    )

### Arguments
NameTypeDefaultDocs`check``any | module`The check to run. See `Ash.Policy.Check` for more.
### Options
NameTypeDefaultDocs`name``String.t`A short name or description for the check, used when explaining authorization results
### Introspection

Target: `Ash.Policy.Check`

### Introspection

Target: `Ash.Policy.FieldPolicy`



# Ash.DataLayer.Ets

An ETS \(Erlang Term Storage\) backed Ash Datalayer, for testing and lightweight usage.

Remember, this does not have support for transactions\! This is not recommended for production use, especially in multi-user applications. It can, however, be great for prototyping.

## ets

A section for configuring the ets data layer

### Examples

    ets         do    
          # Used in testing    
          private?         true        end    

### Options
NameTypeDefaultDocs`private?``boolean``false`Sets the ets table protection to private, and scopes it to only this process. The table name will not be used directly if this is true, to allow multiple processes to use this resource separately.`table``atom`The name of the table. Defaults to the resource name. 


# Ash.DataLayer.Mnesia

An Mnesia backed Ash Datalayer.

In your application initialization, you will need to call `Mnesia.create_schema([node()])`.

Additionally, you will want to create your mnesia tables there.

This data layer is *unoptimized*, fetching all records from a table and filtering them in memory. For that reason, it is not recommended to use it with large amounts of data. It can be great for prototyping or light usage, though.

## mnesia

A section for configuring the mnesia data layer

### Examples

    mnesia         do    
          table         :custom_table        end    

### Options
NameTypeDefaultDocs`table``atom`The table name to use, defaults to the name of the resource 


# Ash.Reactor

`Ash.Reactor` is a `Reactor` extension which provides steps for working with Ash resources and actions.

See the Ash Reactor Guide for more information.

## ash

Ash-related configuration for the `Ash.Reactor` extension

### Options
NameTypeDefaultDocs`default_domain``module`A domain to use by default when calling actions
### reactor.action

    action         name    ,         resource    ,         action         \\         nil

Declares a step that will call a generic action on a resource.

#### Undo behaviour

This step has three different modes of undo.

+ `never` - The result of the action is never undone. This is the default.
+ `always` - The `undo_action` will always be called.
+ `outside_transaction` - The `undo_action` will not be called when running inside a `transaction` block, but will be otherwise.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ tenant
+ wait\_for

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`undo_action``atom`The name of the action to call on the resource when the step is to be undone.`undo``:always | :never | :outside_transaction``:never`How to handle undoing this action
### reactor.action.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.action.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.action.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.action.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.action.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.action.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.action.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Action`

### reactor.ash\_step

    ash_step         name    ,         impl         \\         nil

Specifies a Ash.Reactor step.

This is basically a wrapper around `Reactor.step`, in order to handle any returned notifications from the run step/function.

See the `Reactor.Step` behaviour for more information.

### Nested DSLs

+ argument
+ wait\_for
+ guard
+ where

### Examples

    ash_step         :create_post    ,         MyApp.CreatePostStep         do    
          argument         :title    ,         input    (    :title    )        end    

    ash_step         :create_post         do    
          argument         :title    ,         input    (    :title    )    

          run         fn         %{    title    :         title    }    ,         _         ->    
            MyApp.Post    .    create    (    title    ,         return_notifications?    :         true    )    
          end        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.`impl``module | nil`A module that implements the `Reactor.Step` behaviour that provides the implementation.
### Options
NameTypeDefaultDocs`run``(any -> any) | mfa | (any, any -> any) | mfa`Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument.`undo``(any -> any) | mfa | (any, any -> any) | mfa | (any, any, any -> any) | mfa`Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.`compensate``(any -> any) | mfa | (any, any -> any) | mfa | (any, any, any -> any) | mfa`Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.`max_retries``:infinity | non_neg_integer``:infinity`The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the entire argument map before it is passed to the step.
### reactor.ash\_step.argument

    argument         name    ,         source         \\         nil

Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before being passed to any steps.

### Examples

    argument         :name    ,         input    (    :name    )    

    argument         :year    ,         input    (    :date    ,         [    :year    ]    )    

    argument         :user    ,         result    (    :create_user    )    

    argument         :user_id    ,         result    (    :create_user    )         do    
          transform         &         &1    .    id        end    

    argument         :user_id    ,         result    (    :create_user    ,         [    :id    ]    )    

    argument         :three    ,         value    (    3    )    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument which will be used as the key in the `arguments` map passed to the implementation.`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.
### Options
NameTypeDefaultDocs`description``String.t | nil`An optional description for the argument.`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the argument before it is passed to the step.
### Introspection

Target: `Reactor.Dsl.Argument`

### reactor.ash\_step.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### reactor.ash\_step.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.ash\_step.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### Introspection

Target: `Ash.Reactor.Dsl.AshStep`

### reactor.bulk\_create

    bulk_create         name    ,         resource    ,         action         \\         nil

Declares a step which will call a create action on a resource with a collection of inputs.

### Check the docs\!

Make sure to thoroughly read and understand the documentation in `Ash.bulk_create/4` before using. Read each option and note the default values. By default, bulk creates don't return records or errors, and don't emit notifications.

Caveats/differences from `Ash.bulk_create/4`:

1. `max_concurrency` specifies the number of tasks that Ash will start to process batches, and has no effect on Reactor concurrency targets. It's could be possible to create a very large number of processes if a number of steps are running bulk actions with a high degree of concurrency.
2. Setting `notify?` to `true` will cause both `notify?` and `return_notifications?` to be set to true in the underlying call to `Ash.bulk_create/4`. Notifications will then be managed by the `Ash.Reactor.Notifications` Reactor middleware.
3. If you specify an undo action it must be a generic action which takes the bulk result as it's only argument.

#### Undo behaviour

This step has three different modes of undo.

+ `never` - The result of the action is never undone. This is the default.
+ `always` - The `undo_action` will always be called.
+ `outside_transaction` - The `undo_action` will not be called when running inside a `transaction` block, but will be otherwise.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ load
+ tenant
+ wait\_for

### Examples

    bulk_create         :create_posts    ,         MyApp.Post    ,         :create         do    
          initial         input    (    :titles    )    
          actor         result    (    :get_user    )    
          tenant         result    (    :get_organisation    ,         [    :id    ]    )        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`initial``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`A collection of inputs to pass to the create action. Must implement the `Enumerable` protocol.`assume_casted?``boolean``false`Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting`authorize_changeset_with``:filter | :error``:filter`If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error`authorize_query_with``:filter | :error``:filter`If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error`batch_size``nil | pos_integer`The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.`max_concurrency``non_neg_integer``0`If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously.`notification_metadata``map | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value``%{}`Metadata to be merged into the metadata field for all notifications sent from this operation.`notify?``boolean``false`Whether or not to generate any notifications. This may be intensive for large bulk actions.`read_action``atom`The action to use when building the read query.`return_errors?``boolean``true`Whether or not to return all of the errors that occur. Defaults to false to account for large inserts.`return_records?``boolean``false`Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts.`return_stream?``boolean``false`If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.`rollback_on_error?``boolean``true`Whether or not to rollback the transaction on error, if the resource is in a transaction.`select``atom | list(atom)`A select statement to apply to records. Ignored if `return_records?` is not `true`.`skip_unknown_inputs``atom | String.t | list(atom | String.t)`A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.`sorted?``boolean``false`Whether or not to sort results by their input position, in cases where `return_records?` is set to `true`.`stop_on_error?``boolean``true`If `true`, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped.`success_state``:success | :partial_success``:success`Bulk results can be entirely or partially successful. Chooses the `Ash.BulkResult` state to consider the step a success.`timeout``timeout`If none is provided, the timeout configured on the domain is used \(which defaults to `30_000`\).`transaction``:all | :batch | false``:batch`Whether or not to wrap the entire execution in a transaction, each batch, or not at all.`upsert_fields``atom | list(atom)`The fields to upsert. If not set, the action's `upsert_fields` is used.`upsert_identity``atom`The identity to use for the upsert`upsert?``boolean``false`Whether or not this action should be executed as an upsert.`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`undo_action``atom`The name of the action to call on the resource when the step is to be undone.`undo``:always | :never | :outside_transaction``:never`How to handle undoing this action
### reactor.bulk\_create.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.bulk\_create.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.bulk\_create.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.bulk\_create.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.bulk\_create.load

    load         source

Allows the addition of an Ash load statement to the action

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the load
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.ActionLoad`

### reactor.bulk\_create.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.bulk\_create.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.BulkCreate`

### reactor.bulk\_update

    bulk_update         name    ,         resource    ,         action         \\         nil

Declares a step which will call an update action on a resource with a collection of inputs.

### Check the docs\!

Make sure to thoroughly read and understand the documentation in `Ash.bulk_update/4` before using. Read each option and note the default values. By default, bulk updates don't return records or errors, and don't emit notifications.

Caveats/differences from `Ash.bulk_update/4`:

1. `max_concurrency` specifies the number of tasks that Ash will start to process batches, and has no effect on Reactor concurrency targets. It's could be possible to create a very large number of processes if a number of steps are running bulk actions with a high degree of concurrency.
2. Setting `notify?` to `true` will cause both `notify?` and `return_notifications?` to be set to true in the underlying call to `Ash.bulk_create/4`. Notifications will then be managed by the `Ash.Reactor.Notifications` Reactor middleware.
3. If you specify an undo action it must be a generic action which takes the bulk result as it's only argument.

#### Undo behaviour

This step has three different modes of undo.

+ `never` - The result of the action is never undone. This is the default.
+ `always` - The `undo_action` will always be called.
+ `outside_transaction` - The `undo_action` will not be called when running inside a `transaction` block, but will be otherwise.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ tenant
+ wait\_for

### Examples

    bulk_update         :publish_posts    ,         MyApp.Post    ,         :publish         do    
          initial         input    (    :posts    )    ,    
          actor         result    (    :get_user    )        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`initial``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`A collection of inputs to pass to the create action. Must implement the `Enumerable` protocol.`allow_stream_with``:keyset | :offset | :full_read``:keyset`The 'worst' strategy allowed to be used to fetch records if the :stream strategy is chosen. See the `Ash.stream!/2` docs for more.`assume_casted?``boolean``false`Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting`atomic_update``map`A map of atomic updates to apply. See `Ash.Changeset.atomic_update/3` for more.`authorize_changeset_with``:filter | :error``:filter`If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error`authorize_query_with``:filter | :error``:filter`If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error`authorize_query?``boolean``true`If a query is given, determines whether or not authorization is run on that query.`batch_size``nil | pos_integer`The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.`filter``map | keyword`A filter to apply to records. This is also applied to a stream of inputs.`lock``any`A lock statement to add onto the query.`max_concurrency``non_neg_integer``0`If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously.`notification_metadata``map | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value``%{}`Metadata to be merged into the metadata field for all notifications sent from this operation.`notify?``boolean``false`Whether or not to generate any notifications. This may be intensive for large bulk actions.`page``keyword``[]`Pagination options, see `Ash.read/2` for more.`read_action``atom`The action to use when building the read query.`return_errors?``boolean``true`Whether or not to return all of the errors that occur. Defaults to false to account for large inserts.`return_records?``boolean``false`Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts.`return_stream?``boolean``false`If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.`reuse_values?``boolean``false`Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer.`rollback_on_error?``boolean``true`Whether or not to rollback the transaction on error, if the resource is in a transaction.`select``atom | list(atom)`A select statement to apply to records. Ignored if `return_records?` is not `true`.`skip_unknown_inputs``atom | String.t | list(atom | String.t)`A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.`sorted?``boolean``false`Whether or not to sort results by their input position, in cases where `return_records?` is set to `true`.`stop_on_error?``boolean``true`If `true`, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped.`strategy``list(:atomic | :atomic_batches | :stream)``[:atomic]`The strategy or strategies to enable. `:stream` is used in all cases if the data layer does not support atomics.`stream_batch_size``pos_integer`Batch size to use if provided a query and the query must be streamed.`stream_with``:keyset | :offset | :full_read`The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more.`success_state``:success | :partial_success``:success`Bulk results can be entirely or partially successful. Chooses the `Ash.BulkResult` state to consider the step a success.`timeout``timeout`If none is provided, the timeout configured on the domain is used \(which defaults to `30_000`\).`transaction``:all | :batch | false``:batch`Whether or not to wrap the entire execution in a transaction, each batch, or not at all.`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`undo_action``atom`The name of the action to call on the resource when the step is to be undone.`undo``:always | :never | :outside_transaction``:never`How to handle undoing this action
### reactor.bulk\_update.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.bulk\_update.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.bulk\_update.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.bulk\_update.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.bulk\_update.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.bulk\_update.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.bulk\_update.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.BulkUpdate`

### reactor.change

    change         name    ,         change

Declares a step that will modify a changeset.

### Nested DSLs

+ argument
+ wait\_for

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for this step.`change``(any, any -> any) | module`The module and options for a change. Also accepts a function that takes the changeset and the context. See `Ash.Resource.Change.Builtins` for builtin changes.
### Options
NameTypeDefaultDocs`initial``module | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`The initial value to work from, either a resource or a changeset`description``String.t | nil`An optional description for the change`only_when_valid?``boolean``false`If the change should only be run on valid changes. By default, all changes are run unless stated otherwise here.`where``(any, any -> any) | module | list((any, any -> any) | module)``[]`Validations that should pass in order for this change to apply. These validations failing will result in this change being ignored.`fail_if_invalid?``boolean``false`Fail if the result of the change is an invalid changeset
### reactor.change.argument

    argument         name    ,         source         \\         nil

Specifies an argument to a Reactor step.

Each argument is a value which is either the result of another step, or an input value.

Individual arguments can be transformed with an arbitrary function before being passed to any steps.

### Examples

    argument         :name    ,         input    (    :name    )    

    argument         :year    ,         input    (    :date    ,         [    :year    ]    )    

    argument         :user    ,         result    (    :create_user    )    

    argument         :user_id    ,         result    (    :create_user    )         do    
          transform         &         &1    .    id        end    

    argument         :user_id    ,         result    (    :create_user    ,         [    :id    ]    )    

    argument         :three    ,         value    (    3    )    

### Arguments
NameTypeDefaultDocs`name``atom`The name of the argument which will be used as the key in the `arguments` map passed to the implementation.`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.
### Options
NameTypeDefaultDocs`description``String.t | nil`An optional description for the argument.`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the argument before it is passed to the step.
### Introspection

Target: `Reactor.Dsl.Argument`

### reactor.change.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Change`

### reactor.create

    create         name    ,         resource    ,         action         \\         nil

Declares a step that will call a create action on a resource.

#### Undo behaviour

This step has three different modes of undo.

+ `never` - The result of the action is never undone. This is the default.
+ `always` - The `undo_action` will always be called.
+ `outside_transaction` - The `undo_action` will not be called when running inside a `transaction` block, but will be otherwise.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ load
+ tenant
+ wait\_for

### Examples

    create         :create_post    ,         MyApp.Post    ,         :create         do    
          inputs         %{    
            title    :         input    (    :post_title    )    ,    
            author_id    :         result    (    :get_user    ,         [    :id    ]    )    
          }    
          actor         result    (    :get_user    )    
          tenant         result    (    :get_organisation    ,         [    :id    ]    )        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`initial``nil | module | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`The initial value passed into the action.`upsert_identity``atom`The identity to use for the upsert`upsert?``boolean``false`Whether or not this action should be executed as an upsert.`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`undo_action``atom`The name of the action to call on the resource when the step is to be undone.`undo``:always | :never | :outside_transaction``:never`How to handle undoing this action
### reactor.create.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.create.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.create.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.create.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.create.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.create.load

    load         source

Allows the addition of an Ash load statement to the action

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the load
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.ActionLoad`

### reactor.create.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.create.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Create`

### reactor.destroy

    destroy         name    ,         resource    ,         action         \\         nil

Declares a step that will call a destroy action on a resource.

#### Undo behaviour

This step has three different modes of undo.

+ `never` - The result of the action is never undone. This is the default.
+ `always` - The `undo_action` will always be called.
+ `outside_transaction` - The `undo_action` will not be called when running inside a `transaction` block, but will be otherwise.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ load
+ tenant
+ wait\_for

### Examples

    destroy         :delete_post    ,         MyApp.Post    ,         :destroy         do    
          initial         input    (    :post    )    
          actor         result    (    :get_user    )    
          tenant         result    (    :get_organisation    ,         [    :id    ]    )        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`initial``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`The record to update.`return_destroyed?``boolean``false`Whether or not the step should return the destroyed record upon completion.`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`undo_action``atom`The name of the action to call on the resource when the step is to be undone.`undo``:always | :never | :outside_transaction``:never`How to handle undoing this action
### reactor.destroy.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.destroy.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.destroy.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.destroy.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.destroy.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.destroy.load

    load         source

Allows the addition of an Ash load statement to the action

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the load
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.ActionLoad`

### reactor.destroy.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.destroy.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Destroy`

### reactor.load

    load         name    ,         records    ,         load

Declares a step that will load additional data on a resource.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ tenant
+ wait\_for

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`records``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`The records upon which to add extra loaded data`load``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`An Ash load statement
### Options
NameTypeDefaultDocs`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load statement before it is passed to the load.`lazy?``boolean`If set to true, values will only be loaded if the related value isn't currently loaded.`reuse_values?``boolean`Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer.`strict?``boolean`If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.
### reactor.load.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.load.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.load.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.load.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.load.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.load.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Load`

### reactor.read\_one

    read_one         name    ,         resource    ,         action         \\         nil

Declares a step that will call a read action on a resource returning a single record.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ load
+ tenant
+ wait\_for

### Examples

    read_one         :post_by_id    ,         MyApp.Post    ,         :read         do    
          inputs         %{    id    :         input    (    :post_id    )    }        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`fail_on_not_found?``boolean``false`When set to true the step will fail if the resource is not found.`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step
### reactor.read\_one.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.read\_one.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.read\_one.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.read\_one.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.read\_one.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.read\_one.load

    load         source

Allows the addition of an Ash load statement to the action

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the load
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.ActionLoad`

### reactor.read\_one.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.read\_one.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.ReadOne`

### reactor.read

    read         name    ,         resource    ,         action         \\         nil

Declares a step that will call a read action on a resource.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ load
+ tenant
+ wait\_for

### Examples

    read         :read_posts    ,         MyApp.Post    ,         :read    

    read         :read_posts_in_range    ,         MyApp.Post    ,         :read_in_range         do    
          inputs         %{    min_date    :         input    (    :min_date    )    ,         max_date    :         input    (    :max_date    )    }        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step
### reactor.read.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.read.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.read.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.read.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.read.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.read.load

    load         source

Allows the addition of an Ash load statement to the action

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the load
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.ActionLoad`

### reactor.read.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.read.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Read`

### reactor.transaction

    transaction         name    ,         resources

Creates a group of steps which will be executed inside a data layer transaction.

### Nested DSLs

+ guard
+ where
+ wait\_for

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resources``module | list(module)`A resource or list of resources to consider in the transaction.
### Options
NameTypeDefaultDocs`return``atom`The name of the step whose result will be returned as the return value of the transaction.`timeout``pos_integer | :infinity``15000`How long to allow the transaction to run before timing out.
### reactor.transaction.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.transaction.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.transaction.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Transaction`

### reactor.update

    update         name    ,         resource    ,         action         \\         nil

Declares a step that will call an update action on a resource.

#### Undo behaviour

This step has three different modes of undo.

+ `never` - The result of the action is never undone. This is the default.
+ `always` - The `undo_action` will always be called.
+ `outside_transaction` - The `undo_action` will not be called when running inside a `transaction` block, but will be otherwise.

### Nested DSLs

+ actor
+ context
+ guard
+ where
+ inputs
+ load
+ tenant
+ wait\_for

### Examples

    update         :publish_post    ,         MyApp.Post    ,         :update         do    
          initial         input    (    :post    )    
          inputs         %{    
            published    :         value    (    true    )    
          }    
          actor         result    (    :get_user    )    
          tenant         result    (    :get_organisation    ,         [    :id    ]    )        end    

### Arguments
NameTypeDefaultDocs`name``atom`A unique name for the step.`resource``module`The resource to call the action on.`action``atom`The name of the action to call on the resource.
### Options
NameTypeDefaultDocs`initial``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`The record to update.`domain``module`The Domain to use when calling the action. Defaults to the Domain set on the resource or in the `ash` section.`async?``boolean``true`When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.`authorize?``boolean | nil`Explicitly enable or disable authorization for the action.`description``String.t`A description for the step`undo_action``atom`The name of the action to call on the resource when the step is to be undone.`undo``:always | :never | :outside_transaction``:never`How to handle undoing this action
### reactor.update.actor

    actor         source

Specifies the action actor

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the actor.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the actor before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Actor`

### reactor.update.context

    context         context

A map to be merged into the action's context

### Arguments
NameTypeDefaultDocs`context``nil | Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value | map`A map to be merged into the action's context.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the context before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Context`

### reactor.update.guard

    guard         fun

Provides a flexible method for conditionally executing a step, or replacing it's result.

Expects a two arity function which takes the step's arguments and context and returns one of the following:

+ `:cont` - the guard has passed.
+ `{:halt, result}` - the guard has failed - instead of executing the step use the provided result.

### Examples

    step         :read_file_via_cache         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          guard         fn         %{    path    :         path    }    ,         %{    cache    :         cache    }         ->    
            case         Cache    .    get    (    cache    ,         path    )         do    
              {    :ok    ,         content    }         ->         {    :halt    ,         {    :ok    ,         content    }    }    
              _         ->         :cont    
            end    
          end        end    

### Arguments
NameTypeDefaultDocs`fun``(any, any -> any) | mfa`The guard function.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Guard`

### reactor.update.where

    where         predicate

Only execute the surrounding step if the predicate function returns true.

This is a simple version of `guard` which provides more flexibility at the cost of complexity.

### Examples

    step         :read_file         do    
          argument         :path    ,         input    (    :path    )    
          run         &    File    .    read    (    &1    .    path    )    
          where         &    File    .    exists?    (    &1    .    path    )        end    

### Arguments
NameTypeDefaultDocs`predicate``(any -> any) | mfa | (any, any -> any) | mfa`Provide a function which takes the step arguments and optionally the context and returns a boolean value.
### Options
NameTypeDefaultDocs`description``String.t`An optional description of the guard.
### Introspection

Target: `Reactor.Dsl.Where`

### reactor.update.inputs

    inputs         template

Specify the inputs for an action

### Examples

    inputs         %{    
          author    :         result    (    :get_user    )    ,    
          title    :         input    (    :title    )    ,    
          body    :         input    (    :body    )        }    

    inputs    (    author    :         result    (    :get_user    )    )    

### Arguments
NameTypeDefaultDocs`template``%{optional(atom) => Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value} | keyword(Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value)`
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which will transform the inputs before executing the action.
### Introspection

Target: `Ash.Reactor.Dsl.Inputs`

### reactor.update.load

    load         source

Allows the addition of an Ash load statement to the action

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the load
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the load before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.ActionLoad`

### reactor.update.tenant

    tenant         source

Specifies the action tenant

### Arguments
NameTypeDefaultDocs`source``Reactor.Template.Element | Reactor.Template.Input | Reactor.Template.Result | Reactor.Template.Value`What to use as the source of the tenant.
### Options
NameTypeDefaultDocs`transform``(any -> any) | module | nil`An optional transformation function which can be used to modify the tenant before it is passed to the action.
### Introspection

Target: `Ash.Reactor.Dsl.Tenant`

### reactor.update.wait\_for

    wait_for         names

Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`

### Examples

    wait_for         :create_user

### Arguments
NameTypeDefaultDocs`names``atom | list(atom)`The name of the step to wait for.
### Options
NameTypeDefaultDocs`description``String.t`An optional description.
### Introspection

Target: `Reactor.Dsl.WaitFor`

### Introspection

Target: `Ash.Reactor.Dsl.Update`



# Glossary

## Action

An action describes an operation that can be performed for a given resource; it is the *verb* to a resource's *noun*. Examples of actions:

+ User.*create*
+ Comment.*delete*
+ BlogPost.*publish*
+ Article.*search*

Ash supports five different types of actions. `create`, `read`, `update` and `destroy` \(collectively often abbreviated as CRUD\), and `action`, referring to a generic action with a custom return type. A resource can define multiple actions per action type, eg. a *publish* action would be considered an `update` because it is updating an existing instance of a resource. Actions are much more flexible than simple CRUD, but these five action types serve as templates for anything you might want to do.

See the Actions guide for more.

## Actor

The entity that performs an action. 

Most actions are run on direct user request, eg. if a user presses a Create button on a page then the actor is the user.

The actor can be anything that you want it to be. It is most typically a map or a struct containing information about the "entity" that is performing the action. In the vast majority of cases, the actor will be something like `%MyApp.Accounts.User{}`. We recommend that the actor be a struct, but it could also be a map or any other kind of value.

Some example actor types used in practice:

+ `%MyApp.Accounts.User{}`
+ `%MyApp.Accounts.Device{}`
+ `%MyApp.SystemUser{}`

Actors can be used in a number of places, from modifying the behavior of an action to auditing who did what in your system. They are most prominent, however, when writing policies.

See the Actors & Authorization guide for more.

## Aggregate

An aggregate is a special type of field for a resource, one that summarizes related information of the record. A more specialized type of a calculation.

If a Project resource has\_many Ticket resources, an example of an aggregate on the Project might be to count the tickets associated to each project.

See the Aggregates guide for more.

## Attribute

A piece of data belonging to a resource. The most basic building block; an attribute has a type and a value. For resources backed by a data layer, they typically represent a column in a database table, or a key in an object store, for example.

See the Attributes guide for more.

## Authorizer

An authorizer is an extension that can be added to a resource that will be given the opportunity to modify and/or prevent requests to a resource. In practice, you will almost always be using `Ash.Policy.Authorizer`, but you can still write your own if you need to.

See the Actors & Authorization and Policies guides for more.

## Calculation

A calculation is a special type of field for a resource, one that is not directly stored in the data layer but generated on-demand. Typically it will derive from other information on the record, but it may come from some other data source entirely.

See the Calculations guide for more.

## Changeset

Changesets encapsulate data changes made while creating or updating an instance of a resource. Similarly to Ecto changesets, they include data validations but they also have their own callback hook lifecycle.

See `Ash.Changeset` for more.

## Domain

A method of broadly separating resources into different domains, A.K.A bounded contexts.

See the Domains guide for more.

## Extension

A packaged bundle of code that can be included in a resource to provide additional functionality. Built-in functionality such as the resource DSL itself is provided by an extension, and libraries like AshPostgres and AshAdmin also provide extensions that you can add to your resources with just one line of code.

See Extending Resources for more.

## Filter

Filters are applied to queries to limit the data returned. They can also be applied to changesets, to ensure only data matching a certain condition is updated. For example:

+ Fetching Articles that include a certain search term in the title
+ Fetching Posts created by a specific user
+ Fetching Tickets updated in the last week
+ Updating a record only if it's version matches your in memory version \(optimistic locking\)

See `Ash.Filter` for more.

## Identity

A way to uniquely identify an instance of a resource. A primary key is an example of an identity that is automatically generated; you can manually add others such as a user's email address, or a URL slug for a post. If using AshPostgres, constraints will be created by the migration generator to enforce identities at the database level.

See the Identities guide for more.

## Notifier

Notifiers are modules that are called for each action that occurs on a resource \(except generic actions\). They are called at the end of transactions, meaning that if a notifier is called, it is guaranteed that the action they pertain to has completed successfully.

See the Notifiers guide for more.

## Policy

A set of rules defining who is authorized to perform specific actions on a resource. Common policy checks include rules such as:

+ Forbidding anyone other than the user who wrote a blog post, from editing it
+ Allowing only admins to update site-wide settings

See the Policies guide for more.

## Query

The tools and functions used for reading and filtering stored data, from the data layer.

See `Ash.Query` for more.

## Record

A record is an "instance" of a resource. Keep in mind that this is not an "instance" in a mutable/object-oriented sense, but rather a snapshot of the data at a given point in time. When you call a read action, you get back records. You can provide a record to an update action to determine what data is being updated.

## Relationship

Relationships are named links between resources, that define how they relate to each other. Relationships can be used to signify ownership of a record, membership of a group, or can be used in filtering and querying data.

See the Relationships guide for more.

## Resource

The central concept in Ash, a resource can be used to model all kinds of things. Most often, they will map to a data store, and represent things like rows of a database table. However, they can also be backed by external data sources, be used for validating data with no persistence at all, or even be simple containers for generic actions, completely stateless.

See the Resource DSL docs for DSL documentation.

## Tenant

Multitenancy is the siloing of your app's data into discrete non-overlapping groups, typically by customer or organization \(the tenant\). Ash supports multitenancy both at the code level and the data layer level \(depending on the data layer; for example, AshPostgres uses schemas to fully separate data per tenant.\)

See the Multitenancy guide for more.



# Expressions

Ash expressions are used in various places like calculations, filters, and policies, and are meant to be portable representations of elixir expressions. You can create an expression using the `Ash.Expr.expr/1` macro, like so:

    Ash.Expr    .    expr    (    1         +         2    )        Ash.Expr    .    expr    (    x         +         y    )        Ash.Expr    .    expr    (    post    .    title         <>         " | "         <>         post    .    subtitle    )

### Ash Expressions are SQL-ish

Ash expressions have some interesting properties in their evaluation, primarily because they are made to be portable, i.e executable in some data layer \(like SQL\) or executable in Elixir. In general, these expressions will behave the same way they do in Elixir. The primary difference is how `nil` values work. They behave the way that `NULL` values behave in SQL. This is primarily because this pattern is easier to replicate to various popular data layers, and is generally safer when using expressions for things like authentication. The practical implications of this are that `nil` values will "poison" many expressions, and cause them to return `nil`. For example, `x + nil` would always evaluate to `nil`. Additionally, `true and nil` will always result in `nil`, *this is also true with or and not*, i.e `true or nil` will return `nil`, and `not nil` will return `nil`.

Additionally, atoms and strings compare as if the atom was a string. This is because most external data layers do not know about atoms, and so they are converted to strings before comparison.

## Operators

The following operators are available and they behave the same as they do in Elixir, except for the `nil` addendum above.

+ `==`
+ `!=`
+ `>`
+ `>=`
+ `<`
+ `<=`
+ `in`
+ `*`
+ `-`
+ `/`
+ `<>`
+ `and` - Boolean and operator
+ `or` - Boolean or operator
+ `||` - Elixir-ish or operator, if left is not `nil` or `false`, then left. Othewise right.
+ `&&` - Elixir-ish and operator, if left is not `nil` or `false`, then right. Otherwise left.
+ 
`is_nil` | Only works as an operator in maps/keyword list syntax. i.e `[x: [is_nil: true]]`


### Elixir-ish operators

Prefer to use `and` and `or` if you are dealing with booleans, as they will typically perform much better in SQL data layers. `&&` and `||` should only be used when you want to deal with more than boolaens.

For example:

    calculate         :identifier    ,         expr    (    manual_identifier         ||         employee_id         <>         " "         <>         location_code    )

## Functions

The following functions are built in. Data Layers can add their own functions to expressions. For example, `AshPostgres` adds `trigram_similarity` function.

The following functions are built in:

+ 
`if` | Works like elixir's `if`.

+ 
`is_nil/1` | Works like elixir's `is_nil`

+ 
`get_path/2` | i.e `get_path(value, ["foo", "bar"])`. This is what expressions like `value[:foo]["bar"]` are turned into under the hood.

+ 
`contains/2` | if one string contains another string, i.e `contains("fred", "red")`

+ 
`length/1` | the length of a list, i.e. `length([:foo, :bar])`

+ 
`type/2` | Cast a given value to a specific type, i.e `type(^arg(:id), :uuid)` or `type(integer_field, :string)`

+ 
`string_downcase/1` | Downcases a string

+ 
`string_join/1` | Concatenates a list of strings, and ignores any nil values

+ 
`string_join/2` | As above, but with a joiner

+ 
`string_position/2` | Returns the zero-based position of a substring within a string, or nil, i.e. `string_position("fred", "red") == 1`

+ 
`string_split/1` | Splits a string on spaces

+ 
`string_split/2` | As above, but with a specific delimiter

+ 
`string_split/3` | As above, but with options. See the function for the available options.

+ 
`string_length/1` | Returns the length of a given string, as reported by `String.length/1`

+ 
`string_trim/1` | Trims unicode whitespace from the beginning and the end of a string

+ 
`at/2` | Get an element from a list, i.e `at(list, 1)`

+ 
`round/1` | Round a float, decimal or int to 0 precision, i.e `round(num)`

+ 
`round/2` | Round a float, decimal or int to the provided precision or less, i.e `round(1.1234, 3) == 1.1234` and `round(1.12, 3) == 1.12`

+ 
String interpolation | `"#{first_name} #{last_name}"`, is remapped to the equivalent usage of `<>`

+ 
`fragment/*` | Creates a fragment of a data layer expression. See the section on fragments below.

+ 
`error/2` | Raises an error with a given exception module and parameters. See the section on error expressions below.


## Fragments

Fragments come in two forms.

## String Fragments

For SQL/query-backed data layers, they will be a string with question marks for interpolation. For example: `fragment("(? + ?)", foo, bar)`.

## Function Fragments

For elixir-backed data layers, they will be a function or an MFA that will be called with the provided arguments. For example: `fragment(&Module.add/2, foo, bar)` or `fragment({Module, :add, []}, foo, bar)`. When using anonymous functions, you can *only* use the format `&Module.function/arity`. `&Module.add/2` is okay, but `fn a, b -> Module.add(a, b) end` is not.

## Sub-expressions

+ 
`exists/2` | `exists(foo.bar, name == "fred")` takes an expression scoped to the destination resource, and checks if any related entry matches. See the section on `exists` below.

+ 
`path.exists/2` | Same as `exists` but the source of the relationship is itself a nested relationship. See the section on `exists` below.

+ 
`parent/1` | Allows an expression scoped to a resource to refer to the "outer" context. Used in relationship filters and `exists`


## DateTime Functions

+ 
`now/0` | Evaluates to the current time when the expression is evaluated

+ 
`today/0` | Evaluates to the current date when the expression is evaluated

+ 
`ago/2` | i.e `deleted_at > ago(7, :day)`. The available time intervals are documented in `Ash.Type.DurationName`

+ 
`from_now/2` | Same as `ago` but adds instead of subtracting

+ 
`datetime_add/3` | add an interval to a datetime, i.e `datetime_add(^datetime, 10, :hour)`

+ 
`date_add/3` | add an interval to a date, i.e `date_add(^date, 3, :day)`

+ 
`start_of_day/1-2` | Converts a date or a datetime to the correspond start of its day \(at 00:00 time\).


## Primitives

+ `cond` - `cond` is transformed to a series of `if` expressions under the hood
+ `item[:key] or item["key"]` - accesses keys in a map. In both cases, it prefers a matching atom key, falling back to a matching string key. This is to aid with data stores that store embeds as JSON with string keys \(like AshPostgres\), so that this expression behaves the same in the data layer as it does in Elixir.

## Escape Hatches

+ `lazy/1` - Takes an MFA and evaluates it just before running the query. This is important for calculations, because the `expression/2` callback should be *stable* \(returns the same value given the same input\). For example `lazy({ULID, :generate, [timestamp_input]})`

## Inline Aggregates

Aggregates can be referenced in-line, with their relationship path specified and any options provided that match the options given to `Ash.Query.Aggregate.new/4`. For example:

    calculate         :grade    ,         :decimal    ,         expr    (    
          count    (    answers    ,         query    :         [    filter    :         expr    (    correct         ==         true    )    ]    )         /    
          count    (    answers    ,         query    :         [    filter    :         expr    (    correct         ==         false    )    ]    )        )

The available aggregate kinds can also be seen in the `Ash.Query.Aggregate` module documentation.

## Templates

Most of the time, when you are using an expression, you will actually be creating a *template*. In this template, you have a few references that can be used, which will be replaced before the expression is evaluated. The following references are available:

    ^    actor    (    :key    )         # equivalent to `get_in(actor || %{}, [:key])`        ^    actor    (    [    :key1    ,         :key2    ]    )         # equivalent to `get_in(actor || %{}, [:key, :key2])`        ^    arg    (    :arg_name    )         # equivalent to `Map.get(arguments, :arg_name)`        ^    context    (    :key    )         # equivalent to `get_in(context, :key)`        ^    context    (    [    :key1    ,         :key2    ]    )         # equivalent to `get_in(context, [:key1, :key2])`        ^    ref    (    :key    )         # equivalent to referring to `key`. Allows for dynamic references        ^    ref    (    [    :path    ]    ,         :key    )         # equivalent to referring to `path.key`. Allows for dynamic references with dynamic (or static) paths.

## Custom Expressions

Custom expressions allow you to extend Ash's expression language with your own expressions. To see more, see `Ash.CustomExpression`. To add a custom expression, configure it and recompile ash. For example:

    config         :ash    ,         :custom_expressions    ,         [    
          MyApp.CustomExpression        ]

    mix         deps    .    compile         ash         --    force

These expressions will be available across all usages of Ash expressions within your application.

## Filter semantics & joins

The semantics of Ash filters are probably slightly different than what you are used to, and they are important to understand. Every filter expression is always talking about a single row, potentially "joined" to single related rows. By referencing relationships, you are implicitly doing a join. For those familiar with SQL terminology, it is equivalent to a left join, although AshPostgres can detect when it is safe to do an inner join \(for performance reasons\). Lets use an example of `posts` and `comments`.

Given a filter like the following:

    Ash.Query    .    filter    (    Post    ,         comments    .    points         >         10         and         comments    .    tag    .    name         ==         "elixir"    )

The filter refers to a *single post/comment/tag combination*. So in english, this is "posts where they have a comment with more than 10 points and *that same comment* has a tag with the name `elixir`". What this also means is that filters like the above do not compose nicely when new filters are added. For example:

    def         has_comment_with_more_points_than    (    query    ,         score    )         do    
          Ash.Query    .    filter    (    query    ,         comments    .    points         >         ^    score    )        end    
        def         has_comment_tagged    (    query    ,         tag    )         do    
          Ash.Query    .    filter    (    query    ,         comments    .    tag    .    name         ==         ^    tag    )        end    
        Post        |>         has_comment_with_more_points_than    (    10    )        |>         has_comment_tagged    (    "elixir"    )

That code *seems* like it ought to produce a filter over `Post` that would give us any post with a comment having more than 10 points, *and* with a comment tagged `elixir`. That is not the same thing as having a *single* comment that meets both those criteria. So how do we make this better?

### Many-to-many relationships

When working with expressions that join many-to-many relationships, there may be cases that you wish to refer to "the join row that connects these two things". For example, to sort a many-to-many relationship by the `position` on the join row. For this, we have special-cased references to `parent(join_relationship_name)` to refer to *specifically* the join row that connects the two records.

This allows for things like this:

    many_to_many         :tags    ,         MyDomain.Tag         do    
          through         MyDomain.PostTag    
          join_relationship         :post_tags    
          sort         [    calc    (    parent    (    post_tags    .    position    )    )    ]        end

### Exists

Lets rewrite the above using exists:

    def         has_comment_with_more_points_than    (    query    ,         score    )         do    
          Ash.Query    .    filter    (    query    ,         exists    (    comments    ,         points         >         ^    score    )    )        end    
        def         has_comment_tagged    (    query    ,         tag    )         do    
          Ash.Query    .    filter    (    query    ,         exists    (    comments    .    tag    ,         name         ==         ^    tag    )    )        end    
        Post        |>         has_comment_with_more_points_than    (    10    )        |>         has_comment_tagged    (    "elixir"    )

Now, they will compose properly\! Generally speaking, you should use exists when you are filtering across any relationships that are `to_many` relationships \*even if you don't expect your filter to be composed. Currently, the filter syntax does not minimize\(combine\) these `exists/2` statements, but doing so is not complex and can be added. While unlikely, please lodge an issue if you see any performance issues with `exists`.

### Exists at path

Sometimes, you want the ability to say that some given row must have an existing related entry matching a filter. For example:

    Ash.Query    .    filter    (    Post    ,         author    .    exists    (    roles    ,         name         ==         :admin    )         and         author    .    active    )

While the above is not common, it can be useful in some specific circumstances, and is used under the hood by the policy authorizer when combining the filters of various resources to create a single filter.

## Portability

Ash expressions being portable is more important than it sounds. For example, if you were using AshPostgres and had the following calculation, which is an expression capable of being run in elixir or translated to SQL:

    calculate         :full_name    ,         :string    ,         expr    (    first_name         <>         " "         <>         last_name    )

And you did something like the following:

    User        |>         Ash.Query    .    load    (    :full_name    )        |>         Ash.Query    .    sort    (    :full_name    )        |>         Accounts    .    read!    (    )

You would see that it ran a SQL query with the `full_name` calculation as SQL. This allows for sorting on that value. However, if you had something like this:

    # data can be loaded in the query like above, or on demand later        Accounts    .    load!    (    user    ,         :full_name    ,         reuse_values?    :         true    )

you would see that no SQL queries are run. The calculation is run directly in Elixir without needing to visit the database.

## Parent

`Parent` is a way to "jump out" of a scoped expression. Here are some examples:

    Ash.Query    .    filter    (    exists    (    open_tickets    ,         severity         >=         parent    (    severity_threshold    )    )    )

    has_many         :relevant_tickets    ,         Ticket         do    
          no_attributes?         true    
          # this says that there is no matching source_attribute and destination_attribute on this relationship    
          filter         expr    (    status         ==         :open         and         severity         >=         parent    (    severity_threshold    )    )        end

    count         :count_of_relevant_tickets    ,         :open_tickets         do    
          filter         expr    (    status         ==         :open         and         severity         >=         parent    (    severity_threshold    )    )        end

### Referencing related values

Related values can be references using dot delimiters, i.e `Ash.Query.filter(user.first_name == "fred")`. When referencing related values in filters, if the reference is a `has_one` or `belongs_to`, the filter does exactly what it looks like \(matches if the related value matches\). If it is a `has_many` or a `many_to_many`, it matches if any of the related records match.

### Referencing aggregates and calculations

Aggregates are simple, as all aggregates can be referenced in filter expressions \(if you are using a data layer that supports aggregates\).

For calculations, only those that define an expression can be referenced in other expressions.

Here are some examples:

    # given a `full_name` calculation    
        Ash.Query    .    filter    (    User    ,         full_name         ==         "Hob Goblin"    )    
        # given a `full_name` calculation that accepts an argument called `delimiter`    
        Ash.Query    .    filter    (    User    ,         full_name    (    delimiter    :         "~"    )         ==         "Hob~Goblin"    )

## Case vs Cond Expressions

When working with conditional expressions in Ash, you should use `cond` instead of `case` statements. Here's an example:

    # This works - using cond        calculations         do    
          calculate         :user_order    ,         :integer    ,         expr    (    
            cond         do    
              role         ==         :principal         ->         1    
              role         ==         :teacher         ->         2    
              role         ==         :student         ->         3    
            end    
          )        end    
        # This doesn't work - using case        calculations         do    
          calculate         :user_order    ,         :integer    ,         expr    (    
            case         role         do    
              :principal         ->         1    
              :teacher         ->         2    
              :student         ->         3    
            end    
          )        end

The `cond` expression is the correct way to handle conditional logic in Ash expressions.

## Error Expressions

The `error/2` function is used within atomic validations, changes, and calculations to conditionally raise errors. It takes two arguments:

1. An exception module \(typically an Ash error module\)
2. A map of parameters for the exception

### Basic Usage

    error    (    Ash.Error.Changes.InvalidAttribute    ,         %{    
          field    :         :price    ,    
          value    :         ^    atomic_ref    (    :price    )    ,    
          message    :         "must be greater than 0"        }    )

### Common Pattern in Validations

The `error/2` function is commonly used in atomic validations to produce errors when conditions are not met:

    # In an atomic validation        {    :atomic    ,         [    :price    ]    ,         expr    (    ^    atomic_ref    (    :price    )         <=         0    )    ,    
         expr    (    
           error    (    ^    InvalidAttribute    ,         %{    
             field    :         :price    ,    
             value    :         ^    atomic_ref    (    :price    )    ,    
             message    :         "must be greater than 0"    
           }    )    
         )    }

### Usage in Calculations for Unreachable Branches

The `error/2` function is useful in calculations to handle cases that should never occur, making unreachable code paths explicit:

    calculate         :status_label    ,         :string    ,         expr    (    
          cond         do    
            status         ==         :active         ->         "Active"    
            status         ==         :inactive         ->         "Inactive"    
            status         ==         :pending         ->         "Pending"    
            true         ->         error    (    Ash.Error.Framework.AssumptionFailed    ,         %{    
              message    :         "Unexpected status value: %{status}"    ,    
              vars    :         %{    status    :         status    }    
            }    )    
          end        )

### Example with Variables

You can include variables for message interpolation:

    error    (    Ash.Error.Changes.InvalidChanges    ,         %{    
          message    :         "must be less than or equal to %{max}"    ,    
          vars    :         %{    max    :         ^    max    }        }    )

### Common Error Modules

+ `Ash.Error.Changes.InvalidAttribute` - Used for attribute validation errors
+ `Ash.Error.Changes.InvalidChanges` - Used for general change validation errors
+ `Ash.Error.Changes.StaleRecord` - Used for optimistic locking violations
+ `Ash.Error.Framework.AssumptionFailed` - Used for unreachable code or violated assumptions

### Usage in Atomic Operations

The `error/2` function is essential for atomic operations, allowing you to specify exactly what error should be raised when validation conditions fail:

    # In a compare validation        atomic_update    (    :status    ,     
          expr    (    
            if         ^    atomic_ref    (    :score    )         >         100         do    
              error    (    ^    InvalidAttribute    ,         %{    
                field    :         :score    ,    
                value    :         ^    atomic_ref    (    :score    )    ,    
                message    :         "score cannot exceed 100"    
              }    )    
            else    
              :valid    
            end    
          )        )

For more information about error handling in Ash, see the Error Handling guide.



# Domains

Domains serve three primary purposes:

1. They group related resources together, providing organization and structure to your project.
2. They allow you to define a centralized code interface
3. They allow you to configure certain cross-cutting concerns of those resources in a single place.

If you are familiar with a Phoenix Context, you can think of a domain as the Ash equivalent.

## Grouping Resources

In an `Ash.Domain`, you will typically see something like this:

    defmodule         MyApp.Tweets         do    
          use         Ash.Domain    

          resources         do    
            resource         MyApp.Tweets.Tweet    
            resource         MyApp.Tweets.Comment    
          end        end

With this definition, you can do things like placing all of these resources into a GraphQL Api with AshGraphql. You'd see a line like this:

    use         AshGraphql    ,         domains    :         [    MyApp.Tweets    ]

## Centralized **Code Interface**

Working with our domain & resources in code *can* be done the long form way, by building changesets/queries/action inputs and calling the relevant function in `Ash`. However, we generally want to expose a well defined code API for working with our resources. This makes our code much clearer, and gives us nice things like auto complete and inline documentation.

    defmodule         MyApp.Tweets         do    
          use         Ash.Domain    

          resources         do    
            resource         MyApp.Tweets.Tweet         do    
              # define a function called `tweet` that uses    
              # the `:create` action on MyApp.Tweets.Tweet    
              define         :tweet    ,         action    :         :create    ,         args    :         [    :text    ]    
            end    

            resource         MyApp.Tweets.Comment         do    
              # define a function called `comment` that uses    
              # the `:create` action on MyApp.Tweets.Comment    
              define         :comment    ,         action    :         :create    ,         args    :         [    :tweet_id    ,         :text    ]    
            end    
          end        end

With these definitions, we can now do things like this:

    tweet         =         MyApp.Tweets    .    tweet!    (    "My first tweet!"    ,         actor    :         user1    )        comment         =         MyApp.Tweets    .    comment!    (    tweet    .    id    ,         "What a cool tweet!"    ,         actor    :         user2    )

## Configuring Cross-cutting Concerns

### Built in configuration

`Ash.Domain` comes with a number of built-in configuration options. See `d:Ash.Domain` for more.

For example:

    defmodule         MyApp.Tweets         do    
          use         Ash.Domain    

          resources         do    
            resource         MyApp.Tweets.Tweet    
            resource         MyApp.Tweets.Comment    
          end    

          execution         do    
            # raise the default timeout for all actions in this domain from 30s to 60s    
            timeout         :timer    .    seconds    (    60    )    
          end    

          authorization         do    
            # disable using the authorize?: false flag when calling actions    
            authorize         :always    
          end        end

### Extensions

Extensions will often come with "domain extensions" to allow you to configure the behavior of all resources within a domain, as it pertains to that extension. For example:

    defmodule         MyApp.Tweets         do    
          use         Ash.Domain    ,    
            extensions    :         [    AshGraphql.Domain    ]    

          graphql         do    
            # skip authorization for these resources    
            authorize?         false    
          end    

          resources         do    
            resource         MyApp.Tweets.Tweet    
            resource         MyApp.Tweets.Comment    
          end        end

### Policies

You can also use `Ash.Policy.Authorizer` on your domains. This allows you to add policies that apply to *all* actions using this domain. For example:

    defmodule         MyApp.Tweets         do    
          use         Ash.Domain    ,    
            extensions    :         [    Ash.Policy.Authorizer    ]    

          resources         do    
            resource         MyApp.Tweets.Tweet    
            resource         MyApp.Tweets.Comment    
          end    

          policies         do    
            # add a bypass up front to allow administrators to do whatever they want    
            bypass         actor_attribute_equals    (    :is_admin    ,         true    )         do    
              authorize_if         always    (    )    
            end    

            # forbid all access from disabled users    
            policy         actor_attribute_equals    (    :disabled    ,         true    )         do    
              forbid_if         always    (    )    
            end    
          end        end



# Attributes

Attributes specify the `name`, `type` and additional configuration of a simple property of a record. When using SQL data layers, for example, an attribute would correspond to a column in a database table. For information on types, see `Ash.Type`.

To see all of the options available when building attributes, see `d:Ash.Resource.Dsl.attributes.attribute`

If you are looking to compute values on demand, see the Calculations guide and the aggregates guide.

## Special attributes

In Ash there are 4 special attributes these are:

+ `create_timestamp`
+ `update_timestamp`
+ `integer_primary_key`
+ `uuid_primary_key`

These are really just shorthand for an attribute with specific options set. They're outlined below.

### **`create_timestamp`**

You may recognise this if you have used Ecto before. This attribute will record the time at which each row is created, by default it uses `DateTime.utc_now/1`.

`create_timestamp :inserted_at` is equivalent to an attribute with these options:

    attribute         :inserted_at    ,         :utc_datetime_usec         do    
          writable?         false    
          default         &    DateTime    .    utc_now    /    0    
          match_other_defaults?         true    
          allow_nil?         false        end

### **`update_timestamp`**

This is also similar in Ecto. This attribute records the last time a row was updated, also using `DateTime.utc_now/1` by default.

`update_timestamp :updated_at` is equivalent to:

    attribute         :updated_at    ,         :utc_datetime_usec         do    
          writable?         false    
          default         &    DateTime    .    utc_now    /    0    
          update_default         &    DateTime    .    utc_now    /    0    
          match_other_defaults?         true    
          allow_nil?         false        end

### **`uuid_primary_key`**

This attribute is used in almost every resource. It generates a UUID every time a new record is made. `uuid_primary_key :id` is equivalent to:

    attribute         :id    ,         :uuid         do    
          writable?         false    
          default         &    Ash.UUID    .    generate    /    0    
          primary_key?         true    
          allow_nil?         false        end

### **`integer_primary_key`**

Creates a generated integer primary key. Keep in mind that not all data layers support auto incrementing ids, but for SQL data layers this is a very common practice. For those that don't, it is your own job to provide values for the primary key. We generally suggest using UUIDs over integers, as there are a lot of good reasons to not use autoincrementing integer ids.

`integer_primary_key :id` is equivalent to:

    attribute         :id    ,         :integer         do    
          writable?         false    
          generated?         true    
          primary_key?         true    
          allow_nil?         false        end



# Relationships

Relationships describe the connections between resources and are a core component of Ash. Defining relationships enables you to do things like

+ Loading related data
+ Filtering on related data
+ Managing related records through changes on a single resource
+ Authorizing based on the state of related data

## Relationships Basics

A relationship exists between a source resource and a destination resource. These are defined in the `relationships` block of the source resource. For example, if `MyApp.Tweet` is the source resource, and `MyApp.User` is the destination resource, we could define a relationship called `:owner` like this:

    defmodule         MyApp.Tweet         do    
          use         Ash.Resource    ,    
            data_layer    :         my_data_layer    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :body    ,         :string    
          end    

          relationships         do    
            belongs_to         :owner    ,         MyApp.User    
          end        end

## Kinds of relationships

There are four kinds of relationships:

+ `belongs_to`
+ `has_one`
+ `has_many`
+ `many_to_many`

Each of these relationships has a `source` resource and a `destination` resource with a corresponding attribute on the source resource \(`source_attribute`\), and destination resource \(`destination_attribute`\). Relationships will validate that their configured attributes exist at compile time.

You don't need to have a corresponding "reverse" relationship for every relationship, i.e if you have a `MyApp.Tweet` resource with `belongs_to :user, MyApp.User` you aren't required to have a `has_many :tweets, MyApp.Tweet` on `MyApp.User`. All that is required is that the attributes used by the relationship exist.

### Belongs To

    # on MyApp.Tweet        belongs_to         :owner    ,         MyApp.User

A `belongs_to` relationship means that there is an attribute \(`source_attribute`\) on the source resource that uniquely identifies a record with a matching attribute \(`destination_attribute`\) in the destination. In the example above, the source attribute on `MyApp.Tweet` is `:owner_id` and the destination attribute on `MyApp.User` is `:id`.

#### Attribute Defaults

By default, the `source_attribute` is defined as `:<relationship_name>_id` of the type `:uuid` on the source resource and the `destination_attribute` is assumed to be `:id`. You can override the attribute names by specifying the `source_attribute` and `destination_attribute` options like so:

    belongs_to         :owner    ,         MyApp.User         do    
          # defaults to :<relationship_name>_id (i.e. :owner_id)    
          source_attribute         :custom_attribute_name    

          # defaults to :id    
          destination_attribute         :custom_attribute_name        end

You can further customize the `source_attribute` using options such as:

+ `d:Ash.Resource.Dsl.relationships.belongs_to|define_attribute?` to define it yourself
+ `d:Ash.Resource.Dsl.relationships.belongs_to|attribute_type` to modify the default type
+ `d:Ash.Resource.Dsl.relationships.belongs_to|attribute_public?` to make the source attribute `public?: true`

For example:

    belongs_to         :owner    ,         MyApp.User         do    
          attribute_type         :integer    
          attribute_writable?         false        end

Or if you wanted to define the attribute yourself,

    attributes         do    
          attribute         :owner_foo    ,         MyApp.CustomType        end    
        ...        relationships         do    
          belongs_to         :owner    ,         MyApp.User         do    
            define_attribute?         false    
            source_attribute         :owner_foo    
          end        end

#### Customizing default belongs\_to attribute type

Destination attributes that are added by default are assumed to be `:uuid`. To change this, set the following configuration in `config.exs`:

    config         :ash    ,         :default_belongs_to_type    ,         :integer

See the docs for more: `d:Ash.Resource.Dsl.relationships.belongs_to`

### Has One

    # on MyApp.User        has_one         :profile    ,         MyApp.Profile

A `has_one` relationship means that there is a unique attribute \(`destination_attribute`\) on the destination resource that identifies a record with a matching unique attribute \(`source_resource`\) in the source. In the example above, the source attribute on `MyApp.User` is `:id` and the destination attribute on `MyApp.Profile` is `:user_id`.

A `has_one` is similar to a `belongs_to` except the reference attribute is on the destination resource, instead of the source.

#### Attribute Defaults

By default, the `source_attribute` is assumed to be `:id`, and `destination_attribute` defaults to `<snake_cased_last_part_of_module_name>_id`.

See the docs for more: `d:Ash.Resource.Dsl.relationships.has_one`

### Has Many

    # on MyApp.User        has_many         :tweets    ,         MyApp.Tweet

A `has_many` relationship means that there is a non-unique attribute \(`destination_attribute`\) on the destination resource that identifies a record with a matching attribute \(`source_attribute`\) in the source. In the example above, the source attribute on `MyApp.User` is `:id` and the destination attribute on `MyApp.Tweet` is `:user_id`.

A `has_many` relationship is similar to a `has_one` because the reference attribute exists on the destination resource. The only difference between this and `has_one` is that the destination attribute is not unique, and therefore will produce a list of related items. In the example above, `:tweets` corresponds to a list of `MyApp.Tweet` records.

#### Attribute Defaults

By default, the `source_attribute` is assumed to be `:id`, and `destination_attribute` defaults to `<snake_cased_last_part_of_module_name>_id`.

See the docs for more: `d:Ash.Resource.Dsl.relationships.has_many`

### Many To Many

A `many_to_many` relationship can be used to relate many source resources to many destination resources. To achieve this, the `source_attribute` and `destination_attribute` are defined on a join resource. A `many_to_many` relationship can be thought of as a combination of a `has_many` relationship on the source/destination resources and a `belongs_to` relationship on the join resource.

For example, consider two resources `MyApp.Tweet` and `MyApp.Hashtag` representing tweets and hashtags. We want to be able to associate a tweet with many hashtags, and a hashtag with many tweets. To do this, we could define the following `many_to_many` relationship:

    # on MyApp.Tweet        many_to_many         :hashtags    ,         MyApp.Hashtag         do    
          through         MyApp.TweetHashtag    
          source_attribute_on_join_resource         :tweet_id    
          destination_attribute_on_join_resource         :hashtag_id        end

The `through` option specifies the "join" resource that will be used to store the relationship. We need to define this resource as well:

    defmodule         MyApp.TweetHashtag         do    
          use         Ash.Resource    ,    
            data_layer    :         your_data_layer    

          postgres         do    
            table         "tweet_hashtags"    
            repo         MyApp.Repo    
          end    

          relationships         do    
            belongs_to         :tweet    ,         MyApp.Tweet    ,         primary_key?    :         true    ,         allow_nil?    :         false    
            belongs_to         :hashtag    ,         MyApp.Hashtag    ,         primary_key?    :         true    ,         allow_nil?    :         false    
          end    

          actions         do    
            defaults         [    :read    ,         :destroy    ,         create    :         :*    ,         update    :         :*    ]    
          end        end

It is convention to name this resource `<source_resource_name><destination_resource_name>` however this is not required. The attributes on the join resource must match the `source_attribute_on_join_resource` and `destination_attribute_on_join_resource` options on the `many_to_many` relationship. The relationships on the join resource are standard `belongs_to` relationships, and can be configured as such. In this case, we have specified that the `:tweet_id` and `:hashtag_id` attributes form the primary key for the join resource, and that they cannot be `nil`.

Now that we have a resource with the proper attributes, Ash will use this automatically under the hood when performing relationship operations like filtering and loading.

See the docs for more: `d:Ash.Resource.Dsl.relationships.many_to_many`

## Loading related data

There are two ways to load relationships:

+ in the query using `Ash.Query.load/2`
+ directly on records using `Ash.load/3`

### On records

Given a single record or a set of records, it is possible to load their relationships by calling the `load` function on the record's parent domain. For example:

    # user = %User{...}        Ash    .    load    (    user    ,         :tweets    )    
        # users = [%User{...}, %User{...}, ....]        Ash    .    load    (    users    ,         :tweets    )

This will fetch the tweets for each user, and set them in the corresponding `tweets` key.

    %    User    {    
          ...    
          tweets    :         [    
            %    Tweet    {    ...    }    ,    
            %    Tweet    {    ...    }    ,    
            ...    
          ]        }

See `Ash.load/3` for more information.

### In the query

The following will return a list of users with their tweets loaded identically to the previous example:

    User        |>         Ash.Query    .    load    (    :tweets    )        |>         Ash    .    read    (    )

At present, loading relationships in the query is fundamentally the same as loading on records. Eventually, data layers will be able to optimize these loads \(potentially including them as joins in the main query\).

See `Ash.Query.load/2` for more information.

### More complex data loading

Multiple relationships can be loaded at once, i.e

    Ash    .    load    (    users    ,         [    :tweets    ,         :followers    ]    )

Nested relationships can be loaded:

    Ash    .    load    (    users    ,         followers    :         [    :tweets    ,         :followers    ]    )

The queries used for loading can be customized by providing a query as the value.

    followers         =         Ash.Query    .    sort    (    User    ,         follower_count    :         :asc    )    
        Ash    .    load    (    users    ,         followers    :         followers    )

Nested loads will be included in the parent load.

    followers         =    
          User    
          |>         Ash.Query    .    sort    (    follower_count    :         :asc    )    
          |>         Ash.Query    .    load    (    :followers    )    
        # Will load followers and followers of those followers        Ash    .    load    (    users    ,         followers    :         followers    )

## no\_attributes? true

This is really useful when creating customized relationships that aren't joined with simple attribute matches. For example:

    has_many         :higher_priority_tickets    ,         __MODULE__         do    
          no_attributes?         true    
          # parent/1 in this case puts the expression on this current resource    
          # so this is "tickets with priority higher than this ticket"    
          filter         expr    (    priority         >         parent    (    priority    )    )        end

This can also be useful when combined with schema-based multitenancy. Specifically, if you have a tenant resource like `Organization`, you can use `no_attributes?` to do things like `has_many :employees, Employee, no_attributes?: true`, which lets you avoid having an unnecessary `organization_id` field on `Employee`. The same works in reverse: `has_one :organization, Organization, no_attributes?: true` allows relating the employee to their organization.

You can also use `no_attributes? true` with attribute-based multitenancy in the same situation described above, to avoid an unnecessary second filter. If both resources have attribute multitenancy configured, they will already be filtered by `organization_id` by virtue of having set the tenant.

### Caveats for using `no_attributes?`

1.  You can still manage relationships from one to the other, but "relate" and "unrelate" will have no effect, because there are no fields to change.
2.  Loading the relationship on a list of resources will not behave as expected in all circumstances involving multitenancy. For example, if you get a list of `Organization` and then try to load `employees`, you would need to set a single tenant on the load query, meaning you'll get all organizations back with the set of employees from one tenant. This could eventually be solved, but for now it is considered an edge case.

## Manual Relationships

Manual relationships allow you to express complex or non-typical relationships between resources in a standard way. Individual data layers may interact with manual relationships in their own way, so see their corresponding guides. In general, you should try to use manual relationships sparingly, as you can do *a lot* with filters on relationships, and the `no_attributes?` flag.

### Example

In our Helpdesk example, we'd like to have a way to find tickets

In the `Representative` resource, define a `has_many` relationship as `manual` and point to the module where it will be implemented.

    relationships         do    
          has_many         :tickets_above_threshold    ,         Helpdesk.Support.Ticket         do    
            manual         Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold    
          end        end

Using Ash to get the destination records is ideal, so you can authorize access like normal but if you need to use a raw ecto query here, you can. As long as you return the right structure.

The `TicketsAboveThreshold` module is implemented as follows.

    defmodule         Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold         do    
          use         Ash.Resource.ManualRelationship    
          require         Ash.Query    

          def         load    (    records    ,         _opts    ,         %{    query    :         query    }         =         context    )         do    
            # Use existing records to limit results    
            rep_ids         =         Enum    .    map    (    records    ,         &         &1    .    id    )    

            {    :ok    ,    
             query    
             |>         Ash.Query    .    filter    (    representative_id         in         ^    rep_ids    )    
             |>         Ash.Query    .    filter    (    priority         >         representative    .    priority_threshold    )    
             |>         Ash    .    read!    (    Ash.Context    .    to_opts    (    context    )    )    
             # Return the items grouped by the primary key of the source, i.e representative.id => [...tickets above threshold]    
             |>         Enum    .    group_by    (    &         &1    .    representative_id    )    }    
          end        end

### Reusing the Query

Since you likely want to support things like filtering your relationship when being loaded, you will want to make sure that you use the query being provided. However, depending on how you're loading the relationship, you may need to do things like fetch extra records. To do this, you might do things like

    def         load    (    records    ,         _opts    ,         %{    query    :         query    ,         ..    }    )         do    
          # unset some fields    
          fetch_query         =         Ash.Query    .    unset    (    query    ,         [    :limit    ,         :offset    ]    )    

          # or, to be more safe/explicit, you might make a new query, explicitly setting only a few fields    
          fetch_query         =         query    .    resource         |>         Ash.Query    .    filter    (    ^    query    .    filter    )         |>         Ash.Query    .    sort    (    query    .    sort    )    

          ...        end

### Query when loading with strict?: true

When using `Ash.Query.load` or `Ash.load` with the `strict?: true` option, the query that is provided to the load callback might be configured with a select-statement that doesn't load the attributes you want to group matching results by. If your codebase utilizes the strict loading functionality, it is therefore recommended to use `Ash.Query.ensure_selected` on the query to ensure the required attributes are indeed fetched.

        # Here only :id & :priority is set, which will then configure the relationship query to only        # select those attributes        {    :ok    ,         rep    }         =         Ash    .    load    (    representative    ,         [    tickets_above_threshold    :         [    :id    ,         :priority    ]    ]    ,         strict?    :         true    )    
        defmodule         Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold         do    
          use         Ash.Resource.ManualRelationship    
          require         Ash.Query    

          def         load    (    records    ,         _opts    ,         %{    query    :         query    ,         actor    :         actor    ,         authorize?    :         authorize?    }    )         do    
            rep_ids         =         Enum    .    map    (    records    ,         &         &1    .    id    )    

            {    :ok    ,    
             query    
             # If this isn't added, representative_id would be set to %Ash.NotLoaded, causing the    
             # Enum.group_by call below to fail mapping results to the correct records.    
             |>         Ash.Query    .    ensure_selected    (    [    :representative_id    ]    )    
             |>         Ash.Query    .    filter    (    representative_id         in         ^    rep_ids    )    
             |>         Ash.Query    .    filter    (    priority         >         representative    .    priority_threshold    )    
             |>         Helpdesk.Support    .    read!    (    actor    :         actor    ,         authorize?    :         authorize?    )    
             |>         Enum    .    group_by    (    &         &1    .    representative_id    )    }    
          end        end

### Fetching the records and then applying a query

Lets say the records come from some totally unrelated source, or you can't just modify the query to fetch the records you need. You can fetch the records you need and then apply the query to them in memory.

    def         load    (    records    ,         _opts    ,         %{    query    :         query    ,         ..    }    )         do    
          # fetch the data from the other source, which is capable of sorting    
          data         =         get_other_data    (    data    ,         query    .    sort    )    

          query    
          # unset the sort since we already applied that    
          |>         Ash.Query    .    unset    (    [    :sort    ]    )    
          # apply the query in memory (filtering, distinct, limit, offset)    
          |>         Ash.Query    .    apply_to    (    data    )        end

## Managing Relationships

Ash provides two primary approaches for managing related data, each suited to different scenarios:

1. **Using `change manage_relationship/3` in actions** - When input comes from action arguments
2. **Using `Ash.Changeset.manage_relationship/4` directly** - When building values programmatically in custom changes

### When to Use Which Approach

**Use `change manage_relationship/3` when:**

+ Input comes from action arguments \(API endpoints, form submissions\)
+ You want portable logic across different interfaces \(GraphQL, JSON API\)
+ You need standard CRUD operations on relationships
+ The relationship management logic is straightforward

**Use `Ash.Changeset.manage_relationship/4` when:**

+ Building relationship data programmatically in custom changes
+ You need complex logic or data transformation before managing relationships
+ Conditional relationship management based on changeset state
+ Integration with external APIs or complex business rules

#### Order of operations

In destroy actions, relationships are managed **after** the main action is performed. This means if you're using `manage_relationship` to remove related records in a destroy action, and your database has foreign key constraints with "no action" or "restrict" settings, you may encounter constraint violations because Ash tries to destroy the primary resource first.

To work around this, you can:

+ Use the `cascade_destroy` builtin change instead of `manage_relationship`
+ Configure your database constraints to be deferred
+ Use different constraint settings that allow the operation order

### Using **`change manage_relationship/3`** in Actions

This is the most common approach for managing relationships through action arguments:

    actions         do    
          update         :update         do    
            argument         :add_comment    ,         :map         do    
              allow_nil?         false    
            end    

            argument         :tags    ,         {    :array    ,         :uuid    }         do    
              allow_nil?         false    
            end    

            # First argument is the name of the action argument to use    
            # Second argument is the relationship to be managed    
            # Third argument is options. For more, see `Ash.Changeset.manage_relationship/4`.    
            change         manage_relationship    (    :add_comment    ,         :comments    ,         type    :         :create    )    

            # Second argument can be omitted when argument name matches relationship name    
            change         manage_relationship    (    :tags    ,         type    :         :append_and_remove    )    
          end        end

With this setup, you can use the arguments in action input:

    post        |>         Ash.Changeset    .    for_update    (    :update    ,         %{    
          tags    :         [    tag1    .    id    ,         tag2    .    id    ]    ,    
          add_comment    :         %{    text    :         "comment text"    }        }    )        |>         Ash    .    update!    (    )

#### Common Patterns with Actions

**Creating with related data:**

    create         :create_with_author         do    
          argument         :author    ,         :map    ,         allow_nil?    :         false    
          change         manage_relationship    (    :author    ,         type    :         :create    )        end    
        # Usage        Post        |>         Ash.Changeset    .    for_create    (    :create_with_author    ,         %{    
          title    :         "My Post"    ,    
          author    :         %{    name    :         "John Doe"    ,         email    :         "john@example.com"    }        }    )        |>         Ash    .    create!    (    )

**Managing many-to-many relationships:**

    update         :manage_categories         do    
          argument         :category_names    ,         {    :array    ,         :string    }    

          change         manage_relationship    (    :category_names    ,         :categories    ,    
            type    :         :append_and_remove    ,    
            value_is_key    :         :name    ,    
            on_lookup    :         :relate    ,    
            on_no_match    :         :create    
          )        end

**Different argument and relationship names:**

    update         :assign_reviewer         do    
          argument         :reviewer_id    ,         :uuid    
          change         manage_relationship    (    :reviewer_id    ,         :reviewer    ,         type    :         :append_and_remove    )        end

### Using **`Ash.Changeset.manage_relationship/4`** in Custom Changes

For more complex scenarios, you can use `Ash.Changeset.manage_relationship/4` directly in custom changes:

    defmodule         MyApp.Changes.AssignProjectMembers         do    
          use         Ash.Resource.Change    

          def         change    (    changeset    ,         _opts    ,         context    )         do    
            # Get the current user from context    
            current_user         =         context    .    actor    

            # Build relationship data based on business logic    
            members         =         determine_project_members    (    changeset    ,         current_user    )    

            # Manage the relationship directly    
            Ash.Changeset    .    manage_relationship    (    
              changeset    ,    
              :members    ,    
              members    ,    
              type    :         :append_and_remove    ,    
              authorize?    :         true    
            )    
          end    

          defp         determine_project_members    (    changeset    ,         current_user    )         do    
            # Complex logic to determine who should be project members    
            # based on changeset data and business rules    
            # ...    
          end        end

**Conditional relationship management:**

    defmodule         MyApp.Changes.ConditionalTagging         do    
          use         Ash.Resource.Change    

          def         change    (    changeset    ,         _opts    ,         _context    )         do    
            # Only manage tags if certain conditions are met    
            if         should_auto_tag?    (    changeset    )         do    
              tags         =         generate_auto_tags    (    changeset    )    

              Ash.Changeset    .    manage_relationship    (    
                changeset    ,    
                :tags    ,    
                tags    ,    
                type    :         :append    ,    
                on_no_match    :         :create    
              )    
            else    
              changeset    
            end    
          end        end

**Data transformation before relationship management:**

    defmodule         MyApp.Changes.ProcessOrderItems         do    
          use         Ash.Resource.Change    

          def         change    (    changeset    ,         _opts    ,         _context    )         do    
            case         Ash.Changeset    .    fetch_argument    (    changeset    ,         :raw_items    )         do    
              {    :ok    ,         raw_items    }         ->    
                # Transform and validate the raw item data    
                processed_items         =    
                  raw_items    
                  |>         validate_items    (    )    
                  |>         calculate_pricing    (    )    
                  |>         apply_discounts    (    )    

                Ash.Changeset    .    manage_relationship    (    
                  changeset    ,    
                  :items    ,    
                  processed_items    ,    
                  type    :         :direct_control    
                )    

              :error         ->    
                changeset    
            end    
          end        end

### Management Types and Options

Ash provides several built-in management types that configure common relationship management patterns:

#### Management Types

**`:append`** - Add new related records, ignore existing ones

    change         manage_relationship    (    :tags    ,         type    :         :append    )        # Equivalent to:        # on_lookup: :relate, on_no_match: :error, on_match: :ignore, on_missing: :ignore

**`:append_and_remove`** - Add new related records, remove missing ones

    change         manage_relationship    (    :tags    ,         type    :         :append_and_remove    )        # Equivalent to:        # on_lookup: :relate, on_no_match: :error, on_match: :ignore, on_missing: :unrelate

**`:remove`** - Remove specified related records

    change         manage_relationship    (    :tags    ,         type    :         :remove    )        # Equivalent to:        # on_no_match: :error, on_match: :unrelate, on_missing: :ignore

**`:direct_control`** - Full CRUD control over the related records

    change         manage_relationship    (    :comments    ,         type    :         :direct_control    )        # Equivalent to:        # on_lookup: :ignore, on_no_match: :create, on_match: :update, on_missing: :destroy

**`:create`** - Only create new related records

    change         manage_relationship    (    :items    ,         type    :         :create    )        # Equivalent to:        # on_no_match: :create, on_match: :ignore

#### Key Options

**`on_lookup`** - How to handle records that might exist elsewhere:

+ `:ignore` - Don't look up existing records
+ `:relate` - Look up and relate existing records
+ `{:relate, :action_name}` - Use specific action for relating

**`on_no_match`** - What to do when no matching record exists:

+ `:ignore` - Skip these inputs
+ `:create` - Create new records
+ `{:create, :action_name}` - Use specific create action
+ `:error` - Raise an error

**`on_match`** - What to do when a matching record is found:

+ `:ignore` - Leave the record as-is
+ `:update` - Update the existing record
+ `{:update, :action_name}` - Use specific update action
+ `:unrelate` - Remove the relationship
+ `:error` - Raise an error

**`on_missing`** - What to do with related records not in the input:

+ `:ignore` - Leave them as-is
+ `:unrelate` - Remove the relationship
+ `:destroy` - Delete the records
+ `{:destroy, :action_name}` - Use specific destroy action

#### Decision Flow

The following diagram shows how `manage_relationship` processes input records using these options:

    flowchart TD
        A[manage_relationship input] --> B[Load existing relationships]

        B --> C[Does input exist in current relationships?]
        B --> L

        C -->|Yes - Found match| D[on_match behavior]
        C -->|No - No match found| E[on_lookup behavior]

        E -->|:ignore| F[on_no_match behavior]
        E -->|:relate| G[Query destination resource<br/>using input identities]

        G --> H[Found in lookup?]
        H -->|Yes| I[:relate - Add relationship]
        H -->|No| F

        D --> D1[:ignore - Leave as-is]
        D --> D2[:update - Update existing]
        D --> D3[:unrelate - Remove relationship]
        D --> D4[:error - Raise error]

        F --> F1[:ignore - Skip input]
        F --> F2[:create - Create new record]
        F --> F3[:error - Raise error]

        L[Existing related records not in input] --> J[on_missing behavior]

        J --> J1[:ignore - Leave as-is]
        J --> J2[:unrelate - Remove relationship]
        J --> J3[:destroy - Delete records]

        style A fill:#e1f5fe
        style D1 fill:#fff3e0
        style D2 fill:#e8f5e8
        style D3 fill:#fce4ec
        style D4 fill:#ffebee
        style F1 fill:#fff3e0
        style F2 fill:#e8f5e8
        style F3 fill:#ffebee
        style I fill:#e8f5e8
        style J1 fill:#fff3e0
        style J2 fill:#fce4ec
        style J3 fill:#ffcdd2

#### Advanced Options

**`value_is_key`** - Use a specific field as the key when providing simple values:

    # Allow using category names instead of IDs        change         manage_relationship    (    :category_names    ,         :categories    ,    
          value_is_key    :         :name    ,    
          type    :         :append_and_remove        )

**`use_identities`** - Specify which identities to use for lookups:

    change         manage_relationship    (    :tags    ,    
          type    :         :append_and_remove    ,    
          use_identities    :         [    :name    ,         :_primary_key    ]        )

**`join_keys`** - For many-to-many relationships, specify join table parameters:

    change         manage_relationship    (    :categories    ,    
          type    :         :append_and_remove    ,    
          join_keys    :         [    :priority    ,         :added_by    ]        )

### Relationship Type Considerations

#### belongs\_to Relationships

When managing `belongs_to` relationships, you're typically setting a parent:

    create         :create_with_parent         do    
          argument         :parent    ,         :map    
          change         manage_relationship    (    :parent    ,         type    :         :create    )        end    
        # Or relating to existing parent        update         :assign_parent         do    
          argument         :parent_id    ,         :uuid    
          change         manage_relationship    (    :parent_id    ,         :parent    ,         type    :         :append_and_remove    )        end

#### has\_one Relationships

For `has_one` relationships, you manage a single related record:

    update         :update_profile         do    
          argument         :profile    ,         :map    
          change         manage_relationship    (    :profile    ,         type    :         :direct_control    )        end

#### has\_many Relationships

With `has_many`, you typically manage collections:

    update         :manage_comments         do    
          argument         :comments    ,         {    :array    ,         :map    }    
          change         manage_relationship    (    :comments    ,         type    :         :direct_control    )        end

#### many\_to\_many Relationships

Many-to-many relationships often involve join table management:

    update         :update_post_tags         do    
          argument         :tags    ,         {    :array    ,         :map    }    

          change         manage_relationship    (    :tags    ,    
            type    :         :append_and_remove    ,    
            join_keys    :         [    :tagged_at    ,         :tagged_by    ]    
          )        end

### Advanced Patterns

#### Multiple manage\_relationship Calls

You can call `manage_relationship` multiple times, and they'll be processed in order:

    update         :complex_update         do    
          argument         :add_tags    ,         {    :array    ,         :string    }    
          argument         :remove_tags    ,         {    :array    ,         :string    }    

          change         manage_relationship    (    :add_tags    ,         :tags    ,    
            type    :         :append    ,    
            value_is_key    :         :name    ,    
            meta    :         [    order    :         1    ]    
          )    

          change         manage_relationship    (    :remove_tags    ,         :tags    ,    
            type    :         :remove    ,    
            value_is_key    :         :name    ,    
            meta    :         [    order    :         2    ]    
          )        end

### Argument Types and Value Handling

#### Map and List Inputs

When providing maps or lists of maps, you're providing input for actions on the destination resource:

    # Maps become action input        argument         :comment    ,         :map        change         manage_relationship    (    :comment    ,         :comments    ,         type    :         :create    )    
        # Usage:        %{    comment    :         %{    text    :         "Great post!"    ,         rating    :         5    }    }

#### Simple Value Inputs

You can also provide simple values using `value_is_key`:

    argument         :tag_names    ,         {    :array    ,         :string    }        change         manage_relationship    (    :tag_names    ,         :tags    ,    
          type    :         :append_and_remove    ,    
          value_is_key    :         :name    ,    
          on_lookup    :         :relate    ,    
          on_no_match    :         :create        )    
        # Usage:        %{    tag_names    :         [    "elixir"    ,         "phoenix"    ,         "ash"    ]    }

#### Using Existing Records

You can also pass existing record structs directly:

    # In a custom change        existing_tags         =         Ash    .    read!    (    Tag    ,         actor    :         actor    )        Ash.Changeset    .    manage_relationship    (    changeset    ,         :tags    ,         existing_tags    ,         type    :         :append    )

#### Authorization considerations

When you pass existing record structs directly to `manage_relationship`, Ash assumes that the actor is already authorized to read those records. This bypasses the normal authorization checks that would occur if you had provided IDs instead.

If you provide ids/maps, Ash will read the records and properly check authorization. Only pass existing record structs when you're certain the actor has appropriate read permissions for those records, or authorization is not relevant.

### Integration with Tools

The explicit nature of relationship management options enables rich integrations:

+ **AshPhoenix.Form** - Automatically derives nested form structures
+ **AshGraphQL** - Generates complex input objects for mutations
+ **AshJsonApi** - Creates appropriate API endpoints for relationship management

This works because Ash can determine exactly what actions might be called and what input is needed based on your `manage_relationship` configuration.

For complete documentation of all available options, see `Ash.Changeset.manage_relationship/4`.



# Calculations

Calculations in Ash allow for displaying complex values as a top level value of a resource.

## Primer

## Declaring calculations on a resource

### Expression Calculations

The simplest kind of calculation refers to an Ash expression. For example:

    calculations         do    
          calculate         :full_name    ,         :string    ,         expr    (    first_name         <>         " "         <>         last_name    )        end

See the Expressions guide for more.

### Module Calculations

When calculations require more complex code or can't be pushed down into the data layer, a module that uses `Ash.Resource.Calculation` can be used.

    defmodule         Concat         do    
          # An example concatenation calculation, that accepts the delimiter as an argument,    
          #and the fields to concatenate as options    
          use         Ash.Resource.Calculation    

          # Optional callback that verifies the passed in options (and optionally transforms them)    
          @impl         true    
          def         init    (    opts    )         do    
            if         opts    [    :keys    ]         &&         is_list    (    opts    [    :keys    ]    )         &&         Enum    .    all?    (    opts    [    :keys    ]    ,         &    is_atom    /    1    )         do    
              {    :ok    ,         opts    }    
            else    
              {    :error    ,         "Expected a `keys` option for which keys to concat"    }    
            end    
          end    

          @impl         true    
          # A callback to tell Ash what keys must be loaded/selected when running this calculation    
          # you can include related data here, but be sure to include the attributes you need from said related data    
          # i.e `posts: [:title, :body]`.    
          def         load    (    _query    ,         opts    ,         _context    )         do    
            opts    [    :keys    ]    
          end    

          @impl         true    
          def         calculate    (    records    ,         opts    ,         %{    arguments    :         %{    separator    :         separator    }    }    )         do    
            Enum    .    map    (    records    ,         fn         record         ->    
              Enum    .    map_join    (    opts    [    :keys    ]    ,         separator    ,         fn         key         ->    
                to_string    (    Map    .    get    (    record    ,         key    )    )    
              end    )    
            end    )    
          end    

          # You can implement this callback to make this calculation possible in the data layer    
          # *and* in elixir. Ash expressions are already executable in Elixir or in the data layer, but this gives you fine grain control over how it is done    
          # See the expressions guide for more.    
          # @impl true    
          # def expression(opts, context) do    
          #   expr(your_expression_here)    
          # end        end    
        # Usage in a resource        calculations         do    
          calculate         :full_name    ,         :string    ,         {    Concat    ,         keys    :         [    :first_name    ,         :last_name    ]    }         do    
            # You need to use the [allow_empty?: true, trim?: false] constraints here.    
            # The separator could be an empty string or require a leading or trailing space,    
            # but would be trimmed or even set to `nil` without the constraints shown below.    
            argument         :separator    ,         :string         do    
              allow_nil?         false    
              constraints         [    allow_empty?    :         true    ,         trim?    :         false    ]    
              default         ""    
            end    
          end        end

See the documentation for the calculations section in Resource DSL docs and the `Ash.Resource.Calculation` docs for more information.

The calculations declared on a resource allow for declaring a set of named calculations that can be used by extensions. They can also be loaded in the query using `Ash.Query.load/2`, or after the fact using `Ash.load/3`. Calculations declared on the resource will be keys in the resource's struct.

## Custom calculations in the query

Example:

    User        |>         Ash.Query    .    calculate    (    :full_name    ,         {    Concat    ,         keys    :         [    :first_name    ,         :last_name    ]    }    ,         :string    ,         %{    separator    :         ","    }    )

See the documentation for `Ash.Query.calculate/4` for more information.

## Arguments in calculations

Using the above example with arguments, you can load a calculation with arguments like so:

    load    (    full_name    :         [    separator    :         ","    ]    )

If the calculation uses an expression, you can also filter and sort on it like so:

    query        |>         Ash.Query    .    filter    (    full_name    (    separator    :         " "    )         ==         "Zach Daniel"    )        |>         Ash.Query    .    sort    (    full_name    :         {    %{    separator    :         " "    }    ,         :asc    }    )

## Loading Calculations

When loading calculations, you specify them in the load statement just like relationships and aggregates.

    # load        Ash    .    load!    (    user    ,         [    full_name    :         %{    separator    :         ","    }    ]    )        # => %User{full_name: "Zach,Daniel"}

### Loading with a custom name

Every record in Ash also has a `calculations` field, where arbitrarily named calculations can live. See `Ash.Query.calculate/4` for more. To do this with `load` statements, you use the reserved `as` key in the calculation arguments.

    # load        Ash    .    load!    (    user    ,         [    
          full_name    :         %{    separator    :         " "    ,         as    :         :full_name_with_spaces    }    ,    
          full_name    :         %{    separator    :         ","    ,         as    :         :full_name_with_commas    }        ]    )        # => %User{calculations: %{full_name_with_spaces: "Zach Daniel", full_name_with_commas: "Zach,Daniel"}}

### Loading "through" calculations

If you have calculations that produce records, or loadable types like `Ash.Type.Map` and `Ash.Type.Struct` you can load further things on those records by providing a tuple of calculation input and further load statements.

    # here is a map type that contains a user and a status        defmodule         MyApp.Types.UserAndStatus         do    
          use         Ash.Type.NewType    ,         subtype_of    :         :map    ,         constraints    :         [    
            fields    :         [    
              user    :         [    
                type    :         :struct    ,    
                instance_of    :         MyApp.User    
              ]    ,    
              status    :         [    
                type    :         :atom    ,    
                constraints    :         [    one_of    :         [    :active    ,         :inactive    ]    ]    
              ]    
            ]    
          ]        end    
        # on our organization resource, we might have a calculation that returns a user and their status        calculate         :user_statuses    ,         {    :array    ,         MyApp.Types.UserAndStatus    }    ,         GetUsersAndTheirStatuses

You could then load this calculation like so:

    Ash    .    load!    (    organization    ,         :user_statuses    )        # => [%{user: %User{}, status: :active}, %{user: %User{}, status: :inactive}]

But what if you wanted additional fields from the calculated user? To do this, we provide a tuple of additional loads alongside their arguments. Maps support loading "through" fields by using the configured fields in the map and providing further loads.

    # {arguments, additional_load_statement}        Ash    .    load!    (    organization    ,         user_statuses    :         {    %{    }    ,         [    user    :         [    full_name    :         %{    separator    :         " "    }    ]    ]    }    )    ,        # => [%{user: %User{full_name: "Zach Daniel"}, status: :active}, %{user: %User{full_name: "Tobey Maguire"}, status: :inactive}]



# Aggregates

Aggregates in Ash allow for retrieving summary information over groups of related data. A simple example might be to show the "count of published posts for a user". Aggregates allow us quick and performant access to this data, in a way that supports being filtered/sorted on automatically. More aggregate types can be added, but you will be restricted to only the supported types. In cases where aggregates don't suffice, use Calculations, which are intended to be much more flexible.

## Declaring aggregates on a resource

Aggregates are defined in an `aggregates` section. For all possible types, see below. For a full reference, see `d:Ash.Resource.Dsl.aggregates`.

    aggregates         do    
          count         :count_of_posts    ,         :posts         do    
            filter         expr    (    published         ==         true    )    
          end        end

## Using an aggregate

Aggregates are loaded and filtered on in the same way that calculations are. Lets look at some examples:

### Loading aggregates in a query or on records

    User        |>         Ash.Query    .    load    (    :count_of_posts    )        |>         Map    .    get    (    :count_of_posts    )        # => 10    
        users        |>         Ash    .    load!    (    :count_of_posts    )        |>         Enum    .    map    (    &    (    &1    .    count_of_posts    )    )        # => [3, 5, 2]

### Filtering on aggregates

    require         Ash.Query    
        User        |>         Ash.Query    .    filter    (    count_of_posts         >         10    )        |>         Ash    .    read!    (    )

### Sorting aggregates

    User        |>         Ash.Query    .    sort    (    count_of_posts    :         :asc    )        |>         Ash    .    read!    (    )

## Aggregate types

+ `count` - counts related items meeting the criteria.
+ `exists` - checks if any related items meet the criteria.
+ `first` - gets the first related value matching the criteria. Must specify the `field`.
+ `sum` - sums the related items meeting the criteria. Must specify the `field`.
+ `list` - lists the related values. Must specify the `field`.
+ `max` - gets the maximum related value. Must specify the `field`.
+ `min` - gets the minimum related value. Must specify the `field`.
+ `avg` - gets the average related value. Must specify the `field`.
+ `custom` - allows for a custom aggregate. Implementation depends on the data layer. Must provide an `implementation`.

The declared set of named aggregates can be used by extensions and referred to throughout your application As an escape hatch, they can also be loaded in the query using `Ash.Query.load/2`, or after the fact using `Ash.load/3`. Aggregates declared on the resource will be keys in the resource's struct.

See the docs on `d:Ash.Resource.Dsl.aggregates` for more information.

## Custom aggregates in the query

Custom aggregates can be added to the query and will be placed in the `aggregates` key of the results. This is an escape hatch, and is not the primary way that you should be using aggregates. It does, however, allow for dynamism, i.e if you are accepting user input that determines what the filter and/or field should be, that kind of thing.

Example:

    User        |>         Ash.Query    .    aggregate    (    
          :count_of_posts    ,    
          :count    ,    
          :posts    ,    
          query    :         [    
            filter    :         [    published    :         published?    ]    
          ]        )

See the documentation for `Ash.Query.aggregate/4` for more information.

## Join Filters

Join filters allows for more complex aggregate queries, including joining with predicates based on multiple related values.

### Example

          aggregates         do    
            sum         :saved_money    ,         [    :redeems    ,         :deal    ]    ,         :amount         do    
              # where any redeem of the deal is redeemed    
              filter         expr    (    redeems    .    redeemed         ==         true    )    

              # where the `redeems` are `redeemed`    
              join_filter         :redeems    ,         expr    (    redeemed         ==         true    )    

              # where the `redeems.deal.active` == `redeems.require_active`    
              join_filter         [    :redeems    ,         :deal    ]    ,         expr    (    active         ==         parent    (    require_active    )    )    
            end    
          end

## Inline Aggregates

Aggregates can be created in-line in expressions, with their relationship path specified and any options provided that match the options given to `Ash.Query.Aggregate.new/4`. For example:

    calculate         :grade    ,         :decimal    ,         expr    (    
          count    (    answers    ,         query    :         [    filter    :         expr    (    correct         ==         true    )    ]    )         /    
          count    (    answers    ,         query    :         [    filter    :         expr    (    correct         ==         false    )    ]    )        )

See the Expressions guide for more.



# Validations

Validations are similar to changes, except they cannot modify the changeset. They can only continue, or add an error.

Validations work on all action types. When used on queries and generic actions, they validate the arguments to ensure they meet your requirements before processing.

## Builtin Validations

There are a number of builtin validations that can be used, and are automatically imported into your resources. See `Ash.Resource.Validation.Builtins` for more.

### Query Support

The following builtin validations support both changesets and queries:

+ `action_is` - validates the action name
+ `argument_does_not_equal`, `argument_equals`, `argument_in` - validates argument values
+ `compare` - compares values \(arguments or attributes\)
+ `confirm` - confirms two values match
+ `match` - validates values against regex patterns
+ `negate` - negates other validations
+ `one_of` - validates values are in allowed options
+ `present` - validates required values are present
+ `string_length` - validates string length

Some examples of usage of builtin validations

    # Works on both changesets and queries        validate         match    (    :email    ,         "@"    )    
        validate         compare    (    :age    ,         greater_than_or_equal_to    :         18    )         do    
          message         "must be over 18 to sign up"        end    
        validate         present    (    :last_name    )         do    
          where         [    present    (    :first_name    )    ,         present    (    :middle_name    )    ]    
          message         "must also be supplied if setting first name and middle_name"        end    
        # Example for read actions        actions         do    
          read         :search         do    
            argument         :email    ,         :string    
            argument         :role    ,         :string    

            validate         match    (    :email    ,         ~r/^[^    \s    ]+@[^    \s    ]+    \.    [^    \s    ]+$/    )    
            validate         one_of    (    :role    ,         [    "admin"    ,         "user"    ,         "moderator"    ]    )    
          end    

          # Example for generic actions    
          action         :send_notification    ,         :boolean         do    
            argument         :recipient_email    ,         :string    
            argument         :priority    ,         :atom    

            validate         match    (    :recipient_email    ,         ~r/^[^    \s    ]+@[^    \s    ]+    \.    [^    \s    ]+$/    )    
            validate         one_of    (    :priority    ,         [    :low    ,         :medium    ,         :high    ]    )    
          end        end

## Custom Validations

    defmodule         MyApp.Validations.IsPrime         do    
          # transform and validate opts    

          use         Ash.Resource.Validation    

          @impl         true    
          def         init    (    opts    )         do    
            if         is_atom    (    opts    [    :attribute    ]    )         do    
              {    :ok    ,         opts    }    
            else    
              {    :error    ,         "attribute must be an atom!"    }    
            end    
          end    

          @impl         true    
          def         supports    (    _opts    )    ,         do    :         [    Ash.Changeset    ]    

          @impl         true    
          def         validate    (    changeset    ,         opts    ,         _context    )         do    
            value         =         Ash.Changeset    .    get_attribute    (    changeset    ,         opts    [    :attribute    ]    )    
            # this is a function I made up for example    
            if         is_nil    (    value    )         ||         Math    .    is_prime?    (    value    )         do    
              :ok    
            else    
              # The returned error will be passed into `Ash.Error.to_ash_error/3`    
              {    :error    ,         field    :         opts    [    :attribute    ]    ,         message    :         "must be prime"    }    
            end    
          end        end

### Supporting Queries in Custom Validations

To make a custom validation work on both changesets and queries, implement the `supports/1` callback:

    defmodule         MyApp.Validations.ValidEmail         do    
          use         Ash.Resource.Validation    

          @impl         true    
          def         init    (    opts    )         do    
            {    :ok    ,         opts    }    
          end    

          @impl         true    
          def         supports    (    _opts    )    ,         do    :         [    Ash.Changeset    ,         Ash.Query    ]    

          @impl         true    
          def         validate    (    subject    ,         opts    ,         _context    )         do    
            value         =         get_value    (    subject    ,         opts    [    :attribute    ]    )    

            if         is_nil    (    value    )         ||         valid_email?    (    value    )         do    
              :ok    
            else    
              {    :error    ,         field    :         opts    [    :attribute    ]    ,         message    :         "must be a valid email"    }    
            end    
          end    

          defp         get_value    (    %    Ash.Changeset    {    }         =         changeset    ,         attribute    )         do    
            Ash.Changeset    .    get_argument_or_attribute    (    changeset    ,         attribute    )    
          end    

          defp         get_value    (    %    Ash.Query    {    }         =         query    ,         attribute    )         do    
            Ash.Query    .    get_argument    (    query    ,         attribute    )    
          end    

          defp         valid_email?    (    email    )         do    
            String    .    match?    (    email    ,         ~r/^[^    \s    ]+@[^    \s    ]+    \.    [^    \s    ]+$/    )    
          end        end

This could then be used in a resource via:

    validate         {    MyApp.Validations.IsPrime    ,         attribute    :         :foo    }

## Anonymous Function Validations

You can also use anonymous functions for validations. Keep in mind, these cannot be made atomic. This is great for prototyping, but we generally recommend using a module, both for organizational purposes, and to allow adding atomic behavior.

    validate         fn         changeset    ,         _context         ->    
          # put your code here        end

## Where

The `where` can be used to perform validations conditionally.

The value of the `where` option can either be a validation or a list of validations. All of the `where`-validations must first pass for the main validation to be applied. For expressing complex conditionals, passing a list of built-in validations to `where` can serve as an alternative to writing a custom validation module.

### Examples

    validate         present    (    :other_number    )    ,         where    :         absent    (    :that_number    )

    validate         present    (    :other_number    )         do    
          where         {    MyApp.Validations.IsPrime    ,         attribute    :         :foo    }        end

    validate         present    (    :other_number    )    ,    
          where    :         [    
            numericality    (    :large_number    ,         greater_than    :         100    )    ,    
            one_of    (    :magic_number    ,         [    7    ,         13    ,         123    ]    )    
          ]

## Action vs Global Validations

You can place a validation in any create, update, or destroy action. For example:

    actions         do    
          create         :create         do    
            validate         compare    (    :age    ,         greater_than_or_equal_to    :         18    )    
          end        end

Or you can use the global validations block to validate on all actions of a given type. Where statements can be used in either. Note the warning about running on destroy actions below.

    validations         do    
          validate         present    (    [    :foo    ,         :bar    ]    ,         at_least    :         1    )         do    
            on         [    :create    ,         :update    ]    
            where         present    (    :baz    )    
          end        end

The validations section allows you to add validations across multiple actions of a changeset

### Running on destroy actions

By default, validations in the global `validations` block will run on create and update only. Many validations don't make sense in the context of destroys. To make them run on destroy, use `on: [:create, :update, :destroy]`

## only\_when\_valid? Option

Use the `only_when_valid?` option to skip validations when the changeset or query is already invalid. This is useful for expensive validations that should only run if other validations have passed.

    actions         do    
          create         :create         do    
            validate         present    (    :required_field    )    

            # This expensive validation only runs if query is valid so far    
            validate         expensive_external_validation    (    )         do    
              only_when_valid?         true    
            end    
          end    

          read         :search         do    
            argument         :email    ,         :string    

            validate         present    (    :email    )    

            # Only validate email format if email is present    
            validate         match    (    :email    ,         ~r/^[^    \s    ]+@[^    \s    ]+    \.    [^    \s    ]+$/    )         do    
              only_when_valid?         true    
            end    
          end        end

### Examples

    validations         do    
          validate         present    (    [    :foo    ,         :bar    ]    )    ,         on    :         :update    
          validate         present    (    [    :foo    ,         :bar    ,         :baz    ]    ,         at_least    :         2    )    ,         on    :         :create    
          validate         present    (    [    :foo    ,         :bar    ,         :baz    ]    ,         at_least    :         2    )    ,         where    :         [    action_is    (    [    :action1    ,         :action2    ]    )    ]    
          validate         absent    (    [    :foo    ,         :bar    ,         :baz    ]    ,         exactly    :         1    )    ,         on    :         [    :update    ,         :destroy    ]    
          validate         {    MyCustomValidation    ,         [    foo    :         :bar    ]    }    ,         on    :         :create        end

## Atomic Validations

To make a validation atomic, you have to implement the `Ash.Resource.Validation.atomic/3` callback. This callback returns an atomic instruction, or a list of atomic instructions, or an error/indication that the validation cannot be done atomically. For our `IsPrime` example above, this would look something like:

    defmodule         MyApp.Validations.IsPrime         do    
          # transform and validate opts    

          use         Ash.Resource.Validation    

          ...    

          def         atomic    (    changeset    ,         opts    ,         context    )         do    
            # lets ignore that there is no easy/built-in way to check prime numbers in postgres    
            {    :atomic    ,    
              # the list of attributes that are involved in the validation    
              [    opts    [    :attribute    ]    ]    ,    
              # the condition that should cause the error    
              # here we refer to the new value or the current value    
              expr    (    not    (    fragment    (    "is_prime(?)"    ,         ^    atomic_ref    (    opts    [    :attribute    ]    )    )    )    )    ,    
              # the error expression    
              expr    (    
                error    (    ^    InvalidAttribute    ,         %{    
                  field    :         ^    opts    [    :attribute    ]    ,    
                  # the value that caused the error    
                  value    :         ^    atomic_ref    (    opts    [    :attribute    ]    )    ,    
                  # the message to display    
                  message    :         ^    (    context    .    message         ||         "%{field} must be prime"    )    ,    
                  vars    :         %{    field    :         ^    opts    [    :attribute    ]    }    
                }    )    
              )    
            }    
          end        end

In some cases, validations operate on arguments only and therefore have no need of atomic behavior. for this, you can call `validate/3` directly from `atomic/3`. The builtin `Ash.Resource.Validation.Builtins.argument_equals/2` validation does this, for example.

    @impl         true        def         atomic    (    changeset    ,         opts    ,         context    )         do    
          validate    (    changeset    ,         opts    ,         context    )        end



# Changes

Changes are the primary way of customizing create/update/destroy action behavior. If you are familiar with `Plug`, you can think of an `Ash.Resource.Change` as the equivalent of a `Plug` for changesets. At its most basic, a change will take a changeset and return a new changeset. Changes can be simple, like setting or modifying an attribute value, or more complex, attaching hooks to be executed within the lifecycle of the action.

## Builtin Changes

There are a number of builtin changes that can be used, and are automatically imported into your resources. See `Ash.Resource.Change.Builtins` for more.

Some examples of usage of builtin changes

    # set the `owner` to the current actor        change         relate_actor    (    :owner    )    
        # set `commited_at` to the current timestamp when the action is called        change         set_attribute    (    :committed_at    ,         &    DateTime    .    utc_now    /    0    )    
        # optimistic lock using the `version` attribute        change         optimistic_lock    (    :version    )

## Custom Changes

    defmodule         MyApp.Changes.Slugify         do    

          use         Ash.Resource.Change    

          # transform and validate opts    
          @impl         true    
          def         init    (    opts    )         do    
            if         is_atom    (    opts    [    :attribute    ]    )         do    
              {    :ok    ,         opts    }    
            else    
              {    :error    ,         "attribute must be an atom!"    }    
            end    
          end    

          @impl         true    
          def         change    (    changeset    ,         opts    ,         _context    )         do    
            case         Ash.Changeset    .    fetch_change    (    changeset    ,         opts    [    :attribute    ]    )         do    
              {    :ok    ,         new_value    }         ->    
                slug         =         String    .    replace    (    new_value    ,         ~r/    \s    +/    ,         "-"    )    
                Ash.Changeset    .    force_change_attribute    (    changeset    ,         opts    [    :attribute    ]    ,         slug    )    
              :error         ->    
                changeset    
            end    
          end        end

This could then be used in a resource via:

    change         {    MyApp.Changes.Slugify    ,         attribute    :         :foo    }

## Anonymous Function Changes

You can also use anonymous functions for changes. Keep in mind, these cannot be made atomic, or support batching. This is great for prototyping, but we generally recommend using a module, both for organizational purposes, and to allow adding atomic/batch behavior.

    change         fn         changeset    ,         _context         ->    
          # put your code here        end

## Where

The `where` can be used to perform changes conditionally. This functions by running the validations in the `where`, and if the validation returns an error, we discard the error and skip the operation. This means that even custom validations can be used in conditions.

For example:

    change         {    Slugify    ,         attribute    :         :foo    }         do    
          where         [    attribute_equals    (    :slugify    ,         true    )    ]        end

## Action vs Global Changes

You can place a change on any create, update, or destroy action. For example:

    actions         do    
          create         :create         do    
            change         {    Slugify    ,         attribute    :         :name    }    
          end        end

Or you can use the global changes block to apply to all actions of a given type. Where statements can be used in both cases. Use `on` to determine the types of actions the validation runs on. By default, it only runs on create and update actions.

    changes         do    
          change         {    Slugify    ,         attribute    :         :name    }         do    
            on         [    :create    ]    
          end        end

The changes section allows you to add changes across multiple actions of a resource.

### Running on destroy actions

By default, changes in the global `changes` block will run on create and update only. Many changes don't make sense in the context of destroys. To make them run on destroy, use `on: [:create, :update, :destroy]`

### Examples

    changes         do    
          change         relate_actor    (    :owner    )    
          change         set_attribute    (    :committed_at    ,         &    DateTime    .    utc_now    /    0    )    
          change         optimistic_lock    (    :version    )    ,         on    :         [    :create    ,         :update    ,         :destroy    ]    
          change         {    Slugify    ,         [    attribute    :         :foo    ]    }    ,         on    :         :create        end

## Atomic Changes

To make a change atomic, you have to implement the `Ash.Resource.Change.atomic/3` callback. This callback returns a map of changes to attributes that should be changed atomically. We will also honor any `Ash.Resource.Change.after_batch/3` functionality to run code after atomic changes have been applied \(only if `atomic/3` callback has also been defined\). Note that `Ash.Resource.Change.before_batch/3` is not supported in this scenario and will be ignored.

    defmodule         MyApp.Changes.Slugify         do    
          # transform and validate opts    

          use         Ash.Resource.Change    

          ...    

          def         atomic    (    changeset    ,         opts    ,         context    )         do    
            {    :atomic    ,         %{    
              opts    [    :attribute    ]         =>         expr    (    
                fragment    (    "regexp_replace(?, ?, ?)"    ,         ^    ref    (    opts    [    :attribute    ]    )    ,         ~r/    \s    +/    ,         "-"    )    
              )    
            }    }    
          end        end

In some cases, changes operate only on arguments or context, or otherwise can do their work regardless of atomicity. In these cases, you can make your atomic callback call the `change/3` function

    @impl         true        def         atomic    (    changeset    ,         opts    ,         context    )         do    
          {    :ok    ,         change    (    changeset    ,         opts    ,         context    )    }        end

In other cases, a change may not be necessary in a fully atomic action. For this, you can simply return `:ok`

    @impl         true        def         atomic    (    _changeset    ,         _opts    ,         _context    )         do    
          :ok        end

## Batches

Changes can support being run on batches of changesets, using the `Ash.Resource.Change.batch_change/3`, `Ash.Resource.Change.before_batch/3`, and `Ash.Resource.Change.after_batch/3` callbacks.

### When do we use batch callbacks?

`Ash.Resource.Change.batch_change/3` must be defined for `Ash.Resource.Change.before_batch/3` and `Ash.Resource.Change.after_batch/3` to be called\!

The one exception is that `after_batch/3` is called after atomic changes as well as batches, so it will be called in cases that `atomic/3` is defined. `before_batch/3` is ignored when calling changes atomically.

For some changes, this may not be necessary at all, i.e the `Slugify` example has no benefit from batching. If no batch callbacks are added, your change will be run on a loop over the changesets. For the sake of example, however, we will show what it might look like to implement batching for our `Slugify` example.

    defmodule         MyApp.Changes.Slugify         do    
          # transform and validate opts    

          use         Ash.Resource.Change    

          @impl         true    
          def         init    (    opts    )         do    
            if         is_atom    (    opts    [    :attribute    ]    )         do    
              {    :ok    ,         opts    }    
            else    
              {    :error    ,         "attribute must be an atom!"    }    
            end    
          end    

          @impl         true    
          def         batch_change    (    changeset    ,         opts    ,         context    )         do    
            # here we could run queries or do common work required    
            # for a given batch of changesets.    
            # in this example, however, we just return the changesets with    
            # the change logic applied.    
            Enum    .    map    (    changesets    ,         &    change    (    &1    ,         opts    ,         context    )    )    
          end        end



# Preparations

Preparations are the primary way of customizing read action behavior, and are also supported by generic actions. If you are familiar with `Plug`, you can think of an `Ash.Resource.Preparation` as the equivalent of a `Plug` for queries and action inputs. At its most basic, a preparation will take a query or action input and return a new query or action input. Preparations can be simple, like adding a filter or a sort, or more complex, attaching hooks to be executed within the lifecycle of the action.

## Builtin Preparations

There are builtin preparations that can be used, and are automatically imported into your resources. See `Ash.Resource.Preparation.Builtins` for more.

The primary preparation you will use is `build/1`, which passes the arguments through to `Ash.Query.build/2` when the preparation is run. See that function for what options can be provided.

Some examples of usage of builtin preparations

    # sort by inserted at descending        prepare         build    (    sort    :         [    inserted_at    :         :desc    ]    )    
        # only show the top 5 results        prepare         build    (    sort    :         [    total_points    :         :desc    ]    ,         limit    :         5    )    
        # conditional preparation with where clause        prepare         build    (    filter    :         [    active    :         true    ]    )         do    
          where         argument_equals    (    :include_inactive    ,         false    )        end    
        # skip preparation if query is invalid        prepare         expensive_preparation    (    )         do    
          only_when_valid?         true        end

## Custom Preparations

    defmodule         MyApp.Preparations.Top5         do    
          use         Ash.Resource.Preparation    

          # transform and validate opts    
          @impl         true    
          def         init    (    opts    )         do    
            if         is_atom    (    opts    [    :attribute    ]    )         do    
              {    :ok    ,         opts    }    
            else    
              {    :error    ,         "attribute must be an atom!"    }    
            end    
          end    

          @impl         true    
          def         prepare    (    query    ,         opts    ,         _context    )         do    
            attribute         =         opts    [    :attribute    ]    

            query    
            |>         Ash.Query    .    sort    (    [    {    attribute    ,         :desc    }    ]    )    
            |>         Ash.Query    .    limit    (    5    )    
          end        end

This could then be used in a resource via:

    prepare         {    MyApp.Preparations.Top5    ,         attribute    :         :foo    }

## Anonymous Function Queries

You can also use anonymous functions for preparations. This is great for prototyping, but we generally recommend using a module for organizational purposes.

    prepare         fn         query    ,         _context         ->    
          # put your code here        end

## Action vs Global Preparations

You can place a preparation on a read action, like so:

    actions         do    
          read         :read         do    
            prepare         {    Top5    ,         attribute    :         :name    }    
          end        end

Or you can use the global preparations block to apply to all read actions.

    preparations         do    
          prepare         {    Top5    ,         attribute    :         :name    }        end

The preparations section allows you to add preparations across multiple actions of a resource.

## Where Clauses

Use `where` clauses to conditionally apply preparations based on validations:

    actions         do    
          read         :search         do    
            argument         :include_archived    ,         :boolean    ,         default    :         false    
            argument         :sort_by    ,         :string    ,         default    :         "name"    

            # Only apply archived filter if not including archived items    
            prepare         build    (    filter    :         [    archived    :         false    ]    )         do    
              where         argument_equals    (    :include_archived    ,         false    )    
            end    

            # Conditional sorting    
            prepare         build    (    sort    :         [    updated_at    :         :desc    ]    )         do    
              where         argument_equals    (    :sort_by    ,         "updated_at"    )    
            end    
          end        end

## only\_when\_valid? Option

Use the `only_when_valid?` option to skip preparations when the query is already invalid. This is useful for expensive preparations that should only run if validations have passed.

    actions         do    
          read         :complex_search         do    
            argument         :required_field    ,         :string    

            # This validation must pass first    
            validate         present    (    :required_field    )    

            # This expensive preparation only runs if query is valid    
            prepare         expensive_data_preparation    (    )         do    
              only_when_valid?         true    
            end    
          end        end



# Code Interface

One of the ways that we interact with our resources is via hand-written code. The general pattern for that looks like building a query or a changeset for a given action, and calling it via functions like `Ash.read/2` and `Ash.create/2`. This, however, is just one way to use Ash, and is designed to help you build tools that work with resources, and to power things like `AshPhoenix.Form`, `AshGraphql.Resource` and `AshJsonApi.Resource`. When working with your resources in code, we generally want something more idiomatic and simple. For example, on a domain called `Helpdesk.Support`.

    resources         do    
          resource         Ticket         do    
            define         :open_ticket    ,         args    :         [    :subject    ]    ,         action    :         :open    
          end        end

This simple setup now allows you to open a ticket with `Helpdesk.Support.open_ticket(subject)`. You can cause it to raise errors instead of return them with `Helpdesk.Support.open_ticket!(subject)`. For information on the options and additional inputs these defined functions take, look at the generated function documentation, which you can do in iex with `h Helpdesk.Support.open_ticket`. For more information on the code interface, read the DSL documentation: `d:Ash.Domain.Dsl.resources.resource.define`.

## Code interfaces on the resource

You can define a code interface on individual resources as well, using the `code_interface` block. The DSL is the same as the DSL for defining it in the `domain`. For example:

    code_interface         do    
          # the action open can be omitted because it matches the function name    
          define         :open    ,         args    :         [    :subject    ]        end

These will then be called on the resource itself, i.e `Helpdesk.Support.Ticket.open(subject)`.

## Using the code interface

If the action is an update or destroy, it will take a record or a changeset as its *first* argument. If the action is a read action, it will take a starting query as an *opt in the last* argument.

All functions will have an optional last argument that accepts options. See `Ash.Resource.Interface` for valid options.

For reads:

+ `:query` - a query to start the action with, can be used to filter/sort the results of the action. This can be a keyword list of any of the options that `Ash.Query.build/3` supports.

For creates:

+ `:changeset` - a changeset to start the action with

They will also have an optional second to last argument that is a freeform map to provide action input. It *must be a map*. If it is a keyword list, it will be assumed that it is actually `options` \(for convenience\). This allows for the following behaviour:

    # Because the 3rd argument is a keyword list, we use it as options        Accounts    .    register_user    (    username    ,         password    ,         [    tenant    :         "organization_22"    ]    )        # Because the 3rd argument is a map, we use it as action input        Accounts    .    register_user    (    username    ,         password    ,         %{    key    :         "val"    }    )        # When all arguments are provided it is unambiguous        Accounts    .    register_user    (    username    ,         password    ,         %{    key    :         "val"    }    ,         [    tenant    :         "organization_22"    ]    )

For a full list of options, see the functions in `Ash.Resource.Interface`, or use iex help on your generated functions, i.e

    iex>     h         Accounts    .    register_user    /    3

### get\_by functions

A common pattern in Ash applications is the "get by" function for retrieving individual records. This pattern provides a clean alternative to using `Ash.get!/2` directly in your web modules.

**Avoid this pattern:**

    # In a LiveView or Controller - DON'T DO THIS        group         =    
          MyApp.Ash.Dashboards.DashboardGroup    
          |>         Ash    .    get!    (    group_id    )    
          |>         Ash    .    load!    (    students    :         [    :user    ]    )

This is similar to using `Repo.get/2` and `Repo.preload/2` directly outside of context modules, which is generally considered a bad practice.

**Use this pattern instead:**

    # In your domain        resource         DashboardGroup         do    
          define         :get_dashboard_group_by_id    ,         action    :         :read    ,         get_by    :         [    :id    ]        end    
        # In your LiveView or Controller        group         =         MyApp.Dashboards    .    get_dashboard_group_by_id!    (    group_id    )

The `get_by` option automatically creates a function that:

+ Uses the primary read action with an applied filter
+ Supports dynamic loading and filtering through the standard options
+ Provides both raising \(`!`\) and non-raising versions

**Dynamic loading and filtering:**

Code interfaces automatically support loading and filtering options:

    # Load relationships        MyApp.Dashboards    .    get_dashboard_group_by_id!    (    id    ,         load    :         [    students    :         [    :user    ]    ]    )    
        # Apply additional filters        MyApp.Dashboards    .    get_dashboard_group_by_id!    (    id    ,         query    :         [    filter    :         [    status    :         :active    ]    ]    )    
        # Combine both        MyApp.Dashboards    .    get_dashboard_group_by_id!    (    id    ,    
          load    :         [    students    :         [    :user    ]    ]    ,    
          query    :         [    filter    :         [    status    :         :active    ]    ]        )

The `query` option accepts either an `Ash.Query` struct or a keyword list that gets passed to `Ash.Query.build/2`.

**When to use actions vs code interfaces:**

+ **Actions** define what operations are possible on your resource
+ **Code interfaces** provide function-based access to those actions
+ Actions don't require code interfaces and can be used by extensions like `AshJsonApi`
+ Code interfaces make actions callable as functions \(e.g., `DashboardGroup.get_by_id/1`\)

This pattern encourages proper separation of concerns by keeping domain logic in your resources and providing clean interfaces for your web layer.

## Calculations

Resource calculations can be run dynamically using `Ash.calculate/3`, but you can also expose them using the code\_interface with `define_calculation`.

For example:

    calculations         do    
          calculate         :full_name    ,         :string    ,         expr    (    first_name         <>         ^    arg    (    :separator    )         <>         last_name    )         do    
            argument         :separator    ,         :string         do    
              allow_nil?         false    
              default         " "    
            end    
          end        end    
        # in your domain        resource         User         do    
          define_calculation         :full_name    ,         args    :         [    :first_name    ,         :last_name    ,         {    :optional    ,         :separator    }    ]    
          # or if you want to take a record as an argument    
          define_calculation         :full_name    ,         args    :         [    :_record    ]        end

This could now be used like so:

    Accounts    .    full_name    (    "Jessie"    ,         "James"    ,         "-"    )        # or with a record as an argument        Accounts    .    full_name    (    user    )

This allows for running calculations without an instance of a resource, normally done via `Ash.load(user, :full_name)`

By default, configured args will be provided for any matching named reference *or* argument. This is normally fine, but in the case that you have an argument and a reference with the same name, you can specify it by supplying `{:arg, :name}` and `{:ref, :name}`. For example:

    define_calculation         :id_matches    ,         args    :         [    {    :arg    ,         :id    }    ,         {    :ref    ,         :id    }    ]

To make arguments optional, wrap them in `{:optional, ..}`, for example:

    define_calculation         :id_matches    ,         args    :         [    {    :arg    ,         :id    }    ,         {    :optional    ,         {    :ref    ,         :id    }    }    ]

## Bulk & atomic actions

### Bulk Updates & Destroys

Updates support a list, stream, or query as the first argument. This allows for bulk updates. In this mode, an `%Ash.BulkResult{}` is returned.

### Valid inputs

You cannot provide "any enumerable", only lists, streams \(a function or a %Stream\{\}\), and queries. We have to be able to distinguish the input as a bulk input and not input to the action itself.

For example:

    Post        |>         Ash.Query    .    filter    (    author_id         ==         ^    author_id    )        |>         MyApp.Blog    .    archive_post!    (    )        # => %Ash.BulkResult{}    
        [    %    Post    {    }    ,         %    Post    {    }    ]        |>         MyApp.Blog    .    destroy_post!    (    )        # => %Ash.BulkResult{}        end

You can pass options to the bulk operation with the `bulk_options` option to your code interface function.

### Bulk Creates

For bulk creates, you can provide a list or stream of inputs. In this mode also, an `%Ash.BulkResult{}` is returned.

### Valid inputs

You cannot provide "any enumerable", only lists, streams \(a function or a %Stream\{\}\). We have to be able to distinguish the input as a bulk input and not input to the action itself.

Any arguments on the code interface will be applied to *all* inputs given as a list, and the arguments will come first.

    [    %{    title    :         "Post 1"    }    ,         %{    title    :         "Post 2"    }    ,         ...    ]        # if `:special` is an action argument, it will be applied to all inputs        |>         MyApp.Blog    .    create_post!    (    :special    ,         bulk_options    :         [    batch_size    :         10    ]    )

### Returning streams from read actions

The `:stream?` option allows you to return a stream to be enumerated later.

For example:

    MyApp.Blog    .    my_posts    (    stream?    :         true    ,         actor    :         me    )        # => #Stream<...>

### Customizing the generated function

Often we want to have a slightly different interface when calling actions with functions, or we want to maintain backwards compatibility for callers of our code interface while changing the underlying action implementation.

You can define `custom_input`s on your code interfaces to massage arguments from the function into a shape expected by the action.

For example, lets say we have an action that accepts an `artist_id` as an argument. We want it to use `artist_id` for two reasons: it is the only part of the artist required to perform the action, and accepting ids is better for an action supporting usage over an API. However, we want the function itself to accept either an artist *or* an artist\_id.

    define         :follow_artist         do    
          action         :follow    

          # `artist` (from the custom input below) is a positional argument to the function    
          args         [    :artist    ]    

          # make a custom input called `artist`, that is a union type    
          custom_input         :artist    ,         :union         do    
            # allow passing either an artist or an artist_id    
            constraints         types    :         [    
              artist    :         [    type    :         :struct    ,         constraints    :         [    instance_of    :         Artist    ]    ]    ,    
              artist_id    :         [    type    :         :uuid    ]    
            ]    

            transform         do    
              # Pass it to the action as `artist_id`    
              to         :artist_id    

              # Extracting the value using this function    
              using         fn    
                %    Ash.Union    {    type    :         :artist    ,         value    :         value    }         ->    
                  value    .    id    
                %    Ash.Union    {    type    :         :artist_id    ,         value    :         value    }         ->    
                  value    
              end    
            end    
          end        end

The example above is a bit verbose. In practice we might create a type, called `ArtistOrId`, for example, and extract that logic like so:

    defmodule         MyApp.Types.ArtistOrId         do    
          use         Ash.Type.NewType    ,         subtype_of    :         :union    ,         constraints    :         [    
            types    :         [    
              artist    :         [    type    :         :struct    ,         constraints    :         [    instance_of    :         Artist    ]    ]    ,    
              artist_id    :         [    type    :         :uuid    ]    
            ]    
          ]    

          def         to_artist_id    (    %    Ash.Union    {    type    :         :artist    ,         value    :         artist    }    )    ,         do    :         artist    .    id    
          def         to_artist_id    (    %    Ash.Union    {    type    :         :artist_id    ,         value    :         artist_id    }    )    ,         do    :         artist_id        end

And then we can refactor the above example like so:

    define         :follow_artist         do    
          action         :follow    
          args         [    :artist    ]    

          custom_input         :artist    ,         MyApp.Types.ArtistOrId         do    
            transform         do    
              to         :artist_id    
              using         &    MyApp.Types.ArtistOrId    .    to_artist_id    /    1    
            end    
          end        end

### Default Options

You can provide default options that will be merged with client-provided options using the `default_options` configuration. This is useful for setting common options that should be applied to all calls of a particular interface function.

`default_options` accepts either:

+ A keyword list of static options
+ A zero-arity function that returns a keyword list of dynamic options

#### Static Default Options

    code_interface         do    
          define         :get_user    ,         action    :         :read    ,         get_by    :         [    :id    ]    ,    
            default_options    :         [    
              load    :         [    :profile    ,         :posts    ]    
            ]        end

With this configuration, calling `MyApp.get_user(123)` will automatically load the profile and posts relationships and enable authorization.

#### Dynamic Default Options

For options that need to be computed at runtime, you can provide a function:

    code_interface         do    
          define         :get_user_with_timestamp    ,         action    :         :read    ,         get_by    :         [    :id    ]    ,    
            default_options    :         fn         ->    
              [    
                load    :         [    :profile    ]    ,    
                context    :         %{    
                  requested_at    :         DateTime    .    utc_now    (    )    ,    
                  request_id    :         System    .    unique_integer    (    )    
                }    
              ]    
            end        end

The function is called each time the interface function is invoked, allowing for dynamic values like timestamps or request IDs.

#### Option Merging Behavior

Default options are merged with client-provided options using the following rules:

+ Most options: Client options override defaults
+ `:load` options: Combined \(both default and client loads are applied\)
+ `:bulk_options` and `:page` options: Deep merged \(keyword lists are merged together\)

Example:

    # With default_options: [load: [:profile], authorize?: true]        MyApp    .    get_user    (    123    ,         load    :         [    :posts    ]    ,         authorize?    :         false    )        # Results in: [load: [:profile, :posts], authorize?: false]

### Authorization Functions

For each action defined in a code interface, Ash automatically generates corresponding authorization check functions:

+ `can_action_name?(actor, params \\ %{}, opts \\ [])` - Returns `true`/`false` for authorization checks
+ `can_action_name(actor, params \\ %{}, opts \\ [])` - Returns `{:ok, true/false}` or `{:error, reason}`

Example usage:

    # Check if user can create a post        if         MyApp.Blog    .    can_create_post?    (    current_user    )         do    
          # Show create button        end    
        # Check if user can update a specific post        if         MyApp.Blog    .    can_update_post?    (    current_user    ,         post    )         do    
          # Show edit button        end    
        # Check if user can destroy a specific comment        if         MyApp.Blog    .    can_destroy_comment?    (    current_user    ,         comment    )         do    
          # Show delete button        end

These functions are particularly useful for conditional rendering of UI elements based on user permissions.

#### Authorization Function Options

The authorization functions accept the same options as `Ash.can/3` and `Ash.can?/3`, including:

+ `log?` - Whether to log the authorization result at `:info` level for debugging purposes

    # Enable logging for this specific authorization check        if         MyApp.Blog    .    can_update_post?    (    current_user    ,         post    ,         log?    :         true    )         do    
          # Show edit button        end    
        # This will log authorization details to help with debugging        MyApp.Blog    .    can_create_post    (    current_user    ,         %{    title    :         "New Post"    }    ,         log?    :         true    )



# Embedded Resources

Embedded resources are stored as maps in attributes of other resources. They are great for storing structured data, and support a whole range of useful features that resources support. For example, you can have calculations, validations, policies and even relationships on embedded resources.

## Consider Simpler Alternatives

Before creating a full embedded resource, consider if one of these simpler options might meet your needs:

### Ash.TypedStruct

For simple structured data with type validation but without the need for calculations, validations, or policies:

    defmodule         MyApp.Address         do    
          use         Ash.TypedStruct    

          typed_struct         do    
            field         :street    ,         :string    ,         allow_nil?    :         false    
            field         :city    ,         :string    ,         allow_nil?    :         false    
            field         :state    ,         :string    ,         constraints    :         [    max_length    :         2    ]    
            field         :zip    ,         :string    ,         constraints    :         [    match    :         ~r/^    \d    {5}$/    ]    
          end        end

### Ash.Type.Struct

For when you need a generic struct type with field specifications:

    attribute         :address    ,         :struct         do    
          constraints         fields    :         [    
            street    :         [    type    :         :string    ,         allow_nil?    :         false    ]    ,    
            city    :         [    type    :         :string    ,         allow_nil?    :         false    ]    ,    
            state    :         [    type    :         :string    ,         constraints    :         [    max_length    :         2    ]    ]    ,    
            zip    :         [    type    :         :string    ,         constraints    :         [    match    :         ~r/^    \d    {5}$/    ]    ]    
          ]        end

Use embedded resources when you need the full power of Ash resources, including actions, calculations, validations, and policies.

## Example Embedded Resource

Here is an example of a simple embedded resource:

    defmodule         MyApp.Profile         do    
          use         Ash.Resource    ,    
            data_layer    :         :embedded         # Use the atom `:embedded` as the data layer.    

          attributes         do    
            attribute         :first_name    ,         :string    ,         public?    :         true    
            attribute         :last_name    ,         :string    ,         public?    :         true    
          end        end

### Embedded resources can't do everything

Embedded resources cannot have aggregates, or expression calculations that rely on data-layer-specific capabilities.

## Adding embedded resource attributes

Embedded resources define an `Ash.Type` under the hood, meaning you can use them anywhere you would use an Ash type.

    defmodule         MyApp.User         do    
          use         Ash.Resource    ,         ...    

          attributes         do    
            ...    

            attribute         :profile    ,         MyApp.Profile    ,         public?    :         true    
            attribute         :profiles    ,         {    :array    ,         MyApp.Profile    }    ,         public?    :         true         # You can also have an array of embeds    
          end        end

## Handling nil values

By default, all fields on an embedded resource will be included in the data layer, including keys with nil values. To prevent this, add the `embed_nil_values?` option to `use Ash.Resource`. For example:

    defmodule         YourEmbed         do    
          use         Ash.Resource    ,    
            data_layer    :         :embedded    ,    
            embed_nil_values?    :         false        end

## Editing embedded attributes

If you manually supply instances of the embedded structs, the structs you provide are used with no validation. For example:

    Ash.Changeset    .    for_update    (    user    ,         :update    ,         %{    profile    :         %    MyApp.Profile    {    first_name    :         "first_name"    ,         last_name    :         "last_name"    }    }    )

However, you can also treat embedded resources like regular resources that can be "created", "updated", and "destroyed". To do this, provide maps as the input, instead of structs. In the example above, if you just wanted to change the `first_name`, you'd provide:

    Ash.Changeset    .    for_update    (    user    ,         :update    ,         %{    profile    :         %{    first_name    :         "first_name"    }    }    )

This will call the primary `update` action on the resource. This allows you to define an action on the embed, and add validations to it. For example, you might have something like this:

    defmodule         MyApp.Profile         do    
          use         Ash.Resource    ,    
            data_layer    :         :embedded         # Use the atom `:embedded` as the data layer.    

          attributes         do    
            attribute         :first_name    ,         :string    ,         public?    :         true    
            attribute         :last_name    ,         :string    ,         public?    :         true    
          end    

          validations         do    
            validate         present    (    [    :first_name    ,         :last_name    ]    ,         at_least    :         1    )    
          end        end

## Calculations

Calculations can be added to embedded resources. When you use an embedded resource, you declare what calculations to load via a `constraint`. For example:

    defmodule         MyApp.Profile         do    
          use         Ash.Resource    ,    
            data_layer    :         :embedded         # Use the atom `:embedded` as the data layer.    

          attributes         do    
            attribute         :first_name    ,         :string    ,         public?    :         true    
            attribute         :last_name    ,         :string    ,         public?    :         true    
          end    

          calculations         do    
            calculate         :full_name    ,         :string    ,         concat    (    [    :first_name    ,         :last_name    ]    ,         " "    )    
          end        end    
        defmodule         MyApp.User         do    
          use         Ash.Resource    ,    
            ...    

          attributes         do    
            attribute         :profile    ,         MyApp.Profile         do    
              public?         true    
              constraints         [    load    :         [    :full_name    ]    ]    
            end    
          end        end

## Determining what action\(s\) will be called:

Remember: default actions are already implemented for a resource, with no need to add them. They are called `:create`, `:update`, `:destroy`, and `:read`. You can use those without defining them. You only need to define them if you wish to override their configuration.

### Single Embeds

+ If the current value is `nil` - a `create` with the provided values
+ If the current value is not `nil` - an `update` with the provided values
+ If the current value is not `nil` and the *new value* is `nil` - a `destroy` with the original value

### Array Embeds

All values in the original array are destroyed, and all maps in the new array are used to `create` new records.

## Adding a primary key

Adding a primary key to your embedded resources is especially useful when managing lists of data. Specifically, it allows you to consider changes to elements with matching primary key values as `updates`.

For example:

    defmodule         MyApp.Tag         do    
          use         Ash.Resource    ,    
            data_layer    :         :embedded    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :name    ,         :string    ,         public?    :         true    
            attribute         :counter    ,         :integer    ,         public?    :         true    
          end    

          validations         do    
            validate         {    Increasing    ,         field    :         :counter    }    ,         on    :         :update    
          end        end

Now, you can accept input meant to `update` individual list items. The entire list must still be provided, but any items with a matching id will be considered an `update` instead of a `destroy` \+ `create`.

### Determining what action\(s\) will be called with a primary key:

#### Single Embeds with primary keys

+ If you provide a struct, instead of a map, the value provided is used as the new relationship value directly.
+ If the current value is `nil` - a `create` with the provided values
+ If the current value is not `nil` and the primary keys match - an `update` with the provided values
+ If the current value is not `nil` and the primary keys *don't* match - a `destroy` of the original value and a `create` of the new value
+ If the current value is not `nil` and the *new value* is `nil` - a `destroy` with the original value

#### Array Embeds with primary keys

+ If you provide structs, instead of maps, the value provided is used as the new relationship value directly.
+ Any values in the original list with no primary key matching in the new list are `destroy`ed.
+ Any values in the new list with no primary key matching in the original list are `create`d.
+ Any values with a primary key match in the original list and the new list are `update`d

## Identities

Identities can be added on an embedded resource, which will ensure that for any given list, they are unique on that identity. For example, if you had an embedded resource called `Tag`, you could add an identity on `name` to ensure that nothing has duplicate tag names.

## Usage in Extensions

The AshJsonApi extension exposes these attributes as maps. However, the AshGraphql extension allows you to specify a type \(but not queries/mutations\) for an embedded resource. If you do, instead of being treated as a `:json` type it will get its own named input object type and field type.

## Accessing the source changeset

When building changesets for embedded resources, the source changeset will be available in action changes under `changeset.context.__source__`. This allows you to customize the action based on the details of the parent changeset.



# Identities

Identities are a way to declare that a record \(an instance of a resource\) can be uniquely identified by a set of attributes. This information can be used in various ways throughout the framework. The primary key of the resource does not need to be listed as an identity.

## Defining an identity

Identities are defined at the top level of a resource module, eg.

    defmodule         MyApp.MyResource         do    
          use         Ash.Resource         #, ...    
          # ...    

          identities         do    
            # If the `email` attribute must be unique across all records    
            identity         :unique_email    ,         [    :email    ]    

            # If the `username` attribute must be unique for every record with a given `site` value    
            identity         :special_usernames    ,         [    :username    ,         :site    ]    

            # If the `user_id` field should hold the errors for the uniqueness violation    
            identity         :unique_email    ,         [    :email    ]    ,         field_names    :         [    :user_id    ]    
          end        end

See `d:Ash.Resource.Dsl.identities` for the full range of options available when defining identities.

## Using **`Ash.get`**

This will allow these fields to be passed to `Ash.get/3`, e.g `Ash.get(Resource, %{email: "foo"})`.

## Using upserts

Create actions support the `upsert?: true` option, if the data layer supports it. An `upsert?` involves checking for a conflict on some set of attributes, and translating the behavior to an update in the case one is found. By default, the primary key is used when looking for duplicates, but you can set `[upsert?: true, upsert_identity: :identity_name]` to tell it to look for conflicts on a specific identity.

## Creating unique constraints

Tools like `AshPostgres` will create unique constraints in the database automatically for each identity. These unique constraints will honor other configuration on your resource, like the `base_filter` and attribute multitenancy

## Eager Checking

Setting `eager_check?: true` on an identity will allow that identity to be checked when building a create changeset over the resource. This allows for showing quick up-front validations about whether some value is taken, for example. If the resource does not have the domain configured, you can specify the domain to use with `eager_check_with: DomainName`.

If you are using `AshPhoenix.Form`, for example, this looks for a conflicting record on each call to `Form.validate/2`. For updates, it is only checked if one of the involved fields is being changed.

For creates, The identity is checked unless your are performing an `upsert`, and the `upsert_identity` is this identity. Keep in mind that for this to work properly, you will need to pass the `upsert?: true, upsert_identity: :identity_name` *when creating the changeset*. The `primary?` read action is used to search for a record. This will error if you have not configured one.

## Pre Checking

`pre_check?` behaves the same as `eager_check?`, but it runs just prior to the action being committed. Useful for data layers that don't support transactions/unique constraints, or manual resources with identities. `Ash.DataLayer.Ets` will require you to set `pre_check?` since the ETS data layer has no built in support for unique constraints. The domain can be manually specified with `pre_check_with: DomainName`.



# Notifiers

## What are notifiers for?

Notifiers allow you to tap into create, update and destroy actions on a resource. Notifiers are called after the current transaction is committed, which solves a lot of problems that can happen from performing a certain kind of side effect in your action code.

A common example of one such issue is using Phoenix PubSub to notify another part of your app \(often a LiveView or phoenix channel\) of a change. If you send a message to another process while your transaction is still open, and that process tries to look up a record you just created, it won't find it yet, because your transaction is still open\!

Notifiers are a solution for a certain kind of side effect, what we call "at most once" effects. An example is sending an event to an analytics system, or our pubsub example above. It is "okay" if the event is fired and some error in that process prevents it from being sent.

### When you really need an event to happen

In these cases you are looking for something other than a notifier. For example, you may want to look into integrating https://hexdocs.pm/oban into your application, allowing you to commit a "job" in the same transaction as your changes, to be processed later.

Alternatively, you could look into using `Reactor`, which is designed for writing "sagas" and has first-class support for Ash via the `AshReactor` extension.

### Including a notifier in a resource

If the notifier is also an extension, include it in the `notifiers` key:

    defmodule         MyResource         do    
          use         Ash.Resource    ,    
            notifiers    :         [    ExampleNotifier    ]        end

Configuring a notifier for a specific action or actions can be a great way to avoid complexity in the implementation of a notifier. It allows you to avoid doing things like pattern matching on the action, and treat it more like a change module, that does its work whenever it is called.

    create         :create         do    
          notifiers         [    ExampleNotifier    ]        end

When your notifier is not an extension, and you want it to run on all actions, include it this way to avoid unnecessary compile time dependencies:

    defmodule         MyResource         do    
          use         Ash.Resource    ,    
            simple_notifiers    :         [    ExampleNotifier    ]        end

## Built-in Notifiers

Ash comes with a builtin pub\_sub notifier: `Ash.Notifier.PubSub`. See the module documentation for more.

## Creating your own notifier

A notifier is a simple extension that must implement a single callback `notify/1`. Notifiers do not have to implement an Ash DSL extension, but they may in order to configure how that notifier should behave. See `Ash.Notifier.Notification` for the currently available fields on a notification.

For more information on creating a DSL extension to configure your notifier, see the docs for `Spark.Dsl.Extension`.

### Notifier performance

Notifiers should not do intensive synchronous work. If any heavy work needs to be done, they should delegate to something else to handle the notification, like sending it to a GenServer or GenStage.

### Example notifier

    defmodule         ExampleNotifier         do    
          use         Ash.Notifier    

          def         notify    (    %    Ash.Notifier.Notification    {    resource    :         resource    ,         action    :         %{    type    :         :create    }    ,         actor    :         actor    }    )         do    
            if         actor         do    
              Logger    .    info    (    "    #{    actor    .    id    }     created a     #{    resource    }    "    )    
            else    
              Logger    .    info    (    "A non-logged in user created a     #{    resource    }    "    )    
            end    
          end        end

## Transactions

Domain calls involving resources who's datalayer supports transactions \(like Postgres\), notifications are saved up and sent after the transaction is closed. For example, the domain call below ultimately results in many many database calls.

    Post        |>         Ash.Changeset    .    for_update    (    :update    ,         %{    }    )        |>         Ash.Changeset    .    manage_relationship    (    :related_posts    ,         [    1    ,         2    ,         3    ]    ,         type    :         :append    )        |>         Ash.Changeset    .    manage_relationship    (    :related_posts    ,         [    4    ,         5    ]    ,         type    :         :remove    )        |>         Ash.Changeset    .    manage_relationship    (    :comments    ,         [    10    ]    ,         type    :         :append    )        |>         Ash    .    update!    (    )

`Ash.Changeset.manage_relationship` doesn't leverage bulk operations yet, so it performs the following operations:

+ a read of the currently related posts
+ a read of the currently related comments
+ a creation of a post\_link to relate to 1
+ a creation of a post\_link to relate to 2
+ a creation of a post\_link to relate to 3
+ a destruction of the post\_link related to 4
+ a destruction of the post\_link related to 5
+ an update to comment 10, to set its `post_id` to this post

If all three of these resources have notifiers configured, we need to send a notification for each operation \(notifications are not sent for reads\). For data consistency reasons, if a data layer supports transactions, all writes are done in a transaction. However, if you try to read the record from the database that you have just received a notification about before the transaction has been closed, in a different process, the information will be wrong. For this reason, Ash accumulates notifications until they can be sent.

If you need to perform multiple operations against your resources in your own transaction, you will have to handle that case yourself. To support this, `Ash.create/2`, `Ash.update/2` and `Ash.destroy/2` support a `return_notifications?: true` option. This causes the domain call to return `{:ok, result, notifications}` in the successful case. Here is an example of how you might use it.

    result         =    
          Ash.DataLayer    .    transaction    (    resource    ,         fn         ->    
            {    :ok    ,         something    ,         notifications1    }         =         create_something    (    )    
            {    :ok    ,         result    ,         notifications2    }         =         create_another_thing    (    something    )    
            {    :ok    ,         notifications3    }         =         destroy_something    (    something    )    

            {    result    ,         Enum    .    concat    (    [    notifications1    ,         notifications2    ,         notifications3    ]    )    }    
          end    )    
        case         result         do    
          {    :ok    ,         value    ,         notifications    }         ->    
             Ash.Notifier    .    notify    (    notifications    )    

             value    
          {    :error    ,         error    }         ->    
            handle_error    (    error    )        end



# Actions

In Ash, actions are the primary way to interact with your resources. There are five types of actions:

+ Read
+ Create
+ Update
+ Destroy
+ Generic

All actions can be run in a transaction. Create, update and destroy actions are run in a transaction by *default*, whereas read and generic actions require opting in with `transaction? true` in the action definition. Each action has its own set of options, ways of calling it, and ways of customizing it. See the relevant guide for specifics on each action type. This topic focuses on idiomatic ways to use actions, and concepts that cross all action types.

## Primary Actions

Primary actions are a way to inform the framework which actions should be used in certain "automated" circumstances, or in cases where an action has not been specified. If a primary action is attempted to be used but does not exist, you will get an error about it at runtime.

The place you typically need primary actions is when Managing Relationships. When using the `defaults` option to add default actions, they are marked as primary.

A simple example where a primary action would be used:

    # No action is specified, so we look for a primary read.        Ash    .    get!    (    Resource    ,         "8ba0ab56-c6e3-4ab0-9c9c-df70e9945281"    )

To mark an action as primary, add the option, i.e

    read         :action_name         do    
          primary?         true        end

## Accepting Inputs

Create and Update actions can accept attributes as input. There are two primary ways that you annotate this.

### Using **`accept`** in specific actions

Each action can define what it accepts, for example:

    create         :create         do    
          accept         [    :name    ,         :description    ]        end

You could then pass in `%{name: "a name", description: "a description"}` to this action.

### Using **`default_accept`** for all actions

The resource can have a `default_accept`, declared in its `actions` block, which will be used as the accept list for `create` and `update` actions, if they don't define one.

    actions         do    
          default_accept         [    :name    ,         :description    ]    

          create         :create    
          update         :update    

          update         :special_update         do    
            accept         [    :something_else    ]    
          end        end

In the example above, you can provide `%{name: "a name", description: "a description"}` to both the `:create` and `:update` actions, but only `%{something_else: "some_value"}` to `:special_update`.

#### Using module attributes for action specific accept lists

You can also use module attributes to define the accept list. This is useful if you have a lot of attributes and different variations for different actions.

    @accepts_special_update         [    :name    ,         :description    ,         :foo    ,         :bar    ,         :baz    ]    
        @accepts_super_special_update         @accepts_special_update         ++         [    :something_else    ,         :another_thing    ]    
        actions         do    
          default_accept         [    :name    ,         :description    ]    

          create         :create    
          update         :update    

          update         :special_update         do    
            accept         @accepts_special_update    
          end        end

This is extremely simple example

## Context

There are two kinds of contexts in Ash:

1. the context given to a changeset/action call, stored in `changeset.context`,
2. the context given to a callback function like `Ash.Resource.Change.change/3`, which contains the above context in it's `source_context` key, as well as additional information specific to the callback, and/or commonly needed keys for callbacks \(actor, tenant, etc.\).

Actions accept a free-form map of context, which can be used for whatever you like. Whenever context is set, it is *deep merged*. I.e if you do `changeset |> Ash.Changeset.set_context(%{a: %{b: 1}}) |> Ash.Changeset.set_context(%{a: %{c: 2}})`, the resulting context will be `%{a: %{b: 1, c: 2}}`. Structs are not merged.

There are some special keys in context to note:

### **`:private`**

The `:private` key is reserved for use by `Ash` itself. You shouldn't read from or write to it.

### **`:shared`**

The `:shared` key will be passed to all nested actions built by Ash, and should be passed by you to any actions you call within changes/preparations etc. Whenever `:shared` context is set, it is also written to the outer context. For example `set_context(%{shared: %{locale: "en"}})` is equivalent to `set_context(%{shared: %{locale: "en"}, locale: "en"})`

This will generally happen automatically if you use one of the two abstractions provided by Ash for threading options through to nested action calls.

### Careful with shared

Shared context is passed to all nested actions, so don't pass massive values around, and also don't set context

## **`:query_for`**

This is set on queries when they are being run for a "special" purpose. The values this can take are:

+ none, if a read action is being run, then no value is set for this context
+ `:bulk_update`, if the query is being built to power a bulk update action
+ `:bulk_destroy`, if the query is being built to power a bulk destroy action
+ `:load`, if the query is being built to power an `Ash.load` call

You can use this to adjust the behavior of your query preparations as needed.

## **`:bulk_create`**, **`:bulk_update`**, **`:bulk_destroy`**

This is set on changesets when they are being run in bulk. The value will be a map with the following keys \(more may be added in the future\):

`:index` -> The index of the changeset in the bulk operation.

#### **`Ash.Scope.ToOpts`**

`Ash.Scope.ToOpts` is newer and is the recommended way to do this. In action callbacks in Ash, you will be provided with a context, which can be passed down as a `scope` option when running nested actions or building nested changesets/queries. For example:

    def         change    (    changeset    ,         opts    ,         context    )         do    
          Ash.Changeset    .    after_action    (    changeset    ,         fn         changeset    ,         result         ->    
            # automatically passes the `shared` context to the nested action    
            MyApp.MyDomain    .    create_something_else    (    ...    ,         scope    :         context    ,         other    :         :options    )    
          end    )        end

To get the opts for a given scope, you can use `Ash.Scope.to_opts(scope)`, but this is typically not necessary.

#### **`Ash.Context.to_opts/2`**

`Ash.Context.to_opts/2` is a helper function that converts a context map into a list of options that can be passed to nested actions. It automatically passes the `shared` context to the nested action as well.

    def         change    (    changeset    ,         opts    ,         context    )         do    
          Ash.Changeset    .    after_action    (    changeset    ,         fn         changeset    ,         result         ->    
            # automatically passes the `shared` context to the nested action    
            MyApp.MyDomain    .    create_something_else    (    ...    ,         Ash.Context    .    to_opts    (    context    ,         other    :         :options    )    )    
          end    )        end

## Idiomatic Actions

### Name Your Actions

The intent behind Ash is *not* to have you building simple CRUD style applications. In a typical set up you may have a resource with four basic actions, there is even a shorthand to accomplish this:

    actions         do    
          defaults         [    :read    ,         :destroy    ,         create    :         :*    ,         update    :         :*    ]        end

But that is just a simple way to get started, or to create resources that really don't do anything beyond those four operations. You can have *as many actions as you want*. The best designed Ash applications will have numerous actions, named after the intent behind how they are used. They won't have all reads going through a single read action, and the same goes for the other action types. The richer the actions on the resource, the better interface you can have. With that said, many resources may only have those four basic actions, especially those that are "managed" through some parent resource. See the guide on Managing Relationships for more.

### Put everything inside the action

Ash provides utilities to modify queries and changesets *outside* of the actions on the resources. This is a very important tool in our tool belt, *but* it is very easy to abuse. The intent is that as much behavior as possible is put into the action. Here is the "wrong way" to do it. There is a lot going on here, so don't hesitate to check out other relevant guides if you see something you don't understand.

    def         top_tickets    (    user_id    )         do    
          Ticket    
          |>         Ash.Query    .    for_read    (    :read    )    
          |>         Ash.Query    .    filter    (    priority         in         [    :medium    ,         :high    ]    )    
          |>         Ash.Query    .    filter    (    representative_id         ==         ^    user_id    )    
          |>         Ash.Query    .    filter    (    status         ==         :open    )    
          |>         Ash.Query    .    sort    (    opened_at    :         :desc    )    
          |>         Ash.Query    .    limit    (    10    )    
          |>         Helpdesk.Support    .    read!    (    )        end    
        # in the resource    
        actions         do    
          defaults         [    :read    ,         ...    ]        end

And here is the "right way", where the rules about getting the top tickets have been moved into the resource as a nicely named action, and included in the `code_interface` of that resource. The reality of the situation is that `top_tickets/1` is meant to be obsoleted by your Ash resource\! Here is how it *should* be done.

    # in the resource    
        code_interface         do    
          define         :top    ,         args    :         [    :user_id    ]        end    
        actions         do    
          read         :top         do    
            argument         :user_id    ,         :uuid         do    
              allow_nil?         false    
            end    

            prepare         build    (    limit    :         10    ,         sort    :         [    opened_at    :         :desc    ]    )    

            filter         expr    (    priority         in         [    :medium    ,         :high    ]         and         representative_id         ==         ^    arg    (    :user_id    )         and         status         ==         :open    )    
          end        end

Now, whatever code I had that would have called `top_tickets/1` can now call `Helpdesk.Support.Ticket.top(user.id)`. By doing it this way, you get the primary benefit of getting a nice simple interface to call into, but you *also* have a way to modify how the action is invoked in any way necessary, by going back to the old way of building the query manually. For example, if I also only want to see top tickets that were opened in the last 10 minutes:

    Ticket        |>         Ash.Query    .    for_read    (    :top    ,         %{    user_id    :         user    .    id    }    )        |>         Ash.Query    .    filter    (    opened_at         >         ago    (    10    ,         :minute    )    )        |>         Helpdesk.Support    .    read!    (    )

That is the best of both worlds\! These same lessons transfer to changeset based actions as well.

## Private Inputs

The concept of a "private input" can be somewhat paradoxical, but it can be used by actions that require something provided by the "system", as well as something provided by the caller. For example, you may want an `ip_address` input that can't be set by the user. For this, you have two options.

### Private Options

    create         :create         do    
          argument         :ip_address    ,         :string    ,         allow_nil?    :         false    ,         public?    :         false    

          ...        end

    Ash.Changeset    .    for_create    (    Resource    ,         :create    ,         %{    }    ,         private_arguments    :         %{    ip_address    :         "<ip_address>"    }    )

### Context

You can also provide things to the action via `context`. Context is a map that is a free form map provided to the action. Context is occasionally used by callers to provide additional information that the action may or may not use.

Context is *deep merged* with any existing context, and also contains a `private` key that is reserved for use by Ash internals. You should not remove or manipulate the `private` context key in any way.

    create         :create         do    
          ...    
          change         fn         changeset    ,         _         ->    
            changeset    .    context         # %{ip_address: "<ip_address>"}    
          end        end

    Ash.Changeset    .    for_create    (    Resource    ,         :create    ,         %{    }    ,         context    :         %{    ip_address    :         "<ip_address>"    }    )

## Action Lifecycle

This section provides a comprehensive overview of the Ash resource action lifecycle, detailing when each phase executes in relation to database transactions.

### Overview

Ash resource actions follow a well-defined lifecycle that ensures proper data validation, transformation, and persistence. The lifecycle is divided into three main phases:

+ **Pre-Transaction Phase** - Operations before database transaction
+ **Transaction Phase** - Operations within database transaction 
+ **Post-Transaction Phase** - Operations after database transaction

#### Important Note:

+ **Around Action Behavior**: `around_action` hooks do not complete their "end" phase if the action fails

### Complete Lifecycle Flow

    graph TD
        subgraph "Pre-Transaction Phase"
            START["Action Invocation<br/>(Ash.create, Ash.read, Ash.run_action, etc.)"] --> PREP["Changeset/Query/ActionInput Creation"]
            PREP --> AROUND_START["around_transaction (start)"]
            AROUND_START --> BEFORE_TRANS["before_transaction"]
        end

        subgraph "Transaction Phase"
            TRANS_START["🔒 Transaction Begins"] --> ACTION_TYPE{"Action Type?"}

            %% Create/Update/Destroy path
            ACTION_TYPE -->|"Create/Update/Destroy"| CUD_ACTION_PREP["Action Preparations/Validations/Changes<br/>(In order of definition)"]
            CUD_ACTION_PREP --> CUD_GLOBAL_PREP["Global Preparations/Validations/Changes<br/>(Resource-level, in order of definition)"]
            CUD_GLOBAL_PREP --> CUD_AROUND_ACTION_START["around_action (start)"]
            CUD_AROUND_ACTION_START --> CUD_BEFORE_ACTION["before_action"]
            CUD_BEFORE_ACTION --> DATA_LAYER["💾 Data Layer Operation<br/>(Database interaction)"]
            DATA_LAYER --> CUD_SUCCESS{"Success?"}
            CUD_SUCCESS -->|Yes| CUD_AFTER_ACTION["after_action<br/>(Success only)"]
            CUD_SUCCESS -->|No| CUD_ERROR_HANDLE["Error Handling"]
            CUD_AFTER_ACTION --> CUD_AROUND_ACTION_END["around_action (end)<br/>✅ Only on success"]
            CUD_ERROR_HANDLE --> TRANS_ROLLBACK["🔓 Transaction Rollback"]
            CUD_AROUND_ACTION_END --> TRANS_COMMIT["🔓 Transaction Commit"]

            %% Read/Generic path
            ACTION_TYPE -->|"Read/Generic"| RG_GLOBAL_PREP["Global Preparations/Validations<br/>(Resource-level, in order of definition)"]
            RG_GLOBAL_PREP --> RG_ACTION_PREP["Action Preparations/Validations<br/>(In order of definition)"]
            RG_ACTION_PREP --> RG_BEFORE_ACTION[before_action]
            RG_BEFORE_ACTION --> RG_OPERATION{"Operation Type?"}
            RG_OPERATION -->|"Read"| READ_DATA_LAYER["💾 Data Layer Operation<br/>(Database query)"]
            RG_OPERATION -->|"Generic"| GENERIC_LOGIC["🔧 Custom Action Logic<br/>(User-defined function)"]
            READ_DATA_LAYER --> RG_SUCCESS{"Success?"}
            GENERIC_LOGIC --> RG_SUCCESS
            RG_SUCCESS -->|Yes| RG_AFTER_ACTION["after_action<br/>(Success only)"]
            RG_AFTER_ACTION -->|Yes| TRANS_COMMIT
            RG_SUCCESS -->|No| RG_ERROR_HANDLE["Error Handling"]
            RG_ERROR_HANDLE --> TRANS_ROLLBACK
        end

        subgraph "Post-Transaction Phase"
            AFTER_TRANS["after_transaction<br/>(Always runs - success/error)"] --> AROUND_END["around_transaction (end)"]
            AROUND_END --> NOTIFICATIONS["Notifications<br/>(If enabled)"]
            NOTIFICATIONS --> RESULT["Return Result"]
        end

        %% Flow connections
        BEFORE_TRANS --> TRANS_START
        TRANS_COMMIT --> AFTER_TRANS
        TRANS_ROLLBACK --> AFTER_TRANS

### Detailed Phase Breakdown

#### Pre-Transaction Phase \(Outside Database Transaction\)



##### 1. Action Invocation



+ **Entry point**: `Ash.create/2`, `Ash.update/2`, `Ash.read/2`, `Ash.destroy/2`
+ Initial setup and parameter validation



##### 2. Changeset/Query Creation



+ Creates appropriate changeset or query structure
+ Applies initial transformations and validations



##### 3. around\_transaction \(Start\)



+ **When**: Before transaction begins
+ **Purpose**: Wrap entire transaction with setup/cleanup logic
+ **Use Cases**:
	+ External service setup
	+ Resource allocation
	+ Logging/monitoring setup

+ **Transaction Context**: Outside transaction



##### 4. before\_transaction



+ **When**: Just before transaction starts
+ **Purpose**: Operations that must happen before database transaction
+ **Use Cases**:
	+ External API calls
	+ File system operations
	+ Cache warming
	+ Non-transactional preparations

+ **Transaction Context**: Outside transaction

#### Transaction Phase \(Inside Database Transaction\)



##### 5. Transaction Begins 🔒



+ Database transaction is initiated
+ All subsequent operations until commit/rollback are atomic



##### 6. Global Preparations/Validations/Changes \(Queries & Generic Actions\)



+ **When**: First operations inside transaction \(for queries and generic actions\)
+ **Purpose**: Execute resource-level preparations, validations, and changes
+ **Order**: Run in the order they are defined at the resource level \(not grouped by type\)
+ **Operations**:
	+ Resource-level preparations
	+ Resource-level validations
	+ Resource-level changes
	+ Global business logic

+ **Transaction Context**: Inside transaction
+ **Note**: For create/update/destroy actions, these run after action-level operations. In Ash 4.0, global preparations will run after action preparations for all action types.



##### 7. Action Preparations/Validations/Changes



+ **When**: After global operations \(for queries and generic actions\) or first operations \(for create/update/destroy\)
+ **Purpose**: Execute action-specific preparations, validations, and changes
+ **Order**: Run in the order they are defined in the action \(not grouped by type\)
+ **Operations**:
	+ Action-level preparations \(query modifications, filters, sorts\)
	+ Action-level validations \(business rules, constraints\)
	+ Action-level changes \(data transformations, attribute modifications\)

+ **Transaction Context**: Inside transaction



##### 8. around\_action \(Start\)



+ **When**: Just before data layer operation
+ **Purpose**: Wrap the actual database operation
+ **Use Cases**:
	+ Performance monitoring
	+ Debugging and development tools
	+ Advanced error handling
	+ Action timing

+ **Transaction Context**: Inside transaction
+ **Note**: Must call the callback function



##### 9. before\_action



+ **When**: Immediately before data layer operation
+ **Purpose**: Final modifications before database interaction
+ **Use Cases**:
	+ Last-minute data modifications
	+ Transactional side effects
	+ Audit logging
	+ Final validations

+ **Transaction Context**: Inside transaction



##### 10. Data Layer Operation 💾



+ **When**: Core of the transaction
+ **Purpose**: Actual database interaction
+ **Operations**:
	+ INSERT, UPDATE, DELETE, SELECT operations
	+ Constraint enforcement
	+ Database-level validations
	+ Index updates

+ **Transaction Context**: Inside transaction



##### 11. Success/Error Decision Point



+ Determines if the operation succeeded or failed
+ Affects which subsequent hooks are called



##### 12. after\_action \(Success Path Only\)



+ **When**: After successful data layer operation
+ **Purpose**: Post-success operations within transaction
+ **Use Cases**:
	+ Success-only side effects
	+ Transactional cleanup
	+ Related record updates
	+ Success logging

+ **Transaction Context**: Inside transaction
+ **Note**: Only runs on successful operations



##### 13. Error Handling \(Error Path\)



+ **When**: After failed data layer operation
+ **Purpose**: Handle errors within transaction context
+ **Operations**:
	+ Error processing
	+ Rollback preparation
	+ Error logging

+ **Transaction Context**: Inside transaction



##### 14. around\_action \(End\)



+ **When**: After successful action completion only
+ **Purpose**: Cleanup and finalization within transaction
+ **Use Cases**:
	+ Resource cleanup
	+ Final transaction operations
	+ Monitoring completion

+ **Transaction Context**: Inside transaction
+ **Note**: This phase does NOT execute if the action fails



##### 15. Transaction Commits/Rollbacks 🔓



+ **Success**: Transaction commits, changes are persisted
+ **Error**: Transaction rolls back, changes are discarded
+ End of transactional context

#### Post-Transaction Phase \(Outside Database Transaction\)



##### 16. after\_transaction



+ **When**: After transaction completion \(success or error\)
+ **Purpose**: Operations that should happen regardless of outcome
+ **Use Cases**:
	+ External service notifications
	+ Cache invalidation
	+ Cleanup operations
	+ Logging \(success and error cases\)
	+ Retry mechanisms - can change error results to success

+ **Transaction Context**: Outside transaction
+ **Special Capability**: Can transform the final result \(e.g., retry failed operations\)
+ **Note**: Always runs, regardless of success/failure



##### 17. around\_transaction \(End\)



+ **When**: Final cleanup phase
+ **Purpose**: Complete the transaction wrapper
+ **Use Cases**:
	+ Resource deallocation
	+ Final cleanup
	+ Monitoring completion

+ **Transaction Context**: Outside transaction



##### 18. Notifications



+ **When**: After all hooks complete
+ **Purpose**: Broadcast events and notifications
+ **Operations**:
	+ PubSub notifications
	+ Event broadcasting
	+ External system integrations
	+ Webhook calls

+ **Transaction Context**: Outside transaction



##### 19. Return Result



+ **Success**: Returns data with metadata
+ **Error**: Returns error details and context

### Hook Execution Order

The hooks execute in the following order \(as of Ash 3.0\+\):

#### For Create/Update/Destroy Actions:

1. `around_transaction` \(start\)
2. `before_transaction`
3. Transaction begins
4. Action preparations/validations/changes \(in order of definition\)
5. Global preparations/validations/changes \(in order of definition\)
6. `around_action` \(start\)
7. `before_action`
8. Data layer operation
9. `after_action` \(success only\) OR Error handling
10. `around_action` \(end\) - Only on success
11. Transaction commits/rollbacks
12. `after_transaction`
13. `around_transaction` \(end\)

#### For Read/Query Actions:

1. `around_transaction` \(start\)
2. `before_transaction`
3. Transaction begins \(if applicable\)
4. Global preparations/validations/changes \(in order of definition\)
5. Action preparations/validations/changes \(in order of definition\)
6. `around_action` \(start\)
7. `before_action`
8. Data layer operation
9. `after_action` \(success only\) OR Error handling
10. `around_action` \(end\) - Only on success
11. Transaction commits/rollbacks \(if applicable\)
12. `after_transaction` \(always runs - success/error\)
13. `around_transaction` \(end\)

#### For Generic Actions:

1. `around_transaction` \(start\)
2. `before_transaction`
3. Transaction begins \(if `transaction? true`\)
4. Global preparations/validations \(in order of definition\)
5. Action preparations/validations \(in order of definition\)
6. `around_action` \(start\)
7. `before_action`
8. Custom action logic execution
9. `after_action` \(success only\) OR Error handling
10. `around_action` \(end\) - Only on success
11. Transaction commits/rollbacks \(if applicable\)
12. `after_transaction` \(always runs\)
13. `around_transaction` \(end\)

### Key Points

#### Transaction Boundaries

+ **Outside Transaction**: `around_transaction`, `before_transaction`, `after_transaction`
+ **Inside Transaction**: Action preparations/validations/changes, Global preparations/validations/changes, `around_action`, `before_action`, `after_action`

#### Error Handling

+ `after_action` only runs on successful operations
+ `around_action` \(end\) only runs on successful operations
+ `after_transaction` always runs \(success and error\)
+ `after_transaction` can change the final result - can transform errors into successes \(useful for retries\)
+ Transaction rollback occurs automatically on errors

#### Execution Order Details

+ **Preparations/Validations/Changes**: Run in the order they are defined, NOT grouped by type
+ **Create/Update/Destroy**: Action-level preparations/validations/changes run first, then global \(resource-level\) preparations/validations/changes
+ **Read/Query/Generic**: Global \(resource-level\) preparations/validations/changes run first, then action-level preparations/validations/changes
+ **Ash 4.0 Change**: In Ash 4.0, global preparations will run after action preparations for all action types
+ **Hook Order Changes \(Ash 3.0\+\)**: Before/after action hooks now run in the order they are added \(not reverse order\)
+ **Restriction**: `after_transaction` hooks cannot be added from within other lifecycle hooks

#### Performance Considerations

+ Operations inside the transaction should be fast and focused
+ Long-running operations should be in `before_transaction` or `after_transaction`
+ Database connections are held during the entire transaction phase

### Action Type Differences

#### Create/Update/Destroy Actions

+ Run in transactions by default, unless no hooks of any kind are added to the changeset.
+ Have complete error handling and rollback capabilities

#### Read/Query Actions

+ Do not run in transactions by default
+ Focus on data retrieval and filtering

#### Generic Actions

+ Support validations, preparations, and all hook types
+ Can run in transactions by setting `transaction? true` in the action definition
+ Focus on custom business logic and operations

### Best Practices

+ Use `before_transaction` for external API calls
+ Use `before_action` for final data modifications
+ Use `after_action` for transactional side effects
+ Use `after_transaction` for external notifications
+ Use `after_transaction` for retry mechanisms and result transformation
+ Keep transaction phase operations fast and focused
+ Handle errors appropriately at each phase
+ Remember that `around_action` cleanup won't run on failures

### Example Implementation

    defmodule         MyApp.User         do    
          use         Ash.Resource    

          actions         do    
            create         :create         do    
              accept         [    :name    ,         :email    ]    
              argument         :retries    ,         :integer    ,         default    :         3    ,         allow_nil?    :         false    

              change         before_transaction    (    fn         changeset    ,         _context         ->    
                # External API call before transaction    
                case         ExternalService    .    validate_email    (    changeset    .    attributes    .    email    )         do    
                  :ok         ->         changeset    
                  {    :error    ,         reason    }         ->         Ash.Changeset    .    add_error    (    changeset    ,         reason    )    
                end    
              end    )    

              change         before_action    (    fn         changeset    ,         _context         ->    
                # Final modifications before database    
                Ash.Changeset    .    change_attribute    (    changeset    ,         :created_at    ,         DateTime    .    utc_now    (    )    )    
              end    )    

              change         after_action    (    fn         changeset    ,         result    ,         _context         ->    
                # Success-only operations within transaction    
                Logger    .    info    (    "User created:     #{    result    .    id    }    "    )    
                {    :ok    ,         result    }    
              end    )    

              change         fn         changeset    ,         context         ->    
                # Retry mechanism using after_transaction    
                if         changeset    .    arguments    [    :retries    ]         >         0         do    
                  Ash.Changeset    .    after_transaction    (    changeset    ,         fn     
                    changeset    ,         {    :ok    ,         result    }         ->    
                      # Success case - send notification and return result    
                      NotificationService    .    send_welcome_email    (    result    )    
                      {    :ok    ,         result    }    
                    changeset    ,         {    :error    ,         _error    }         ->    
                      # Error case - retry with decremented counter    
                      __MODULE__    
                      |>         Ash.Changeset    .    for_create    (    
                        changeset    .    action    .    name    ,     
                        Map    .    put    (    changeset    .    params    ,         :retries    ,         changeset    .    arguments    .    retries         -         1    )    ,     
                        scope    :         context    
                      )    
                      |>         Ash    .    create    (    )    
                  end    )    
                else    
                  # No retries left - add final after_transaction for cleanup    
                  Ash.Changeset    .    after_transaction    (    changeset    ,         fn         changeset    ,         result         ->    
                    case         result         do    
                      {    :ok    ,         user    }         ->     
                        NotificationService    .    send_welcome_email    (    user    )    
                        result    
                      error         ->     
                        Logger    .    error    (    "User creation failed after all retries"    )    
                        error    
                    end    
                  end    )    
                end    
              end    
            end    
          end        end

#### Key Points from Example:

+ **Retry Logic**: The `after_transaction` hook can transform a failed result into a new attempt
+ **Result Transformation**: Failed operations can become successful ones through retries
+ **Context Preservation**: The retry maintains the original context and decrements the retry counter
+ **Conditional Behavior**: Different `after_transaction` hooks based on retry availability
+ **Final Cleanup**: Even after retries are exhausted, cleanup operations still occur

This lifecycle ensures data consistency, proper error handling, and allows for complex business logic while maintaining transactional integrity.



# Read Actions

Read actions operate on an `Ash.Query`. Read actions always return lists of data. The act of pagination, or returning a single result, is handled as part of the interface, and is not a concern of the action itself. Here is an example of a read action:

    # Giving your actions informative names is always a good idea        read         :ticket_queue         do    
          # Use arguments to take in values you need to run your read action.    
          argument         :priorities    ,         {    :array    ,         :atom    }         do    
            constraints         items    :         [    one_of    :         [    :low    ,         :medium    ,         :high    ]    ]    
          end    

          # This action may be paginated,    
          # and returns a total count of records by default    
          pagination         offset    :         true    ,         countable    :         :by_default    

          # Arguments can be used in preparations and filters    
          filter         expr    (    status         ==         :open         and         priority         in         ^    arg    (    :priorities    )    )        end

For a full list of all of the available options for configuring read actions, see the Ash.Resource.Dsl documentation.

## Calling Read Actions

The basic formula for calling a read action looks like this:

    Resource        |>         Ash.Query    .    for_read    (    :action_name    ,         %{    argument    :         :value    }    ,         ...    opts    )        |>         Ash    .    read!    (    )

See below for variations on action calling, and see the code interface guide guide for how to define idiomatic and convenient functions that call your actions.

## Ash.get\!

The `Ash.get!` function is a convenience function for running a read action, filtering by a unique identifier, and expecting only a single result. It is equivalent to the following code:

    # action can be omitted to use the primary read action        Ash    .    get!    (    Resource    ,         1    ,         action    :         :read_action    )    
        # is roughly equivalent to    
        Resource        |>         Ash.Query    .    filter    (    id         ==         1    )        |>         Ash.Query    .    limit    (    2    )        |>         Ash.Query    .    for_read    (    :read_action    ,         %{    }    )        |>         Ash    .    read!    (    )        |>         case         do    
          [    ]         ->         # raise not found error    
          [    result    ]         ->         result    
          [    _    ,         _    ]         ->         # raise too many results error        end

## Ash.read\_one\!

The `Ash.read_one!` function is a similar convenience function to `Ash.get!`, but it does not take a unique identifier. It is useful when you expect an action to return only a single result, and want to enforce that and return a single result.

    Ash    .    read_one!    (    query    )    
        # is roughly equivalent to    
        query        |>         Ash.Query    .    limit    (    2    )        |>         Ash    .    read!    (    )        |>         case         do    
          [    ]         ->         nil    
          [    result    ]         ->         result    
          [    _    ,         _    ]         ->         # raise too many results error        end

## Pagination

Ash provides built-in support for pagination when reading resources and their relationships. You can find more information about this in the pagination guide.

### Pagination configuration on default vs custom read actions

The default read action supports keyset pagination automatically. You need to explicitly enable pagination strategies you want to support when defining your own read actions.

## What happens when you call Ash.Query.for\_read/4

The following steps are performed when you call `Ash.Query.for_read/4`.

+ Cast input arguments - `d:Ash.Resource.Dsl.actions.read.argument`
+ Set default argument values - `d:Ash.Resource.Dsl.actions.read.argument|default`
+ 
Add errors for missing required arguments | `d:Ash.Resource.Dsl.actions.read.argument|allow_nil?`

+ 
Run query preparations and validations \(in definition order\) | `d:Ash.Resource.Dsl.actions.read.prepare` and `d:Ash.Resource.Dsl.actions.read.validate`

+ 
Add action filter | `d:Ash.Resource.Dsl.actions.read|filter`


## What happens when you run the action

These steps are trimmed down, and are aimed at helping users understand the general flow. Some steps are omitted.

+ Run `Ash.Query.for_read/3` if it has not already been run
+ Apply tenant filters for attribute
+ Apply pagination options
+ Run before action hooks
+ Multi-datalayer filter is synthesized. We run queries in other data layers to fetch ids and translate related filters to `(destination_field in ^ids)`
+ Strict Check & Filter Authorization is run
+ Data layer query is built and validated
+ Field policies are added to the query
+ Data layer query is Run
+ Authorizer "runtime" checks are run \(you likely do not have any of these\)

The following steps happen while\(asynchronously\) or after the main data layer query has been run

+ If paginating and count was requested, the count is determined at the same time as the query is run.
+ Any calculations & aggregates that were able to be run outside of the main query are run
+ Relationships, calculations, and aggregates are loaded

## Customizing Queries When Calling Actions

When calling read actions through code interfaces, you can customize the query using the `query` option. This allows you to filter, sort, limit, and otherwise modify the results without manually building queries.

#### User Input Safety

When accepting query parameters from untrusted sources \(like web requests\), always use the `_input` variants \(`sort_input`, `filter_input`\) instead of the regular options. These functions only allow access to public fields and provide safe parsing of user input.

### Query Options via Code Interfaces

The `query` option accepts all the options that `Ash.Query.build/2` accepts:

    # Filtering results        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    filter    :         [    status    :         :published    ]    ]        )    
        # Sorting results        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    sort    :         [    published_at    :         :desc    ]    ]        )    
        # Limiting results        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    limit    :         10    ]        )    
        # Combining multiple query options        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    
            filter    :         [    status    :         :published    ,         author_id    :         author    .    id    ]    ,    
            sort    :         [    published_at    :         :desc    ]    ,    
            limit    :         10    ,    
            offset    :         20    
          ]        )    
        # Loading related data with query constraints        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    
            load    :         [    
              comments    :         [    
                filter    :         [    approved    :         true    ]    ,    
                sort    :         [    created_at    :         :desc    ]    ,    
                limit    :         5    
              ]    
            ]    
          ]        )

### Handling User Input

When accepting query parameters from user input, use the safe input variants:

    # Safe sorting from user input        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    sort_input    :         params    [    "sort"    ]         ||         "+published_at"    ]        )    
        # Safe filtering from user input        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    filter_input    :         params    [    "filter"    ]         ||         %{    }    ]        )    
        # Combining user input with application-defined constraints        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    
            # User-controlled sorting    
            sort_input    :         params    [    "sort"    ]    ,    
            # User-controlled filtering    
            filter_input    :         params    [    "filter"    ]    ,    
            # Application-enforced constraints    
            filter    :         [    archived    :         false    ]    ,    
            limit    :         100          # Prevent excessive data fetching    
          ]        )

### Default Query Behavior in Actions

You can configure default query behavior in your action definitions:

    actions         do    
          read         :recent_posts         do    
            # Default sort - overridden if user provides any sort    
            prepare         build    (    default_sort    :         [    published_at    :         :desc    ]    )    

            # Always applied filter - cannot be overridden    
            filter         expr    (    status         ==         :published    )    

            # Default pagination    
            pagination         offset    :         true    ,         default_limit    :         20    
          end    

          read         :search         do    
            argument         :query    ,         :string    ,         allow_nil?    :         false    

            # Prepare modifies the query before execution    
            prepare         fn         query    ,         _context         ->    
              Ash.Query    .    filter    (    query    ,         contains    (    title    ,         ^    query    .    arguments    .    query    )    )    
            end    
          end    

          read         :user_posts         do    
            argument         :email    ,         :string    ,         allow_nil?    :         false    
            argument         :status    ,         :string    ,         default    :         "published"    

            # Validate arguments before processing    
            validate         match    (    :email    ,         ~r/^[^    \s    ]+@[^    \s    ]+    \.    [^    \s    ]+$/    )         do    
              message         "must be a valid email address"    
            end    

            validate         one_of    (    :status    ,         [    "published"    ,         "draft"    ,         "archived"    ]    )    

            # Conditional validation - only validate if email is provided    
            validate         present    (    :email    )         do    
              where         present    (    :email    )    
            end    
          end        end

### Building Queries Manually

For more complex scenarios, you can build queries manually before calling the action:

    require         Ash.Query    
        # Build a complex query        query         =     
          MyApp.Post    
          |>         Ash.Query    .    filter    (    status         ==         :published    )    
          |>         Ash.Query    .    sort    (    published_at    :         :desc    )    
          |>         Ash.Query    .    limit    (    10    )    
        # Execute the query        posts         =         Ash    .    read!    (    query    )    
        # Or use it with a specific action        posts         =         Ash    .    read!    (    query    ,         action    :         :published_posts    )

### Common Query Patterns

#### Pagination

    # With page options        posts         =         MyApp.Blog    .    list_posts!    (    
          page    :         [    limit    :         20    ,         offset    :         40    ]        )    
        # with a query        MyApp.Post        |>         Ash.Query    .    page    (    
          limit    :         20    ,         offset    :         40        )    
        # when calling an action    
        MyApp.Post        |>         Ash.Query    .    for_read    (    ...    )        |>         Ash    .    read!    (    page    :         [    limit    :         20    ,         offste    :         40    ]    )

#### Complex Filtering

    # Filtering with relationships        posts         =         MyApp.Blog    .    list_posts!    (    
          query    :         [    
            filter    :         [    
              author    :         [    verified    :         true    ]    ,    
              comments_count    :         [    greater_than    :         5    ]    
            ]    
          ]        )    
        # Using filter expressions (requires building query manually)        query         =     
          MyApp.Post    
          |>         Ash.Query    .    filter    (    
            status         ==         :published         and     
            (    author    .    verified         ==         true         or         author    .    admin         ==         true    )    
          )

## Validations on Read Actions

Read actions support validations to ensure query arguments meet your requirements before processing. Most built-in validations work on both changesets and queries.

Validations run alongside preparations during the query building phase, in the order they are defined in the action. This means you can mix preparations and validations, and they will execute in the sequence you specify.

### Supported Validations

The following built-in validations support queries:

+ `action_is` - validates the action name
+ `argument_does_not_equal`, `argument_equals`, `argument_in` - validates argument values
+ `compare` - compares argument values 
+ `confirm` - confirms two arguments match
+ `match` - validates arguments against regex patterns
+ `negate` - negates other validations
+ `one_of` - validates arguments are in allowed values
+ `present` - validates required arguments are present
+ `string_length` - validates string argument length

### Validation Examples

    actions         do    
          read         :user_search         do    
            argument         :email    ,         :string    
            argument         :role    ,         :string    
            argument         :min_age    ,         :integer    
            argument         :max_age    ,         :integer    

            # Validate email format    
            validate         match    (    :email    ,         ~r/^[^    \s    ]+@[^    \s    ]+    \.    [^    \s    ]+$/    )         do    
              message         "must be a valid email address"    
            end    

            # Validate role is one of allowed values    
            validate         one_of    (    :role    ,         [    "admin"    ,         "user"    ,         "moderator"    ]    )    

            # Validate age range makes sense    
            validate         compare    (    :min_age    ,         less_than    :         :max_age    )         do    
              message         "minimum age must be less than maximum age"    
            end    

            # Conditional validation - only validate email if provided    
            validate         present    (    :email    )         do    
              where         present    (    :email    )    
            end    

            # Skip expensive validation if query is already invalid    
            validate         expensive_validation    (    )         do    
              only_when_valid?         true    
            end    
          end        end

### Where Clauses

Use `where` clauses to conditionally apply validations:

    read         :conditional_search         do    
          argument         :include_archived    ,         :boolean    ,         default    :         false    
          argument         :archive_reason    ,         :string    

          # Only validate archive_reason if including archived items    
          validate         present    (    :archive_reason    )         do    
            where         argument_equals    (    :include_archived    ,         true    )    
          end        end

### only\_when\_valid? Option

Use `only_when_valid?` to skip validations when the query is already invalid:

    read         :complex_search         do    
          argument         :required_field    ,         :string    

          # This validation must pass    
          validate         present    (    :required_field    )    

          # This expensive validation only runs if query is valid so far    
          validate         expensive_external_validation    (    )         do    
            only_when_valid?         true    
          end        end

For detailed information about query capabilities, see:

+ `Ash.Query` module documentation for building queries
+ `Ash.Query.build/2` for all available query options
+ Write Queries guide for practical examples
+ Validations guide for more validation examples



# Create Actions

Create actions are used to create new records in the data layer. For example:

    # on a ticket resource        create         :open         do    
          accept         [    :title    ]    
          change         set_attribute    (    :status    ,         :open    )        end

Here we have a create action called `:open` that allows setting the `title`, and sets the `status` to `:open`. It could be called like so:

    Ticket        |>         Ash.Changeset    .    for_create    (    :open    ,         %{    title    :         "Need help!"    }    )        |>         Ash    .    create!    (    )

For a full list of all of the available options for configuring create actions, see the Ash.Resource.Dsl documentation.

See the Code Interface guide for creating an interface to call the action more elegantly, like so:

    Support    .    open_ticket!    (    "Need help!"    )

## Bulk creates

Bulk creates take a list or stream of inputs for a given action, and batches calls to the underlying data layer.

Given our example above, you could call `Ash.bulk_create` like so:

    Ash    .    bulk_create    (    [    %{    title    :         "Foo"    }    ,         %{    title    :         "Bar"    }    ]    ,         Ticket    ,         :open    )

### Check the docs\!

Make sure to thoroughly read and understand the documentation in `Ash.bulk_create/4` before using. Read each option and note the default values. By default, bulk creates don't return records or errors, and don't emit notifications.

## Performance

Generally speaking, all regular Ash create actions are compatible \(or can be made to be compatible\) with bulk create actions. However, there are some important considerations.

+ 
`Ash.Resource.Change` modules can be optimized for bulk actions by implementing `batch_change/3`, `before_batch/3` and `after_batch/3`. If you implement `batch_change/3`, the `change` function will no longer be called, and you should swap any behavior implemented with `before_action` and `after_action` hooks to logic in the `before_batch` and `after_batch` callbacks.

+ 
Actions that reference arguments in changes, i.e `change set_attribute(:attr, ^arg(:arg))` will prevent us from using the `batch_change/3` behavior. This is usually not a problem, for instance that change is lightweight and would not benefit from being optimized with `batch_change/3`

+ 
If your action uses `after_action` hooks, or has `after_batch/3` logic defined for any of its changes, then we *must* ask the data layer to return the records it inserted. Again, this is not generally a problem because we throw away the results of each batch by default. If you are using `return_records?: true` then you are already requesting all of the results anyway.


## Returning a Stream

Returning a stream allows you to work with a bulk action as an Elixir Stream. For example:

    input_stream    (    )        |>         Ash    .    bulk_create    (    Resource    ,         :action    ,         return_stream?    :         true    ,         return_records?    :         true    )        |>         Stream    .    map    (    fn         {    :ok    ,         result    }         ->    
          # process results    
          {    :error    ,         error    }         ->    
          # process errors        end    )        |>         Enum    .    reduce    (    %{    }    ,         fn         {    :ok    ,         result    }    ,         acc         ->    
           # process results    
           {    :error    ,         error    }         ->    
           # process errors        end    )

### Be careful with streams

Because streams are lazily evaluated, if you were to do something like this:

    [    input1    ,         input2    ,         ...    ]         # has 300 things in it        |>         Ash    .    bulk_create    (    
          Resource    ,    
          :action    ,    
          return_stream?    :         true    ,    
          return_records?    :         true    ,    
          batch_size    :         100         #  default is 100        )        |>         Enum    .    take    (    150    )         # stream has 300, but we only take 150

What would happen is that we would insert 200 records. The stream would end after we process the first two batches of 100. Be sure you aren't using things like `Stream.take` or `Enum.take` to limit the amount of things pulled from the stream, unless you actually want to limit the number of records created.

## Upserts

Upserting is the process of "creating or updating" a record, modeled with a single simple create. Both bulk creates and regular creates support upserts. Upserts can be declared in the action, like so:

    create         :create_user         do    
          accept         [    :email    ]    
          upsert?         true    
          upsert_identity         :unique_email        end

Or they can be done with options when calling the create action.

    Ash    .    create!    (    changeset    ,         upsert?    :         true    ,         upsert_identity    :         :unique_email    )

### Upserts do not use an update action

While an upsert is conceptually a "create or update" operation, it does not result in an update action being called. The data layer contains the upsert implementation. This means that if you have things like global changes that are only run on update, they will not be run on upserts that result in an update. Additionally, notifications for updates will not be emitted from upserts. Most importantly, there are no *read* or *update* policies applied\! You must take care that an upsert can only target records that the user has permission to update.

#### Targeting Upserts

Lets imagine that you want a user to upsert an article by its slug, but only if it is their article:

If your action looked like this:

    create         :upsert_article_by_slug         do    
          upsert?         true    
          accept         [    :slug    ,         :title    ,         :body    ]    
          upsert_identity         :unique_slug        end

And one way it could be called is like so:

    Article        |>         Ash.Changeset    .    for_create    (    
          :upsert_article_by_slug    ,     
          %{    slug    :         "foo"    ,         title    :         "new title"    ,         slug    :         "new slug"    }    ,    
          actor    :         current_user        )        |>         Ash    .    create!    (    )

This would create an article, unless there is an article with a matching slug in which case it would update the title and the body to match the provided input. Let's add the "only if it is their article" functionality.

For this we use a `filter` change to further scope the upsert:

    create         :upsert_article_by_slug         do    
          upsert?         true    
          accept         [    :slug    ,         :title    ,         :body    ]    
          upsert_identity         :unique_slug    
          upsert_condition         expr    (    user_id         ==         ^    actor    (    :id    )    )        end

### What is `^actor(:id)` ?

Many places in Ash that support expression support *templates*. These are ways to refer to certain things that are commonly available, like the actor, or action argument values.

For more information, see the expressions guide

Now, when we perform this upsert, there are three possible outcomes:

+ There is no article with that `slug`, in which case the article is created
+ There is an article with that `slug`, and the `user_id` matches the provided actor's `id`, so it is updated with the new title and body.
+ There is an article with that `slug`, and the `user_id` does not match the provided actor's, `id`, in which case the action results in a `Ash.Error.Changes.StaleRecord` error. This is the same error that would occur if the actor attempted to update something that had changed in some unexpected way in the database.

### Improving the stale record error

You may wish to transform this into an error message that can be displayed to the user, using the `d:actions.create.error_handler` option. For example:

    create         :upsert_article_by_slug         do    
          upsert?         true    
          accept         [    :slug    ,         :title    ,         :body    ]    
          upsert_identity         :unique_slug    
          upsert_condition         expr    (    user_id         ==         ^    actor    (    :id    )    )    
          error_handler         fn     
            _changeset    ,         %    Ash.Error.Changes.StaleRecord    {    }         ->    
              Ash.Error.Changes.InvalidChanges    .    exception    (    field    :         :slug    ,         message    :         "has already been taken"    )    "    

            _         changeset    ,         other         ->    
              # leave other errors untouched    
              other    
          end        end

### Atomic Updates

Upserts support atomic updates. These atomic updates *do not apply to the data being created*. They are only applied in the case of an update. For example:

    create         :create_game         do    
          accept         [    :identifier    ]    
          upsert?         true    
          upsert_identity         :identifier    
          change         set_attribute    (    :score    ,         0    )    
          change         atomic_update    (    :score    ,         expr    (    score         +         1    )    )        end

This will result in creating a game with a score of 0, and if the game already exists, it will increment the score by 1.

For information on options configured in the action, see `d:Ash.Resource.Dsl.actions.create`. For information on options when calling the action, see `Ash.create/2`.

## What happens when you run a create Action

All actions are run in a transaction if the data layer supports it. You can opt out of this behavior by supplying `transaction?: false` when creating the action. When an action is being run in a transaction, all steps inside of it are serialized because transactions cannot be split across processes.

+ Authorization is performed on the changes
+ A before action hook is added to set up belongs\_to relationships that are managed. This means potentially creating/modifying the destination of the relationship, and then changing the `destination_attribute` of the relationship.
+ `before_transaction` and `around_transaction` hooks are called \(`Ash.Changeset.before_transaction/2`\). Keep in mind, any validations that are marked as `before_action? true` \(or all global validations if your action has `delay_global_validations? true`\) will not have happened at this point.
+ A transaction is opened if the action is configured for it \(by default they are\) and the data layer supports transactions
+ `before_action` hooks are performed in order
+ The main action is sent to the data layer
+ `after_action` hooks are performed in order
+ Non-belongs-to relationships are managed, creating/updating/destroying related records.
+ The transaction is closed, if one was opened
+ `after_transaction` hooks are invoked with the result of the transaction \(even if it was an error\)



# Update Actions

Update actions are used to update records in the data layer. For example:

    # on a ticket resource        update         :close         do    
          accept         [    :close_reason    ]    
          change         set_attribute    (    :status    ,         :closed    )        end

Here we have an update action called `:close` that allows setting the `close_reason`, and sets the `status` to `:closed`. It could be called like so:

    ticket         # providing an initial ticket to close        |>         Ash.Changeset    .    for_update    (    :close    ,         %{    close_reason    :         "I figured it out."    }    )        |>         Ash    .    update!    (    )

For a full list of all of the available options for configuring update actions, see the Ash.Resource.Dsl documentation.

See the Code Interface guide for creating an interface to call the action more elegantly, like so:

    Support    .    close_ticket!    (    ticket    ,         "I figured it out."    )        # You can also provide an id        Support    .    close_ticket!    (    ticket    .    id    ,         "I figured it out."    )

## Atomics

Atomic updates can be added to a changeset, which will update the value of an attribute given by an expression. Atomics can be a very powerful way to model updating data in a simple way. An action does not have to be fully atomic in order to leverage atomic updates. For example:

    update         :add_to_name         do    
          argument         :to_add    ,         :string    ,         allow_nil?         false    
          change         atomic_update    (    :name    ,         expr    (    "    #{    name    }    _    #{    to_add    }    "    )    )        end

Changing attributes in this way makes them safer to use in concurrent environments, and is typically more performant than doing it manually in memory.

### Atomics are not stored with other changes

While we recommend using atomics wherever possible, it is important to note that they are stored in their own map in the changeset, i.e `changeset.atomics`, meaning if you need to do something later in the action with the new value for an attribute, you won't be able to access the new value. This is because atomics are evaluated in the data layer. You can, however, access "the old or new value" in a similar way to `Ash.Changeset.get_attribute`, using the template expression, `atomic_ref(:name)`. See the section below for more.

### **`atomic_ref/1`**

Lets say that you have an action that may perform multiple atomic update on a single column, or for some other reason needs to refer to the new value. The only way to access that new value is *also* in an atomic update, change, or validation, using `atomic_ref/1`. There is no way to access the new value prior to the action being run with something like `Ash.Changeset.get_attribute/2`.

For example, lets say you have a postgres function that will slugify a string, and you want to make sure to always set it to the slugified version of `name`, whenever `name` is changing.

    changes         do    
          change         atomic_update    (    :slug    ,         expr    (    fragment    (    "slugify(?)"    ,         ^    atomic_ref    (    :name    )    )    )    )    ,         where    :         changing    (    :name    )    ,         on    :         [    :update    ]        end

By using `atomic_ref/1` here, you are always referring to the new value of `name`, even if another atomic update has been made that modifies `name`.

Because the validation `changing/1` can be done atomically, and the change `atomic_update/2` \(naturally\) can be done atomically, this is a fully atomic update. Lets say that you paired this with an action like this:

    update         :add_to_name         do    
          argument         :to_add    ,         :string    ,         allow_nil?         false    
          change         atomic_update    (    :name    ,         expr    (    "    #{    name    }    _    #{    to_add    }    "    )    )        end

and would produce a SQL update along the lines of:

    UPDATE table
      SET name = name || $1,
      slug = CASE
        WHEN name = name || $1 THEN
          slug
        ELSE
          slugify(name || $1)
      END
    WHERE id = $2

This is a *fully atomic update*, because all changes are done atomically in the data layer. We now have the benefits of composable building blocks *and* atomic updates.

## Fully Atomic updates

Atomic updates are a special case of update actions that can be done completely atomically. If your update action can't be done atomically, you will get an error unless you have set `require_atomic? false`. This is to encourage you to opt for atomic updates wherever reasonable. Not all actions can reasonably be made atomic, and not all non-atomic actions are problematic for concurrency. The goal is only to make sure that you are aware and have considered the implications.

### What does atomic mean?

An atomic update is one that can be done in a single operation in the data layer. This ensures that there are no issues with concurrent access to the record being updated, and that it is as performant as possible. For example, the following action cannot be done atomically, because it has an anonymous function change on it.

    update         :increment_score         do    
          change         fn         changeset    ,         _         ->    
            Ash.Changeset    .    change_attribute    (    changeset    ,         :score    ,         changeset    .    data    .    score         +         1    )    
          end        end

The action shown above is not safe to run concurrently. If two separate processes fetch the record with score `1`, and then call `increment_score`, they will both set the score to `2`, when what you almost certainly intended to do was end up with a score of `3`

By contrast, the following action *can* be done atomically

    update         :increment_score         do    
          change         atomic_update    (    :score    ,         expr    (    score         +         1    )    )        end

In a SQL data layer, this would produce SQL along the lines of

    "UPDATE table SET score = score + 1 WHERE id = post_id"

## What makes an action not atomic?

### Types that can't be atomically casted

Not all types support being casted atomically. For instance, `:union` types, and embedded resources that have primary keys\(and therefore may need to use an update action\) cannot currently be casted atomically.

### Changes without an **`atomic`** callback

Changes can be enhanced to support atomics by defining `Ash.Resource.Change.atomic/3`. This callback can return a map of atomic updates to be made to attributes. Here is a simplified example from the built in `Ash.Resource.Change.Builtins.increment/2` change:

    @impl         true        def         atomic    (    _changeset    ,         opts    ,         _context    )         do    
          # Set the requested attribute to its current value (atomic_ref) + the amount    
          {    :atomic    ,         %{    opts    [    :attribute    ]         =>         expr    (    ^    atomic_ref    (    opts    [    :attribute    ]    )         +         ^    opts    [    :amount    ]    )    }    }        end

### Validations without an **`atomic`** callback

Validations can be enhanced to support atomics by defining `Ash.Resource.Validation.atomic/3`. This callback can return an atomic validation \(or a list of atomic validations\), which is represented by a list of affected attributes \(not currently used\), an expression that should trigger an error, and the expression producing the error. Here is an example from the built in `Ash.Resource.Validations.Builtins.attribute_equals/2` validation:

    @impl         true        def         atomic    (    _changeset    ,         opts    ,         context    )         do    
          {    :atomic    ,         [    opts    [    :attribute    ]    ]    ,         expr    (    ^    atomic_ref    (    opts    [    :attribute    ]    )         !=         ^    opts    [    :value    ]    )    ,    
           expr    (    
             error    (    ^    InvalidAttribute    ,         %{    
               field    :         ^    opts    [    :attribute    ]    ,    
               value    :         ^    atomic_ref    (    opts    [    :attribute    ]    )    ,    
               message    :         ^    (    context    .    message         ||         "must equal %{value}"    )    ,    
               vars    :         %{    field    :         ^    opts    [    :attribute    ]    ,         value    :         ^    opts    [    :value    ]    }    
             }    )    
           )    }        end

## Bulk updates

There are three strategies for bulk updating data. They are, in order of preference: `:atomic`, `:atomic_batches`, and `:stream`. When calling `Ash.bulk_update/4`, you can provide a strategy or strategies that can be used, and Ash will choose the best one available. The implementation of the update action and the capabilities of the data layer determine what strategies can be used.

## Atomic

Atomic bulk updates are used when the subject of the bulk update is a query, and the update action can be done atomically and the data layer supports updating a query. They map to a single statement to the data layer to update all matching records. The data layer must support updating a query.

### Example

    Ticket        |>         Ash.Query    .    filter    (    status         ==         :open    )        |>         Ash    .    bulk_update!    (    :close    ,         %{    reason    :         "Closing all open tickets."    }    )

If using a SQL data layer, this would produce a query along the lines of

    UPDATE tickets
    SET status = 'closed',
        reason = 'Closing all open tickets.'
    WHERE status = 'open';

## Atomic Batches

Atomic batches is used when the subject of the bulk update is an enumerable \(i.e list or stream\) of records and the update action can be done atomically and the data layer supports updating a query. The records are pulled out in batches, and then each batch follows the logic described above. The batch size is controllable by the `batch_size` option.

### Example

        Ash    .    bulk_update!    (    one_hundred_tickets    ,         :close    ,         %{    reason    :         "Closing all open tickets."    }    ,         batch_size    :         10    )

If using a SQL data layer, this would produce ten queries along the lines of

    UPDATE tickets
    SET status = 'closed',
        reason = 'Closing all open tickets.'
    WHERE id IN (...ids)

## Stream

Stream is used when the update action cannot be done atomically or if the data layer does not support updating a query. If a query is given, it is run and the records are used as an enumerable of inputs. If an enumerable of inputs is given, each one is updated individually. There is nothing inherently wrong with doing this kind of update, but it will naturally be slower than the other two strategies. The benefit of having a single interface \(`Ash.bulk_update/4`\) is that the caller doesn't need to change based on the performance implications of the action.

## Running a standard update action

All actions are run in a transaction if the data layer supports it. You can opt out of this behavior by supplying `transaction?: false` when creating the action. When an action is being run in a transaction, all steps inside of it are serialized because transactions cannot be split across processes.

+ Authorization is performed on the changes
+ A before action hook is added to set up belongs\_to relationships that are managed. This means potentially creating/modifying the destination of the relationship, and then changing the `destination_attribute` of the relationship.
+ `before_transaction` and `around_transaction` hooks are called \(`Ash.Changeset.before_transaction/2`\). Keep in mind, any validations that are marked as `before_action? true` \(or all global validations if your action has `delay_global_validations? true`\) will not have happened at this point.
+ A transaction is opened if the action is configured for it \(by default they are\) and the data layer supports transactions
+ `before_action` hooks are performed in order
+ The main action is sent to the data layer
+ `after_action` hooks are performed in order
+ Non-belongs-to relationships are managed, creating/updating/destroying related records.
+ The transaction is closed, if one was opened
+ `after_transaction` hooks are invoked with the result of the transaction \(even if it was an error\)

## Atomic Upgrade

Update actions that are run as "normal" update actions will, at the time of execution, be "upgraded" to an atomic action if possible. This means taking the original inputs and building a corresponding atomic action. This behavior is primarily useful for using things like `AshPhoenix.Form`, where you want to validate and see the effects of an action before running it, but want the ultimate invocation to be atomic \(i.e concurrency safe\).

You can disable this by adding `atomic_upgrade? false` to the action configuration. Additionally, you may want to configure the read action used for atomic upgrades \(defaults to the primary read\), with `atomic_upgrade_with` option, i.e `atomic_upgrade_with :list_all`



# Destroy Actions

Destroy actions are comparatively simple. They expect to remove a given record, and by default return `:ok` in the successful case.

Most destroy actions are one-liners, for example:

    destroy         :destroy        # Can be added with the defaults        defaults         [    :read    ,         :destroy    ]

## Soft Destroy

You can mark a destroy action as `soft? true`, in which case it is handled by the `update` action logic.

For example:

    destroy         :archive         do    
          soft?         true    
          change         set_attribute    (    :archived_at    ,         &    DateTime    .    utc_now    /    0    )        end

For a full list of all of the available options for configuring destroy actions, see the Ash.Resource.Dsl documentation.

## Calling Destroy Actions

The basic formula for calling a destroy action looks like this:

    record        |>         Ash.Changeset    .    for_destroy    (    :action_name    ,         %{    argument    :         :value    }    ,         ...    opts    )        |>         Ash    .    destroy!    (    )

See below for variations on action calling, and see the code interface guide guide for how to define idiomatic and convenient functions that call your actions.

## Returning the destroyed record

You can use the `return_destroyed?` option to return the destroyed record.

    # when a resource is passed, or a query w/ no action, the primary destroy action is used.        ticket         =         Ash    .    get!    (    Ticket    ,         1    )        Ash    .    destroy!    (    ticket    )        # => :ok        ticket         =         Ash    .    get!    (    Ticket    ,         2    )        Ash    .    destroy!    (    ticket    ,         return_destroyed?    :         true    )        # => {:ok, %Ticket{}}

### Loading on destroyed records

Keep in mind that using `Ash.load` on destroyed data will produced mixed results. Relationships may appear as empty, or may be loaded as expected \(depending on the data layer/relationship implementation\) and calculations/aggregates may show as `nil` if they must be run in the data layer.

## Bulk Destroys

There are three strategies for bulk destroying data. They are, in order of preference: `:atomic`, `:atomic_batches`, and `:stream`. When calling `Ash.bulk_destroy/4`, you can provide a strategy or strategies that can be used, and Ash will choose the best one available. The capabilities of the data layer determine what strategies can be used.

## Atomic

Atomic bulk destroys are used when the subject of the bulk destroy is a query and the data layer supports destroying a query. They map to a single statement to the data layer to destroy all matching records.

### Example

    Ticket        |>         Ash.Query    .    filter    (    status         ==         :open    )        |>         Ash    .    bulk_destroy!    (    :close    ,         %{    }    )

If using a SQL data layer, this would produce a query along the lines of

    DELETE FROM tickets
    WHERE status = 'open';

## Atomic Batches

Atomic batches are used when the subject of the bulk destroy is an enumerable \(i.e list or stream\) of records and the data layer supports destroying a query. The records are pulled out in batches, and then each batch follows the logic described above. The batch size is controllable by the `batch_size` option.

### Example

        Ash    .    bulk_destroy!    (    one_hundred_tickets    ,         :close    ,         %{    }    ,         batch_size    :         10    )

If using a SQL data layer, this would produce ten queries along the lines of

    DELETE FROM tickets
    WHERE id IN (...ids)

## Stream

Stream is used when the data layer does not support destroying a query. If a query is given, it is run and the records are used as an enumerable of inputs. If an enumerable of inputs is given, each one is destroyed individually. There is nothing inherently wrong with doing this kind of destroy, but it will naturally be slower than the other two strategies. The benefit of having a single interface \(`Ash.bulk_destroy/4`\) is that the caller doesn't need to change based on the performance implications of the action.

### Check the docs\!

Make sure to thoroughly read and understand the documentation in `Ash.bulk_destroy/4` before using. Read each option and note the default values. By default, bulk destroys don't return records or errors, and don't emit notifications.

### Destroying records

If you provide an enumerable of records, they will be destroyed in batches. For example:

    Ash    .    bulk_destroy    (    [    %    Ticket    {    }    ,         %    Ticket    {    }    ]    ,         :destroy    ,         %{    }    )

### Destroying

## Running the Destroy Action

All actions are run in a transaction if the data layer supports it. You can opt out of this behavior by supplying `transaction?: false` when creating the action. When an action is being run in a transaction, all steps inside of it are serialized because transactions cannot be split across processes.

+ Authorization is performed on the changes
+ A before action hook is added to set up belongs\_to relationships that are managed. This means potentially creating/modifying the destination of the relationship, and then changing the `destination_attribute` of the relationship.
+ `before_transaction` and `around_transaction` hooks are called \(`Ash.Changeset.before_transaction/2`\). Keep in mind, any validations that are marked as `before_action? true` \(or all global validations if your action has `delay_global_validations? true`\) will not have happened at this point.
+ A transaction is opened if the action is configured for it \(by default they are\) and the data layer supports transactions
+ `before_action` hooks are performed in order
+ The main action is sent to the data layer
+ `after_action` hooks are performed in order
+ Non-belongs-to relationships are managed, creating/updating/destroying related records.
+ The transaction is closed, if one was opened
+ `after_transaction` hooks are invoked with the result of the transaction \(even if it was an error\)



# Generic Actions

Generic actions are so named because there are no special rules about how they work. A generic action takes arguments and returns a value. The struct used for building input for a generic action is `Ash.ActionInput`.

    action         :say_hello    ,         :string         do    
          argument         :name    ,         :string    ,         allow_nil?    :         false    

          run         fn         input    ,         _         ->    
            {    :ok    ,         "Hello:     #{    input    .    arguments    .    name    }    "    }    
          end        end

A generic action declares its arguments, return type, and implementation, as illustrated above.

### No return? No problem\!

Generic actions can omit a return type, in which case running them returns `:ok` if successful.

    action         :schedule_job         do    
          argument         :job_name    ,         :string    ,         allow_nil?    :         false    
          run         fn         input    ,         _         ->    
            # Schedule the job    
            :ok    
          end        end

For a full list of all of the available options for configuring generic actions, see the Ash.Resource.Dsl documentation.

## Calling Generic Actions

The basic formula for calling a generic action looks like this:

    Resource        |>         Ash.ActionInput    .    for_action    (    :action_name    ,         %{    argument    :         :value    }    ,         ...    opts    )        |>         Ash    .    run_action!    (    )

See the code interface guide guide for how to define idiomatic and convenient functions that call your actions.

## Why use generic actions?

The example above could be written as a normal function in elixir, i.e

    def         say_hello    (    name    )    ,         do    :         "Hello:     #{    name    }    "

The benefit of using generic actions instead of defining normal functions:

+ They can be used with api extensions like `ash_json_api` and `ash_graphql`
+ Their inputs are type checked and casted
+ They support Ash authorization patterns \(i.e policies\)
+ They can be included in the code interface of a resource
+ They can be made transactional with a single option \(`transaction? true`\)

If you don't need any of the above, then there is no problem with writing regular Elixir functions\!

## Return types and constraints

Generic actions do not cast their return types. It is expected that the action return a valid value for the type that they declare. However, declaring additional constraints can inform API usage, and make the action more clear. For example:

    action         :priority    ,         :integer         do    
          constraints         [    min    :         1    ,         max    :         3    ]    
          argument         :status    ,         :atom    ,         constraints    :         [    one_of    :         [    :high    ,         :medium    ,         :low    ]    ]    

          run         fn         input    ,         _         ->    
            case         input    .    arguments    .    status         do    
              :high         ->         {    :ok    ,         3    }    
              :medium         ->         {    :ok    ,         2    }    
              :low         ->         {    :ok    ,         1    }    
            end    
          end        end

#### Returning resource instances

It sometimes happens that you want to make a generic action which returns an instance or instances of the resource. It's natural to assume that you can set your action's return type to the name of your resource. This won't work as resources do not define a type, unless they are embedded. In embedded resources, this won't work because the module is still being compiled, so referencing yourself as a type causes a compile error. Instead, use the `:struct` type and the `instance_of` constraint, like so:

    action         :get    ,         :struct         do    
          constraints         instance_of    :         __MODULE__    

          run         # ...        end

For returning many instances of the resource, you can set your action's return type to `{:array, :struct}` and set the `items` constraint to the name of your resource.

         action         :list_resources    ,         {    :array    ,         :struct    }         do    
           constraints         items    :         [    instance_of    :         __MODULE__    ]    

           run         # ...    
         end

## Calling Generic Actions

To execute a generic action in Ash, follow these steps:

1. **Prepare the action input:** Use `Ash.ActionInput.for_action/4` to specify the resource, the action and its arguments.
2. **Run the action:** Use `Ash.run_action/2` to execute the action with the prepared input.

### Example Usage

Consider an `Ash.Resource` with the action `:say_hello`:

    action         :say_hello    ,         :string         do    
          argument         :name    ,         :string    ,         allow_nil?    :         false    

          run         fn         input    ,         _         ->    
            {    :ok    ,         "Hello:     #{    input    .    arguments    .    name    }    "    }    
          end        end

Call this action:

    {    :ok    ,         greeting    }         =         Resource        |>         Ash.ActionInput    .    for_action    (    :say_hello    ,         %{    name    :         "Alice"    }    )        |>         Ash    .    run_action    (    )    
        IO    .    puts    (    greeting    )          # Output: Hello: Alice

### Using Code Interface

You can also use Code Interfaces to call actions:

Given a definition like:

    define         :say_hello    ,         args    :         [    :name    ]

    {    :ok    ,         greeting    }         =         Resource    .    say_hello    (    "Alice"    )        greeting         =         Resource    .    say_hello!    (    "Alice"    )

## Validations and Preparations

Generic actions support validations and preparations, allowing you to add business logic and input validation to your actions.

### Validations

Validations in generic actions work similarly to those in other action types. They validate the action input before the action logic runs.

    action         :create_user    ,         :struct         do    
          constraints         instance_of    :         __MODULE__    

          argument         :name    ,         :string    ,         allow_nil?    :         false    
          argument         :email    ,         :string    ,         allow_nil?    :         false    
          argument         :age    ,         :integer    

          validate         present    (    [    :name    ,         :email    ]    )    
          validate         match    (    :email    ,         ~r/@/    )    
          validate         compare    (    :age    ,         greater_than    :         13    )         do    
            message         "Must be at least 13 years old"    
          end    

          run         fn         input    ,         _         ->    
            # Create user logic here    
            {    :ok    ,         %    __MODULE__    {    
              name    :         input    .    arguments    .    name    ,    
              email    :         input    .    arguments    .    email    ,    
              age    :         input    .    arguments    .    age    
            }    }    
          end        end

You can also use custom validation modules:

    action         :transfer_funds    ,         :boolean         do    
          argument         :from_account    ,         :string    ,         allow_nil?    :         false    
          argument         :to_account    ,         :string    ,         allow_nil?    :         false    
          argument         :amount    ,         :decimal    ,         allow_nil?    :         false    

          validate         {    MyApp.Validations.SufficientFunds    ,         field    :         :amount    }    

          run         fn         input    ,         _         ->    
            # Transfer logic here    
            {    :ok    ,         true    }    
          end        end

### Preparations

Preparations allow you to modify the action input before the action runs. This is useful for setting computed values or applying business logic.

    action         :audit_log    ,         :string         do    
          argument         :action    ,         :string    ,         allow_nil?    :         false    
          argument         :details    ,         :map    ,         default    :         %{    }    

          prepare         fn         input    ,         _context         ->    
            # Add timestamp and actor information    
            updated_details         =         Map    .    merge    (    input    .    arguments    .    details    ,         %{    
              timestamp    :         DateTime    .    utc_now    (    )    ,    
              actor_id    :         input    .    context    [    :actor    ]    &    .    id    
            }    )    

            Ash.ActionInput    .    set_argument    (    input    ,         :details    ,         updated_details    )    
          end    

          run         fn         input    ,         _         ->    
            # Log the action    
            log_entry         =         "    #{    input    .    arguments    .    action    }    :     #{    inspect    (    input    .    arguments    .    details    )    }    "    
            {    :ok    ,         log_entry    }    
          end        end

You can also use the built-in `build` preparation:

    action         :search_with_defaults         do    
          argument         :query    ,         :string    
          argument         :filters    ,         :map    ,         default    :         %{    }    

          prepare         build    (    
            arguments    :         %{    
              filters    :         expr    (    Map    .    merge    (    ^    arg    (    :filters    )    ,         %{    active    :         true    }    )    )    
            }    
          )    

          run         fn         input    ,         _         ->    
            # Search logic with default filters applied    
            {    :ok    ,         perform_search    (    input    .    arguments    .    query    ,         input    .    arguments    .    filters    )    }    
          end        end

## Action Hooks

Generic actions support action-level hooks that run before and after the action execution.

### Before Action Hooks

Before action hooks run immediately before the action logic executes:

    action         :process_payment    ,         :boolean         do    
          argument         :amount    ,         :decimal    ,         allow_nil?    :         false    
          argument         :payment_method    ,         :string    ,         allow_nil?    :         false    

          validate         present    (    [    :amount    ,         :payment_method    ]    )    

          # Using a function    
          change         before_action    (    fn         input    ,         _context         ->    
            # Log the payment attempt    
            Logger    .    info    (    "Processing payment of     #{    input    .    arguments    .    amount    }    "    )    

            # Validate payment method    
            if         input    .    arguments    .    payment_method         not         in         [    "credit_card"    ,         "bank_transfer"    ]         do    
              Ash.ActionInput    .    add_error    (    input    ,         "Invalid payment method"    )    
            else    
              input    
            end    
          end    )    

          run         fn         input    ,         _         ->    
            # Process payment logic    
            {    :ok    ,         true    }    
          end        end

### After Action Hooks

After action hooks run after successful action execution:

    action         :send_notification    ,         :boolean         do    
          argument         :message    ,         :string    ,         allow_nil?    :         false    
          argument         :recipient    ,         :string    ,         allow_nil?    :         false    

          change         after_action    (    fn         input    ,         result    ,         _context         ->    
            # Log successful notification    
            Logger    .    info    (    "Notification sent to     #{    input    .    arguments    .    recipient    }    "    )    

            # Could perform additional side effects here    
            {    :ok    ,         result    }    
          end    )    

          run         fn         input    ,         _         ->    
            # Send notification logic    
            send_notification    (    input    .    arguments    .    recipient    ,         input    .    arguments    .    message    )    
            {    :ok    ,         true    }    
          end        end

### Using Custom Change Modules

You can also create reusable change modules for generic actions:

    defmodule         MyApp.Changes.AuditAction         do    
          use         Ash.Resource.Change    

          def         change    (    input    ,         _opts    ,         context    )         do    
            Ash.ActionInput    .    before_action    (    input    ,         fn         input         ->    
              # Log the action attempt    
              MyApp.AuditLog    .    log_action    (    input    .    action    .    name    ,         input    .    arguments    ,         context    .    actor    )    
              input    
            end    )    
            |>         Ash.ActionInput    .    after_action    (    fn         input    ,         result         ->    
              # Log successful completion    
              MyApp.AuditLog    .    log_success    (    input    .    action    .    name    ,         result    ,         context    .    actor    )    
              {    :ok    ,         result    }    
            end    )    
          end        end

Then use it in your action:

    action         :sensitive_operation    ,         :boolean         do    
          argument         :data    ,         :map    ,         allow_nil?    :         false    

          change         MyApp.Changes.AuditAction    

          run         fn         input    ,         _         ->    
            # Sensitive operation logic    
            {    :ok    ,         true    }    
          end        end

## Global Validations and Preparations

Generic actions also support global validations and preparations defined at the resource level:

    defmodule         MyApp.MyResource         do    
          use         Ash.Resource    

          # Global preparations that apply to all actions    
          preparations         do    
            prepare         fn         input    ,         _context         ->    
              # Add tenant information to all actions    
              Ash.ActionInput    .    set_context    (    input    ,         %{    tenant    :         "default"    }    )    
            end         do    
              # Only apply to generic actions    
              on    :         [    :action    ]    
            end    
          end    

          # Global validations that apply to all actions    
          validations         do    
            validate         present    (    :actor    )         do    
              message         "Authentication required"    
              on    :         [    :action    ]          # Only apply to generic actions    
            end    
          end    

          actions         do    
            action         :my_action         do    
              # Action-specific logic    
            end    
          end        end

## Execution Order

For generic actions, the execution order is:

1. Global preparations/validations \(in order of definition\)
2. Action preparations/validations \(in order of definition\)
3. `before_action` hooks
4. Action logic execution
5. `after_action` hooks \(success only\)

This order ensures that global business logic runs first, followed by action-specific logic, and finally the action hooks.



# Manual Actions

Manual actions allow you to control how an action is performed instead of dispatching to a data layer. To do this, specify the `manual` option with a module that adopts the appropriate behavior.

Manual actions are a way to implement an action in a fully custom way. This can be a very useful escape hatch when you have something that you are finding difficult to model with Ash's builtin tools.

## Manual Creates/Updates/Destroy

For manual create, update and destroy actions, a module is passed that uses one of the following \(`Ash.Resource.ManualCreate`, `Ash.Resource.ManualUpdate` and `Ash.Resource.ManualDestroy`\).

For example:

    create         :special_create         do    
          manual         MyApp.DoCreate        end    
        # The implementation        defmodule         MyApp.DoCreate         do    
          use         Ash.Resource.ManualCreate    

          def         create    (    changeset    ,         _    ,         _    )         do    
            record         =         create_the_record    (    changeset    )    
            {    :ok    ,         record    }    

            # An `{:error, error}` tuple should be returned if something failed    
          end        end

The underlying record can be retrieved from `changeset.data` for update and destroy manual actions. The changeset given to the manual action will be after any `before_action` hooks, and before any `after_action` hooks.

## Manual Read Actions

Manual read actions work the same, except the will also get the "data layer query". For AshPostgres, this means you get the ecto query that would have been run. You can use `Ash.Query.apply_to/3` to apply a query to records in memory. This allows you to fetch the data in a way that is not possible with the data layer, but still honor the query that was provided to.

    # in the resource        actions         do    
          read         :action_name         do    
            manual         MyApp.ManualRead    
            # or `{MyApp.ManualRead, ...opts}`    
          end        end    
        # the implementation        defmodule         MyApp.ManualRead         do    
          use         Ash.Resource.ManualRead    

          def         read    (    ash_query    ,         ecto_query    ,         _opts    ,         _context    )         do    
            ...    
            {    :ok    ,         query_results    }         |         {    :error    ,         error    }    
          end        end

In addition to returning query results, you can return a `t:Ash.Resource.ManualRead.extra_info()`. This contains a `full_count` key, which can be used when paginating to set the total count of records.

    defmodule         MyApp.ManualRead         do    
          use         Ash.Resource.ManualRead    

          def         read    (    ash_query    ,         ecto_query    ,         _opts    ,         _context    )         do    
            %{    "data"         =>         data    ,         "count"         =>         count    }         =         make_some_api_request    (    ...    )    
            if         ash_query    .    page    [    :count    ]         do    
              {    :ok    ,         query_results    }    
            else    
              {    :ok    ,         query_results    ,         %{    full_count    :         count    }    }     
            end    
          end        end    

### Modifying the query

As an alternative to manual read actions, you can also provide the `modify_query` option, which takes an `MFA` and allows low level manipulation of the query just before it is dispatched to the data layer.

For example:

    read         :read         do    
          modify_query         {    MyApp.ModifyQuery    ,         :modify    ,         [    ]    }        end    
        defmodule         MyApp.ModifyQuery         do    
          def         modify    (    ash_query    ,         data_layer_query    )         do    
            {    :ok    ,         modify_data_layer_query    (    data_layer_query    )    }    
          end        end

This can be used as a last-resort escape hatch when you want to still use resource actions but need to do something that you can't do easily with Ash tools. As with any low level escape hatch, here be dragons.



# Actors & Authorization

Authorization in Ash involves three things:

+ actor - the entity \(i.e user, organization, device\) performing a given action. See the glossary for more.
+ authorize? - a flag that tells Ash to run authorization.
+ authorizers - the extensions on a resource that can modify or forbid the action.

## Setting **`actor`** and **`authorize?`**

All functions in Ash that may perform authorization and/or wish to use the actor accept an `actor` and an `authorize?` option. For example:

Building a changeset/query/input is the best time to provide the actor option

    Ash.Changeset    .    for_create    (    Post    ,         %{    title    :         "Post Title"    }    ,         actor    :         current_user    ,         authorize?    :         true    )

If calling a function without changeset/query/input, you can provide the `actor` option at that point.

    Ash    .    count!    (    Post    ,         actor    :         current_user    ,         authorize?    :         true    )

Functions created with the code interface also accept an `actor` option.

    MyDomain    .    create_post!    (    Post    ,         authorize?    :         true    )

### Set the actor on the query/changeset/input

The hooks on a query/changeset/input to an action may need to know the actor, so you need to set the actor when building them, not when calling the action.

    # DO THIS    
        Post        |>         Ash.Query    .    for_read    (    :read    ,         %{    }    ,         actor    :         current_user    )        |>         Ash    .    read!    (    )    
        # DON'T DO THIS    
        Post        |>         Ash.Query    .    for_read!    (    :read    )        |>         Ash    .    read!    (    actor    :         current_user    )

## Default value of **`authorize?`**

The default value of `authorize?` is determined by the `authorization` configuration of the relevant domain. By default, `authorize?` is set to `true` \(and so can be omitted in all of the examples above\). If a resource has no authorizers, then all requests will be allowed.

## Authorizers

Authorizers are in control of what happens during authorization. Generally, you won't need to create your own authorizer, as the builtin policy authorizer `Ash.Policy.Authorizer` works well for any use case. See the Policies guide for more.

## Domain Authorization Configuration

### **`d:Ash.Domain.Dsl.authorization|require_actor?`**

Requires that an actor is set for all requests.

Important: `nil` is still a valid actor, so this won't prevent providing `actor: nil`. It only requires that the option itself is provided.

### **`d:Ash.Domain.Dsl.authorization|authorize`**

When to run authorization for a given request.

+ `:by_default` sets `authorize?: true` if the `authorize?` option was not set \(so it can be set to `false`\). This is the default.
+ `:always` forces `authorize?: true` on all requests to the domain.
+ `:when_requested` sets `authorize?: true` whenever an actor is set or `authorize?: true` is explicitly passed.



# Sensitive Data

## Public & Private Attributes

By default, attributes, calculations, aggregates and relationships are *private* \(they are marked `public?: false`\).  
If you are working with Ash in code, reading a resource, for example using `Ash.read/2`, the public/private status of an attribute is not relevant.  
However, when working with api extensions like `AshGraphql` and `AshJsonApi`, they will only include public fields in their interfaces. This helps avoid accidentally exposing data over "public" interfaces.

## Public & Private Arguments

Public/private arguments work the same way as public/private fields, except that they default to `public?: true`.  
This is because arguments to an action being used in a public interface would naturally be expected to be `public`. If an argument is marked as `public?: false`, it can only be set using one of the following methods:

1. `Ash.Query.set_argument/3`
2. `Ash.Changeset.set_argument/3`
3. By setting `private_argument` option when creating a changeset. For eg., `Ash.Changeset.for_create(:create_with_private_argument, %{public_title: "title"}, private_arguments: %{private_name: "private"}`

## Sensitive Attributes

Using `sensitive? true` will cause an attribute, calculation or argument to show as `"** Redacted **"` when inspecting records.  
In filter statements, any value used in the same expression as a sensitive field will also be redacted. For example, you might see: `email == "** Redacted **"` in a filter statement if `email` is marked as sensitive.

### Show Sensitive Attributes

**IMPORTANT WARNING:** The following configuration should only ever be used in development mode\!

To display sensitive attributes in their original form during development, use the following config.

    config         :ash    ,         show_sensitive?    :         true

## Field Policies

Field policies are a way to control the visibility of individual fields \(except for relationships\) as a part of authorization flow, for those using `Ash.Policy.Authorizer`.  
If a field is not visible, it will be populated with `%Ash.ForbiddenField{}`, or will be not shown \(or may show an error\) in public interfaces. See the Policies guide for more.



# Policies

Policies determine what actions on a resource are permitted for a given actor, and can also filter the results of read actions to restrict the results to only records that should be visible.

To restrict access to specific fields \(attributes, aggregates, calculations\), see the section on field policies.

Read and understand the Actors & Authorization guide before proceeding, which explains actors, how to set them, and other relevant configurations.

## Setup

You'll need to add the extension to your resource, like so:

    use         Ash.Resource    ,         authorizers    :         [    Ash.Policy.Authorizer    ]

Then you can start defining policies for your resource.

## Policies

### Anatomy of a Policy

Each policy defined in a resource has two parts -

+ a condition or a list of conditions, such as `action_type(:read)`, `[action_type(:read), actor_attribute_equals(:admin, true)]` or `always()`. If the condition, or all conditions if given a list are true for a given action request, then the policy will be applied to the request.
+ a set of policy checks, each of which will be evaluated individually if a policy applies to a request.

If more than one policy applies to any given request \(eg. an admin actor calls a read action\) then **all applicable policies must pass** for the action to be performed.

A policy will produce one of three results: `:forbidden`, `:authorized`, or `:unknown`. `:unknown` is treated the same as `:forbidden`.

### The Simplest Policy

Let's start with the simplest \(most permissive\) policy:

    policies         do    
          policy         always    (    )         do    
            authorize_if         always    (    )    
          end        end

The first argument to `policy` is the condition. In this case, the condition is `always()` - a built-in helper always returning true, meaning that the policy applies to every request.

Within this policy we have a single policy check, declared with `authorize_if`. Checks logically apply from top to bottom, based on their check type. In this case, we'd read the policy as "this policy always applies, and authorizes always".

There are four check types, all of which do what they sound like they do:

+ `authorize_if` - if the check is true, the whole policy is authorized.
+ `authorize_unless` - if the check is false, the whole policy is authorized.
+ `forbid_if` - if the check is true, the whole policy is forbidden.
+ `forbid_unless` - if the check is false, the whole policy is forbidden.

If a single check does not explicitly authorize or forbid the whole policy, then the flow moves to the next check. For example, if an `authorize_if` check does NOT return true, this *does not mean the whole policy is forbidden* - it means that further checking is required.

### Policy with **`condition`** inside **`do`** block

A condition or a list of conditions can also be moved inside the `policy` block.

This can make a really long list of conditions easier to read.

    policies         do    
          policy         do    
            condition         always    (    )    
            authorize_if         always    (    )    
          end        end

### How a Decision is Reached

**Not every check in a policy must pass\!** This is described above, but is very important so another example is provided here. Checks go from top to bottom, are evaluated independently of each other, and *the first one that reaches a decision* determines the overall *policy result*. For example:

    policy         action_type    (    :create    )         do    
          authorize_if         IsSuperUser    
          forbid_if         Deactivated    
          authorize_if         IsAdminUser    
          forbid_if         RegularUserCanCreate    
          authorize_if         RegularUserAuthorized        end

We check those from top to bottom, so the first one of those that returns `:authorized` or `:forbidden` determines the entire outcome. For example:

    authorize_if         IsSuperUser         # If this is true, the actor is a superuser    
        # None of the rest of the checks matter, even if the actor is deactivated.        forbid_if         Deactivated        authorize_if         IsAdminUser        forbid_if         RegularUserCanCreate        authorize_if         RegularUserAuthorized

Conversely:

    authorize_if         IsSuperUser         # This can be false        forbid_if         Deactivated         # This can be false        authorize_if         IsAdminUser         # If this is true, then the policy is still authorized.    
        # And none of these checks matter        forbid_if         RegularUserCanCreate        authorize_if         RegularUserAuthorized

### Not all policy checks have yes/no answers

This will be covered in greater detail in Checks, but will be briefly mentioned here.

Ash provides two basic types of policy checks - *simple* checks and *filter* checks. Simple checks are what we commonly think of with authorization, and what the above example would suggest - is an actor allowed to perform a given operation, yes or no? But we can also use filter checks - given a list of resources, which ones is an actor allowed to perform the operation on?

Filter checks are applied to all read actions, including those generated for bulk updates and destroys.

### Read Actions and Filtering Behavior

An important characteristic of read actions is that, by default, they are **filtered** by policies rather than returning authorization errors. This means:

+ When a user is not allowed to see certain records, those records are simply filtered out of the results
+ Instead of receiving a `Forbidden` error, users typically get a `NotFound` error \(for single record queries\) or an empty/reduced result set \(for multi-record queries\)
+ This filtering behavior applies to all read actions, including `get`, `read`, and any custom read actions you define

For example, if a policy restricts users to only see their own posts, a query for all posts will automatically filter to only return the current user's posts, rather than raising an authorization error. Similarly, attempting to fetch a specific post that belongs to another user will result in a `NotFound` error rather than `Forbidden`.

This design is a security feature that prevents **enumeration attacks** and **information disclosure**. By not distinguishing between "record doesn't exist" and "record exists but you can't access it", the system prevents attackers from probing to discover the existence of protected data, mapping out the system's data structure, or conducting reconnaissance attacks through systematic querying.

#### Bypassing this behavior

You can bypass this behavior on a case-by-case basis with the `authorize_with` option, for data layers that support error expressions \(all of the core ones except `AshSqlite`\).

For example, given a post that the user cannot see:

    Ash    .    get!    (    Post    ,         123    )        # * Invalid:        # not found    
        Ash    .    get!    (    Post    ,         123    ,         authorize_with    :         :error    )        # * Forbidden

### Bypass policies

A bypass policy is just like a regular policy, except if a bypass passes, then other policies after it *do not need to pass*. This can be useful for writing complex access rules, or for a simple rule like "an admin can do anything" without needing to specify it as part of every other policy.

### A realistic policy

In this example, we use some of the provided built-in checks.

    policies         do    
          # Anything you can use in a condition, you can use in a check, and vice-versa    
          # This policy applies if the actor is a super_user    
          # Additionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without    
          # failing the whole request, and that if this check *passes*, the entire request passes.    
          bypass         actor_attribute_equals    (    :super_user    ,         true    )         do    
            authorize_if         always    (    )    
          end    

          # This will likely be a common occurrence. Specifically, policies that apply to all read actions    
          policy         action_type    (    :read    )         do    
            # unless the actor is an active user, forbid    
            forbid_unless         actor_attribute_equals    (    :active    ,         true    )    
            # if the record is marked as public, authorize    
            authorize_if         expr    (    public         ==         true    )    
            # if the actor is related to the data via that data's `owner` relationship, authorize    
            authorize_if         relates_to_actor_via    (    :owner    )    
          end        end

## Policy Groups

Policy groups are a small abstraction over policies, that allow you to group policies together that have shared conditions. Each policy inside of a policy group have the same conditions as their group.

    policies         do    
          policy_group         actor_attribute_equals    (    :role    ,         :owner    )         do    
            policy         action_type    (    :read    )         do    
              authorize_if         expr    (    owner_id         ==         ^    actor    (    :id    )    )    
            end    

            policy         action_type    (    [    :update    ,         :destroy    ]    )         do    
              authorize_if         expr    (    owner_id         ==         ^    actor    (    :id    )    )    
            end    

            policy         action_type    (    :create    )         do    
              authorize_if         relating_to_actor    (    :owner    )    
            end    
          end        end

### Nesting Policy groups

Policy groups can be nested. This can help when you have lots of policies and conditions.

    policies         do    
          policy_group         condition         do    
            policy_group         condition2         do    
               policy         condition3         do    
                 # This policy applies if condition, condition2, and condition3 are all true    
               end    
            end    
          end        end

### Bypasses

Policy groups can *not* contain bypass policies. The purpose of policy groups is to make it easier to reason about the behavior of policies. When you see a policy group, you know that no policies inside that group will interact with policies in other policy groups, unless they also apply.

### Access Type

Policies have an "access type" that determines when they are applied. By default, `access_type` is `:filter`. When applied to a read action, `:filter` will result in a filtered read. For other action types, the filter will be evaluated to determine if a forbidden error should be raised.

There are three access types, and they determine the *latest point in the process* that any check contained by a policy can be applied.

+ `strict` - All checks must be applied statically. These result in a forbidden error if they are not met.
+ `filter` - All checks must be applied either statically or as a filter. These result in a filtered read if they are not met, and a forbidden error for other action types.
+ `runtime` - This allows checks to be run *after* the data has been read. It is exceedingly rare that you would need to use this access type.

For example, given this policy:

    policy         action    (    :read_hidden    )         do    
          authorize_if         actor_attribute_equals    (    :is_admin    ,         true    )        end

A non-admin using the `:read_hidden` action would see an empty list of records, rather than a forbidden error.

However, with this policy

    policy         action    (    :read_hidden    )         do    
          access_type         :strict    

          authorize_if         actor_attribute_equals    (    :is_admin    ,         true    )        end

A non-admin using the `:read_hidden` action would see a forbidden error.

### Relationships and Policies

A common point of confusion when working with relationships is when they return less results or no results due to policies. Additionally, when requesting related data that produces a forbidden error, it forbids the *entire request*.

For example, if you have a `Post`, that `belongs_to` `:author`, and the user requesting data cannot see the `author` due to a **filter** policy, then you may see something like this:

    %    MyApp.Post    {    author    :         nil    ,         ...    }

Even though it is not possible for a `Post` to exist without an associated `:author`\!

Additionally, if the user cannot read the `author` due to a `:strict` policy, if you attempt to load the `:author`, the result of the **entire operation** will be `{:error, %Ash.Error.Forbidden{}}`.

There are two ways that you can improve this behavior

#### The **`allow_forbidden_field?`** Option

This option will **default to `true`** in 4.0. You can adopt this behavior now with the following configuration.

    config         :ash    ,         :allow_forbidden_field_for_relationships_by_default?    ,         true

This option adjusts the relationship reading logic such that, if running a related read action would produce a forbidden error, the relationship will be set to `%Ash.ForbiddenField{}`, instead of forbidding the entire request.

So in the example above where the **entire operation** fails, you would instead get:

    {    :ok    ,         %    MyApp.Post    {    author    :         %    Ash.ForbiddenField    {    }    }    }

#### The **`authorize_read_with`** Option

This option typically only makes sense to apply on `has_one` and `belongs_to` relationships. This alters the behavior of policy filtering when loading related records. In our above example, lets say there is a policy like the following on `MyApp.Author`, that prevents us from reading an author that has been deactivated.

    policy         action_type    (    :read    )         do    
          access_type         :filter         # This is the default access type. It is here for example.    
          authorize_if         expr    (    active         ==         false    )        end

When running a normal read action against that resource, you want any deactivated authors to be filtered out. However, when reading the `:author` relationship, you don't want the author to appear as `nil`. This is especially useful when combined with `allow_forbidden_field? true`.

So lets make our `belongs_to` relationship looks like this.

    belongs_to         :author    ,         MyApp.Author         do    
          allow_nil?         false    
          allow_forbidden_field?         true    
          authorize_read_with         :error        end

Now, that filter will be applied in such a way that produces an error if any record exists that matches `not(active == false)`.

So a forbidden read of the `:author` relationship will never produce a `nil` value, nor will it produce an `{:error, %Ash.Error.Forbidden{}}` result. Instead, the value of `:author` will be `%Ash.ForbiddenField{}`\!

## Checks

Checks evaluate from top to bottom within a policy. A check can produce one of three results, the same that a policy can produce. While checks are not necessarily evaluated in order, they *logically apply* in that order, so you may as well think of it in that way. It can be thought of as a step-through algorithm.

For each check, starting from the top:

+ Run the check.
	+ If it returns `:authorized`, the policy is `:authorized`
	+ If it returns `:forbidden`, the policy is `:forbidden`
	+ If it returns `:unknown`, the next check down is checked


For the example from earlier:

+ `authorize_if IsSuperUser`
	+ If this check succeeds, it returns `:authorized`, the whole policy is `:authorized`, and checks stop running
	+ If this check fails, it returns `:unknown` and the next check is checked

+ `forbid_if Deactivated`
	+ We only care about this result if the previous check failed, ie. the actor is not a super user.
	+ If this check succeeds, it returns `:forbidden`, the whole policy is `:forbidden`, and checks stop running
	+ If this check fails, it returns `:unknown` and the next check is checked

+ `authorize_if IsAdminUser`
	+ We only care about this result if the previous checks failed, ie. the actor is not a super user and is not deactivated.
	+ If this check succeeds, it returns `:authorized`, the whole policy is `:authorized` and checks stop running.
	+ If this check fails, it returns `:unknown` and the next check is checked

+ `authorize_if RegularUserAuthorized`
	+ We only care about this result if the previous checks failed, ie. the actor is not a super user, not deactivated and not an admin user.
	+ If this check succeeds, it returns `:authorized`, the whole policy is `:authorized` and checks stop running.
	+ If this check fails, it returns `:unknown`. As there are no more checks to run, the whole policy returns `:unknown`, which is treated as forbidden and the actor is not allowed to perform the action.


### Types of checks

As mentioned earlier, there are two distinct types of checks - *simple* checks and *filter* checks. So far we've seen examples of both - let's look in a bit more detail.

#### Manual Checks

Both simple and filter checks are a subset of a third type of check - a *manual* check - but you will almost always want to write simple or filter checks.

#### Simple checks

Simple checks are determined at the outset of a request, and can only cause a request to be authorized or forbidden. These are typically yes/no questions - is the actor an admin? Did the actor create the post they want to call the `update` action on? Is the actor old enough to drink alcohol?

You can write a simple check by creating a new module and using the `Ash.Policy.SimpleCheck` module:

    defmodule         MyApp.Checks.ActorIsOldEnough         do    
          use         Ash.Policy.SimpleCheck    

          # This is used when logging a breakdown of how a policy is applied - see Logging below.    
          def         describe    (    _    )         do    
            "actor is old enough"    
          end    

          # The context here may have a changeset, query, resource, and domain module, depending    
          # on the action being run.    
          # `match?` should return true or false, and answer the statement being posed in the description,    
          # i.e "is the actor old enough?"    
          def         match?    (    %    MyApp.User    {    age    :         age    }         =         _actor    ,         %{    resource    :         MyApp.Beer    }         =         _context    ,         _opts    )         do    
            age         >=         21    
          end    

          def         match?    (    _    ,         _    ,         _    )    ,         do    :         false        end

You can then use this module as the check name, as part of a policy:

    defmodule         MyApp.Beer         do    
          # ...    

          policies         do    
            policy         action    (    :drink    )         do    
              authorize_if         MyApp.Checks.ActorIsOldEnough    
            end    
          end    

          # ...        end

Ash will internally convert the true/false return value from `match?/3` to a `:authorized`/`:forbidden`/`:unknown` response, depending on how the check is being run \(ie. whether it's part of an `authorize_if`/`forbid_if`/etc.\)

#### Filter checks

Many checks won't return a status yes/no, but instead return a "filter" to apply to a collection of data. They are most commonly used for read actions, but can be used for all types of actions.

For update and destroy actions, they apply to the data *before* the action is run.

For read actions, they will automatically restrict the returned data to be compliant with the filter. Using the drinking example from earlier, we could write a filter check to list only users that are old enough to drink alcohol.

There are two ways to write a filter check - by creating a module and using the `Ash.Policy.FilterCheck` module, or by using inline expression syntax.

    defmodule         MyApp.Checks.ActorOverAgeLimit         do    
          use         Ash.Policy.FilterCheck    

          # A description is not necessary, as it will be derived from the filter, but one could be added    
          # def describe(_opts), do: "actor is over the age limit"    

          def         filter    (    actor    ,         _authorizer    ,         _opts    )         do    
            expr    (    age_limit         <=         ^    actor    .    age    )    
          end        end

You can then use this module as the check name, as part of a policy:

    defmodule         MyApp.User         do    
          # ...    

          policies         do    
            policy         action    (    :of_drinking_age    )         do    
              authorize_if         MyApp.Checks.ActorOverAgeLimit    
            end    
          end    

          # ...        end

#### Inline checks

Inline checks are filter checks, but are different enough to warrant their own documentation. These are written directly in a policy, eg.

    policy         action_type    (    :read    )         do    
          # Allow records with the attribute `public` set to true to be read    
          authorize_if         expr    (    public         ==         true    )    

          # Allow records with the attribute `level` less than the value of the `level`    
          # argument to the action to be read    
          authorize_if         expr    (    level         <=         ^    arg    (    :level    )    )        end



##### Inline checks for create actions



When using expressions inside of policies that apply to create actions, you may not reference the data being created. For example:

    policy         action_type    (    :create    )         do    
          # This check is fine, as we only reference the actor    
          authorize_if         expr    (    ^    actor    (    :admin    )         ==         true    )    
          # This check is not, because it contains a reference to a field    
          authorize_if         expr    (    status         ==         :active    )        end

### Why can't we reference data in creates?

We cannot allow references to the data being created in create policies, because we do not yet know what the result of the action will be. For updates and destroys, referencing the data always references the data *prior* to the action being run, and so it is deterministic.

If a policy that applies to creates, would result in a filter, you will get a `Ash.Error.Forbidden.CannotFilterCreates` at runtime explaining that you must change your check. Typically this means writing a custom `Ash.Policy.SimpleCheck` instead.

Ash also comes with a set of built-in helpers for writing inline checks - see `Ash.Policy.Check.Builtins` for more information.



##### Referencing the actor



In expression checks, the `actor` template can be used \(other templates that may work in filter expressions, for example, are not available\). For example:

    # Authorize records that have an author relationship with the author ID the same as the actor ID        # ie. records authored by the actor        authorize_if         expr    (    author    .    id         ==         ^    actor    (    :id    )    )



##### Using **`exists`**



A common mistake when using related data in filters is to be too restrictive. Imagine a scenario where you have an action like this:

    read         :friends_of_ted         do    
          filter         expr    (    friends    .    first_name         ==         "ted"    )        end

If this was in a User resource, it would return users that have a friend with the first name "ted". So far so good. Then someone calls it like so:

    Resource        |>         Ash.Query    .    for_read    (    :friends_of_ted    )        |>         Ash.Query    .    filter    (    friends    .    last_name         ==         "dansen"    )

The resulting filter is `friends.first_name == "ted" and friends.last_name == "dansen"`- this means that you'll get users that have a friend with the full name "ted dansen". That *might* be what you meant, but more likely you would want "users that have a friend with the first name "ted", that also have a friend with the last name 'dansen'".

To accomplish that, we can use the `exists` helper and rework the example like so:

    # There exists a friend with the first name "ted"        read         :friends_of_ted         do    
          filter         expr    (    exists    (    friends    ,         first_name         ==         "ted"    )    )        end    
        # And there also exists a friend with the last name "dansen"        # They may be the same friend if the user is friends with Ted Dansen!        Resource        |>         Ash.Query    .    for_read    (    :friends_of_ted    )        |>         Ash.Query    .    filter    (    exists    (    friends    ,         last_name         ==         "dansen"    )    )

In policies \(and often any time you mean "a related thing exists where some condition is true"\), it is advised to use `exists/2` when referring to relationships because of the way that the policy authorizer may mix & match your policies when building filters. This is also true when adding filters to actions. If you use `exists`, then your policies can be used in filters without excluding unnecessary data.

## Field Policies

Field policies allow you to authorize access to specific fields via policies scoped to fields.

For example:

    field_policies         do    
          field_policy         :role         do    
            authorize_if         actor_attribute_equals    (    :role    ,         :supervisor    )    
          end        end

If *any* field policies exist then *all* fields must be authorized by a field policy. If you want a "deny-list" style, then you can add policies for specific fields. and add a catch-all policy using the special field name `:*`. All policies that apply to a field must be authorized.

The only exception to the above behavior is primary keys, which can always be read by everyone.

Additionally, keep in mind that adding `Ash.Policy.Authorizer` will require that all actions pass policies. If you want to just add field policies, you will need to add a policy that allows all access explicitly, i.e

    policies         do    
          policy         always    (    )         do    
            authorize_if         always    (    )    
          end        end

### Using Expressions In Field Policies

Unlike in regular policies, expressions in field policies cannot refer to related entities currently \(except when using exists\). Instead, you will need to create aggregates or expression calculations that return the results you want to reference.

In results, forbidden fields will be replaced with a special value: `%Ash.ForbiddenField{}`.

When these fields are referred to in filters, they will be replaced with an expression that evaluates to `nil`. To support this behavior, only simple and filter checks are allowed in field policies.

### Handling private fields in internal functions

When calling internal functions like `Ash.read!/1`, private fields will by default always be shown. Even if field policies apply to the resource. You can change the default behaviour by setting the `private_fields` option on field policies.

    field_policies         do    
          private_fields         :include        end

The different options are:

+ `:show` will always show private fields
+ `:hide` will always hide private fields
+ `:include` will let you to write field policies for private fields and private fields will be shown or hidden depending on the outcome of the policy

If you want to overwrite the default option that is `:show`, you can do that by setting a global flag:

    config         :ash    ,         :policies    ,         private_fields    :         :include

## References to related data & fields

### Calculations

The dependencies of a calculation do not have any authorization applied to them. This includes the dependencies loaded with `Ash.Resource.Calculation.load/3`, as well as any dependencies referenced in a calculation expression. To understand why this is the case, take the following calculation:

    calculate         :users_ssn_last_4    ,         :string    ,         expr    (    fragment    (    "RIGHT(?, 4)"    ,         user    .    ssn    )    )

The `user` record may not be visible to the actor loading this calculation, and if it is, the `ssn` field may not be visible due to field policies. If calculations authorized access to their dependencies, you would *never* be able to write a calculation like the above.

#### Aggregates

Aggregates are the one exception to the above. Aggregates referenced *anywhere* will *always* authorize access to the related data they reference \(unless `authorize?: false` is set when running the action\). They will not, however, authorize references to the actual field that they refer to. For example, you may not allow managers to see the email of their team members, but they are allowed to know something like "how many team members have set up their email". So in an aggregate like the following:

    aggregate         :users_with_email    ,         :count    ,         :email

if the field policies were applied to `:email`, that number would always show `0`, because all `:email` attributes would appear to be `nil` to the manager.

### Fields annotated as **`input`**

When you use `Ash.Query.filter_input` or `Ash.Query.sort_input` \(which extensions like `AshGraphql` and `AshJsonApi` do when filters/sorts are provided by the user\), the contained field references are annotated as `input`. The following rules are honored for field references annotated as `input` only. Per the above section, the *contents* of a calculation's expression referenced in filters are never annotated as `input`, although the calculation itself will be, so that you can write field policies on calculations.

#### Relationship paths in filters

When a field is referenced at a relationship path, the authorization rules for that related resource's primary read action \(or the relationship's configured `:read_action`\) will be applied to the filter as well. For example, say that you have a `User` resource, and a `Post` resource. The `User` resource can only be read by the actor if their id matches the user's id \(i.e they can only read themselves\).

These policies might look like this:

    # on `User`        policy         action_type    (    :read    )         do    
          authorize_if         expr    (    id         ==         ^    actor    (    :id    )    )        end

Given a filter like `Ash.Query.filter_input(Post, %{user: %{email: "example@example.com"}})`, the resulting filter expression would be:

    expr    (    
          user    .    email         ==         "example@example.com"         and    
            user    .    id         ==         ^    actor    (    :id    )        )

This prevents a common security vulnerability that would allow malicious actors to "sniff" related data by providing filters over `User`, and seeing what `Post` records are returned.

#### Field references in filters & sorts

When a field is referenced in filters or sorts, the field reference is replaced with a conditional, that evaluates to the field value if the actor is authorized to view the field, or `nil` otherwise \(causing all conditions to evaluate to `false`\).

Lets say that users have a field policy that only allows viewing the email address if the user's id matches the actor's id, similar to the abvoe example.

    field_policies         do    
          field_policy         :email    ,         always    (    )         do    
            authorize_if         expr    (    user    .    id         ==         ^    actor    (    :id    )    )    
          end        end

When that field is referenced in filters or sorts, like so: `Ash.Query.filter_input(Post, %{user: %{email: "example@example.com"}})`, the resulting expression would become:

    expr    (    
          if         user    .    id         ==         ^    actor    (    :id    )         do    
            user    .    email    
          else    
            nil    
          end         ==         "example@example.com"        )

This prevents the same security vulnerability as described above, which would allow malicious actors to "sniff" field values that should not be visible to them by providing filters and/or sorts that reference that field.

## Debugging and Logging

### Policy Breakdowns

Policy breakdowns can be fetched on demand for a given forbidden error \(either an `Ash.Error.Forbidden` that contains one or more `Ash.Error.Forbidden.Policy` errors, or an `Ash.Error.Forbidden.Policy` error itself\), via `Ash.Error.Forbidden.Policy.report/2`.

Additionally, you can request that they be provided in the error message for all raised forbidden errors \(without the help text\), by setting

    config         :ash    ,         :policies    ,         show_policy_breakdowns?    :         true

Here is an example policy breakdown from tests.

    Policy Breakdown
    A check status of `?` implies that the solver did not need to determine that check.
    Some checks may look like they failed when in reality there was no need to check them.
    Look for policies with `✘` and `✓` in check statuses.

    A check with a `⬇` means that it didn't determine if the policy was authorized or forbidden, and so moved on to the next check.
    `🌟` and `⛔` mean that the check was responsible for producing an authorized or forbidden (respectively) status.

    If no check results in a status (they all have `⬇`) then the policy is assumed to have failed. In some cases, however, the policy
    may have just been ignored, as described above.

      Admins and managers can create posts | ⛔:
        authorize if: actor.admin == true | ✘ | ⬇
        authorize if: actor.manager == true | ✘ | ⬇

To remove the help text, you can pass the `help_text?: false` option, which would leave you with:

    Policy Breakdown
      Admins and managers can create posts | ⛔:
        authorize if: actor.admin == true | ✘ | ⬇
        authorize if: actor.manager == true | ✘ | ⬇

### Including in error messages

**IMPORTANT WARNING:** The following configuration should only ever be used in development mode\!

For security reasons, authorization errors don't include any extra information, aside from `forbidden`. To have authorization errors include a policy breakdown \(without help text\) use the following config.

    config         :ash    ,         :policies    ,         show_policy_breakdowns?    :         true

### Logging

It is generally safe to log authorization error details, even in production. This can be very helpful when investigating certain classes of issue.

#### Global Logging Configuration

To have Ash automatically log each authorization failure, use

    config         :ash    ,         :policies    ,         log_policy_breakdowns    :         :error         # Use whatever log level you'd like to use here

To have Ash log all policy breakdowns, even successful ones \(this will be lots of noise, and should only be used for dev testing\)

    config         :ash    ,         :policies    ,         log_successful_policy_breakdowns    :         :error         # Use whatever log level you'd like to use here

#### Per-Request Logging

You can also enable logging for individual authorization checks by using the `log?` option with `Ash.can/3` and `Ash.can?/3`:

    # Log the authorization result for this specific check        Ash    .    can?    (    Post    ,         :read    ,         current_user    ,         log?    :         true    )    
        # This will log at info level when authorization succeeds or fails        MyDomain    .    can_read_post?    (    current_user    ,         post    ,         log?    :         true    )

When `log?: true` is set, authorization results will be logged at the `:info` level regardless of the global logging configuration. This is useful for debugging specific authorization issues without enabling verbose logging globally.



# Manual Installation

This guide will walk you through the process of manually installing Ash into your project. If you are starting from scratch, you can use `mix new` or `mix igniter.new` and follow these instructions. These installation instructions apply both to new projects and existing ones.

## Install & Setup Dependencies

See the readmes for `spark` and `reactor` for more information on their installation. We've included their changes here for your convenience.

Create `.formatter.exs`:

    # Used by "mix format"        [    
          inputs    :         [    "{mix,.formatter}.exs"    ,         "{config,lib,test}/**/*.{ex,exs}"    ]    ,    
          plugins    :         [    Spark.Formatter    ]        ]    

Create `config/config.exs`:

    import         Config        config         :spark    ,         formatter    :         [    remove_parens?    :         true    ]    

Update `mix.exs`:

    ...            defp deps do              [        +       {:sourceror, "~> 1.8", only: [:dev, :test]}                # {:dep_from_hexpm, "~> 0.3.0"},                # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"}        ...

Update `.formatter.exs`:

    ...          [            inputs: ["{mix,.formatter}.exs", "{config,lib,test}/**/*.{ex,exs}"],        -   plugins: [Spark.Formatter]        +   plugins: [Spark.Formatter],        +   import_deps: [:reactor]          ]

## Skip protocol consolidation

To avoid warnings about protocol consolidation when recompiling in dev, we set protocolc onsolidation to happen only in non-dev environments.

## Setup The Formatter

Configure the DSL auto-formatter. This tells the formatter to remove excess parentheses and how to sort sections in your Ash.Resource & Ash.Domain modules for consistency.

Update `.formatter.exs`:

    ...            inputs: ["{mix,.formatter}.exs", "{config,lib,test}/**/*.{ex,exs}"],            plugins: [Spark.Formatter],        -   import_deps: [:reactor]        +   import_deps: [:ash, :reactor]          ]

Update `config/config.exs`:

      import Config        - config :spark, formatter: [remove_parens?: true]                  + config :spark,        +   formatter: [        +     remove_parens?: true,        +     "Ash.Resource": [        +       section_order: [        +         :resource,        +         :code_interface,        +         :actions,        +         :policies,        +         :pub_sub,        +         :preparations,        +         :changes,        +         :validations,        +         :multitenancy,        +         :attributes,        +         :relationships,        +         :calculations,        +         :aggregates,        +         :identities        +       ]        +     ],        +     "Ash.Domain": [section_order: [:resources, :policies, :authorization, :domain, :execution]]        +   ]        +

## Configure Dev/Test environments

Configure backwards compatibility settings. See the backwards compatibility guide for an explanation of each of the configurations.

Update `config/config.exs`:

    ...            ]                  + import_config "#{config_env()}.exs"        +

Create `config/dev.exs`:

    import         Config        config         :ash    ,         policies    :         [    show_policy_breakdowns?    :         true    ]    

Create `config/prod.exs`:

    import         Config    

Create `config/test.exs`:

    import         Config        config         :ash    ,         policies    :         [    show_policy_breakdowns?    :         true    ]    

## Setup Backwards Compatibility Configurations

Configure backwards compatibility settings. See the backwards compatibility guide for an explanation of each of the configurations.

Update `config/config.exs`:

      import Config                  + config :ash,        +   allow_forbidden_field_for_relationships_by_default?: true,        +   include_embedded_source_by_default?: false,        +   show_keysets_for_all_actions?: false,        +   default_page_type: :keyset,        +   policies: [no_filter_static_forbidden_reads?: false],        +   keep_read_action_loads_when_loading?: false,        +   default_actions_require_atomic?: true,        +   read_action_after_action_hooks_in_order?: true,        +   bulk_actions_default_to_errors?: true        +           config :spark,            formatter: [        ...



# Multi-Step Actions

Actions in Ash allow you to create sophisticated workflows that coordinate multiple changes or processes. Often business logic crosses multiple resources, and we often want it to be transactional. By leveraging action lifecycle hooks, you can build powerful domain-specific operations. This guide will explore how to build and use multi-step actions using a helpdesk example.

For most use cases, hooks are the preferred approach due to their simplicity and tight integration with Ash's action lifecycle. Reactor is the comprehensive solution for truly complex orchestration scenarios. Additionally, you can write generic actions by hand, implementing an action with fully custom code. Reactors can be used as the `run` function for generic actions, giving them first class support in Ash extensions. See below for an example.

## When to use hooks vs reactors vs generic actions

You should use hooks for most multi-step workflow scenarios as they provide simplicity and leverage Ash's transactional nature. The key decision point is whether you need compensation/rollback across external services:

**Use hooks when:**

+ Coordinating changes within Ash resources \(leverages database transactions\)
+ Performing side effects that don't require rollback \(logging, notifications\)
+ Working with external services that don't need compensation logic
+ Building small-to-medium complexity workflows

**Use reactor when:**

+ You need to compensate/undo changes across multiple external services
+ Building complex workflows that require sophisticated error handling and rollback logic
+ Coordinating long-running processes that span multiple systems

**Use generic actions when:**

+ You need a high-level action that works on multiple resources, and reactor or hooks are not fitting
+ There aren't side effects or external services
+ Short transactional operations that can be understood at a glance

### Durable Workflows

For durable workflows, we suggest to use Oban. We provide tools to integrate with Oban in AshOban. AshOban supports very specific types of common workflows, like "triggers" that run periodically for resources, and "scheduled actions" which run generic actions on a cron. You should not be afraid to write "standard" Oban jobs and code where possible. Don't bend over backwards trying to fit everything into AshOban.

## Action Lifecycle Hooks

At the core of Ash's multi-step action capability are action lifecycle hooks. These hooks allow you to run code at specific points during an action's execution:

+ 
**before\_transaction**: Runs before the transaction is started. Useful for operations that should happen before the transaction, like external API calls.

+ 
**before\_action**: Runs in the transaction, before the data layer is called. Perfect for side effects and expensive logic. This hook can be used with changesets and queries.

+ 
**after\_action**: Runs in the transaction, after the data layer is called, only if the action is successful. Ideal for transactional side effects that should only happen on success. This hook can be used with changesets and queries.

+ 
**after\_transaction**: Runs after the transaction completes, in both success and error cases. Ideal for operations that should happen regardless of the transaction outcome, and for operations that work with external services.


There are other hooks that we won't go into here, as they are rarely used. See the documentation in `Ash.Changeset` for more.

+ **around\_action**: Runs code both before and after the action logic, within the transaction.
+ **around\_transaction**: Runs code both before and after the transaction, outside the transaction.

## Examples

Let's explore multi-step actions through a series of increasingly complex examples using a helpdesk system. Each example builds on concepts from the previous ones.

### Example 1: Simple Activity Logging

The simplest multi-step action uses a single hook to perform a transactional effect. Here's a basic example that logs ticket creation by inserting an activity log.

    defmodule         HelpDesk.Changes.LogActivity         do    
          use         Ash.Resource.Change    

          @impl         true    
          def         change    (    changeset    ,         _opts    ,         _context    )         do    
            # Log activity after the ticket is successfully created    
            Ash.Changeset    .    after_action    (    changeset    ,         fn         _changeset    ,         ticket         ->    
              HelpDesk.ActivityLog    .    log    (    "Ticket     #{    ticket    .    id    }     created:     #{    ticket    .    title    }    "    )    
              {    :ok    ,         ticket    }    
            end    )    
          end        end

Use it in your Ticket resource:

    actions         do    
          create         :create         do    
            accept         [    :title    ,         :description    ]    
            change         HelpDesk.Changes.LogActivity    
          end        end

### Example 2: Multi-Hook Ticket Assignment

Building on the first example, let's add ticket assignment logic that uses multiple hooks to coordinate a transactional workflow:

    defmodule         HelpDesk.Changes.AssignTicket         do    
          use         Ash.Resource.Change    

          @impl         true    
          def         change    (    changeset    ,         _opts    ,         _context    )         do    
            changeset    
            |>         Ash.Changeset    .    before_action    (    &    find_and_assign_agent    /    1    )    
            |>         Ash.Changeset    .    after_action    (    &    notify_assignment    /    2    )    
          end    

          defp         find_and_assign_agent    (    changeset    )         do    
            case         HelpDesk.AgentManager    .    find_available_agent    (    )         do    
              {    :ok    ,         agent    }         ->    
                changeset    
                |>         Ash.Changeset    .    force_change_attribute    (    :agent_id    ,         agent    .    id    )    
                |>         Ash.Changeset    .    force_change_attribute    (    :status    ,         "assigned"    )    
                |>         Ash.Changeset    .    put_context    (    :assigned_agent    ,         agent    )    

              {    :error    ,         reason    }         ->    
                Ash.Changeset    .    add_error    (    changeset    ,         "No agents available:     #{    reason    }    "    )    
            end    
          end    

          defp         notify_assignment    (    changeset    ,         ticket    )         do    
            HelpDesk.Notifications    .    notify_assignment    (    changeset    .    context    [    :agent    ]    ,         ticket    )    

            {    :ok    ,         ticket    }    
          end        end

### Example 3: Complex Workflow with External Services

This example shows a sophisticated workflow that interacts with external services and handles various error conditions:

    defmodule         HelpDesk.Changes.ProcessUrgentTicket         do    
          use         Ash.Resource.Change    

          @impl         true    
          def         change    (    changeset    ,         _opts    ,         _context    )         do    
            changeset    
            # uses before_transaction as it communicates with an external service    
            # and we don't want to keep a transaction longer than necessary    
            |>         Ash.Changeset    .    before_transaction    (    &    validate_external_services    /    1    )    
            # Prepare for processing transactionally    
            |>         Ash.Changeset    .    before_action    (    &    prepare_urgent_processing    /    1    )    
            # Complete the workflow transactionally    
            |>         Ash.Changeset    .    after_action    (    &    complete_urgent_workflow    /    2    )    
            # Perform success or failure logic after the transaction    
            |>         Ash.Changeset    .    after_transaction    (    &    cleanup_and_notify    /    2    )    
          end    

          defp         validate_external_services    (    changeset    )         do    
            # Check external services before starting transaction    
            case         HelpDesk.ExternalServices    .    health_check    (    )         do    
              :ok         ->    
                changeset    

              {    :error    ,         service    }         ->    
                Ash.Changeset    .    add_error    (    changeset    ,    
                  message    :         "External service     #{    service    }     unavailable for urgent processing"    )    
            end    
          end    

          defp         prepare_urgent_processing    (    changeset    )         do    
            priority         =         Ash.Changeset    .    get_attribute    (    changeset    ,         :priority    )    

            if         priority         ==         "urgent"         do    
              # Reserve resources for urgent processing    
              case         HelpDesk.ResourceManager    .    reserve_urgent_slot    (    )         do    
                {    :ok    ,         slot_id    }         ->    
                  changeset    
                  |>         Ash.Changeset    .    force_change_attribute    (    :status    ,         "urgent_processing"    )    
                  |>         Ash.Changeset    .    force_change_attribute    (    :processing_slot_id    ,         slot_id    )    
                  |>         Ash.Changeset    .    put_context    (    :reserved_slot    ,         slot_id    )    

                {    :error    ,         :no_slots_available    }         ->    
                  # Fallback to normal priority with notification    
                  changeset    
                  |>         Ash.Changeset    .    force_change_attribute    (    :priority    ,         "high"    )    
                  |>         Ash.Changeset    .    put_context    (    :priority_downgraded    ,         true    )    
              end    
            else    
              changeset    
            end    
          end    

          defp         complete_urgent_workflow    (    _changeset    ,         ticket    )         do    
            if         ticket    .    status         ==         "urgent_processing"         do    
              # Create escalation path and update external tracking    
              with         {    :ok    ,         _escalation    }         <-         create_escalation_path    (    ticket    )    ,    
                   {    :ok    ,         _external_ref    }         <-         HelpDesk.ExternalServices    .    create_urgent_case    (    ticket    )         do    

                # Update ticket with external reference    
                ticket    
                |>         Ash.Changeset    .    for_update    (    :add_external_reference    ,         %{    
                  external_ref    :         "URG-    #{    ticket    .    id    }    -    #{    System    .    system_time    (    :second    )    }    "    
                }    )    
                |>         HelpDesk.Ticket    .    update!    (    )    
              else    
                {    :error    ,         reason    }         ->    
                  # Handle errors gracefully    
                  HelpDesk.Logger    .    error    (    "Failed to complete urgent workflow for ticket     #{    ticket    .    id    }    :     #{    inspect    (    reason    )    }    "    )    
                  {    :ok    ,         ticket    }    
              end    
            end    

            {    :ok    ,         ticket    }    
          end    

          defp         cleanup_and_notify    (    {    :ok    ,         ticket    }    ,         changeset    )         do    
            # Success case - perform cleanup and notifications    
            # Any more complex cleanup than this should be    
            # pushing you to consider reactor and/or oban    
            if         slot_id         =         Ash.Changeset    .    get_context    (    changeset    ,         :reserved_slot    )         do    
              HelpDesk.ResourceManager    .    release_slot    (    slot_id    )    
            end    

            if         Ash.Changeset    .    get_context    (    changeset    ,         :priority_downgraded    )         do    
              HelpDesk.Notifications    .    notify_priority_downgrade    (    ticket    )    
            end    

            HelpDesk.Metrics    .    increment_urgent_tickets    (    )    
            {    :ok    ,         ticket    }    
          end    

          defp         cleanup_and_notify    (    {    :error    ,         _reason    }         =         error    ,         changeset    )         do    
            # Error case - clean up resources    
            if         slot_id         =         Ash.Changeset    .    get_context    (    changeset    ,         :reserved_slot    )         do    
              HelpDesk.ResourceManager    .    release_slot    (    slot_id    )    
            end    

            error    
          end    

          defp         create_escalation_path    (    ticket    )         do    
            HelpDesk.Escalation    
            |>         Ash.Changeset    .    for_create    (    :create    ,         %{    
              ticket_id    :         ticket    .    id    ,    
              level    :         1    ,    
              escalated_at    :         DateTime    .    utc_now    (    )    
            }    )    
            |>         HelpDesk.Escalation    .    create    (    )    
          end        end

These examples demonstrate the progression from simple logging to complex cross-resource workflows. Each example builds on the previous concepts while introducing new patterns and considerations for multi-step actions.

### Shortcuts for hooks

There are multiple ways to add hooks to actions. What we showed above, defining an `Ash.Resource.Change` module, and using the functions in `Ash.Changeset` to add callbacks to the module is the most organized & idiomatic way. However, you can also use the following techniques as shorthand. In general, prefer to write your changes into modules to keep your resources clean and keep compile times down \(more smaller modules is typically better than fewer larger modules\).

#### Anonymous Function Changes

Here we use an anonymous function change, which is a shorthand for defining a change module with a single function. Just like in the `change/3` function, you can add hooks to the changeset.

    create         :open_and_assign         do    
          change         fn         changeset    ,         context         ->    
            Ash.Changeset    .    after_action    (    changeset    ,         fn         changeset    ,         result         ->    
              ...    
            end    )    
          end        end

#### Builtin Hook Changes

If you know that you just want to add a single hook to an action, you can use some of the functions in `Ash.Resource.Change.Builtins`, which are simple shorthands for the above form. For example:

    create         :open_and_assign         do    
          change         after_action    (    changeset    ,         result    ,         context         ->    
            ...    
          end    )        end

Notice how the anonymous function takes an extra argument. In the first format above, the `context` value came from `change fn changeset, context ->`, but in this format, it is provided as an argument at the end of the builtin function, i.e `change after_action(changeset, result, context -> .`

## Batch Callbacks

When working with bulk actions \(like `Ash.bulk_create/3`, `Ash.bulk_update/3`, etc.\), you can optimize your changes by implementing batch callbacks. These allow you to process multiple changesets together, which can be much more efficient than processing them individually.

### Understanding Batch Callbacks

Batch callbacks are optional methods you can implement in your change modules:

+ **`batch_change/3`**: Replaces `change/3` for batch operations, receiving a list of changesets
+ **`before_batch/3`**: Runs before the batch is sent to the data layer
+ **`after_batch/3`**: Runs after the batch completes, receiving changeset-result pairs

### Batch Operations and Transactions

The batch logic is currently all within transactions. There is no `before_batch_transaction` or `after_batch_transaction` hooks yet.

### When are batch callbacks used?

+ `batch_change/3` must be defined for `before_batch/3` and `after_batch/3` to be called
+ The exception is `after_batch/3`, which is also called after atomic changes when `atomic/3` is defined
+ `before_batch/3` is ignored when calling changes atomically
+ If you define `batch_change/3`, you can omit `change/3` entirely

### Example: Batch Processing with External API

Here's an example that demonstrates efficient batch processing for ticket creation with external service integration:

    defmodule         HelpDesk.Changes.BatchNotifyExternalSystem         do    
          use         Ash.Resource.Change    

          @impl         true    
          def         batch_change    (    changesets    ,         _opts    ,         _context    )         do    
            # Process all changesets together - you can do expensive setup here    
            # that would be wasteful to repeat for each individual changeset    
            Enum    .    map    (    changesets    ,         &    prepare_for_external_notification    /    1    )    
          end    

          @impl         true    
          def         before_batch    (    changesets    ,         opts    ,         context    )         do    
            # Validate external service availability before processing the batch    
            case         HelpDesk.ExternalAPI    .    health_check    (    )         do    
              :ok         ->    
                # Mark all changesets as ready for external notification    
                Enum    .    map    (    changesets    ,         fn         changeset         ->    
                  Ash.Changeset    .    put_context    (    changeset    ,         :external_api_ready    ,         true    )    
                end    )    

              {    :error    ,         reason    }         ->    
                # Add errors to all changesets if external service is down    
                Enum    .    map    (    changesets    ,         fn         changeset         ->    
                  Ash.Changeset    .    add_error    (    changeset    ,    
                    message    :         "External API unavailable:     #{    reason    }    "    )    
                end    )    
            end    
          end    

          @impl         true    
          def         after_batch    (    changesets_and_results    ,         opts    ,         context    )         do    
            # Efficiently batch notify external system    
            notifications         =    
              changesets_and_results    
              |>         Enum    .    filter    (    fn         {    changeset    ,         _result    }         ->    
                Ash.Changeset    .    get_context    (    changeset    ,         :external_api_ready    ,         false    )    
              end    )    
              |>         Enum    .    map    (    fn         {    _changeset    ,         result    }         ->    
                %{    
                  ticket_id    :         result    .    id    ,    
                  title    :         result    .    title    ,    
                  created_at    :         result    .    inserted_at    
                }    
              end    )    

            # Single API call for entire batch instead of one per ticket    
            case         HelpDesk.ExternalAPI    .    batch_notify_tickets    (    notifications    )         do    
              {    :ok    ,         _response    }         ->    
                # Return :ok to indicate success    
                :ok    

              {    :error    ,         error    }         ->    
                # You can return individual errors or notifications    
                Enum    .    map    (    changesets_and_results    ,         fn         {    _changeset    ,         result    }         ->    
                  {    :error    ,         Ash.Error.Invalid    .    exception    (    
                    message    :         "Failed to notify external system for ticket     #{    result    .    id    }    :     #{    error    }    "    
                  )    }    
                end    )    
            end    
          end    

          defp         prepare_for_external_notification    (    changeset    )         do    
            # Add any metadata needed for external notification    
            changeset    
            |>         Ash.Changeset    .    put_context    (    :needs_external_notification    ,         true    )    
          end        end

### Example: Optimized Database Operations

This example shows how to use batch callbacks to optimize database operations:

    defmodule         HelpDesk.Changes.BatchAssignAgents         do    
          use         Ash.Resource.Change    

          @impl         true    
          def         before_batch    (    changesets    ,         _opts    ,         _context    )         do    
            # Pre-load all available agents once for the entire batch    
            available_agents         =    
              HelpDesk.Agent    
              |>         Ash.Query    .    filter    (    status         ==         "available"    )    
              |>         Ash.Query    .    sort    (    :workload    )    
              |>         Ash    .    read!    (    )    

            # Distribute agents across the batch    
            {    assigned_changesets    ,         _remaining_agents    }         =    
              Enum    .    map_reduce    (    changesets    ,         available_agents    ,         fn         changeset    ,         [    agent         |         rest    ]         ->    
                updated_changeset         =    
                  changeset    
                  |>         Ash.Changeset    .    change_attribute    (    :agent_id    ,         agent    .    id    )    
                  |>         Ash.Changeset    .    change_attribute    (    :status    ,         "assigned"    )    
                  |>         Ash.Changeset    .    put_context    (    :assigned_agent    ,         agent    )    

                {    updated_changeset    ,         rest         ++         [    %{    agent         |         workload    :         agent    .    workload         +         1    }    ]    }    
              end    )    

            assigned_changesets    
          end    

          @impl         true    
          def         after_batch    (    changesets_and_results    ,         _opts    ,         _context    )         do    
            # Batch update agent workloads    
            agent_updates         =    
              changesets_and_results    
              |>         Enum    .    map    (    fn         {    changeset    ,         _result    }         ->    
                Ash.Changeset    .    get_context    (    changeset    ,         :assigned_agent    )    
              end    )    
              |>         Enum    .    filter    (    &         &1    )    
              |>         Enum    .    group_by    (    &         &1    .    id    )    
              |>         Enum    .    map    (    fn         {    agent_id    ,         assignments    }         ->    
                %{    id    :         agent_id    ,         workload_increment    :         length    (    assignments    )    }    
              end    )    

            # Single bulk operation to update all agent workloads    
            HelpDesk.Agent    
            |>         Ash    .    bulk_update    (    :increment_workload    ,         agent_updates    )    

            :ok    
          end    

          # Define batch_change/3 to enable batch callbacks    
          @impl         true    
          def         batch_change    (    changesets    ,         _opts    ,         _context    )         do    
            # The actual changeset modifications happen in before_batch    
            # This just returns the changesets as-is    
            changesets    
          end        end

### Example: Conditional Batch Processing

You can control when batch callbacks are used with the `batch_callbacks?/3` callback:

    defmodule         HelpDesk.Changes.ConditionalBatchProcessing         do    
          use         Ash.Resource.Change    

          @impl         true    
          def         batch_callbacks?    (    changesets    ,         opts    ,         context    )         do    
            # Only use batch processing for large batches    
            length    (    changesets    )         >=         10    
          end    

          @impl         true    
          def         change    (    changeset    ,         opts    ,         context    )         do    
            # This runs for individual changes or small batches    
            changeset    
            |>         perform_individual_processing    (    opts    ,         context    )    
          end    

          @impl         true    
          def         batch_change    (    changesets    ,         opts    ,         context    )         do    
            # This runs for large batches (10+ items)    
            changesets    
            |>         perform_optimized_batch_processing    (    opts    ,         context    )    
          end    

          defp         perform_individual_processing    (    changeset    ,         _opts    ,         _context    )         do    
            # Simple processing for individual items    
            changeset    
          end    

          defp         perform_optimized_batch_processing    (    changesets    ,         _opts    ,         _context    )         do    
            # Optimized processing for large batches    
            changesets    
          end        end

### Best Practices for Batch Callbacks

1. **Use batch callbacks for expensive operations**: Database queries, external API calls, file I/O
2. **Keep individual operations fast**: If your change is already fast, batch callbacks may not be worth the complexity
3. **Handle errors gracefully**: Return appropriate error tuples from `after_batch/3` when things go wrong
4. **Test both paths**: Ensure your change works correctly both individually and in batches

## Generic Action Example

    # Define a plain-old elixir module/function to express the action        defmodule         HelpDesk.Actions.AssignTicket         do    
          def         run    (    input    ,         context    )         do    
            with         {    :ok    ,         agent    }         <-         HelpDesk.AgentManager    .    find_available_agent    (    )    ,    
                 {    :ok    ,         ticket    }         <-         HelpDesk    .    get_ticket_by_id    (    input    .    arguments    .    ticket_id    )    ,    
                 {    :ok    ,         ticket    }         <-         HelpDesk    .    update_ticket    (    ticket    ,         %{    agent_id    :         agent    .    id    ,         status    :         :assigned    }    ,         actor    :         input    .    actor    )    
                 :ok         <-         Helpdesk.Notifications    .    notify_assignment    (    agent    ,         ticket    )    
            end    
          end        end    
        # Invoke the action from Resource        actions         do    
          action         :assign_to_available_agent         do    
            transaction?         true    
            argument         :ticket_id    ,         :uuid    
            run         HelpDesk.Actions.AssignTicket    
          end        end



# Reactor

`Ash.Reactor` is an extension for `Reactor` which adds explicit support for interacting with resources via their defined actions.

See Getting started with Reactor to understand the core Reactor concepts first. Then return to this guide to see how `Ash.Reactor` adds conveniences for using Reactor from Ash.

## Usage

You can either add the `Ash.Reactor` extension to your existing reactors eg:

    defmodule         MyExistingReactor         do    
          use         Reactor    ,         extensions    :         [    Ash.Reactor    ]        end

or for your convenience you can use `use Ash.Reactor` which expands to exactly the same as above.

## Running Reactors as an action

Ash's generic actions support providing a Reactor module directly as their `run` option. This is the preferred way for you to initiate reactors in your application. These actions could be defined on your existing resources, your you could even have a resource w/ a single action on it that runs a reactor, and no attributes/data layer etc. for example.

Notes:

+ Every Reactor input must have a corresponding action argument.
+ Ash's action context is passed in as the Reactor's context \(including things like actor, tenant, etc\).
+ Reactor runtime options can be set by setting `run {MyReactor, opts}` instead of just `run MyReactor`.
+ If you set the `transaction?` action DSL option to true then the Reactor will be run synchronously - regardless of the value of the `async?` runtime option.

### Example

### Resources can just have generic actions

Below is a fully valid resource in its entirety. Not all resources need to have state/data layers associated with them

    defmodule         MyApp.Blog.Actions         do    
          use         Ash.Resource    

          action         :create_post    ,         :struct         do    
            constraints         instance_of    :         MyBlog.Post    

            argument         :blog_title    ,         :string    ,         allow_nil?    :         false    
            argument         :blog_body    ,         :string    ,         allow_nil?    :         false    
            argument         :author_email    ,         :ci_string    ,         allow_nil?    :         false    

            run         MyApp.Blog.Reactors.CreatePost    
          end        end

## Example

An example is worth 1000 words of prose:

    defmodule         ExampleReactor         do    
          use         Ash.Reactor    

          ash         do    
            default_domain         ExampleDomain    
          end    

          input         :customer_name    
          input         :customer_email    
          input         :plan_name    
          input         :payment_nonce    

          create         :create_customer    ,         Customer         do    
            inputs         %{    name    :         input    (    :customer_name    )    ,         email    :         input    (    :customer_email    )    }    
          end    

          read_one         :get_plan    ,         Plan    ,         :get_plan_by_name         do    
            inputs         %{    name    :         input    (    :plan_name    )    }    
            fail_on_not_found?         true    
          end    

          action         :take_payment    ,         PaymentProvider         do    
            inputs         %{    
              nonce    :         input    (    :payment_nonce    )    ,    
              amount    :         result    (    :get_plan    ,         [    :price    ]    )    
            }    
          end    

          create         :subscription    ,         Subscription         do    
            inputs         %{    
              plan_id    :         result    (    :get_plan    ,         [    :id    ]    )    ,    
              payment_provider_id    :         result    (    :take_payment    ,         :id    )    
            }    
          end        end

## Actions

For each action type there is a corresponding step DSL, which needs a name \(used to refer to the result of the step by other steps\), a resource and optional action name \(defaults to the primary action if one is not provided\).

Actions have several common options and some specific to their particular type. See the DSL documentation for details.

### Action inputs

Ash actions take a map of input parameters which are usually a combination of resource attributes and action arguments. You can provide these values as a single map using the `inputs` DSL entity with a map or keyword list which refers to Reactor inputs, results and hard-coded values via Reactor's predefined template functions.

For action types that act on a specific resource \(ie `update` and `destroy`\) you can provide the value using the `initial` DSL option.

#### Example

    input         :blog_title        input         :blog_body        input         :author_email    
        read         :get_author    ,         MyBlog.Author    ,         :get_author_by_email         do    
          inputs         %{    email    :         input    (    :author_email    )    }        end    
        create         :create_post    ,         MyBlog.Post    ,         :create         do    
          inputs         %{    
            title    :         input    (    :blog    ,         [    :title    ]    )    ,    
            body    :         input    (    :blog    ,         [    :body    ]    )    ,    
            author_id    :         result    (    :get_author    ,         [    :email    ]    )    
          }        end    
        update         :author_post_count    ,         MyBlog.Author    ,         :update_post_count         do    
          wait_for         :create_post    
          initial         result    (    :get_author    )        end    
        return         :create_post

## Handling failure

Reactor is a saga executor, which means that when failure occurs it tries to clean up any intermediate state left behind. By default the `create`, `update` and `destroy` steps do not specify any behaviour for what to do when there is a failure downstream in the reactor. This can be changed by providing both an `undo_action` and changing the step's `undo` option to either `:outside_transaction` or `:always` depending on your resource and datalayer semantics.

### The **`undo`** option

+ `:never` - this is the default, and means that the reactor will never try and undo the action's work. This is the most performant option, as it means that the reactor doesn't need to store as many intermediate values.
+ `:outside_transaction` - this option allows the step to decide at runtime whether it should support undo based on whether the action is being run within a transaction. If it is, then no undo is required because the transaction will rollback.
+ `:always` - this forces the step to always undo it's work on failure.

### The **`undo_action`** option

The behaviour of the `undo_action` is action specific:

+ For `create` actions, the `undo_action` should be the name of a `destroy` action with no specific requirements.
+ For `update` actions, the `undo_action` should also be an `update` action which takes a `changeset` argument, which will contain the `Ash.Changeset` which was used to execute the original update.
+ For `destroy` actions, the `undo_action` should be the name of a `create` action which takes a `record` argument, which will contain the resource record which was used destroyed.

### Transactions

You can use the `transaction` step type to wrap a group of steps inside a data layer transaction, however the following caveats apply:

+ All steps inside a transaction must happen in the same process, so the steps inside the transaction will only ever be executed synchronously.
+ Notifications will be sent only when the transaction is committed.

#### Example

    input         :blog_title        input         :blog_body        input         :author_email    
        read         :get_author    ,         MyBlog.Author    ,         :get_author_by_email         do    
          inputs         %{    email    :         input    (    :author_email    )    }        end    
        transaction         :create_post_transaction    ,         [    MyBlog.Post    ,         MyBlog.Author    ]         do    
          create         :create_post    ,         MyBlog.Post    ,         :create         do    
            inputs         %{    
              title    :         input    (    :blog    ,         [    :title    ]    )    ,    
              body    :         input    (    :blog    ,         [    :body    ]    )    ,    
              author_id    :         result    (    :get_author    ,         [    :email    ]    )    
            }    
          end    

          update         :author_post_count    ,         MyBlog.Author    ,         :update_post_count         do    
            wait_for         :create_post    
            initial         result    (    :get_author    )    
          end    

          return         :create_post        end    
        return         :create_post_transaction

## Notifications

Because a reactor has transaction-like semantics notifications are automatically batched and only sent upon successful completion of the reactor.



# Monitoring

Monitoring in Ash has two primary components, `Ash.Tracer` and `:telemetry`. Monitoring might also be referred to as observability and instrumentation.

## Packages

If you want to integrate with Appsignal, use the AshAppsignal package, which is maintained by the core team. We believe that Appsignal is a great way to get started quickly, is relatively cost effective, and provides a great user experience.

## Telemetry

Ash emits the following telemetry events, suffixed with `:start` and `:stop`. Start events have `system_time` measurements, and stop events have `system_time` and `duration` measurements. All times will be in the native time unit.

### Important

Note the mention of `:start` and `:stop` suffixes. The event below `[:ash, (domain_short_name), :create]`, is actually referring to two events, `[:ash, (domain_short_name), :create, :start]` and `[:ash, (domain_short_name), :create, :stop]`.

\_Replace `(domain_short_name)` with your domain short name, from `d:Ash.Domain.Info.short_name`.

### Events

+ `[:ash, (domain_short_name), :create]` - The execution of a create action. Use `resource_short_name` and `action` metadata to break down measurements.
+ `[:ash, (domain_short_name), :update]` - The execution of a update action. Use `resource_short_name` and `action` metadata to break down measurements.
+ `[:ash, (domain_short_name), :read]` - The execution of a read action. Use `resource_short_name` and `action` metadata to break down measurements.
+ `[:ash, (domain_short_name), :destroy]` - The execution of a destroy action. Use `resource_short_name` and `action` metadata to break down measurements.
+ `[:ash, (domain_short_name), :action]` - The execution of a generic action. Use `resource_short_name` and `action` metadata to break down measurements.
+ `[:ash, :changeset]` - A changeset being processed for a given action, i.e with `Ash.Changeset.for_create`. Use `resource_short_name` metadata to break down measurements.
+ `[:ash, :query]` - A query being processed for an action, with `Ash.Query.for_read`. Use `resource_short_name` metadata to break down measurements.
+ `[:ash, :validation]` - A validation being run on a changeset. Use `resource_short_name` and `validation` metadata to break down measurements.
+ `[:ash, :change]` - A change being run on a changeset. Use `resource_short_name` and `change` metadata to break down measurements.
+ `[:ash, :calculation]` - A calculation being computed in the app. Use `resource_short_name` and `calculation` metadata to break down measurements.
+ `[:ash, :before_action]` - A before\_action being run on a changeset. Use `resource_short_name` to break down measurements.
+ `[:ash, :after_action]` - An after\_action being run on a changeset. Use `resource_short_name` to break down measurements.
+ `[:ash, :preparation]` - A preparation being run on a changeset. Use `resource_short_name` and `preparation` metadata to break down measurements.
+ `[:ash, :notifier]` - A notifier being run with a notification. Use `resource_short_name` and `notifier` metadata to break down measurements.
+ `[:ash, :request_step]` - The resolution of an internal request. Ash breaks up its operations internally into multiple requests, this can give you a high resolution insight onto the execution of those internal requests resolution. Use `name` metadata to break down measurements.

## Tracing

Tracing is very similar to telemetry, but gives you some additional hooks to `set_span_context()` and `get_span_context()`. This allows you to "move" some piece of context between two processes. Ash will call this whenever it starts a new process to do anything. What this means is that if you are using a tracing tool or library you can ensure that any processes spawned by Ash are properly included in the trace. Additionally, you should be able to integrate a tracing library to include Ash actions/spans relatively easily by implementing the other callbacks.

A tracer can be configured globally in application config.

    config         :ash    ,         :tracer    ,         MyApp.Tracer

Additionally, one can be provide when creating changesets or calling an action, i.e

    Resource        # better to put it here, as changesets are traced as well. It will be carried over to the domain action        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    }    ,         tracer    :         MyApp.Tracer    )        # but you can also pass it here.        |>         Ash    .    create!    (    tracer    :         MyApp.Tracer    )

For customizing the names created for each span, see:

+ `d:Ash.Domain.Dsl.execution|trace_name`
+ `d:Ash.Resource.Dsl.resource|trace_name`

### Trace types

These are the list of trace types.

+ :custom
+ :action
+ :changeset
+ :validation
+ :change
+ :calculation
+ :before\_transaction
+ :before\_action
+ :after\_transaction
+ :after\_action
+ :request\_step
+ :query
+ :notifier
+ :preparation
+ :preparation

## After/Before Action Hooks

Due to the way before/after action hooks run, their execution time won't be included in the span created for the change. In practice, before/after action hooks are where the long running operations tend to be. We start a corresponding `span` and emit a telemetry event for before and after hooks, but they are only so useful. In a trace, they can highlight that "some hook" took a long time. In telemetry metrics they are of even less use. The cardinality of the metric would be extremely high, and we don't have a "name" or anything to distinguish them. To that end, you can use the macros & functions available in `Ash.Tracer` to create custom spans and/or emit custom telemetry events from your hooks. They automatically handle cases where the provided tracer is `nil`, for convenience. For example:

    defmodule         MyApp.CustomChange         do    
          use         Ash.Resource.Change    

          require         Ash.Tracer    

          def         change    (    changeset    ,         _    ,         _    )         do    
            changeset    
            |>         Ash.Changeset    .    before_action    (    fn         changeset         ->    
              Ash.Tracer    .    span    (    :custom    ,         "custom name"    ,         changeset    .    context    [    :private    ]    [    :tracer    ]    )         do    
                # optionally set some metadata    
                metadata         =         %{    ...    }    
                Ash.Tracer    .    set_metadata    (    changeset    .    context    [    :private    ]    [    :tracer    ]    ,         :custom    ,         metadata    )    
                # will get `:start` and `:stop` suffixed events emitted    
                Ash.Tracer    .    telemetry_span    (    [    :telemetry    ,         :event    ,         :name    ]    ,         metadata    )         do    
                  ## Your logic here    
                end    
              end    
            end    )    
          end        end



# Pagination

    Mix    .    install    (    [    {    :ash    ,         "~> 3.0"    }    ]    ,         consolidate_protocols    :         false    )        Logger    .    configure    (    level    :         :warning    )

## Pagination in Ash

Ash has built-in support for two kinds of pagination: `offset` and `keyset`. You can perform pagination by passing the `:page` option to read actions, or using `Ash.Query.page/2` on the query. The page options vary depending on which kind of pagination you want to perform.

Pagination support is configured on a per-action basis. A single action can support both kinds of pagination if desired, but typically you would use one or the other. Read actions generated with `defaults [:read]` support both offset and keyset pagination, for other `read` actions you have to configure the `pagination` section.
> 
> ### Default Pagination Type

> When an action supports both pagination types, the behavior depends on your application configuration. See the "Default Pagination Behavior" section below for details on how Ash determines which type to use.
> 
> ### Check the updated query return type\!

> Pagination will modify the return type of calling the query action.

> Without pagination, Ash will return a list of records.

> But *with* pagination, Ash will return an `Ash.Page.Offset` struct \(for offset pagination\) or `Ash.Page.Keyset` struct \(for keyset pagination\). Both structs contain the list of records in the `results` key of the struct.

## Offset Pagination

Offset pagination is done via providing a `limit` and an `offset` when making queries.

+ The `limit` determines how many records should be returned in the query.
+ The `offset` describes how many records from the beginning should be skipped.

### Pros of offset pagination

+ Simple to think about
+ Possible to skip to a page by number. E.g the 5th page of 10 records is `offset: 40`
+ Easy to reason about what page you are currently on \(if the total number of records is requested\)
+ Can go to the last page \(though data may have changed between calculating the last page details, and requesting it\)

### Cons of offset pagination

+ Does not perform well on large datasets \(if you have to ask if your dataset is "large", it probably isn't\)
+ When moving between pages, if data was created or deleted, individual records may be missing or appear on multiple pages

## Keyset Pagination

Keyset pagination, also known as cursor pagination, is done via providing an `after` or `before` option, as well as a `limit`.

+ The `limit` determines how many records should be returned in the query.
+ The `after` or `before` value should be a `keyset` value that has been returned from a previous request. Keyset values are returned whenever there is any read action on a resource that supports keyset pagination, and they are stored in the `__metadata__` key of each record.
> 
> ### Keysets are directly tied to the sorting applied to the query

> You can't change the sort applied to a request being paginated, and use the same keyset. If you want to change the sort, but *keep* the record who's keyset you are using in the `before` or `after` option, you must first request the individual record, with the new sort applied. Then, you can use the new keyset.

### Pros of keyset pagination

+ Performs very well on large datasets \(assuming indices exist on the columns being sorted on\)
+ Behaves well as data changes. The record specified will always be the first or last item in the page

### Cons of keyset paginations

+ A bit more complex to use
+ Can't go to a specific page number

## Counting records

When calling an action that uses pagination, the full count of records can be requested by adding the option `count: true` to the page options. Note that this will perform a second query to fetch the count, which can be expensive on large data sets.

## Relationship pagination

In addition to paginating root data, Ash is also capable of paginating relationships when you load them. To do this, pass a custom query in the load and call `Ash.Query.page/2` on it.

This can be leveraged by extensions to provide arbitrarily nested pagination, or it can be used directly in code to split data processing when dealing with relationship with a high cardinality.
> 
> ## Pagination Defaults for Custom Read Actions

> When you define a custom `read` action \(instead of using the default generated by `defaults [:read]`\), **pagination is not enabled by default**. This means features like streaming, offset, or keyset pagination will not work unless you explicitly configure them.

> To enable both offset and keyset pagination \(matching the default behavior\), add:

    read         :read         do    
          primary?         true    
          pagination         required?         false    ,         offset?         true    ,         keyset?         true        end

> If you omit this, you may see errors like:

    Invalid         Error        *         ...    read         had         no         matching         bulk         strategy         that         could         be         used    .        Requested         strategies    :         [    :stream    ]        ...        Action         ...         does         not         support         streaming         with         one         of         [    :keyset    ]    .

> See the pagination guide for more details.

## Pagination example

Modify the setup block and configure the log level to `:debug` to see logs from the ETS data layer.

    Logger    .    configure    (    level    :         :debug    )

### Define some resources for our purpose

    defmodule         Post         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    

          attributes         do    
            uuid_primary_key    (    :id    )    
            attribute    (    :title    ,         :string    ,         allow_nil?    :         false    )    
            attribute    (    :text    ,         :string    ,         allow_nil?    :         false    )    
          end    

          actions         do    
            defaults    (    create    :         [    :title    ,         :text    ]    )    

            read         :read         do    
              primary?    (    true    )    
              prepare    (    build    (    sort    :         :title    )    )    

              pagination         do    
                required?    (    false    )    
                offset?    (    true    )    
                keyset?    (    true    )    
                countable    (    true    )    
              end    
            end    

            read         :keyset         do    
              prepare    (    build    (    sort    :         :title    )    )    
              pagination    (    keyset?    :         true    )    
            end    

            update         :add_comment         do    
              require_atomic?    (    false    )    
              argument    (    :comment    ,         :string    ,         allow_nil?    :         false    )    
              change    (    manage_relationship    (    :comment    ,         :comments    ,         value_is_key    :         :text    ,         type    :         :create    )    )    
            end    
          end    

          relationships         do    
            has_many    (    :comments    ,         Comment    ,         sort    :         [    :created_at    ]    )    
          end        end    
        defmodule         Comment         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    

          attributes         do    
            uuid_primary_key    (    :id    )    
            attribute    (    :text    ,         :string    ,         allow_nil?    :         false    )    
            create_timestamp    (    :created_at    )    
          end    

          actions         do    
            defaults    (    [    :read    ,         create    :         [    :text    ,         :post_id    ]    ,         update    :         [    :text    ,         :post_id    ]    ]    )    
          end    

          relationships         do    
            belongs_to    (    :post    ,         Post    ,         sort    :         [    :created_at    ]    )    
          end        end    
        defmodule         Domain         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         Post         do    
              define    (    :list_posts    ,         action    :         :read    )    
              define    (    :list_posts_with_keyset    ,         action    :         :keyset    )    
              define    (    :create_post    ,         action    :         :create    ,         args    :         [    :title    ,         :text    ]    )    
              define    (    :add_comment_to_post    ,         action    :         :add_comment    ,         args    :         [    :comment    ]    )    
            end    

            resource    (    Comment    )    
          end        end

    {    :module    ,         Domain    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         2    ,         31    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           Ash.Domain.Dsl    ,    
           %{    opts    :         [    ]    ,         entities    :         [    ...    ]    }    ,    
           Ash.Domain.Dsl    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           ...    
         ]    }

### Create 5 posts with 5 comments each

    for         post_idx         <-         1    ..    5         do    
          post         =         Domain    .    create_post!    (    "post     #{    post_idx    }    "    ,         "text     #{    post_idx    }    "    )    

          for         comment_idx         <-         1    ..    5         do    
            Domain    .    add_comment_to_post!    (    post    ,         "comment     #{    comment_idx    }    "    )    
          end        end    
        Domain    .    list_posts!    (    load    :         :comments    )

    [    
          #    Post    <    
            comments    :         [    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "6cdea87b-cb69-4dc5-9ff3-54fb46bd70b0"    ,    
                text    :         "comment 1"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.013913Z]    ,    
                post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "c653e92c-fe2f-4011-84c8-ace28ebbb207"    ,    
                text    :         "comment 2"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.021204Z]    ,    
                post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "aa207735-0a02-4b51-b5f6-69564a2a6365"    ,    
                text    :         "comment 3"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.022890Z]    ,    
                post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "09f9cdfe-5a88-4f6a-a8d9-2f8aa312efb8"    ,    
                text    :         "comment 4"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.024526Z]    ,    
                post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "9b92edf4-e79e-4870-9dd0-9130863a9715"    ,    
                text    :         "comment 5"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.026132Z]    ,    
                post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    
            ]    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
            title    :         "post 1"    ,    
            text    :         "text 1"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Post    <    
            comments    :         [    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "9a87a3a0-6930-4920-9345-8227b861c2ed"    ,    
                text    :         "comment 1"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.028515Z]    ,    
                post_id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "a5107151-5519-4925-ab73-aef75274cd4a"    ,    
                text    :         "comment 2"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.030176Z]    ,    
                post_id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "0d7e9835-25a0-4df9-bb41-06aa964dc677"    ,    
                text    :         "comment 3"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.031780Z]    ,    
                post_id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "7c6663a8-6a36-4c9a-a947-a70436add8be"    ,    
                text    :         "comment 4"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.033389Z]    ,    
                post_id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "4a54ee7f-18fe-401b-9a86-7c768bc52a1d"    ,    
                text    :         "comment 5"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.034976Z]    ,    
                post_id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    
            ]    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
            title    :         "post 2"    ,    
            text    :         "text 2"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Post    <    
            comments    :         [    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "9d01f179-4220-4796-bb7d-63527385e36b"    ,    
                text    :         "comment 1"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.037470Z]    ,    
                post_id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "49b7a671-bc6f-4772-b8f8-73b2a4c75b34"    ,    
                text    :         "comment 2"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.039117Z]    ,    
                post_id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "7d2ee81c-696f-4190-8d1a-45702bfaaef2"    ,    
                text    :         "comment 3"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.040795Z]    ,    
                post_id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "98d80b57-b911-44f5-9a63-5db90c1a0d57"    ,    
                text    :         "comment 4"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.042457Z]    ,    
                post_id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "a0f08863-ec7f-4eba-b9f5-f9d7764dc934"    ,    
                text    :         "comment 5"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.044061Z]    ,    
                post_id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    
            ]    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
            title    :         "post 3"    ,    
            text    :         "text 3"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Post    <    
            comments    :         [    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "2a57aa5f-0431-4d7b-a054-3bf0fc6cb2e8"    ,    
                text    :         "comment 1"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.046395Z]    ,    
                post_id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "1604094f-864e-4df3-9365-a16a77ace0ba"    ,    
                text    :         "comment 2"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.048111Z]    ,    
                post_id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "6153ecb4-4668-4afb-94c8-b1e57ed1a187"    ,    
                text    :         "comment 3"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.049749Z]    ,    
                post_id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "0844db43-39f7-41c3-aa74-41238b0882c9"    ,    
                text    :         "comment 4"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.051385Z]    ,    
                post_id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "b22db803-cad0-4d90-ada1-944f0abdd304"    ,    
                text    :         "comment 5"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.053563Z]    ,    
                post_id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    
            ]    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
            title    :         "post 4"    ,    
            text    :         "text 4"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Post    <    
            comments    :         [    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "7b5fc51b-8e68-441e-bcd0-e52a0158e779"    ,    
                text    :         "comment 1"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.056055Z]    ,    
                post_id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "e3f01413-c79c-44ef-abd9-6cb27a3b31fc"    ,    
                text    :         "comment 2"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.057708Z]    ,    
                post_id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "a461c559-5036-4113-93be-3f531af4d2f3"    ,    
                text    :         "comment 3"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.059418Z]    ,    
                post_id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "a704a781-3ff2-479c-b428-d8a414223f00"    ,    
                text    :         "comment 4"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.061034Z]    ,    
                post_id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    ,    
              #    Comment    <    
                post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
                __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
                id    :         "2d9e9279-ef21-4dd4-bdc6-adc3597fefb2"    ,    
                text    :         "comment 5"    ,    
                created_at    :         ~U[2024-05-28 21:32:59.062631Z]    ,    
                post_id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
                aggregates    :         %{    }    ,    
                calculations    :         %{    }    ,    
                ...    
              >    
            ]    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
            title    :         "post 5"    ,    
            text    :         "text 5"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

## Offset pagination

When using offset pagination, a `%Ash.Page.Offset{}` struct is returned from read actions.

    page         =         Domain    .    list_posts!    (    page    :         [    limit    :         2    ]    )

    %    Ash.Page.Offset    {    
          results    :         [    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
              title    :         "post 1"    ,    
              text    :         "text 1"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
              title    :         "post 2"    ,    
              text    :         "text 2"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         2    ,    
          offset    :         0    ,    
          count    :         nil    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Post    ,    
             sort    :         [    title    :         :asc    ]    ,    
             select    :         [    :id    ,         :title    ,         :text    ]    ,    
             page    :         [    limit    :         2    ]    
           >    ,         [    authorize?    :         true    ,         reuse_values?    :         false    ,         return_query?    :         false    ]    }    ,    
          more?    :         true        }

You can find the results in the `results` field of the page

    page    .    results

    [    
          #    Post    <    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
            title    :         "post 1"    ,    
            text    :         "text 1"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Post    <    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
            title    :         "post 2"    ,    
            text    :         "text 2"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

The `more?` field contains a boolean indicating if there are more pages available

    page    .    more?

    true

### Retrieving the next page

You can calculate the next offset with the information available in the page and pass it in the page options to retrieve the following page

    next_offset         =         page    .    offset         +         page    .    limit        second_page         =         Domain    .    list_posts!    (    page    :         [    limit    :         2    ,         offset    :         next_offset    ]    )

    %    Ash.Page.Offset    {    
          results    :         [    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
              title    :         "post 3"    ,    
              text    :         "text 3"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
              title    :         "post 4"    ,    
              text    :         "text 4"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         2    ,    
          offset    :         2    ,    
          count    :         nil    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Post    ,    
             sort    :         [    title    :         :asc    ]    ,    
             select    :         [    :id    ,         :title    ,         :text    ]    ,    
             page    :         [    limit    :         2    ,         offset    :         2    ]    
           >    ,         [    authorize?    :         true    ,         reuse_values?    :         false    ,         return_query?    :         false    ]    }    ,    
          more?    :         true        }

If you have the current page in memory, you can also use `Ash.page!/2` to navigate between pages.

    last_page         =         Ash    .    page!    (    second_page    ,         :next    )

    %    Ash.Page.Offset    {    
          results    :         [    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "b0b20225-17f0-4bd1-8bd1-681e63ee26a8"    ,    
              title    :         "post 5"    ,    
              text    :         "text 5"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         2    ,    
          offset    :         4    ,    
          count    :         nil    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Post    ,    
             sort    :         [    title    :         :asc    ]    ,    
             select    :         [    :title    ,         :id    ,         :text    ]    ,    
             page    :         [    offset    :         4    ,         limit    :         2    ]    
           >    ,         [    authorize?    :         true    ,         reuse_values?    :         false    ,         return_query?    :         false    ]    }    ,    
          more?    :         false        }

And since we had 5 posts, this should be the last page:

    last_page    .    more?

    false

### Keyset pagination

When using keyset pagination, a `%Ash.Page.Keyset{}` struct is returned from read actions.

    page         =         Domain    .    list_posts_with_keyset!    (    page    :         [    limit    :         2    ]    )

    %    Ash.Page.Keyset    {    
          results    :         [    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
              title    :         "post 1"    ,    
              text    :         "text 1"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
              title    :         "post 2"    ,    
              text    :         "text 2"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          count    :         nil    ,    
          before    :         nil    ,    
          after    :         nil    ,    
          limit    :         2    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Post    ,    
             sort    :         [    title    :         :asc    ]    ,    
             select    :         [    :id    ,         :title    ,         :text    ]    ,    
             page    :         [    limit    :         2    ]    
           >    ,         [    authorize?    :         true    ,         reuse_values?    :         false    ,         return_query?    :         false    ]    }    ,    
          more?    :         true        }

`results` and `more?` work in the same way as offset pagination

    page    .    results

    [    
          #    Post    <    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
            title    :         "post 1"    ,    
            text    :         "text 1"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Post    <    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "78cd10f0-a509-4602-861f-24652c68d54b"    ,    
            title    :         "post 2"    ,    
            text    :         "text 2"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

### Retrieving the next page

To retrieve the next page, you have to pass the keyset of the last record in the current page. The keyset is stored in `record.__metadata__.keyset`.

    last_keyset         =    
          page    .    results    
          |>         List    .    last    (    )    
          |>         Map    .    get    (    :__metadata__    )    
          |>         Map    .    get    (    :keyset    )    
        second_page         =         Domain    .    list_posts_with_keyset!    (    page    :         [    limit    :         2    ,         after    :         last_keyset    ]    )

    %    Ash.Page.Keyset    {    
          results    :         [    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
              title    :         "post 3"    ,    
              text    :         "text 3"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
              title    :         "post 4"    ,    
              text    :         "text 4"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          count    :         nil    ,    
          before    :         nil    ,    
          after    :         "g2wAAAACbQAAAAZwb3N0IDJtAAAAJDc4Y2QxMGYwLWE1MDktNDYwMi04NjFmLTI0NjUyYzY4ZDU0Ymo="    ,    
          limit    :         2    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Post    ,    
             sort    :         [    title    :         :asc    ]    ,    
             select    :         [    :id    ,         :title    ,         :text    ]    ,    
             page    :         [    
               limit    :         2    ,    
               after    :         "g2wAAAACbQAAAAZwb3N0IDJtAAAAJDc4Y2QxMGYwLWE1MDktNDYwMi04NjFmLTI0NjUyYzY4ZDU0Ymo="    
             ]    
           >    ,         [    authorize?    :         true    ,         reuse_values?    :         false    ,         return_query?    :         false    ]    }    ,    
          more?    :         true        }

`Ash.page!/2` works with keyset pagination too

    last_page         =         Ash    .    page!    (    second_page    ,         :next    )    
        last_page    .    more?

    false

### Default Pagination Behavior When Both Types Are Supported

When an action supports both `offset` and `keyset` pagination \(such as default read actions\), Ash uses the following logic to determine which pagination type to use:

**1. Explicit pagination parameters take precedence:**

+ If `after` or `before` is provided → keyset pagination
+ If `offset` is provided → offset pagination

**2. Configuration-based default for ambiguous cases:** Ash is configured to use keyset-pagination by default when installed with `mix igniter.install ash`, or the homepage installer.

#### Practical Examples

Regardless of configuration, the records will have keyset metadata, so you can always transition between pagination types:

    # By default, this uses keyset pagination        %{    results    :         [    _    ,         last    ]    }         =         Ash    .    read!    (    Post    ,         page    :         [    limit    :         2    ]    )    
        # Explicitly use keyset pagination for the next page        Ash    .    read!    (    Post    ,         page    :         [    limit    :         2    ,         after    :         last    .    __metadata__    .    keyset    ]    )    
        # Explicitly use offset pagination        Ash    .    read!    (    Post    ,         page    :         [    limit    :         2    ,         offset    :         2    ]    )

    %    Ash.Page.Offset    {    results    :         [    _    ,         last    ]    }         =         Domain    .    list_posts!    (    page    :         [    limit    :         2    ]    )    
        Domain    .    list_posts!    (    page    :         [    limit    :         2    ,         after    :         last    .    __metadata__    .    keyset    ]    )

    %    Ash.Page.Keyset    {    
          results    :         [    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "ab8e9909-2a6c-42d7-bae9-09fad4356ea4"    ,    
              title    :         "post 3"    ,    
              text    :         "text 3"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Post    <    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "91d639c2-4a2c-4931-b446-543e118644f1"    ,    
              title    :         "post 4"    ,    
              text    :         "text 4"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          count    :         nil    ,    
          before    :         nil    ,    
          after    :         "g2wAAAACbQAAAAZwb3N0IDJtAAAAJDc4Y2QxMGYwLWE1MDktNDYwMi04NjFmLTI0NjUyYzY4ZDU0Ymo="    ,    
          limit    :         2    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Post    ,    
             sort    :         [    title    :         :asc    ]    ,    
             select    :         [    :id    ,         :title    ,         :text    ]    ,    
             page    :         [    
               limit    :         2    ,    
               after    :         "g2wAAAACbQAAAAZwb3N0IDJtAAAAJDc4Y2QxMGYwLWE1MDktNDYwMi04NjFmLTI0NjUyYzY4ZDU0Ymo="    
             ]    
           >    ,         [    authorize?    :         true    ,         reuse_values?    :         false    ,         return_query?    :         false    ]    }    ,    
          more?    :         true        }

### Retrieving count

Both `%Ash.Page.Offset{}` and `%Ash.Page.Keyset{}` have a `count` field that contains the total count of the items that are being paginated when `count: true` is passed in the page options.

    page         =         Domain    .    list_posts!    (    page    :         [    limit    :         2    ,         count    :         true    ]    )    
        page    .    count

    5

### Relationship pagination

To paginate a relationship, pass a query customized with the page options to the load statement. This works both on paginated and unpaginated root data, and relationships can load arbitrarily nested paginated relationships.

    paginated_comments         =    
          Comment    
          |>         Ash.Query    .    page    (    limit    :         2    )    
        first_post         =    
          Domain    .    list_posts!    (    load    :         [    comments    :         paginated_comments    ]    )    
          |>         List    .    first    (    )    
        first_post    .    comments

    %    Ash.Page.Offset    {    
          results    :         [    
            #    Comment    <    
              post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "6cdea87b-cb69-4dc5-9ff3-54fb46bd70b0"    ,    
              text    :         "comment 1"    ,    
              created_at    :         ~U[2024-05-28 21:32:59.013913Z]    ,    
              post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Comment    <    
              post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "c653e92c-fe2f-4011-84c8-ace28ebbb207"    ,    
              text    :         "comment 2"    ,    
              created_at    :         ~U[2024-05-28 21:32:59.021204Z]    ,    
              post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         2    ,    
          offset    :         0    ,    
          count    :         nil    ,    
          rerun    :         {    #    Ash.Query    <    resource    :         Comment    ,         sort    :         [    created_at    :         :asc    ]    ,         page    :         [    limit    :         2    ]    >    ,    
           [    authorize?    :         true    ,         actor    :         nil    ,         tracer    :         [    ]    ]    }    ,    
          more?    :         true        }

You can use all the methods describe above to navigate relationship pages and retrieve their count

    second         =         Ash    .    page!    (    first_post    .    comments    ,         :next    )

    %    Ash.Page.Offset    {    
          results    :         [    
            #    Comment    <    
              post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "aa207735-0a02-4b51-b5f6-69564a2a6365"    ,    
              text    :         "comment 3"    ,    
              created_at    :         ~U[2024-05-28 21:32:59.022890Z]    ,    
              post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            #    Comment    <    
              post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "09f9cdfe-5a88-4f6a-a8d9-2f8aa312efb8"    ,    
              text    :         "comment 4"    ,    
              created_at    :         ~U[2024-05-28 21:32:59.024526Z]    ,    
              post_id    :         "6eb22ea7-184c-4cae-9054-0d1a0474db61"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         2    ,    
          offset    :         2    ,    
          count    :         nil    ,    
          rerun    :         {    #    Ash.Query    <    
             resource    :         Comment    ,    
             sort    :         [    created_at    :         :asc    ]    ,    
             select    :         [    :id    ,         :text    ,         :created_at    ,         :post_id    ]    ,    
             page    :         [    offset    :         2    ,         limit    :         2    ]    
           >    ,         [    reuse_values?    :         false    ,         return_query?    :         false    ,         authorize?    :         true    ,         actor    :         nil    ,         tracer    :         [    ]    ]    }    ,    
          more?    :         true        }



# Combination Queries

Ash Framework provides a powerful feature called "combination queries" that allows you to combine multiple queries into a single result set, giving you the ability to create complex data retrieval patterns with minimal effort. For SQL data-layers, this feature is implemented using SQL's UNION, INTERSECT, and EXCEPT operations.

## Overview

Combination queries let you:

+ Combine multiple distinct queries into a single result set
+ Apply different filters, sorting, limits, and calculations to each subquery
+ Use operations like union, intersection, and exclusion to define how results should be combined
+ Create complex composite queries that would otherwise require multiple separate database calls

## Syntax

To use combination queries, you'll work with the following functions:

    Ash.Query    .    combination_of    (    query    ,         combinations    )

Where `combinations` is a list of combination specifications starting with a base query, followed by additional operations:

+ `Ash.Query.Combination.base/1`: The starting point for your combined query
+ `Ash.Query.Combination.union/1`: Combine with the previous results, removing duplicates
+ `Ash.Query.Combination.union_all/1`: Combine with the previous results, keeping duplicates
+ `Ash.Query.Combination.intersect/1`: Keep only records that appear in both the previous results and this query
+ `Ash.Query.Combination.except/1`: Remove records from the previous results that appear in this query

## Basic Example

Here's a simple example that combines users who meet different criteria:

    read         :best_and_worst_users         do    
          description         """
      Returns the top 10 active users who are not on a losing streak
      (sorted by score descending) and the bottom 10 active users who are not on a
      winning streak (sorted by score ascending)
      """    

          filter         expr    (    active         ==         true    )    

          prepare         fn         query    ,         _         ->    
            Ash.Query    .    combination_of    (    query    ,         [    
              # Must always begin with a base combination    
              Ash.Query.Combination    .    base    (    
                filter    :         expr    (    not    (    on_a_losing_streak    )    )    ,    
                sort    :         [    score    :         :desc    ]    ,    
                limit    :         10    
              )    ,    
              Ash.Query.Combination    .    union    (    
                filter    :         expr    (    not    (    on_a_winning_streak    )    )    ,    
                sort    :         [    score    :         :asc    ]    ,    
                limit    :         10    
              )    
            ]    )    
          end        end

This query would return:

+ The top 10 active users who are not on a losing streak \(sorted by score descending\)
+ Union with the bottom 10 active users who are not on a winning streak \(sorted by score ascending\)

## Using Calculations in Combinations

One of the most powerful features of combination queries is the ability to create calculations that can be referenced across the combinations:

    query         =         "fred"    
        User        |>         Ash.Query    .    filter    (    active         ==         true    )        |>         Ash.Query    .    combination_of    (    [    
          Ash.Query.Combination    .    base    (    
            filter    :         expr    (    trigram_similarity    (    user_name    ,         ^    query    )         >=         0.5    )    ,    
            calculations    :         %{    
              match_score    :         calc    (    trigram_similarity    (    user_name    ,         ^    query    )    ,         type    :         :float    )    
            }    ,    
            sort    :         [    
              {    calc    (    trigram_similarity    (    user_name    ,         ^    query    )    ,         type    :         :float    )    ,         :desc    }    
            ]    ,    
            limit    :         10    
          )    ,    
          Ash.Query.Combination    .    union    (    
            filter    :         expr    (    trigram_similarity    (    email    ,         ^    query    )         >=         0.5    )    ,    
            calculations    :         %{    
              match_score    :         calc    (    trigram_similarity    (    email    ,         ^    query    )    ,         type    :         :float    )    
            }    ,    
            sort    :         [    
              {    calc    (    trigram_similarity    (    email    ,         ^    query    )    ,         type    :         :float    )    ,         :desc    }    
            ]    ,    
            limit    :         10    
          )        ]    )        |>         Ash    .    read!    (    )

When you add calculations to a combination query, they behave differently depending on the name of the calculation. If the name matches the name of an attribute, calculation or aggregate on the resource, then the value is placed in that key. Otherwise, it will be placed into the `calculations` key.

This example searches for users where either their name or email matches "fred" with a similarity score of at least 0.5, and returns the top 10 matches of each type sorted by their match score.

## Accessing Combination Values

To access values from combination queries in your main query, use the `combinations/1` function in your expressions:

    User        |>         Ash.Query    .    combination_of    (    [    
          Ash.Query.Combination    .    base    (    
            filter    :         expr    (    organization    .    name         ==         "bar"    )    ,    
            calculations    :         %{    
              domain    :         calc    (    "bar"    ,         type    :         :string    )    ,    
              full_name    :         calc    (    name         <>         "@bar"    ,         type    :         :string    )    
            }    
          )    ,    
          Ash.Query.Combination    .    union_all    (    
            filter    :         expr    (    organization    .    name         ==         "baz"    )    ,    
            calculations    :         %{    
              domain    :         calc    (    "baz"    ,         type    :         :string    )    ,    
              full_name    :         calc    (    name         <>         "@baz"    ,         type    :         :string    )    
            }    
          )        ]    )        |>         Ash.Query    .    calculate    (    :email_domain    ,         :string    ,         expr    (    ^    combinations    (    :domain    )    )    )        |>         Ash.Query    .    calculate    (    :display_name    ,         :string    ,         expr    (    ^    combinations    (    :full_name    )    )    )        |>         Ash    .    read!    (    )

In this example, the `combinations(:domain)` and `combinations(:full_name)` references allow the outer query to access the calculation values from the inner combinations.

## Sorting and Distinct Operations

You can sort and filter the combined results using the calculations from your combinations:

    User        |>         Ash.Query    .    combination_of    (    [    
          Ash.Query.Combination    .    base    (    calculations    :         %{    sort_order    :         calc    (    3    ,         type    :         :integer    )    }    )    ,    
          Ash.Query.Combination    .    union_all    (    
            filter    :         expr    (    name         ==         "alice"    )    ,    
            calculations    :         %{    sort_order    :         calc    (    1    ,         type    :         :integer    )    }    
          )    ,    
          Ash.Query.Combination    .    union_all    (    
            filter    :         expr    (    name         ==         "john"    )    ,    
            calculations    :         %{    sort_order    :         calc    (    2    ,         type    :         :integer    )    }    
          )        ]    )        |>         Ash.Query    .    sort    (    [    {    calc    (    ^    combinations    (    :sort_order    )    )    ,         :asc    }    ,         {    :name    ,         :asc    }    ]    )        |>         Ash.Query    .    distinct    (    :name    )        |>         Ash    .    read!    (    )

This will return results in the order: Alice, John, and then all other users, thanks to the custom sort\_order calculation.

## Important Rules and Limitations

1. 
**This is an internal power tool**: No public interfaces like `AshJsonApi`/`AshGraphql` will be updated to allow this sort of query to be built "from the outside". It is designed to be implemented within an action, "under the hood".

2. 
**Base Combination Required**: Your list of combinations must always start with `Ash.Query.Combination.base/1`.

3. 
**Field Consistency**: All combinations must produce the same set of fields. This means:

	+ If one combination has a calculation, all combinations need that calculation
	+ Select statements should be consistent across combinations
	+ If a calculation added to a combination has the same name as an attribute, then it will be used by `combinations(:that_field)`, allowing for combinations to "override" attribute values.

4. 
**Primary Keys**: When adding runtime calculations or loading related data with `Ash.Query.load/2`, all fieldsets must include the primary key of the resource. If this is not the case, the query will fail.

5. 
**Type Specification**: When referencing calculation values with `combinations/1`, the calculation must have been added with a specified type on the `base` query at a minimum:

    # Correct - type is specified        calc    (    expression    ,         type    :         :string    )    
        # Incorrect - will raise an error when referenced        calc    (    expression    )


## Data Layer Support

Combination queries depend on data layer support. The implementation in this release includes support for ETS data layer, with implementation for SQL and Postgres to be added in future releases.

## Performance Considerations

Combination queries can be more efficient than multiple separate queries, especially when:

+ You need to apply complex ordering or pagination to combined datasets
+ You want to deduplicate results across multiple selection criteria
+ You need to perform operations like intersection or exclusion between sets

However, be mindful that complex combinations can generate equally complex SQL queries, so monitor performance in production scenarios.

## Practical Examples

### Example 1: Search across multiple fields

    Post        |>         Ash.Query    .    combination_of    (    [    
          Ash.Query.Combination    .    base    (    
            filter    :         expr    (    ilike    (    title    ,         ^    (    "%"         <>         search_term         <>         "%"    )    )    )    ,    
            calculations    :         %{    match_type    :         calc    (    "title"    ,         type    :         :string    )    }    ,    
            sort    :         [    published_at    :         :desc    ]    ,    
            limit    :         10    
          )    ,    
          Ash.Query.Combination    .    union    (    
            filter    :         expr    (    ilike    (    body    ,         ^    (    "%"         <>         search_term         <>         "%"    )    )    )    ,    
            calculations    :         %{    match_type    :         calc    (    "body"    ,         type    :         :string    )    }    ,    
            sort    :         [    published_at    :         :desc    ]    ,    
            limit    :         10    
          )        ]    )        |>         Ash.Query    .    sort    (    [    published_at    :         :desc    ]    )        |>         Ash.Query    .    calculate    (    :matched_in    ,         :string    ,         expr    (    ^    combinations    (    :match_type    )    )    )        |>         Ash    .    read!    (    )

### Example 2: Complex filtering with intersection

    User        |>         Ash.Query    .    combination_of    (    [    
          Ash.Query.Combination    .    base    (    filter    :         expr    (    role         ==         "admin"    )    )    ,    
          Ash.Query.Combination    .    intersect    (    filter    :         expr    (    last_login         >         ^    one_month_ago    )    )        ]    )        |>         Ash    .    read!    (    )

This returns all admin users who have logged in within the last month.

## Summary

Combination queries provide a powerful tool for creating complex data retrieval patterns in Ash. By combining multiple queries with different filters, sorts, and calculations, you can build sophisticated interfaces that would otherwise require multiple database queries and application-level merging of results.

This feature is particularly valuable for search interfaces, reporting tools, and anywhere you need to blend data from different filter conditions in a single, cohesive result set.



# Timeouts

## Ways to Specify Timeouts

You have a few options.

You can specify a timeout when you call an action. This takes the highest precedence.

    Ash    .    read!    (    query    ,         timeout    :         :timer    .    seconds    (    30    )    )

You can specify one using `Ash.Changeset.timeout/2` or `Ash.Query.timeout/2`. This can be useful if you want to conditionally set a timeout based on the details of the request. For example, you might do something like this:

    # in your resource        defmodule         MyApp.SetReportTimeout         do    
          use         Ash.Resource.Preparation    

          def         prepare    (    query    ,         _    ,         _    )         do    
            if         Ash.Query    .    get_argument    (    query    ,         :full_report    )         do    
              Ash.Query    .    timeout    (    query    ,         :timer    .    minutes    (    3    )    )    
            else    
              Ash.Query    .    timeout    (    query    ,         :timer    .    minutes    (    1    )    )    
            end    
          end        end    
        actions         do    
          read         :report_items         do    
            argument         :full_report    ,         :boolean    ,         default    :         false    

            prepare         MyApp.SetReportTimeout    
          end        end

You can also specify a default timeout on your domain modules.

    execution         do    
          timeout         :timer    .    seconds    (    30    )         # the default is `:infinity`        end

Keep in mind, you can't specify timeouts in a before\_action or after\_action hook, because at that point you are already "within" the code that should have a timeout applied.

### timeouts use processes

Timeouts are implemented using processes. This means that potentially large query results will be copied across processes. Because of this, specifying timeouts globally or for things that you don't suspect would ever exceed that timeout is not recommended.

## How are timeouts handled?

Timeouts in Ash work a bit differently than other tools. The following considerations must be taken into account:

1. If you run a resource action in a transaction, then the timeout applies to the entire transaction.
2. If the resource action you are running, and any of its `touches_resources` is *already in a transaction* then the timeout is ignored, as the outer transaction is handling the timeout.
3. If the resource is not in a transaction, and supports async execution \(ash\_postgres does\), then everything is run in a task and awaited with the provided timeout.
4. If the data layer of the resource does not support timeouts, or async execution then timeouts are **ignored**.



# Multitenancy

Multitenancy is the splitting up your data into discrete areas, typically by customer. One of the most common examples of this, is the idea of splitting up a postgres database into "schemas" one for each customer that you have. Then, when making any queries, you ensure to always specify the "schema" you are querying, and you never need to worry about data crossing over between customers. The biggest benefits of this kind of strategy are the simplification of authorization logic, and better performance. Instead of all queries from all customers needing to use the same large table, they are each instead all using their own smaller tables. Another benefit is that it is much easier to delete a single customer's data on request.

In Ash, there are two primary strategies for implementing multitenancy. The first \(and simplest\) works for any data layer that supports filtering, and requires very little maintenance/mental overhead. It is done via expecting a given attribute to line up with the `tenant`, and is called `:attribute`. The second, is based on the data layer backing your resource, and is called `:context`. For information on context based multitenancy, see the documentation of your data layer. For example, `AshPostgres` uses postgres schemas. While the `:attribute` strategy is simple to implement, it also offers fewer advantages, primarily acting as another way to ensure your data is filtered to the correct tenant.

## Attribute Multitenancy

    defmodule         MyApp.Users         do    
          use         Ash.Resource    ,         ...    

          multitenancy         do    
            strategy         :attribute    
            attribute         :organization_id    
          end    

          ...    

          relationships         do    
            belongs_to         :organization    ,         MyApp.Organization    
          end        end

In this case, if you were to try to run a query without specifying a tenant, you would get an error telling you that the tenant is required.

Setting the tenant is done via `Ash.Query.set_tenant/2` and `Ash.Changeset.set_tenant/2`. If you are using a code interface, you can pass `tenant:` in the options list \(the final parameter\). If you are using an extension, such as `AshJsonApi` or `AshGraphql` the method of setting tenant context is explained in that extension's documentation.

Example usage of the above:

    # Error when not setting a tenant        MyApp.Users        |>         Ash.Query    .    filter    (    name         ==         "fred"    )        |>         Ash    .    read!    (    )        ** (Ash.Error.Invalid)    
        *         "Queries against the Helpdesk.Accounts.User resource require a tenant to be specified"    
            (    ash         1.22    .    0    )         lib    /    ash    /    domain    /    domain    .    ex    :    944    :         Ash.Domain    .    unwrap_or_raise!    /    2    
        # Automatically filtering by `organization_id == 1`        MyApp.Users        |>         Ash.Query    .    filter    (    name         ==         "fred"    )        |>         Ash.Query    .    set_tenant    (    1    )        |>         Ash    .    read!    (    )    
        [    ...    ]    
        # Automatically setting `organization_id` to `1`        MyApp.Users        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    name    :         "fred"    }    )        |>         Ash.Changeset    .    set_tenant    (    1    )        |>         Ash    .    create!    (    )    
        %    MyApp.User    {    organization_id    :         1    }    
        # Setting tenant with a code interface that exposes `list_all` as a read action        MyApp.Users    .    list_all    (    tenant    :         1    )

If you want to enable running queries *without* a tenant as well as queries with a tenant, the `global?` option supports this. You will likely need to incorporate this ability into any authorization rules though, to ensure that users from one tenant can't access other tenant's data.

    multitenancy         do    
          strategy         :attribute    
          attribute         :organization_id    
          global?         true        end

You can also provide the `parse_attribute?` option if the tenant being set doesn't exactly match the attribute value, e.g the tenant is `org_10` and the attribute is `organization_id`, which requires just `10`.

## Tenant-Aware Identities

When using identities in a multitenant resource, the tenant attribute is automatically included in the uniqueness constraints. This means that the same identity value can exist across different tenants, but must be unique within a single tenant. For example, if you have a `User` resource with an email identity, users in different organizations could have the same email address.

If you need an identity to be globally unique across all tenants \(like a global user email system\), you can set `all_tenants?: true` on the identity.

    defmodule         MyApp.User         do    
          use         Ash.Resource    ,         ...    

          multitenancy         do    
            strategy         :attribute    
            attribute         :organization_id    
          end    

          identities         do    
            # This email must be unique within a tenant    
            identity         :tenant_scoped_email    ,         [    :email    ]    

            # This username must be unique across all tenants    
            identity         :global_username    ,         [    :username    ]    ,         all_tenants?    :         true    
          end        end

Example implications:

    # These are valid because they're in different tenants        User        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    email    :         "fred@example.com"    }    )        |>         Ash.Changeset    .    set_tenant    (    1    )        |>         Ash    .    create!    (    )    
        User        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    email    :         "fred@example.com"    }    )        |>         Ash.Changeset    .    set_tenant    (    2    )        |>         Ash    .    create!    (    )    
        # This would fail because usernames are global        User        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    username    :         "fred"    }    )        |>         Ash.Changeset    .    set_tenant    (    1    )        |>         Ash    .    create!    (    )    
        User        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    username    :         "fred"    }    )        |>         Ash.Changeset    .    set_tenant    (    2    )        |>         Ash    .    create!    (    )         # Error: username already taken

## Context Multitenancy

Context multitenancy allows for the data layer to dictate how multitenancy works. For example, a csv data layer might implement multitenancy via saving the file with different suffixes, or an API wrapping data layer might use different subdomains for the tenant.

For `AshPostgres` context multitenancy, which uses postgres schemas and is referred to ash "Schema Based Multitenancy", see the guide

## Possible Values for tenant

By default, the tenant value is passed directly to the relevant implementation. For example, if you are using schema multitenancy with `ash_postgres`, you might provide a schema like `organization.subdomain`. In Ash, a tenant should be identifiable by a single value, like an integer or a string.

You can use the `Ash.ToTenant` protocol to automatically convert values into this simple value. The example below will allow you to use the same organization everywhere, and have it automatically converted into the correct schema for postgres, and the correct id for attribute-based multitenant resources. You can use this without looking up the relevant record as well, as long as the required fields used in your protocol are present.

    Ash.Changeset    .    for_create    (    ...    ,         tenant    :         %    MyApp.Organization    {    id    :         id    }    )

    # in Organization resource    
        defimpl         Ash.ToTenant         do    
          def         to_tenant    (    %{    id    :         id    }    ,         resource    )         do    
            if         Ash.Resource.Info    .    data_layer    (    resource    )         ==         AshPostgres.DataLayer    
              &&         Ash.Resource.Info    .    multitenancy_strategy    (    resource    )         ==         :context         do    
              "org_    #{    id    }    "    
            else    
              id    
            end    
          end        end

This allows you to pass an `%Organization{}` or an organization\_id around, and have that `organization_id` properly used with attribute and context-based multitenancy.



# Writing Extensions

Extensions allow you to make powerful modifications to DSL entities. If you are using `AshPostgres`, `AshGraphql` or `AshJsonApi`, they are all integrated into Ash using extensions. In this guide we will build a simple extension for `Ash.Resource` that adds timestamps to your resource. We'll also show some simple patterns that can help ensure that all of your resources are using your extension.

## Creating an extension

What we call an "extension" is typically one or more `Spark.Dsl.Extension`, and then any additional code that is used by that extension. For example, `AshGraphql` has a domain extension called `AshGraphql.Domain`, a resource extension called `AshGraphql.Resource`, and code to connect a GraphQL schema to your resources.

### DSL Extension

Here we create a DSL extension called `MyApp.Extensions.Base`, and configure a single transformer, called `MyApp.Extensions.Base.AddTimestamps`

    defmodule         MyApp.Extensions.Base         do    
          use         Spark.Dsl.Extension    ,         transformers    :         [    MyApp.Extensions.Base.AddTimestamps    ]        end

### Transformers

Transformers are all run serially against a map of data called `dsl_state`, which is the data structure that we build as we use the DSL. For example:

    attributes         do    
          attribute         :name    ,         :string        end

Would, under the hood, look something like this:

    %{    
          [    :attributes    ]         =>         %{    entities    :         [    
              %    Ash.Resource.Attribute    {    name    :         :name    ,         type    :         :string    }    
            ]    
          }    ,    
          ...        }

A transformer exposes `transform/1`, which takes the `dsl_state` and returns either `{:ok, dsl_state}` or `{:error, error}`

    defmodule         MyApp.Extensions.Base.AddTimestamps         do    
          use         Spark.Dsl.Transformer    
          alias         Spark.Dsl.Transformer    

          def         transform    (    dsl_state    )         do    
            dsl_state    
            # Ash.Resource.Builder has utilities for extending resources    
            |>         Ash.Resource.Builder    .    add_new_create_timestamp    (    :inserted_at    )    
            |>         Ash.Resource.Builder    .    add_new_update_timestamp    (    :updated_at    )    
          end        end

This transformer builds adds a `create_timestamp` called `:inserted_at` and an `update_timestamp` called `:updated_at`, unless they already exist.

### Make the extension configurable

So far we've covered transformers, and using them to modify resources, but now lets say we want to make this behavior opt-out. Perhaps certain resources really shouldn't have timestamps, but we want it to be the default. Lets add a "DSL Section" to our extension.

    defmodule         MyApp.Extensions.Base         do    
          @base         %    Spark.Dsl.Section    {    
            name    :         :base    ,    
            describe    :         """
        Configure the behavior of our base extension.
        """    ,    
            examples    :         [    
              """
          base do
            timestamps? false
          end
          """    
            ]    ,    
            schema    :         [    
              timestamps?    :         [    
                type    :         :boolean    ,    
                doc    :         "Set to false to skip adding timestamps"    ,    
                default    :         true    
              ]    
            ]    
          }    



          use         Spark.Dsl.Extension    ,    
            transformers    :         [    MyApp.Extensions.Base.AddTimestamps    ]    ,    
            sections    :         [    @base    ]        end    
        defmodule         MyApp.Extensions.Base.Info         do    
          use         Spark.InfoGenerator    ,         extension    :         MyApp.Extensions.Base    ,         sections    :         [    :base    ]    

          # This will define `base_timestamps?/1`.        end

Now we can use this configuration in our transformer, like so:

          def         transform    (    dsl_state    )         do    
            # Introspection functions can take a `dsl_state` *or* a module    
            if         MyApp.Extensions.Base.Info    .    base_timestamps?    (    dsl_state    )         do    
              dsl_state    
              |>         Ash.Resource.Builder    .    add_new_create_timestamp    (    :inserted_at    )    
              |>         Ash.Resource.Builder    .    add_new_update_timestamp    (    :updated_at    )    
            else    
              {    :ok    ,         dsl_state    }    
            end    
          end

And now we have a configurable base extension\! For more information on writing DSLs, see `Spark`. `Spark` is still lacking in documentation, unfortunately, as its something that mostly the adventurous/power users work with, and they often learn by way of examples, looking at `Ash` extensions. We would like to rectify this in the future. Please reach out if you're interested in assisting with that effort\!

### Ordering of transformers

In this case, this transformer can run in any order. However, as we start adding transformers and/or modify the behavior of this one, we may need to ensure that our transformer runs before or after specific transformers. As of the writing of this guide, the best way to look at the list of transformers is to look at the source of the extension, and see what transformers it has and what they do. The Resource DSL for example.

If you need to affect the ordering, you can define `before?/1` and `after?/1` in your transformer, i.e

    # I go after every transformer        def         after?    (    _    )    ,         do    :         true    
        # except I go before `SomeOtherTransformer`        def         before?    (    SomeOtherTransformer    )    ,         do    :         true        def         before?    (    _    )    ,         do    :         false

## Using your extension

Now it can be used in a resource:

    defmodule         MyApp.Tweet         do    
          use         Ash.Resource    ,    
            extensions    :         [    MyApp.Extensions.Base    ]    

          base         do    
            # And you can configure it like so    
            timestamps?         false    
          end        end

Your extension will automatically support autocompletion if using `ElixirLS`, showing inline documentation and type-aware auto complete as you type. For more, see Development Utilities

## Base Resources

Base resources are a "quick and easy" way to ensure that all or a set of your resources use the same behavior. If we want to ensure that all of our resources have timestamps, we could create a module like so:

    defmodule         MyApp.Resource         do    
          defmacro         __using__    (    opts    )         do    
            quote         do    
              use         Ash.Resource    ,         unquote    (    opts    )    

              attributes         do    
                timestamps    (    )    
              end    
            end    
          end        end

Then we would configure that this base resource exists, with `config :my_app, base_resources: [MyApp.Resource]`

Now in our resources instead of `use Ash.Resource`, we say `use MyApp.Resource`.

Use `mix ash.gen.base_resource` to create one of these.:w

This pattern is relatively limited, good for simple things like making sure that all of our resources use a particular extension. See the section above on extensions for the ideal way of extending resources.



# Write Queries

    Mix    .    install    (    [    {    :ash    ,         "~> 3.0"    }    ]    ,    
          consolidate_protocols    :         false        )    
        Application    .    put_env    (    :ash    ,         :validate_domain_resource_inclusion?    ,         false    )        Application    .    put_env    (    :ash    ,         :validate_domain_config_inclusion?    ,         false    )    
        ExUnit    .    start    (    )

## Introduction

Here we will show practical examples of using `Ash.Query`. To understand more about its capabilities, limitations, and design, see the module docs of `Ash.Query`.

This guide is here to provide a slew of examples, for more information on any given function or option please search the documentation. Please propose additions for any useful patterns that are not demonstrated here\!

## Setup

First, lets create some resources and some data to query.

    defmodule         MyApp.Posts         do    
          use         Ash.Domain    

          resources         do    
            resource         MyApp.Posts.Post    
            resource         MyApp.Posts.Comment    
          end        end    
        defmodule         MyApp.Posts.Post         do    
          use         Ash.Resource    ,    
            domain    :         MyApp.Posts    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         :destroy    ,         create    :         :*    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    

            attribute         :text    ,         :string         do    
              allow_nil?         false    
              public?         true    
            end    
          end    

          calculations         do    
            calculate         :text_length    ,         :integer    ,         expr    (    string_length    (    text    )    )    
          end    

          aggregates         do    
            count         :count_of_comments    ,         :comments    
          end    

          relationships         do    
            has_many         :comments    ,         MyApp.Posts.Comment         do    
              public?         true    
            end    
          end        end    
        defmodule         MyApp.Posts.Comment         do    
          use         Ash.Resource    ,    
            domain    :         MyApp.Posts    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         :destroy    ,         create    :         :*    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :text    ,         :string         do    
              allow_nil?         false    
              public?         true    
            end    
          end    

          relationships         do    
            belongs_to         :post    ,         MyApp.Posts.Post         do    
              public?         true    
            end    
          end        end

    {    :module    ,         MyApp.Posts.Comment    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         110    ,         ...    >>    ,    
         [    
           Ash.Expr    ,    
           Ash.Resource.Dsl.Relationships.BelongsTo    ,    
           Ash.Resource.Dsl.Relationships.ManyToMany    ,    
           Ash.Resource.Dsl.Relationships.HasMany    ,    
           Ash.Resource.Dsl.Relationships.HasOne    ,    
           %{    ...    }    
         ]    }

    # Get rid of any existing comments/posts        Ash    .    bulk_destroy!    (    MyApp.Posts.Comment    ,         :destroy    ,         %{    }    )        Ash    .    bulk_destroy!    (    MyApp.Posts.Post    ,         :destroy    ,         %{    }    )    
        # Create some posts        post1         =    
          Ash    .    create!    (    MyApp.Posts.Post    ,         %{    text    :         "First post about Ash!"    }    )    
        post2         =    
          Ash    .    create!    (    MyApp.Posts.Post    ,         %{    text    :         "Learning to write queries"    }    )    
        comment1         =    
          Ash    .    create!    (    MyApp.Posts.Comment    ,         %{    text    :         "Great post!"    ,         post_id    :         post1    .    id    }    )    
        comment2         =    
          Ash    .    create!    (    MyApp.Posts.Comment    ,         %{    text    :         "Very helpful!"    ,         post_id    :         post1    .    id    }    )    
        comment3         =    
          Ash    .    create!    (    MyApp.Posts.Comment    ,         %{    text    :         "Thanks for the explanation"    ,         post_id    :         post2    .    id    }    )    
        # Store the created records in module attributes for later use        posts         =         [    post1    ,         post2    ]        comments         =         [    comment1    ,         comment2    ,         comment3    ]    
        IO    .    puts    (    "    \n    Created     #{    length    (    posts    )    }     posts and     #{    length    (    comments    )    }     comments!"    )

        23    :    17    :    15.097         [    debug    ]         ETS    :         Destroying         MyApp.Posts.Comment    

        23    :    17    :    15.104         [    debug    ]         ETS    :         Destroying         MyApp.Posts.Post    

        23    :    17    :    15.110         [    debug    ]         Creating         MyApp.Posts.Post    :    
        %{    id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,         text    :         "First post about Ash!"    }    

        23    :    17    :    15.110         [    debug    ]         Creating         MyApp.Posts.Post    :    
        %{    id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,         text    :         "Learning to write queries"    }    

        23    :    17    :    15.111         [    debug    ]         Creating         MyApp.Posts.Comment    :    
        %{    
          id    :         "05863bdd-38eb-4e0e-9ff7-f23f65639ec3"    ,    
          text    :         "Great post!"    ,    
          post_id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"        }    

        23    :    17    :    15.111         [    debug    ]         Creating         MyApp.Posts.Comment    :    
        %{    
          id    :         "437b6966-2929-4e12-94cc-5807adf60c3e"    ,    
          text    :         "Very helpful!"    ,    
          post_id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"        }    

        23    :    17    :    15.111         [    debug    ]         Creating         MyApp.Posts.Comment    :    
        %{    
          id    :         "09aaffc4-bca7-4848-8b05-2d1ca11aba33"    ,    
          text    :         "Thanks for the explanation"    ,    
          post_id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"        }    

        Created         2         posts         and         3         comments!

    :ok

### Basic Queries

Let's start with some basic query examples. To use `Ash.Query.filter/2`, we'll need to `require Ash.Query`.

    require         Ash.Query

    Ash.Query

## Read everything

    # with a lot of data, you probably shouldn't do this        Ash    .    read!    (    MyApp.Posts.Post    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            text    :         "Learning to write queries"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            text    :         "First post about Ash!"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

## Count all comments

    MyApp.Posts.Comment        |>         Ash    .    count!    (    )

    3

## Filtering

    MyApp.Posts.Post        |>         Ash.Query    .    filter    (    id         ==         ^    post1    .    id    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            text    :         "First post about Ash!"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    MyApp.Posts.Post        # you can filter on calculations        |>         Ash.Query    .    filter    (    text_length         ==         25    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            text    :         "Learning to write queries"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    MyApp.Posts.Post        # you can filter on aggregates        |>         Ash.Query    .    filter    (    count_of_comments         ==         2    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         2    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            text    :         "First post about Ash!"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    MyApp.Posts.Post        # use `filter_input` to filter based on user input        # it only allows accessing public fields        |>         Ash.Query    .    filter_input    (    %{    count_of_comments    :         %{    eq    :         2    }    }    )        |>         Ash    .    read!    (    )

## Sorting

    MyApp.Posts.Post        |>         Ash.Query    .    sort    (    :text    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            text    :         "First post about Ash!"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            text    :         "Learning to write queries"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    # Apply multiple sorts        MyApp.Posts.Post        |>         Ash.Query    .    sort    (    text    :         :asc    ,         count_of_comments    :         :desc    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         2    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            text    :         "First post about Ash!"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         1    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            text    :         "Learning to write queries"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    # use `sort_input` to sort based on user input        # it only allows accessing public fields        MyApp.Posts.Post        |>         Ash.Query    .    sort_input    (    "text,-count_of_comments"    )        |>         Ash    .    read!    (    )

## Distinct

    MyApp.Posts.Comment        # only one comment per post        |>         Ash.Query    .    distinct    (    :post_id    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Comment    <    
            post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "09aaffc4-bca7-4848-8b05-2d1ca11aba33"    ,    
            text    :         "Thanks for the explanation"    ,    
            post_id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    MyApp.Posts.Comment    <    
            post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "05863bdd-38eb-4e0e-9ff7-f23f65639ec3"    ,    
            text    :         "Great post!"    ,    
            post_id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    MyApp.Posts.Comment        # only one comment per post_id & text combination        |>         Ash.Query    .    distinct    (    [    :post_id    ,         :text    ]    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Comment    <    
            post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "09aaffc4-bca7-4848-8b05-2d1ca11aba33"    ,    
            text    :         "Thanks for the explanation"    ,    
            post_id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    MyApp.Posts.Comment    <    
            post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "05863bdd-38eb-4e0e-9ff7-f23f65639ec3"    ,    
            text    :         "Great post!"    ,    
            post_id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    MyApp.Posts.Comment    <    
            post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "437b6966-2929-4e12-94cc-5807adf60c3e"    ,    
            text    :         "Very helpful!"    ,    
            post_id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

## Load calculations/aggregates

    MyApp.Posts.Post        |>         Ash.Query    .    load    (    [    :count_of_comments    ,         :text_length    ]    )        |>         Ash    .    read!    (    )        |>         Enum    .    map    (    &    Map    .    take    (    &1    ,         [    :text    ,         :count_of_comments    ,         :text_length    ]    )    )

    [    
          %{    text    :         "Learning to write queries"    ,         text_length    :         25    ,         count_of_comments    :         1    }    ,    
          %{    text    :         "First post about Ash!"    ,         text_length    :         21    ,         count_of_comments    :         2    }        ]

## Load relationships

    MyApp.Posts.Post        |>         Ash.Query    .    load    (    :comments    )        |>         Ash    .    read!    (    )        |>         Enum    .    at    (    0    )

    #    MyApp.Posts.Post    <    
          text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
          count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
          comments    :         [    
            #    MyApp.Posts.Comment    <    
              post    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :post    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "09aaffc4-bca7-4848-8b05-2d1ca11aba33"    ,    
              text    :         "Thanks for the explanation"    ,    
              post_id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
          id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
          text    :         "Learning to write queries"    ,    
          aggregates    :         %{    }    ,    
          calculations    :         %{    }    ,    
          ...        >

## Limit & Offset

    MyApp.Posts.Post        |>         Ash.Query    .    limit    (    1    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
            text    :         "Learning to write queries"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    MyApp.Posts.Post        |>         Ash.Query    .    offset    (    1    )        |>         Ash    .    read!    (    )

    [    
          #    MyApp.Posts.Post    <    
            text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
            count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
            comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
            text    :         "First post about Ash!"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

## Pagination

    # Offset Pagination    
        MyApp.Posts.Post        |>         Ash.Query    .    page    (    limit    :         1    )        |>         Ash    .    read!    (    )

    %    Ash.Page.Offset    {    
          results    :         [    
            #    MyApp.Posts.Post    <    
              text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
              count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "2f22973b-f1cd-4d2d-b241-d7c53bf097d3"    ,    
              text    :         "Learning to write queries"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         1    ,    
          offset    :         0    ,    
          count    :         nil    ,    
          more?    :         true        }

    # Keyset pagination    
        first_post         =     
          MyApp.Posts.Post    
          # You can paginate using `Ash.Query.page/1`    
          |>         Ash.Query    .    page    (    limit    :         1    )    
          |>         Ash    .    read!    (    )    
          |>         Map    .    get    (    :results    )    
          |>         Enum    .    at    (    0    )    
          MyApp.Posts.Post        # Or using the `page` option        |>         Ash    .    read!    (    page    :         [    limit    :         1    ,         after    :         first_post    .    __metadata__    .    keyset    ]    )

    %    Ash.Page.Keyset    {    
          results    :         [    
            #    MyApp.Posts.Post    <    
              text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
              count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
              text    :         "First post about Ash!"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          count    :         nil    ,    
          before    :         nil    ,    
          after    :         "g2wAAAABbQAAACQyZjIyOTczYi1mMWNkLTRkMmQtYjI0MS1kN2M1M2JmMDk3ZDNq"    ,    
          limit    :         1    ,    
          more?    :         false        }

    MyApp.Posts.Post        |>         Ash.Query    .    page    (    limit    :         1    )        |>         Ash    .    read!    (    )        # you can ask for :next, :prev, :first, :last, or a page number        |>         Ash    .    page!    (    :next    )

    %    Ash.Page.Offset    {    
          results    :         [    
            #    MyApp.Posts.Post    <    
              text_length    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :text_length    >    ,    
              count_of_comments    :         #    Ash.NotLoaded    <    :aggregate    ,         field    :         :count_of_comments    >    ,    
              comments    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :comments    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "eafcb80f-8c90-4c16-8a29-cf0c28964d9b"    ,    
              text    :         "First post about Ash!"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    
          ]    ,    
          limit    :         1    ,    
          offset    :         1    ,    
          count    :         nil    ,    
          more?    :         false        }



# Define Polymorphic Relationships

    Mix    .    install    (    [    {    :ash    ,         "~> 3.0"    }    ]    ,         consolidate_protocols    :         false    )

    :ok

## Introduction

Something that comes up in more complex domains is the idea of "polymorphic relationships". For this example, we will use the concept of a `BankAccount`, which can be either a `SavingsAccount` or a `CheckingAccount`. All accounts have an `account_number` and `transactions`, but checkings & savings accounts might have their own specific information. For example, a `SavingsAccount` has an `interest_rate`, and a `CheckingAccount` has many `debit_card`s.

Ash does not support polymorphic relationships defined *as relationships*, but you can accomplish similar functionality via calculations with the type `Ash.Type.Union`.

For this tutorial, we will have a dedicated resource called `BankAccount`. I suggest taking that approach, as many things down the road will be simplified. With that said, you don't necessarily need to do that when there is no commonalities between the types. Instead of setting up the polymorphism on the `BankAccount` resource, you would define relationships to `SavingsAccount` and `CheckingAccount` directly.

This tutorial is not attempting to illustrate good design of accounting systems. We make many concessions for the sake of the simplicity of our example.

## Defining our Resources

    defmodule         BankAccount         do    
          use         Ash.Resource    ,    
            domain    :         Finance    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         :destroy    ,         create    :         [    :account_number    ,         :type    ]    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    

            attribute         :account_number    ,         :integer    ,         allow_nil?    :         false    
            attribute         :type    ,         :atom    ,         constraints    :         [    one_of    :         [    :checking    ,         :savings    ]    ]    
          end    

          # calculations do    
          #   calculate :implementation, AccountImplementation, GetAccountImplementation do    
          #    allow_nil? false    
          #  end    
          # end    

          relationships         do    
            has_one         :checking_account    ,         CheckingAccount    
            has_one         :savings_account    ,         SavingsAccount    
          end        end    
        defmodule         CheckingAccount         do    
          use         Ash.Resource    ,    
            domain    :         Finance    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         :destroy    ,         create    :         [    :bank_account_id    ]    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    
          end    

          identities         do    
            identity         :unique_bank_account    ,         [    :bank_account_id    ]    ,         pre_check?    :         true    
          end    

          relationships         do    
            belongs_to         :bank_account    ,         BankAccount         do    
              allow_nil?         false    
            end    
          end        end    
        defmodule         SavingsAccount         do    
          use         Ash.Resource    ,    
            domain    :         Finance    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         :destroy    ,         create    :         [    :bank_account_id    ]    ]    
          end    


          attributes         do    
            uuid_primary_key         :id    
          end    

          identities         do    
            identity         :unique_bank_account    ,         [    :bank_account_id    ]    ,         pre_check?    :         true    
          end    

          relationships         do    
            belongs_to         :bank_account    ,         BankAccount         do    
              allow_nil?         false    
            end    
          end        end    
        defmodule         Finance         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         BankAccount    
            resource         SavingsAccount    
            resource         CheckingAccount    
          end        end

    {    :module    ,         Finance    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         44    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           %{    opts    :         [    ]    ,         entities    :         [    %    Ash.Domain.Dsl.ResourceReference    {    ...    }    ,         ...    ]    }    
         ]    }

We haven't implemented the polymorphic part yet, but lets create a few of the above resources to show how they relate. Below we create a `BankAccount` for checkings, and a `BankAccount` for savings, and connect them to their "specific" types, i.e `CheckingAccount` and `SavingsAccount`.

We load the data, you can see that one `BankAccount` has a `:checking_account` but no `:savings_account`. For the other, the opposite is the case.

    bank_account1         =         Ash    .    create!    (    BankAccount    ,         %{    account_number    :         1    ,         type    :         :checking    }    )        bank_account2         =         Ash    .    create!    (    BankAccount    ,         %{    account_number    :         2    ,         type    :         :savings    }    )        checking_account         =         Ash    .    create!    (    CheckingAccount    ,         %{    bank_account_id    :         bank_account1    .    id    }    )        savings_account         =         Ash    .    create!    (    SavingsAccount    ,         %{    bank_account_id    :         bank_account2    .    id    }    )    
        [    bank_account1    ,         bank_account2    ]         |>         Ash    .    load!    (    [    :checking_account    ,         :savings_account    ]    )

    [    
          #    BankAccount    <    
            implementation    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :implementation    >    ,    
            savings_account    :         nil    ,    
            checking_account    :         #    CheckingAccount    <    
              bank_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :bank_account    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "60f585f6-f352-410e-8c09-09ae49448851"    ,    
              bank_account_id    :         "21d27a6c-49b8-4984-a1b7-f2ef030626af"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "21d27a6c-49b8-4984-a1b7-f2ef030626af"    ,    
            account_number    :         1    ,    
            type    :         :checking    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    BankAccount    <    
            implementation    :         #    Ash.NotLoaded    <    :calculation    ,         field    :         :implementation    >    ,    
            savings_account    :         #    SavingsAccount    <    
              bank_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :bank_account    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "d2bcc1cc-d709-418d-a9ff-0d21fd7d667b"    ,    
              bank_account_id    :         "4d8dc988-3e09-4efb-a643-d822013abfba"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            checking_account    :         nil    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "4d8dc988-3e09-4efb-a643-d822013abfba"    ,    
            account_number    :         2    ,    
            type    :         :savings    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

## Defining our union type

Below we define an `Ash.Type.NewType`. This allows defining a new type that is the combination of an existing type and custom constraints.

    defmodule         AccountImplementation         do    
          use         Ash.Type.NewType    ,         subtype_of    :         :union    ,         constraints    :         [    
            types    :         [    
              checking    :         [    
                type    :         :struct    ,    
                constraints    :         [    instance_of    :         CheckingAccount    ]    
              ]    ,    
              savings    :         [    
                type    :         :struct    ,    
                constraints    :         [    instance_of    :         SavingsAccount    ]    
              ]    
            ]    
          ]        end

    {    :module    ,         AccountImplementation    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         44    ,         ...    >>    ,         :ok    }

## Defining the calculation

Next, we'll define a calculation resolves to the specific type of any given account.

    defmodule         GetAccountImplementation         do    
          use         Ash.Resource.Calculation    

          def         load    (    _    ,         _    ,         _    )         do    
            [    :checking_account    ,         :savings_account    ]    
          end    

          # This ensures that all attributes are selected by default    
          # on the related loads we depend on.    
          def         strict_loads?    ,         do    :         false    

          def         calculate    (    records    ,         _    ,         _    )         do    
            Enum    .    map    (    records    ,         fn         record         ->    
              cond         do    
                record    .    checking_account         ->    
                  %    Ash.Union    {    type    :         :checking_account    ,         value    :         record    .    checking_account    }    

                record    .    savings_account         ->    
                  %    Ash.Union    {    type    :         :savings_account    ,         value    :         record    .    savings_account    }    

                true         ->    
                  nil    
              end    
            end    )    
          end        end

    {    :module    ,         GetAccountImplementation    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         13    ,         ...    >>    ,         {    :calculate    ,         3    }    }

## Adding the calculation to our resource

Finally, we'll add the calculation to our `BankAccount` resource\!

For those following along with the LiveBook, go back up and uncomment the commented out calculation.

Now we can load `:implementation` and see that, for one account, it resolves to a `CheckingAccount` and for the other it resolves to a `SavingsAccount`.

    bank_account1         =         Ash    .    create!    (    BankAccount    ,         %{    account_number    :         1    ,         type    :         :checking    }    )        bank_account2         =         Ash    .    create!    (    BankAccount    ,         %{    account_number    :         2    ,         type    :         :savings    }    )        checking_account         =         Ash    .    create!    (    CheckingAccount    ,         %{    bank_account_id    :         bank_account1    .    id    }    )        savings_account         =         Ash    .    create!    (    SavingsAccount    ,         %{    bank_account_id    :         bank_account2    .    id    }    )    
        [    bank_account1    ,         bank_account2    ]         |>         Ash    .    load!    (    [    :implementation    ]    )

    [    
          #    BankAccount    <    
            implementation    :         #    CheckingAccount    <    
              bank_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :bank_account    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "1d1a7b6c-dd08-4b8c-9769-2c1155a41a40"    ,    
              bank_account_id    :         "ce370381-303e-49dc-9950-a05b5052e7f8"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            savings_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :savings_account    >    ,    
            checking_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :checking_account    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "ce370381-303e-49dc-9950-a05b5052e7f8"    ,    
            account_number    :         1    ,    
            type    :         :checking    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    BankAccount    <    
            implementation    :         #    SavingsAccount    <    
              bank_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :bank_account    >    ,    
              __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
              id    :         "e537116d-c5b8-414a-a350-fa9b2afe0a4e"    ,    
              bank_account_id    :         "c4739158-2a1f-4de8-bccb-ee1d1ee9e602"    ,    
              aggregates    :         %{    }    ,    
              calculations    :         %{    }    ,    
              ...    
            >    ,    
            savings_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :savings_account    >    ,    
            checking_account    :         #    Ash.NotLoaded    <    :relationship    ,         field    :         :checking_account    >    ,    
            __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
            id    :         "c4739158-2a1f-4de8-bccb-ee1d1ee9e602"    ,    
            account_number    :         2    ,    
            type    :         :savings    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

## Taking it further

One of the best things about using `Ash.Type.Union` is how it is *integrated*. Every extension \(provided by the Ash team\) supports working with unions. For example:

+ Working with Unions in AshPhoenix.Form
+ AshGraphql & AshJsonApi Unions

You can also synthesize filterable fields with calculations. For example, if you wanted to allow filtering `BankAccount` by `:interest_rate`, and that field only existed on `SavingsAccount`, you might have a calculation like this on `BankAccount`:

    calculate         :interest_rate    ,         :decimal    ,         expr    (    
          if         type         ==         :savings         do    
            savings_account    .    interest_rate    
          else    
            0    
          end        )

This would allow usage like the following:

    BankAccount        |>         Ash.Query    .    filter    (    interest_rate         >         0.01    )        |>         Ash    .    read!    (    )



# Test Resources

    Application    .    put_env    (    :stream_data    ,         :max_runs    ,         10    )        Mix    .    install    (    [    {    :ash    ,         "~> 3.0"    }    ,         {    :simple_sat    ,         "~> 0.1"    }    ]    ,    
          consolidate_protocols    :         false        )    
        Logger    .    configure    (    level    :         :warning    )        ExUnit    .    start    (    )

## Introduction

We recommend testing your resources *thoroughly*. Often, folks think that testing an `Ash.Resource` is "testing the framework", and in some very simple cases this may be true, like a simple create that just accepts a few attributes.

However, testing has two primary roles:

1. Confirming our understanding of the way that our application behaves *now*
2. Ensuring that our application does not change in unintended ways *later*

To this end, we highly recommend writing tests even for your simple actions. A single test that confirms that, with simple inputs, the action returns what you expect, can be very powerful.

Additionally, Ash offers unique ways of testing individual components of our resources, similar to a unit test.

While you don't necessarily need to follow all steps below, we show the various ways you may want to go about testing your resources.

## Testing Resources

+ Add tests for action inputs using property testing
+ Add tests for calling action invocation using property testing
+ Add explicit tests for action inputs/invocation.
+ Add tests for our calculations
+ Test policies "in isolation" using `Ash.can?` \(or `Domain.can_*`, provided by code interfaces\)

## Examples

    defmodule         User         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         create    :         [    :admin?    ]    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :admin?    ,         :boolean         do    
              allow_nil?         false    
              default         false    
            end    
          end        end    
        defmodule         Tweet         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    ,    
            authorizers    :         [    Ash.Policy.Authorizer    ]    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :text    ,         :string         do    
              allow_nil?         false    
              constraints         max_length    :         144    
              public?         true    
            end    

            attribute         :hidden?    ,         :boolean         do    
              allow_nil?         false    
              default         false    
              public?         true    
            end    
          end    

          calculations         do    
            calculate         :tweet_length    ,         :integer    ,         expr    (    string_length    (    text    )    )    
          end    

          relationships         do    
            belongs_to         :user    ,         User    ,         allow_nil?    :         false    
          end    

          actions         do    
            defaults         [    :read    ,         update    :         [    :text    ]    ]    

            create         :create         do    
              primary?         true    
              accept         [    :text    ]    
              change         relate_actor    (    :user    )    
            end    
          end    

          policies         do    
            policy         action_type    (    :read    )         do    
              description         "If a tweet is hidden, only the author can read it. Otherwise, anyone can."    
              authorize_if         relates_to_actor_via    (    :user    )    
              forbid_if         expr    (    hidden?         ==         true    )    
              authorize_if         always    (    )    
            end    

            policy         action_type    (    :create    )         do    
              description         "Anyone can create a tweet"    
              authorize_if         always    (    )    
            end    

            policy         action_type    (    :update    )         do    
              description         "Only an admin or the user who tweeted can edit their tweet"    
              authorize_if         actor_attribute_equals    (    :admin?    ,         true    )    
              authorize_if         relates_to_actor_via    (    :user    )    
            end    
          end        end    
        defmodule         Domain         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         Tweet         do    
              define         :create_tweet    ,         action    :         :create    ,         args    :         [    :text    ]    
              define         :update_tweet    ,         action    :         :update    ,         args    :         [    :text    ]    
              define         :list_tweets    ,         action    :         :read    
            end    

            resource         User         do    
              define         :create_user    ,         action    :         :create    
            end    
          end        end

    {    :module    ,         Domain    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         1    ,         110    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           %{    opts    :         [    ]    ,         entities    :         [    %    Ash.Domain.Dsl.ResourceReference    {    ...    }    ,         ...    ]    }    
         ]    }

## Create a generator

See `Ash.Generator` documentation for more examples and docs.

    defmodule         Generator         do    
          use         Ash.Generator    

          def         user    (    opts         \\         [    ]    )         do    
            changeset_generator    (    
              User    ,    
              :create    ,    
              overrides    :         opts    ,    
              actor    :         opts    [    :actor    ]    
            )     
          end    

          def         tweet    (    opts         \\         [    ]    )         do    
            changeset_generator    (    
              Tweet    ,    
              :create    ,    
              overrides    :         opts    ,    
              actor    :         opts    [    :actor    ]    
            )     
          end        end

    {    :module    ,         Generator    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         10    ,         ...    >>    ,         {    :tweet    ,         1    }    }

## Write some tests

    defmodule         ActionInvocationTest         do    
          use         ExUnit.Case    
          import         ExUnitProperties    
          import         Generator    

          describe         "valid inputs"         do    
            # now if our action inputs are invalid when we think they should be valid, we will find out here    
            property         "accepts all valid input"         do    
              user         =         generate    (    user    (    )    )    

              check         all    (    input         <-         Ash.Generator    .    action_input    (    Tweet    ,         :create    )    )         do    
                {    text    ,         other_inputs    }         =         Map    .    pop!    (    input    ,         :text    )    

                assert         Domain    .    changeset_to_create_tweet    (    
                         text    ,    
                         other_inputs    ,    
                         authorize?    :         false    ,    
                         actor    :         user    
                       )    .    valid?    
              end    
            end    

            # same as the above, but actually call the action. This tests the underlying action implementation    
            # not just initial validation    
            property         "succeeds on all valid input"         do    
              user         =         generate    (    user    (    )    )    

              check         all    (    input         <-         Ash.Generator    .    action_input    (    Tweet    ,         :create    )    )         do    
                {    text    ,         other_inputs    }         =         Map    .    pop!    (    input    ,         :text    )    
                Domain    .    create_tweet!    (    text    ,         other_inputs    ,         authorize?    :         false    ,         actor    :         user    )    
              end    
            end    

            test         "can tweet some specific text, in addition to any other valid inputs"         do    
              user         =         generate    (    user    (    )    )    

              check         all    (    
                      input         <-         Ash.Generator    .    action_input    (    Tweet    ,         :create    ,         %{    text    :         "some specific text"    }    )    
                    )         do    
                {    text    ,         other_inputs    }         =         Map    .    pop!    (    input    ,         :text    )    
                Domain    .    create_tweet!    (    text    ,         other_inputs    ,         actor    :         user    )    
              end    
            end    
          end    

          describe         "authorization"         do    
            test         "allows a user to update their own tweet"         do    
              user         =         generate    (    user    (    )    )    
              tweet         =         generate    (    tweet    (    text    :         "Hello world!"    ,         actor    :         user    )    )    

              assert         Domain    .    can_update_tweet?    (    user    ,         tweet    ,         "Goodbye world!"    )    
            end    

            test         "does not allow a user to update someone elses tweet"         do    
              [    user    ,         user2    ]         =         generate_many    (    user    (    )    ,         2    )    
              tweet         =         Domain    .    create_tweet!    (    "Hello world!"    ,         actor    :         user    )    

              refute         Domain    .    can_update_tweet?    (    user2    ,         tweet    ,         "Goodbye world!"    )    
            end    

            test         "allows an admin user to update someone elses tweet"         do    
              user         =         generate    (    user    (    )    )    
              admin         =         generate    (    user    (    admin?    :         true    )    )    
              tweet         =         generate    (    tweet    (    actor    :         user    )    )    

              assert         Domain    .    can_update_tweet?    (    admin    ,         tweet    ,         "Goodbye world!"    )    
            end    
          end    

          describe         "calculations"         do    
            test         "text length calculation computes the length of the text"         do    
              user         =         generate    (    user    (    )    )    
              tweet         =         generate    (    tweet    (    text    :         "Hello world!"    ,         actor    :         user    )    )    
              assert         Ash    .    calculate!    (    tweet    ,         :tweet_length    )         ==         12    
            end    
          end        end    
        ExUnit    .    run    (    )

    Running         ExUnit         with         seed    :         462155    ,         max_cases    :         28    
        ...    ...    .        Finished         in         0.08         seconds         (    0.00    s         async    ,         0.08    s         sync    )        2         properties    ,         5         tests    ,         0         failures

    %{    total    :         7    ,         failures    :         0    ,         excluded    :         0    ,         skipped    :         0    }



# Authorize Access to Resources

    Mix    .    install    (    
          [    
            {    :ash    ,         "~> 3.0"    }    ,    
            {    :simple_sat    ,         "~> 0.1"    }    ,    
            {    :kino    ,         "~> 0.12"    }    
          ]    ,    
          consolidate_protocols    :         false        )    
        Logger    .    configure    (    level    :         :warning    )        Application    .    put_env    (    :ash    ,         :policies    ,         show_policy_breakdowns?    :         true    )

## Introduction

A key feature of Ash is the ability to build security directly into your resources. We do this with policies.

Because how you write policies is *extremely* situational, this how-to guide provides a list of "considerations" as opposed to "instructions".

For more context, read the policies guide.

## Writing Policies

1. Consider whether or not you want to adopt a specific style of authorization, like ACL, or RBAC. For standard RBAC, look into AshRbac, and you may not need to write any of your own policies at that point
2. Determine if there are any `bypass` policies to add \(admin users, super users, etc.\). Consider placing this on the domain, instead of the resource
3. Begin by making an inventory of each action on your resource, and under what conditions a given actor may be allowed to perform them. If all actions of a given type have the same criteria, we will typically use the `action_type(:type)` condition
4. Armed with this inventory, begin to write policies. Start simple, write a policy per action type, and add a description of what your policy accomplishes.
5. Find patterns, like cross-cutting checks that exist in all policies, that can be expressed as smaller, simpler policies
6. Determine if any field policies are required to prohibit access to attributes/calculations/aggregates
7. Finally, you can confirm your understanding of the authorization flow for a given resource by generating policy charts with `mix ash.generate_policy_charts` \(field policies are not currently included in the generated charts\)

## Example

    defmodule         User         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    

          actions         do    
            defaults         [    :read    ,         create    :         [    :admin?    ]    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :admin?    ,         :boolean         do    
              allow_nil?         false    
              default         false    
            end    
          end        end    
        defmodule         Tweet         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    ,    
            authorizers    :         [    Ash.Policy.Authorizer    ]    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :text    ,         :string         do    
              allow_nil?         false    
              constraints         max_length    :         144    
              public?         true    
            end    

            attribute         :hidden?    ,         :boolean         do    
              allow_nil?         false    
              default         false    
              public?         true    
            end    

            attribute         :private_note    ,         :string         do    
              sensitive?         true    
              public?         true    
            end    
          end    

          calculations         do    
            calculate         :tweet_length    ,         :integer    ,         expr    (    string_length    (    text    )    )         do    
              public?         true    
            end    
          end    

          relationships         do    
            belongs_to         :user    ,         User    ,         allow_nil?    :         false    
          end    

          actions         do    
            defaults         [    :read    ,         update    :         [    :text    ,         :hidden?    ,         :private_note    ]    ]    

            create         :create         do    
              primary?         true    
              accept         [    :text    ,         :hidden?    ,         :private_note    ]    
              change         relate_actor    (    :user    )    
            end    
          end    

          policies         do    
            # action_type-based policies    
            policy         action_type    (    :read    )         do    
              # each policy has a description    
              description         "If a tweet is hidden, only the author can read it. Otherwise, anyone can."    
              # first check this. If true, then this policy passes    
              authorize_if         relates_to_actor_via    (    :user    )    
              # then check this. If false, then this policy fails    
              forbid_if         expr    (    hidden?         ==         true    )    
              # otherwise, this policy passes    
              authorize_if         always    (    )    
            end    

            # blanket allow-listing of creates    
            policy         action_type    (    :create    )         do    
              description         "Anyone can create a tweet"    
              authorize_if         always    (    )    
            end    

            policy         action_type    (    :update    )         do    
              description         "Only an admin or the user who tweeted can edit their tweet"    
              # first check this. If true, then this policy passes    
              authorize_if         actor_attribute_equals    (    :admin?    ,         true    )    
              # then check this. If true, then this policy passes    
              authorize_if         relates_to_actor_via    (    :user    )    
              # otherwise, there is nothing left to check and no decision, so *this policy fails*    
            end    
          end    


          field_policies         do    
            # anyone can see these fields    
            field_policy         [    :text    ,         :tweet_length    ]         do    
              description         "Public tweet fields are visible"    
              authorize_if         always    (    )    
            end    

            field_policy         [    :hidden?    ,         :private_note    ]         do    
              description         "hidden? and private_note are only visible to the author"    
              authorize_if         relates_to_actor_via    (    :user    )    
            end    
          end        end    
        defmodule         Domain         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         Tweet         do    
              define         :create_tweet    ,         action    :         :create    ,         args    :         [    :text    ]    
              define         :update_tweet    ,         action    :         :update    ,         args    :         [    :text    ]    
              define         :list_tweets    ,         action    :         :read    
              define         :get_tweet    ,         action    :         :read    ,         get_by    :         [    :id    ]    
            end    

            resource         User         do    
              define         :create_user    ,         action    :         :create    
            end    
          end        end    

    {    :module    ,         Domain    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         2    ,         117    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           Ash.Domain.Dsl    ,    
           %{    opts    :         [    ]    ,         entities    :         [    ...    ]    }    ,    
           Ash.Domain.Dsl    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           ...    
         ]    }

## Interacting with resources that have policies

    # doing forbidden things produces an `Ash.Error.Forbidden`        user         =         Domain    .    create_user!    (    )        other_user         =         Domain    .    create_user!    (    )    
        tweet         =         Domain    .    create_tweet!    (    "hello world!"    ,         actor    :         user    )        Domain    .    update_tweet!    (    tweet    ,         "Goodbye world"    ,         actor    :         other_user    )

    # Reading data applies policies as filters    
        user         =         Domain    .    create_user!    (    )        other_user         =         Domain    .    create_user!    (    )    
        my_hidden_tweet         =         Domain    .    create_tweet!    (    "hello world!"    ,         %{    hidden?    :         true    }    ,         actor    :         user    )    
        other_users_hidden_tweet         =    
          Domain    .    create_tweet!    (    "hello world!"    ,         %{    hidden?    :         true    }    ,         actor    :         other_user    )    
        my_tweet         =         Domain    .    create_tweet!    (    "hello world!"    ,         actor    :         user    )        other_users_tweet         =         Domain    .    create_tweet!    (    "hello world!"    ,         actor    :         other_user    )    
        tweet_ids         =         Domain    .    list_tweets!    (    actor    :         user    )         |>         Enum    .    map    (    &         &1    .    id    )    
        # I see my own hidden tweets, and other users non-hidden tweets        true         =         my_hidden_tweet    .    id         in         tweet_ids        true         =         other_users_tweet    .    id         in         tweet_ids    
        # but not other users hidden tweets        false         =         other_users_hidden_tweet    .    id         in         tweet_ids    
        :ok

    :ok

    # Field policies return hidden fields as `%Ash.ForbiddenField{}`    
        user         =         Domain    .    create_user!    (    )        other_user         =         Domain    .    create_user!    (    )    
        other_users_tweet         =    
          Domain    .    create_tweet!    (    "hello world!"    ,         %{    private_note    :         "you can't see this!"    }    ,         actor    :         other_user    )    
        %    Ash.ForbiddenField    {    }         =         Domain    .    get_tweet!    (    other_users_tweet    .    id    ,         actor    :         user    )    .    private_note

    #    Ash.ForbiddenField    <    field    :         :private_note    ,         type    :         :attribute    ,         ...    >

    Tweet        |>         Ash.Policy.Chart.Mermaid    .    chart    (    )        |>         Kino.Shorts    .    mermaid    (    )

    flowchart TB
    subgraph at least one policy applies
    direction TB
    at_least_one_policy["action.type == :read
    or action.type == :create
    or action.type == :update"]
    end
    at_least_one_policy--False-->Forbidden
    at_least_one_policy--True-->0_conditions
    subgraph Policy 1[If a tweet is hidden, only the author can read it. Otherwise, anyone can.]
    direction TB
    0_conditions{"action.type == :read"}
    0_checks_0{"record.user == actor"}
    0_checks_1{"hidden? == true"}
    end
    0_conditions--True-->0_checks_0
    0_conditions--False-->1_conditions
    0_checks_0--True-->1_conditions
    0_checks_0--False-->0_checks_1
    0_checks_1--True-->Forbidden
    0_checks_1--False-->1_conditions
    subgraph Policy 2[Anyone can create a tweet]
    direction TB
    1_conditions{"action.type == :create"}
    end
    subgraph Policy 3[Only an admin or the user who tweeted can edit their tweet]
    direction TB
    2_conditions{"action.type == :update"}
    2_checks_0{"actor.admin? == true"}
    2_checks_1{"record.user == actor"}
    end
    2_conditions--True-->2_checks_0
    2_conditions--False-->Authorized
    2_checks_0--True-->Authorized
    2_checks_0--False-->2_checks_1
    2_checks_1--True-->Authorized
    2_checks_1--False-->Forbidden
    subgraph results[Results]
    Authorized([Authorized])
    Forbidden([Forbidden])
    end
    1_conditions--Or-->2_conditions



# Encrypt Attributes

    Mix    .    install    (    [    {    :ash    ,         "~> 3.0"    }    ,         {    :ash_cloak    ,         "~> 0.1.0"    }    ,         {    :cloak    ,         "~> 1.1"    }    ]    ,    
          consolidate_protocols    :         false        )    
        Application    .    put_env    (    :my_app    ,         MyApp.Vault    ,    
          ciphers    :         [    
            default    :         {    
              Cloak.Ciphers.AES.GCM    ,    
              tag    :         "AES.GCM.V1"    ,    
              key    :         Base    .    decode64!    (    "ETpvtowVAL7JmcxfqJ+XVQWzKrt1ynAkC0vT7AxfyNU="    )    ,    
              iv_length    :         12    
            }    
          ]        )    
        defmodule         MyApp.Vault         do    
          use         Cloak.Vault    ,         otp_app    :         :my_app        end    
        MyApp.Vault    .    start_link    (    )

## Introduction

When dealing with PII\(Personally Identifiable Information\) or other sensitive data, we often want to encrypt this data, and control access to the decrypted values.

To do this in `Ash`, we do that with `AshCloak`. See the getting started guide in `AshCloak` for installation instructions.

## Encrypting attributes

1. If you have not yet, follow the getting started guide for `AshCloak` and `Cloak`
2. Add the `AshCloak` extension to your resource
3. Configure the attributes that should be encrypted
4. Add any other additional desired configuration \(provided by `AshCloak`\)

## Examples

    defmodule         User         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    ,    
            extensions    :         [    AshCloak    ]    

          cloak         do    
            vault         MyApp.Vault    
            attributes         [    :ssn    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :ssn    ,         :string    ,         allow_nil?    :         false    
          end    

          actions         do    
            defaults         [    :read    ,         create    :         [    :ssn    ]    ,         update    :         [    :ssn    ]    ]    
          end        end    
        defmodule         Domain         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         User         do    
              define    (    :create_user    ,         action    :         :create    ,         args    :         [    :ssn    ]    )    
              define    (    :update_user    ,         action    :         :update    ,         args    :         [    :ssn    ]    )    
              define    (    :list_users    ,         action    :         :read    )    
            end    
          end        end

    {    :module    ,         Domain    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         1    ,         255    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           Ash.Domain.Dsl    ,    
           %{    opts    :         [    ]    ,         entities    :         [    ...    ]    }    ,    
           Ash.Domain.Dsl    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           ...    
         ]    }

## Data is encrypted when modified and is ***not displayed*** when inspecting.

    user         =         Domain    .    create_user!    (    "111-11-1111"    )

    #    User    <    
          __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
          id    :         "bc5284fe-294a-485e-8585-06130a4bca4e"    ,    
          aggregates    :         %{    }    ,    
          calculations    :         %{    }    ,    
          ...        >

    # AshCloak turned ssn into a calculation        user    .    ssn

    #    Ash.NotLoaded    <    :calculation    ,         field    :         :ssn    >

    # Load the value to decrypt it on-demand        Ash    .    load!    (    user    ,         :ssn    )    .    ssn

    "111-11-1111"



# Prevent concurrent writes

    Mix    .    install    (    [    {    :ash    ,         "~> 3.0"    }    ]    ,         consolidate_protocols    :         false    )        # Set to `:debug` if you want to see ETS logs        Logger    .    configure    (    level    :         :warning    )

## Introduction

Often, when working with resources, we want to ensure that a record has not been edited since we last read it. We may want this for UX reasons, or for ensuring data consistency, etc.

To ensure that a record hasn't been updated since the last time we read it, we use Optimistic Locking.

For more information, see the documentation for `Ash.Resource.Change.OptimisticLock`.

## Add Optimistic Locking

1. Add a `:version` attribute to your resource, of type `:integer`, with a default of `1` and `allow_nil?: false`
2. Add `change optimistic_lock(:version)`. Where you add it depends on which actions you want to prevent concurrent writes for:
	+ If you want optimistic locking to occur for *specific actions*:
		1. Add `change optimistic_lock(:version)` to those specific actions

	+ If you want optimistic locking to occur for *all action types*:
		1. Add a global `changes` block to the resource, if you do not have one
		2. Add `change optimistic_lock(:version), on: [:create, :update, :destroy]`

	+ If you want to apply optimistic locking to *many but not all actions*:
		1. Add a global `changes` block to the resource, if you do not have one
		2. Add `change optimistic_lock(:version), where: action_is([:action1, :action2, :action3])`



## Examples

    defmodule         Address         do    
          use         Ash.Resource    ,    
            domain    :         Domain    ,    
            data_layer    :         Ash.DataLayer.Ets    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :version    ,         :integer    ,         allow_nil?    :         false    ,         default    :         1    
            attribute         :state    ,         :string    ,         allow_nil?    :         false    
            attribute         :county    ,         :string    ,         allow_nil?    :         false    
          end    

          actions         do    
            defaults         [    :read    ,         create    :         [    :state    ,         :county    ]    ]    

            update         :update         do    
              accept         [    :state    ,         :county    ]    
              change         optimistic_lock    (    :version    )    
            end    
          end    

          # apply to all actions    
          # changes do    
          #   change optimistic_lock(:version), on: [:create, :update, :destroy]    
          # end    

          # apply to a list of actions    
          # changes do    
          #   change optimistic_lock(:version), where: action_is([:action1, :action2, :action3])    
          # end        end    
        defmodule         Domain         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         Address         do    
              define    (    :get_address    ,         action    :         :read    ,         get_by    :         [    :id    ]    )    
              define    (    :create_address    ,         action    :         :create    ,         args    :         [    :state    ,         :county    ]    )    
              define    (    :update_address    ,         action    :         :update    )    
            end    
          end        end

    {    :module    ,         Domain    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         2    ,         1    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           Ash.Domain.Dsl    ,    
           %{    opts    :         [    ]    ,         entities    :         [    ...    ]    }    ,    
           Ash.Domain.Dsl    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           ...    
         ]    }

## Triggering a StaleRecord error

    address         =         Domain    .    create_address!    (    "FL"    ,         "Pinellas"    )        Domain    .    update_address!    (    address    ,         %{    state    :         "NC"    ,         county    :         "Guilford"    }    )    
        # `address` still has a version of `1`, so our optimistic lock should catch it!        Domain    .    update_address    (    address    ,         %{    county    :         "Miami-Dade"    }    )

    {    :error    ,    
         %    Ash.Error.Invalid    {    
           changeset    :         "#Changeset<>"    ,    
           errors    :         [    
             %    Ash.Error.Changes.StaleRecord    {    
               resource    :         "Address"    ,    
               filter    :         %{    "version"         =>         1    }    ,    
               splode    :         Ash.Error    ,    
               bread_crumbs    :         [    ]    ,    
               vars    :         [    ]    ,    
               path    :         [    ]    ,    
               stacktrace    :         #    Splode.Stacktrace    <    >    ,    
               class    :         :invalid    
             }    
           ]    
         }    }

## Refetching a record to get the latest version

    address         =         Domain    .    create_address!    (    "FL"    ,         "Pinellas"    )        Domain    .    update_address!    (    address    ,         %{    state    :         "NC"    ,         county    :         "Guilford"    }    )    
        case         Domain    .    update_address    (    address    ,         %{    county    :         "Miami-Dade"    }    )         do    
          {    :error    ,         %    Ash.Error.Invalid    {    errors    :         [    %    Ash.Error.Changes.StaleRecord    {    }    ]    }    }         ->    
            # In a liveview, you wouldn't just refetch and resubmit    
            # you would show the user an error and have them submit the form again    
            address         =         Domain    .    get_address!    (    address    .    id    )    
            Domain    .    update_address!    (    address    ,         %{    county    :         "Miami-Dade"    }    )    

          {    :ok    ,         domain    }         ->    
            domain        end

    #    Address    <    
          __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    >    ,    
          id    :         "91e552e1-3307-4d68-969f-1b7e6651e695"    ,    
          version    :         3    ,    
          state    :         "NC"    ,    
          county    :         "Miami-Dade"    ,    
          aggregates    :         %{    }    ,    
          calculations    :         %{    }    ,    
          ...        >



# Wrap External APIs

    Mix    .    install    (    
          [    
            {    :ash    ,         "~> 3.0"    }    ,    
            {    :req    ,         "~> 0.4.0"    }    
          ]    ,    
          consolidate_protocols    :         false        )

## Introduction

Wrapping external APIs in Ash resources can allow you to leverage the rich and consistent interface provided by `Ash.Resource` for interactions with external services.

There are a few approaches to how you might do this, including the still in progress AshJsonApiWrapper. Here we will leverage "manual actions" as this is fully supported by Ash, and is the commonly used approach.

This approach is most appropriate when you are working with an API that exposes some data, like entities, list of entities, etc. For this example, we will be interacting with https://openlibrary.org, which allows for us to search and list books.

This guide covers reading data from the external API, not creating/updating it. This can be implemented using manual actions of a different type, or generic actions.

## Wrapping External APIs

1. Create a resource for interacting with the given API
2. Create a manual read action
3. In this manual action, we will:
	1. call the target API
	2. transform the results
	3. apply query operations to simulate capabilities provided by Ash


In the example below, we are calling to a *paginated* API, and we want to continue fetching results until we have reached the amount of results requested by the `Ash.Query`. We show this to illustrate that you can do all kinds of creative things when working with external APIs in manual actions.

## Example

    defmodule         Doc         do    
          use         Ash.Resource    ,    
            domain    :         Domain    

          attributes         do    
            uuid_primary_key         :id    
            attribute         :author_name    ,         :string    
            attribute         :title    ,         :string    
            attribute         :type    ,         :string    
          end    

          actions         do    
            read         :search         do    
              primary?         true    
              argument         :query    ,         :string    ,         allow_nil?    :         false    
              prepare         fn         query    ,         _         ->    
                # We require that they limit the results to some reasonable set    
                # (because this API is huge)    
                cond         do    
                  query    .    limit         &&         query    .    limit         >         250         ->    
                    Ash.Query    .    add_error    (    query    ,         "must supply a limit that is less than or equal to 250"    )    
                  query    .    limit         ->    
                    query    
                  true         ->    
                    # limit 5 by default    
                    Ash.Query    .    limit    (    query    ,         5    )    
                end    
              end    

              manual         Doc.Actions.Read    
            end    
          end        end    
        defmodule         Domain         do    
          use         Ash.Domain    ,    
            validate_config_inclusion?    :         false    

          resources         do    
            resource         Doc         do    
              define         :search    ,         args    :         [    :query    ]    
            end    
          end        end

    {    :module    ,         Domain    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         250    ,         ...    >>    ,    
         [    
           Ash.Domain.Dsl.Resources.Resource    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           Ash.Domain.Dsl    ,    
           %{    opts    :         [    ]    ,         entities    :         [    ...    ]    }    ,    
           Ash.Domain.Dsl    ,    
           Ash.Domain.Dsl.Resources.Options    ,    
           ...    
         ]    }

    defmodule         Doc.Actions.Read         do    
          use         Ash.Resource.ManualRead    

          def         read    (    query    ,         _    ,         _opts    ,         _context    )         do    
            # we aren't handling these query options to keep the example simple    
            # but you could on your own    
            if         query    .    sort         !=         [    ]         ||         query    .    offset         !=         0         do    
              {    :error    ,         "Cannot sort or offset documents"    }    
            end    

            if         query    .    sort         &&         query    .    sort         !=         [    ]         do    
              raise         "Cannot apply a sort to docs read"    
            end    

            if         query    .    offset         &&         query    .    offset         !=         0         do    
              raise         "Cannot apply a sort to docs read"    
            end    

            limit         =         query    .    limit         ||         :infinity    

            query         =         Ash.Query    .    unset    (    query    ,         :limit    )    

            query_results         =    
              Stream    .    resource    (    
                fn         ->    
                  {    limit    ,         0    }    
                end    ,    
                fn    
                  {    remaining    ,         page_number    }         when         remaining         <=         0         ->    
                    {    :halt    ,         {    0    ,         page_number    }    }    

                  {    remaining    ,         page_number    }         ->    
                    api_results         =    
                      query    .    arguments    .    query    
                      |>         get!    (    page_number    )    
                      |>         Enum    .    map    (    &    to_doc    /    1    )    

                    case         Ash.Query    .    apply_to    (    query    ,         api_results    )         do    
                      {    :ok    ,         [    ]    }         ->    
                        {    :halt    ,         remaining    }    

                      {    :ok    ,         results    }         ->    
                        count_of_results         =         Enum    .    count    (    results    )    

                        cond         do    
                          # the api gives us batches of 100    
                          remaining         ==         :infinity         &&         count_of_results         ==         100         ->    
                            {    results    ,         {    :infinity    ,         page_number         +         1    }    }    

                          remaining         ==         :infinity         ->    
                            {    results    ,         {    0    ,         page_number         +         1    }    }    

                          true         ->    
                            still_remaining         =         remaining         -         count_of_results    

                            results         =    
                              if         still_remaining         <=         0         do    
                                Enum    .    take    (    results    ,         remaining    )    
                              else    
                                results    
                              end    

                            {    results    ,         {    still_remaining    ,         page_number         +         1    }    }    
                        end    

                      {    :error    ,         error    }         ->    
                        raise         Ash.Error    .    to_ash_error    (    error    )    
                    end    
                end    ,    
                fn         _         ->         :ok         end    
              )    
              |>         Enum    .    to_list    (    )    

            {    :ok    ,         query_results    }    
          end    

          defp         to_doc    (    api_doc    )         do    
            %    Doc    {    author_name    :         api_doc    [    "author_name"    ]    ,         type    :         api_doc    [    "type"    ]    ,         title    :         api_doc    [    "title"    ]    }    
          end    

          defp         get!    (    query    ,         page    )         do    
            params         =    
              if         page         ==         0         do    
                [    q    :         query    ]    
              else    
                [    q    :         query    ,         page    :         page    ]    
              end    

            Req    .    get!    (    "https://openlibrary.org/search.json"    ,         params    :         params    )    .    body    [    "docs"    ]    
          end        end

    {    :module    ,         Doc.Actions.Read    ,         <<    70    ,         79    ,         82    ,         49    ,         0    ,         0    ,         25    ,         ...    >>    ,         {    :get!    ,         2    }    }

## Now we can use this like any other Ash resource

    Domain    .    search!    (    "Lord of the rings"    )

    [    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Lord of the Rings"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Fellowship of the Ring"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Two Towers"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Return of the King"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Lord of the Rings"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]

    require         Ash.Query        query         =         Doc         |>         Ash.Query    .    filter    (    contains    (    title    ,         "Two"    )    )        Domain    .    search!    (    "Lord of the rings"    ,         query    :         query    )

    [    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Two Towers"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "Alessio Cavatore"    ,         "Rick Priestley"    ]    ,    
            title    :         "The Lord of the Rings - The Two Towers"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "The Two Towers"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "Alessio Cavatore"    ,         "Rick Priestley"    ]    ,    
            title    :         "The Lord of the Rings - The Two Towers"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >    ,    
          #    Doc    <    
            __meta__    :         #    Ecto.Schema.Metadata    <    :built    ,         ""    >    ,    
            id    :         nil    ,    
            author_name    :         [    "J.R.R. Tolkien"    ]    ,    
            title    :         "Two Towers : The Lord of the Rings"    ,    
            type    :         "work"    ,    
            aggregates    :         %{    }    ,    
            calculations    :         %{    }    ,    
            ...    
          >        ]



# Upgrade

This document has been moved.



# Ash 

The primary interface to call actions and interact with resources.





# Summary


## **Types** 


actor\(\) 


The actor performing the action - can be any term.




aggregate\(\) 


Aggregate specification for queries.




data\_layer\_query\(\) 


A data layer query structure with execution and counting functions.




load\_statement\(\) 


Load statement for relationships and calculations.




page\_request\(\) 


Page request options for paginated queries.




record\_or\_records\(\) 


A single record or a list of records.





## **Functions** 


aggregate\(query, aggregate\_or\_aggregates, opts \\\\ \[\]\) 


Runs an aggregate or aggregates over a resource query




aggregate\!\(query, aggregate\_or\_aggregates, opts \\\\ \[\]\) 


Runs an aggregate or aggregates over a resource query, returning the result or raising an error.




avg\(query, field, opts \\\\ \[\]\) 


Fetches the average of all values of a given field.




avg\!\(query, field, opts \\\\ \[\]\) 


Fetches the average of all values of a given field or raises an error.




bulk\_create\(inputs, resource, action, opts \\\\ \[\]\) 


Creates many records.




bulk\_create\!\(inputs, resource, action, opts \\\\ \[\]\) 


Creates many records, raising any errors that are returned. See `bulk_create/4` for more.




bulk\_destroy\(query\_or\_stream, action, input, opts \\\\ \[\]\) 


Destroys all items in the provided enumerable or query with the provided input.




bulk\_destroy\!\(stream\_or\_query, action, input, opts \\\\ \[\]\) 


Destroys all items in the provided enumerable or query with the provided input.




bulk\_update\(query\_or\_stream, action, input, opts \\\\ \[\]\) 


Updates all items in the provided enumerable or query with the provided input.




bulk\_update\!\(stream\_or\_query, action, input, opts \\\\ \[\]\) 


Updates all items in the provided enumerable or query with the provided input.




calculate\(resource\_or\_record, calculation, opts \\\\ \[\]\) 


Evaluates the calculation on the resource.




calculate\!\(resource\_or\_record, calculation, opts \\\\ \[\]\) 


Evaluates the calculation on the resource or raises an error. See `calculate/3` for more.




can\(action\_or\_query\_or\_changeset, actor\_or\_scope, opts \\\\ \[\]\) 


Returns whether or not the user can perform the action, or `:maybe`, returning any errors.




can?\(action\_or\_query\_or\_changeset, actor\_or\_scope, opts \\\\ \[\]\) 


Returns whether or not the user can perform the action, or raises on errors.




context\_to\_opts\(map, add\_to \\\\ \[\]\) deprecated 


See `Ash.Context.to_opts/2`.




count\(query, opts \\\\ \[\]\) 


Fetches the count of results that would be returned from a given query.




count\!\(query, opts \\\\ \[\]\) 


Fetches the count of results that would be returned from a given query, or raises an error.




create\(changeset\_or\_resource, params\_or\_opts \\\\ %\{\}, opts \\\\ \[\]\) 


Create a record.




create\!\(changeset\_or\_resource, params \\\\ %\{\}, opts \\\\ \[\]\) 


Create a record. See `create/2` for more information.




data\_layer\_query\(query, opts \\\\ \[\]\) 


Gets the full query and any runtime calculations that would be loaded




data\_layer\_query\!\(query, opts \\\\ \[\]\) 


Gets the full query and any runtime calculations that would be loaded, raising any errors.




destroy\(changeset\_or\_record, opts \\\\ \[\]\) 


Destroy a record.




destroy\!\(changeset\_or\_record, opts \\\\ \[\]\) 


Destroy a record. See `destroy/2` for more information.




exists\(query, opts \\\\ \[\]\) 


Returns whether or not the query would return any results.




exists?\(query, opts \\\\ \[\]\) 


Returns whether or not the query would return any results, or raises an error.




first\(query, field, opts \\\\ \[\]\) 


Fetches the first value for a given field.




first\!\(query, field, opts \\\\ \[\]\) 


Fetches the first value for a given field, or raises an error.




get\(resource, id, opts \\\\ \[\]\) 


Get a record by an identifier.




get\!\(resource, id, opts \\\\ \[\]\) 


Get a record by an identifier, or raises an error. See `get/3` for more.




list\(query, field, opts \\\\ \[\]\) 


Fetches a list of all values of a given field.




list\!\(query, field, opts \\\\ \[\]\) 


Fetches a list of all values of a given field or raises an error.




load\(data, query, opts \\\\ \[\]\) 


Load fields or relationships on already fetched records.




load\!\(data, query, opts \\\\ \[\]\) 


Load fields or relationships on already fetched records. See `load/3` for more information.




max\(query, field, opts \\\\ \[\]\) 


Fetches the greatest of all values of a given field.




max\!\(query, field, opts \\\\ \[\]\) 


Fetches the greatest of all values of a given field or raises an error.




min\(query, field, opts \\\\ \[\]\) 


Fetches the least of all values of a given field.




min\!\(query, field, opts \\\\ \[\]\) 


Fetches the least of all values of a given field or raises an error.




page\(page, n\) 


Fetch a page relative to the provided page.




page\!\(page, request\) 


Fetch a page relative to the provided page or raises an error




read\(query, opts \\\\ \[\]\) 


Runs an `Ash.Query`.




read\!\(query, opts \\\\ \[\]\) 


Run an `Ash.Query`. See `read/2` for more.




read\_first\(query, opts \\\\ \[\]\) 


Runs a query on a resource, returning a first result, nil, or an error.




read\_first\!\(query, opts \\\\ \[\]\) 


Runs an Ash query, returning the first result or nil, or raising an error. See `read_first/2` for more.




read\_one\(query, opts \\\\ \[\]\) 


Runs a query on a resource, returning a single result, nil, or an error.




read\_one\!\(query, opts \\\\ \[\]\) 


Runs an ash query, returning a single result or raise an error. See `read_one/2` for more.




reload\(record, opts \\\\ \[\]\) 


Refetches a record by primary key. See `get/2` for more.




reload\!\(record, opts \\\\ \[\]\) 


Refetches a record by primary key or raises an error. See `reload/2` for more.




run\_action\(input, opts \\\\ \[\]\) 


Runs a generic action.




run\_action\!\(input, opts \\\\ \[\]\) 


Runs a generic action or raises an error. See `run_action/2` for more




stream\!\(query, opts \\\\ \[\]\) 


Streams the results of a query.




sum\(query, field, opts \\\\ \[\]\) 


Fetches the sum of a given field.




sum\!\(query, field, opts \\\\ \[\]\) 


Fetches the sum of a given field or raises an error.




transaction\(resource\_or\_resources, func, opts \\\\ \[\]\) 


Wraps the execution of the function in a transaction with the resource's data\_layer. Collects notifications during the function's execution and sends them if the transaction was successful.




update\(changeset\_or\_record, params\_or\_opts \\\\ %\{\}, opts \\\\ \[\]\) 


Update a record.




update\!\(changeset\_or\_record, params\_or\_opts \\\\ %\{\}, opts \\\\ \[\]\) 


Update a record. See `update/2` for more information.




# Types




# actor\(\)




    @type     actor() ::     any    ()


The actor performing the action - can be any term.





# aggregate\(\)




    @type     aggregate() ::
          Ash.Query.Aggregate.t    ()
      | {name ::     atom    (), kind ::     atom    ()}
      | {name ::     atom    (), kind ::     atom    (), opts ::     Keyword.t    ()}


Aggregate specification for queries.

Can be an `Ash.Query.Aggregate` struct, a `{name, kind}` tuple, or a `{name, kind, opts}` tuple with options.





# data\_layer\_query\(\)




    @type     data_layer_query() :: %{
      query:     Ash.DataLayer.data_layer_query    (),
      ash_query:     Ash.Query.t    (),
      count: (-> {:ok,     integer    () | nil} | {:error,     Ash.Error.t    ()}),
      run: (    Ash.DataLayer.data_layer_query    () ->
              {:ok, [    Ash.Resource.record    ()] |     Ash.Page.page    () |     no_return    ()}
              | {:error,     Ash.Error.t    ()}),
      load: ([    Ash.Resource.record    ()] |     Ash.Page.page    () ->
               {:ok, [    Ash.Resource.record    ()] |     Ash.Page.page    ()}
               | {:error,     Ash.Error.t    ()})
    }


A data layer query structure with execution and counting functions.

Contains the query that would be executed along with functions for counting, running the query, and loading any runtime data needed for the operation.





# load\_statement\(\)




    @type     load_statement() ::
          Ash.Query.t    ()
      | [    atom    ()]
      |     atom    ()
      |     Keyword.t    ()
      | [    atom    () | {    atom    (),     atom    () |     Keyword.t    ()}]


Load statement for relationships and calculations.

Can be a query, a list of atoms, a single atom, keywords, or a list of atoms and tuples with options.





# page\_request\(\)




    @type     page_request() :: :next | :prev | :first | :last | :self |     integer    ()


Page request options for paginated queries.

Can be atoms for navigation \(`:next`, `:prev`, `:first`, `:last`, `:self`\) or an integer for specific page numbers.





# record\_or\_records\(\)




    @type     record_or_records() ::     Ash.Resource.record    () | [    Ash.Resource.record    ()]


A single record or a list of records.





# Functions




# aggregate\(query, aggregate\_or\_aggregates, opts \\\\ \[\]\)




    @spec     aggregate(
          Ash.Query.t    () |     Ash.Resource.t    (),
      aggregates ::     aggregate    () | [    aggregate    ()],
      opts ::     Keyword.t    ()
    ) :: {:ok,     term    ()} | {:error,     Ash.Error.t    ()}


Runs an aggregate or aggregates over a resource query

If you pass an `%Ash.Query.Aggregate{}`, gotten from `Ash.Query.Aggregate.new()`, the query provided as the first argument to this function will not apply. For this reason, it is preferred that you pass in the tuple format, i.e

Prefer this: `Api.aggregate(query, {:count_of_things, :count})`

Over this: `Api.aggregate(query, Ash.Query.Aggregate.new(...))`

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    aggregate    (    {    :count    ,         :count    }    )        {    :ok    ,         %{    count    :         42    }    }    
        iex>     query         |>         Ash    .    aggregate    (    [    {    :avg_likes    ,         :avg    ,         field    :         :likes    }    ,         {    :count    ,         :count    }    ]    )        {    :ok    ,         %{    avg_likes    :         10.5    ,         count    :         42    }    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    aggregate    (    {    :sum_views    ,         :sum    ,         field    :         :view_count    }    )        {    :ok    ,         %{    sum_views    :         1542    }    }

## ******See also**

+ `aggregate!/3` for the raising version
+ `count/2` for counting records specifically
+ `sum/3` for summing field values
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates

## ******Options**

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.





# aggregate\!\(query, aggregate\_or\_aggregates, opts \\\\ \[\]\)




    @spec     aggregate!(
          Ash.Query.t    () |     Ash.Resource.t    (),
          aggregate    () | [    aggregate    ()],
      opts ::     Keyword.t    ()
    ) ::     term    () |     no_return    ()


Runs an aggregate or aggregates over a resource query, returning the result or raising an error.

This is the bang version of `aggregate/3` that raises an error if the operation fails.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    aggregate!    (    {    :count    ,         :count    }    )        42    
        iex>     query         |>         Ash    .    aggregate!    (    [    {    :avg_likes    ,         :avg    ,         field    :         :likes    }    ,         {    :count    ,         :count    }    ]    )        %{    avg_likes    :         10.5    ,         count    :         42    }

## ******See also**

+ `aggregate/3` for the non-raising version
+ `count!/2` for counting records specifically
+ `sum!/3` for summing field values
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates





# avg\(query, field, opts \\\\ \[\]\)




    @spec     avg(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      {:ok,     number    ()} | {:error,     Ash.Error.t    ()}


Fetches the average of all values of a given field.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    avg    (    :view_count    )        {    :ok    ,         42.5    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    avg    (    :likes    )        {    :ok    ,         15.8    }

## ******See also**

+ `avg!/3` for the raising version
+ `sum/3` for getting the total sum
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# avg\!\(query, field, opts \\\\ \[\]\)




    @spec     avg!(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
          number    () |     no_return    ()


Fetches the average of all values of a given field or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    avg!    (    :view_count    )        42.5    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    avg!    (    :likes    )        15.8

## ******See also**

+ `avg/3` for the non-raising version
+ `sum!/3` for getting the total sum
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# bulk\_create\(inputs, resource, action, opts \\\\ \[\]\)




    @spec     bulk_create(
          Enumerable.t    (    map    ()),
      resource ::     Ash.Resource.t    (),
      action ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::
          Ash.BulkResult.t    ()
      | Enumerable.t(
          {:ok,     Ash.Resource.record    ()}
          | {:error,     Ash.Changeset.t    () |     Ash.Error.t    ()}
          | {:notification,     Ash.Notifier.Notification.t    ()}
        )


Creates many records.

## ******Assumptions**

We assume that the input is a list of changesets all for the same action, or a list of input maps for the same action with the `:resource` and `:action` option provided to illustrate which action it is for.

## ******Performance/Feasibility**

The performance of this operation depends on the data layer in question. Data layers like AshPostgres will choose reasonable batch sizes in an attempt to handle large bulk actions, but that does not mean that you can pass a list of 500k inputs and expect things to go off without a hitch \(although it might\). If you need to do large data processing, you should look into projects like GenStage and Broadway. With that said, if you want to do things like support CSV upload and you place some reasonable limits on the size this is a great tool. You'll need to test it yourself, YMMV.

Passing `return_records?: true` can significantly increase the time it takes to perform the operation, and can also make the operation completely unreasonable due to the memory requirement. If you want to do very large bulk creates and display all of the results, the suggestion is to annotate them with a "bulk\_create\_id" in the data layer, and then read the records with that `bulk_create_id` so that they can be retrieved later if necessary.

## ******Changes/Validations**

Changes will be applied in the order they are given on the actions as normal. Any change that exposes the `bulk_change` callbacks will be applied on the entire list.

## ******After Action Hooks**

The following requirements must be met for `after_action` hooks to function properly. If they are not met, and an after\_action hook being applied to a changeset in a `change`.

1. `return_records?` must be set to `true`.
2. The changeset must be setting the primary key as part of its changes, so that we know which result applies to which changeset.

It is possible to use `after_action` hooks with `bulk_change/3`, but you need to return the hooks along with the changesets. This allows for setting up `after_action` hooks that don't need access to the returned record, or `after_action` hooks that can operate on the entire list at once. See the documentation for that callback for more on how to do accomplish that.

## ******See also**

+ `bulk_create!/4` for the raising version
+ `create/3` for creating single records
+ Create Actions Guide for understanding create operations
+ Actions Guide for general action concepts

## ******Options**

+ 
`:upsert?` \(`boolean/0`\) - If a conflict is found based on the primary key, the record is updated in the database \(requires upsert support\) The default value is `false`.

+ 
`:upsert_identity` \(`atom/0`\) - The identity to use when detecting conflicts for `upsert?`, e.g. `upsert_identity: :full_name`. By default, the primary key is used. Has no effect if `upsert?: true` is not provided

+ 
`:upsert_fields` - The fields to upsert. If not set, the action's `upsert_fields` is used. Unlike singular `create`, `bulk_create` with `upsert?` requires that `upsert_fields` be specified explicitly in one of these two locations.

+ 
`:after_action` \(function of arity 2\) - An after\_action hook to be added to each processed changeset

+ 
`:upsert_condition` \(`term/0`\) - An expression to check if the record should be updated when there's a conflict.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:read_action` \(`atom/0`\) - The action to use when building the read query.

+ 
`:assume_casted?` \(`boolean/0`\) - Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting The default value is `false`.

+ 
`:load` \(`term/0`\) - A load statement to apply to records. Ignored if `return_records?` is not true.

+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

+ 
`:authorize_query_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Uses `authorize_with` if not set. Valid values are :filter, :error

+ 
`:authorize_changeset_with` - If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error. Uses `authorize_with` if not set. Valid values are :filter, :error

+ 
`:authorize_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Valid values are :filter, :error The default value is `:filter`.

+ 
`:context` \(`map/0`\) - Context to set on each changeset

+ 
`:private_arguments` \(`map/0`\) - Private argument values to set on each changeset before validations and changes are run. The default value is `%{}`.

+ 
`:sorted?` \(`boolean/0`\) - Whether or not to sort results by their input position, in cases where `return_records?: true` was provided. The default value is `false`.

+ 
`:return_records?` \(`boolean/0`\) - Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts. The default value is `false`.

+ 
`:return_errors?` \(`boolean/0`\) - Whether to return all errors that occur during the operation. Defaults to the value of `:bulk_actions_default_to_errors?` in your config, or `false` if not set. Returning all errors may be expensive for large inserts. The default value is `true`.

+ 
`:batch_size` \(`pos_integer/0`\) - The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.

+ 
`:return_stream?` \(`boolean/0`\) - If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.  
Potential elements:  
`{:notification, notification}` - if `return_notifications?` is set to `true` `{:ok, record}` - if `return_records?` is set to `true` `{:error, error}` - an error that occurred. May be changeset or an individual error. The default value is `false`.

+ 
`:return_nothing?` \(`boolean/0`\) - Mutes warnings about returning nothing.  
Only relevant if `return_stream?` is set to `true` and all other `return_*?` options are set to `false`. The default value is `false`.

+ 
`:stop_on_error?` \(`boolean/0`\) - If true, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped. The default value is `true`.

+ 
`:notify?` \(`boolean/0`\) - Whether or not to generate any notifications. If this is set to `true` then the data layer must return the results from each batch. This may be intensive for large bulk actions.  
Notifications will be automatically sent unless `return_notifications?` is set to `true`. The default value is `false`.

+ 
`:transaction` - Whether or not to wrap the entire execution in a transaction, each batch, or not at all.  
Keep in mind:  
`before_transaction` and `after_transaction` hooks attached to changesets will have to be run *inside* the transaction if you choose `transaction: :all`. Valid values are :all, :batch, false The default value is `:batch`.

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously The default value is `0`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.





# bulk\_create\!\(inputs, resource, action, opts \\\\ \[\]\)




    @spec     bulk_create!(    Enumerable.t    (    map    ()),     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
          Ash.BulkResult.t    () |     no_return    ()


Creates many records, raising any errors that are returned. See `bulk_create/4` for more.





# bulk\_destroy\(query\_or\_stream, action, input, opts \\\\ \[\]\)




    @spec     bulk_destroy(
          Enumerable.t    (    Ash.Resource.record    ()) |     Ash.Query.t    (),
          atom    (),
      input ::     map    (),
          Keyword.t    ()
    ) ::     Ash.BulkResult.t    ()


Destroys all items in the provided enumerable or query with the provided input.

The input is a map of valid inputs for the action. The input will be applied to all records in the enumerable/query.

If the data layer supports destroying from a query, and the destroy action can be done fully atomically, it will be updated in a single pass using the data layer.

Otherwise, this will stream each record and update it.

## ******Options**

+ 
`:resource` \(`Ash.Resource`\) - The resource being destroyed. This must be provided if the input given is a stream, so we know ahead of time what the resource being updated is.

+ 
`:stream_batch_size` \(`integer/0`\) - Batch size to use if provided a query and the query must be streamed

+ 
`:authorize_query?` \(`boolean/0`\) - If a query is given, determines whether or not authorization is run on that query. The default value is `true`.

+ 
`:strategy` - The strategy or strategies to enable. :stream is used in all cases if the data layer does not support atomics. Valid values are :atomic, :atomic\_batches, :stream The default value is `:atomic`.

+ 
`:filter` \(`term/0`\) - A filter to apply to records. This is also applied to a stream of inputs.

+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. Valid values are :keyset, :offset, :full\_read The default value is `:keyset`.

+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more. Valid values are :keyset, :offset, :full\_read

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:read_action` \(`atom/0`\) - The action to use when building the read query.

+ 
`:assume_casted?` \(`boolean/0`\) - Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting The default value is `false`.

+ 
`:load` \(`term/0`\) - A load statement to apply to records. Ignored if `return_records?` is not true.

+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

+ 
`:authorize_query_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Uses `authorize_with` if not set. Valid values are :filter, :error

+ 
`:authorize_changeset_with` - If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error. Uses `authorize_with` if not set. Valid values are :filter, :error

+ 
`:authorize_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Valid values are :filter, :error The default value is `:filter`.

+ 
`:context` \(`map/0`\) - Context to set on each changeset

+ 
`:private_arguments` \(`map/0`\) - Private argument values to set on each changeset before validations and changes are run. The default value is `%{}`.

+ 
`:sorted?` \(`boolean/0`\) - Whether or not to sort results by their input position, in cases where `return_records?: true` was provided. The default value is `false`.

+ 
`:return_records?` \(`boolean/0`\) - Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts. The default value is `false`.

+ 
`:return_errors?` \(`boolean/0`\) - Whether to return all errors that occur during the operation. Defaults to the value of `:bulk_actions_default_to_errors?` in your config, or `false` if not set. Returning all errors may be expensive for large inserts. The default value is `true`.

+ 
`:batch_size` \(`pos_integer/0`\) - The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.

+ 
`:return_stream?` \(`boolean/0`\) - If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.  
Potential elements:  
`{:notification, notification}` - if `return_notifications?` is set to `true` `{:ok, record}` - if `return_records?` is set to `true` `{:error, error}` - an error that occurred. May be changeset or an individual error. The default value is `false`.

+ 
`:return_nothing?` \(`boolean/0`\) - Mutes warnings about returning nothing.  
Only relevant if `return_stream?` is set to `true` and all other `return_*?` options are set to `false`. The default value is `false`.

+ 
`:stop_on_error?` \(`boolean/0`\) - If true, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped. The default value is `true`.

+ 
`:notify?` \(`boolean/0`\) - Whether or not to generate any notifications. If this is set to `true` then the data layer must return the results from each batch. This may be intensive for large bulk actions.  
Notifications will be automatically sent unless `return_notifications?` is set to `true`. The default value is `false`.

+ 
`:transaction` - Whether or not to wrap the entire execution in a transaction, each batch, or not at all.  
Keep in mind:  
`before_transaction` and `after_transaction` hooks attached to changesets will have to be run *inside* the transaction if you choose `transaction: :all`. Valid values are :all, :batch, false The default value is `:batch`.

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously The default value is `0`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.





# bulk\_destroy\!\(stream\_or\_query, action, input, opts \\\\ \[\]\)




    @spec     bulk_destroy!(
          Enumerable.t    (    Ash.Resource.record    ()) |     Ash.Query.t    (),
      action ::     atom    (),
      input ::     map    (),
      opts ::     Keyword.t    ()
    ) ::     Ash.BulkResult.t    () |     no_return    ()


Destroys all items in the provided enumerable or query with the provided input.

See `bulk_destroy/4` for more.





# bulk\_update\(query\_or\_stream, action, input, opts \\\\ \[\]\)




    @spec     bulk_update(
          Enumerable.t    (    Ash.Resource.record    ()) |     Ash.Query.t    (),
          atom    (),
      input ::     map    (),
          Keyword.t    ()
    ) ::     Ash.BulkResult.t    ()


Updates all items in the provided enumerable or query with the provided input.

The input is a map of valid inputs for the action. The input will be applied to all records in the enumerable/query.

If the data layer supports updating from a query, and the update action can be done fully atomically, it will be updated in a single pass using the data layer.

Otherwise, this will stream each record and update it.

## ******Options**

+ 
`:resource` \(`Ash.Resource`\) - The resource being updated. This must be provided if the input given is a stream, so we know ahead of time what the resource being updated is.

+ 
`:atomic_update` \(`map/0`\) - A map of atomic updates to apply. See `Ash.Changeset.atomic_update/3` for more.

+ 
`:stream_batch_size` \(`integer/0`\) - Batch size to use if provided a query and the query must be streamed

+ 
`:authorize_query?` \(`boolean/0`\) - If a query is given, determines whether or not authorization is run on that query. The default value is `true`.

+ 
`:filter` \(`term/0`\) - A filter to apply to records. This is also applied to a stream of inputs.

+ 
`:strategy` - The strategy or strategies to enable. :stream is used in all cases if the data layer does not support atomics. Valid values are :atomic, :atomic\_batches, :stream The default value is `[:atomic]`.

+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. Valid values are :keyset, :offset, :full\_read The default value is `:keyset`.

+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more. Valid values are :keyset, :offset, :full\_read

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:read_action` \(`atom/0`\) - The action to use when building the read query.

+ 
`:assume_casted?` \(`boolean/0`\) - Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting The default value is `false`.

+ 
`:load` \(`term/0`\) - A load statement to apply to records. Ignored if `return_records?` is not true.

+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

+ 
`:authorize_query_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Uses `authorize_with` if not set. Valid values are :filter, :error

+ 
`:authorize_changeset_with` - If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error. Uses `authorize_with` if not set. Valid values are :filter, :error

+ 
`:authorize_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Valid values are :filter, :error The default value is `:filter`.

+ 
`:context` \(`map/0`\) - Context to set on each changeset

+ 
`:private_arguments` \(`map/0`\) - Private argument values to set on each changeset before validations and changes are run. The default value is `%{}`.

+ 
`:sorted?` \(`boolean/0`\) - Whether or not to sort results by their input position, in cases where `return_records?: true` was provided. The default value is `false`.

+ 
`:return_records?` \(`boolean/0`\) - Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts. The default value is `false`.

+ 
`:return_errors?` \(`boolean/0`\) - Whether to return all errors that occur during the operation. Defaults to the value of `:bulk_actions_default_to_errors?` in your config, or `false` if not set. Returning all errors may be expensive for large inserts. The default value is `true`.

+ 
`:batch_size` \(`pos_integer/0`\) - The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.

+ 
`:return_stream?` \(`boolean/0`\) - If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.  
Potential elements:  
`{:notification, notification}` - if `return_notifications?` is set to `true` `{:ok, record}` - if `return_records?` is set to `true` `{:error, error}` - an error that occurred. May be changeset or an individual error. The default value is `false`.

+ 
`:return_nothing?` \(`boolean/0`\) - Mutes warnings about returning nothing.  
Only relevant if `return_stream?` is set to `true` and all other `return_*?` options are set to `false`. The default value is `false`.

+ 
`:stop_on_error?` \(`boolean/0`\) - If true, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped. The default value is `true`.

+ 
`:notify?` \(`boolean/0`\) - Whether or not to generate any notifications. If this is set to `true` then the data layer must return the results from each batch. This may be intensive for large bulk actions.  
Notifications will be automatically sent unless `return_notifications?` is set to `true`. The default value is `false`.

+ 
`:transaction` - Whether or not to wrap the entire execution in a transaction, each batch, or not at all.  
Keep in mind:  
`before_transaction` and `after_transaction` hooks attached to changesets will have to be run *inside* the transaction if you choose `transaction: :all`. Valid values are :all, :batch, false The default value is `:batch`.

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously The default value is `0`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.





# bulk\_update\!\(stream\_or\_query, action, input, opts \\\\ \[\]\)




    @spec     bulk_update!(
          Enumerable.t    (    Ash.Resource.record    ()) |     Ash.Query.t    (),
      action ::     atom    (),
      input ::     map    (),
      opts ::     Keyword.t    ()
    ) ::     Ash.BulkResult.t    () |     no_return    ()


Updates all items in the provided enumerable or query with the provided input.

See `bulk_update/4` for more.





# calculate\(resource\_or\_record, calculation, opts \\\\ \[\]\)




    @spec     calculate(
      resource_or_record ::     Ash.Resource.t    () |     Ash.Resource.record    (),
      calculation ::     atom    (),
      opts ::     Keyword.t    ()
    ) :: {:ok,     term    ()} | {:error,     term    ()}


Evaluates the calculation on the resource.

If a record is provided, its field values will be used to evaluate the calculation.

## ******Examples**

    iex>     Ash    .    calculate    (    post    ,         :word_count    )        {    :ok    ,         142    }    
        iex>     Ash    .    calculate    (    MyApp.User    ,         :age    ,         args    :         %{    birth_date    :         ~D[1990-01-01]    }    )        {    :ok    ,         34    }

## ******See also**

+ `calculate!/3` for the raising version
+ `d:Ash.Resource.Dsl.calculations` for defining calculations on resources
+ Calculations Guide for understanding calculations

## ******Options**

+ 
`:args` \(`map/0`\) - Values for arguments referenced by the calculation. The default value is `%{}`.

+ 
`:refs` \(`map/0`\) - Values for references used by the calculation. The default value is `%{}`.

+ 
`:actor` \(`term/0`\) - The actor for handling `^actor/1` templates, supplied to calculation context.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol. Will overwrite any actor, tenant or context provided. See `Ash.Context` for more.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - The tenant, supplied to calculation context.

+ 
`:context` \(`map/0`\) - Context to set on the calculation input.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not the request is being authorized, provided to calculation context. The default value is `true`.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer, provided to the calculation context.

+ 
`:record` \(`term/0`\) - A record to use as the base of the calculation

+ 
`:data_layer?` \(`boolean/0`\) - Set to `true` to require that the value be computed within the data layer. Only works for calculations that define an expression.

+ 
`:reuse_values?` \(`boolean/0`\) - Set to `true` to reuse existing values on any provided record. Only necessary if providing a record as the basis for calculation. The default value is `false`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use for the action





# calculate\!\(resource\_or\_record, calculation, opts \\\\ \[\]\)




    @spec     calculate!(
      resource_or_record ::     Ash.Resource.t    () |     Ash.Resource.record    (),
      calculation ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     term    () |     no_return    ()


Evaluates the calculation on the resource or raises an error. See `calculate/3` for more.

## ******Examples**

    iex>     Ash    .    calculate!    (    post    ,         :word_count    )        142    
        iex>     Ash    .    calculate!    (    MyApp.User    ,         :age    ,         args    :         %{    birth_date    :         ~D[1990-01-01]    }    )        34

## ******See also**

+ `calculate/3` for the non-raising version
+ `d:Ash.Resource.Dsl.calculations` for defining calculations on resources
+ Calculations Guide for understanding calculations





# can\(action\_or\_query\_or\_changeset, actor\_or\_scope, opts \\\\ \[\]\)




    @spec     can(    Ash.Can.subject    (),     actor    () |     Ash.Scope.t    (),     Keyword.t    ()) ::
      {:ok,     boolean    () | :maybe}
      | {:ok, true,     Ash.Changeset.t    () |     Ash.Query.t    ()}
      | {:ok, true,     Ash.Changeset.t    (),     Ash.Query.t    ()}
      | {:ok, false,     Exception.t    ()}
      | {:error,     term    ()}


Returns whether or not the user can perform the action, or `:maybe`, returning any errors.

In cases with "runtime" checks \(checks after the action\), we may not be able to determine an answer, and so the value `:maybe` will be returned from `can/2`. The `can?` function assumes that `:maybe` means `true`. Keep in mind, this is just for doing things like "can they do this" in a UI, so assuming `:maybe` is `true` is fine. The actual action invocation will be properly checked regardless. If you have runtime checks, you may need to use `can` instead of `can?`, or configure what `:maybe` means.

### ******Accepted inputs**

You can pass many different inputs as the subject to `can/3`.

    # Can this user run this query.        Ash.Query    .    t    (    )    
        # Can this user run this changeset.        Ash.Changeset    .    t    (    )    
        # Can this user run this action.        Ash.ActionInput    .    t    (    )    
        # Can this user run this action.        {    Ash.Resource    .    t    (    )    ,         :action    }    
        # Can this user run this action.        {    Ash.Resource    .    t    (    )    ,         %    Action    {    }    }    
        # Can this user run this action with this input.        {    Ash.Resource    .    t    (    )    ,         :atom    ,         %{    ...    input    }    }    
        # Can this user run this action with this input.        {    Ash.Resource    .    t    (    )    ,         %    Action    {    }    ,         %{    ...    input    }    }

### ******Examples**

    # no actor        Ash    .    can?    (    {    MyApp.Accounts.Organization    ,         :create    }    ,         nil    )        # => false    
        # admin user actor        Ash    .    can?    (    {    MyApp.Accounts.Organization    ,         :create    }    ,         %    MyApp.Accounts.User    {    role    :         :admin    }    )        # => true    
        # check for permission to update a specific thing        user         =         MyApp.Accounts    .    get_post_by_id!    (    «    uuid    »    )        Ash    .    can?    (    {    user    ,         :update    }    ,         %{    role    :         :user    }    )        # => false    
        # read actions        # no logged in user. Will say `true` because the action        # is allowed, but will just be filtered        Ash    .    can?    (    {    MyApp.Accounts.Organization    ,         :read    }    ,         nil    )        # => true    
        # check for permission to read a specific thing        Ash    .    can?    (    {    organization    ,         :read    }    ,         nil    )        # => false

### ******Code Interfaces**

When you define code interfaces, they provide `can_*` functions, which can be used like so:

    # no actor        MyApp.Accounts    .    can_create_organization?    (    nil    )        # => false    
        # admin user actor        MyApp.Accounts    .    can_create_organization?    (    %    MyApp.Accounts.User    {    role    :         :admin    }    )        # => true    
        # check for permission to update a specific thing        user         =         MyApp.Accounts    .    get_post_by_id!    (    «    uuid    »    )        MyApp.Accounts    .    can_update_user    (    user    ,         %{    role    :         :user    }    )        # => false    
        # read actions        # no logged in user. Will say `true` because the action        # is allowed, but will just be filtered        MyApp.Accounts    .    can_read_organizations?    (    nil    )        # => true    
        # check for permission to read a specific thing        MyApp.Accounts    .    can_read_organizations?    (    nil    ,         data    :         organization    )        # => false

## ******See also**

+ `can?/3` for the raising version that returns true/false
+ `d:Ash.Policy.Authorizer.policies` for defining authorization policies
+ Actors and Authorization Guide for understanding authorization
+ Policies Guide for defining authorization policies

## ******Options**

+ 
`:maybe_is` \(`term/0`\) - If the actor *may* be able to perform the action, what value should be returned. The default value is `:maybe`.

+ 
`:filter_with` - If set to `:error`, the query will raise an error on a match. If set to `:filter` the query will filter out unauthorized access. Valid values are :filter, :error The default value is `:filter`.

+ 
`:validate?` \(`boolean/0`\) - Whether or not to treat an invalid action as a non-allowed action. The default value is `false`.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether or not loaded data like aggregates, calculations and relationships should be checked in memory if possible, instead of querying. No effect if `pre_flight?` is `false`. The default value is `false`.

+ 
`:pre_flight?` \(`boolean/0`\) - Whether or not this is a pre\_flight check \(which may perform optimized in-memory checks\) or the final proper check. The default value is `true`.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol. Will overwrite any actor, tenant or context provided. See `Ash.Context` for more.

+ 
`:run_queries?` \(`boolean/0`\) - Whether or not to run queries. If set to `true`, `:maybe` will not be returned. The default value is `true`.

+ 
`:data` - The record or records specifically attempting to be acted upon.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - The tenant to use for authorization

+ 
`:alter_source?` \(`boolean/0`\) - If set to `true`, the source being authorized is returned so it can be run. The default value is `false`.

+ 
`:base_query` \(`term/0`\) - A base query on which to apply an generated filters

+ 
`:no_check?` \(`boolean/0`\) - Whether or not authorization must pass at the strict/filter step, or if post-checks are allowed to be run The default value is `false`.

+ 
`:on_must_pass_strict_check` \(`term/0`\) - Override the value returned when `no_check?` is `true` but a check must be run.

+ 
`:atomic_changeset` \(`term/0`\) - A base query on which to apply an generated filters

+ 
`:return_forbidden_error?` \(`boolean/0`\) - Whether or not to return a forbidden error in cases of not being authorized. The default value is `false`.

+ 
`:log?` \(`boolean/0`\) - Whether or not to log the authorization result. The default value is `false`.





# can?\(action\_or\_query\_or\_changeset, actor\_or\_scope, opts \\\\ \[\]\)




    @spec     can?(    Ash.Can.subject    (),     actor    () |     Ash.Scope.t    (),     Keyword.t    ()) ::
          boolean    () |     no_return    ()


Returns whether or not the user can perform the action, or raises on errors.

Calls `can/3` with a `maybe_is: true`. See `can/3` for more info.

## ******Examples**

    iex>     Ash    .    can?    (    {    MyApp.Post    ,         :create    }    ,         actor    )        true    
        iex>     Ash    .    can?    (    {    MyApp.Post    ,         :read    }    ,         nil    )        true    
        iex>     Ash    .    can?    (    {    post    ,         :update    }    ,         actor    )        false

## ******See also**

+ `can/3` for the non-raising version that returns detailed results
+ `d:Ash.Policy.Authorizer.policies` for defining authorization policies
+ Actors and Authorization Guide for understanding authorization
+ Policies Guide for defining authorization policies

### ******Options**

+ 
`:maybe_is` \(`term/0`\) - If the actor *may* be able to perform the action, what value should be returned. The default value is `true`.

+ 
`:filter_with` - If set to `:error`, the query will raise an error on a match. If set to `:filter` the query will filter out unauthorized access. Valid values are :filter, :error The default value is `:filter`.

+ 
`:validate?` \(`boolean/0`\) - Whether or not to treat an invalid action as a non-allowed action. The default value is `false`.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether or not loaded data like aggregates, calculations and relationships should be checked in memory if possible, instead of querying. No effect if `pre_flight?` is `false`. The default value is `false`.

+ 
`:pre_flight?` \(`boolean/0`\) - Whether or not this is a pre\_flight check \(which may perform optimized in-memory checks\) or the final proper check. The default value is `true`.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol. Will overwrite any actor, tenant or context provided. See `Ash.Context` for more.

+ 
`:run_queries?` \(`boolean/0`\) - Whether or not to run queries. If set to `true`, `:maybe` will not be returned. The default value is `true`.

+ 
`:data` - The record or records specifically attempting to be acted upon.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - The tenant to use for authorization

+ 
`:alter_source?` \(`boolean/0`\) - If set to `true`, the source being authorized is returned so it can be run. The default value is `false`.

+ 
`:base_query` \(`term/0`\) - A base query on which to apply an generated filters

+ 
`:no_check?` \(`boolean/0`\) - Whether or not authorization must pass at the strict/filter step, or if post-checks are allowed to be run The default value is `false`.

+ 
`:on_must_pass_strict_check` \(`term/0`\) - Override the value returned when `no_check?` is `true` but a check must be run.

+ 
`:atomic_changeset` \(`term/0`\) - A base query on which to apply an generated filters

+ 
`:return_forbidden_error?` \(`boolean/0`\) - Whether or not to return a forbidden error in cases of not being authorized. The default value is `false`.

+ 
`:log?` \(`boolean/0`\) - Whether or not to log the authorization result. The default value is `false`.





# context\_to\_opts\(map, add\_to \\\\ \[\]\)



This function is deprecated. Converts a context map to opts to be passed into an action. . 

See `Ash.Context.to_opts/2`.





# count\(query, opts \\\\ \[\]\)




    @spec     count(    Ash.Query.t    () |     Ash.Resource.t    (),     Keyword.t    ()) ::
      {:ok,     non_neg_integer    ()} | {:error,     Ash.Error.t    ()}


Fetches the count of results that would be returned from a given query.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    count    (    )        {    :ok    ,         42    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    count    (    )        {    :ok    ,         15    }

## ******See also**

+ `count!/2` for the raising version
+ `aggregate/3` for running multiple aggregates
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates





# count\!\(query, opts \\\\ \[\]\)




    @spec     count!(    Ash.Query.t    () |     Ash.Resource.t    (),     Keyword.t    ()) ::
          non_neg_integer    () |     no_return    ()


Fetches the count of results that would be returned from a given query, or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    count!    (    )        42    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    count!    (    )        15

## ******See also**

+ `count/2` for the non-raising version
+ `aggregate!/3` for running multiple aggregates
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates





# create\(changeset\_or\_resource, params\_or\_opts \\\\ %\{\}, opts \\\\ \[\]\)




    @spec     create(
      changeset_or_resource ::     Ash.Changeset.t    () |     Ash.Resource.t    (),
      params_or_opts ::     map    () |     Keyword.t    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     term    ()}


Create a record.

## ******Examples**

    iex>     Ash    .    create    (    MyApp.Post    ,         %{    title    :         "Hello World"    ,         content    :         "..."    }    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         title    :         "Hello World"    ,         content    :         "..."    }    }    
        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    ,         %{    name    :         "John"    }    )        iex>     Ash    .    create    (    changeset    )        {    :ok    ,         %    MyApp.User    {    id    :         1    ,         name    :         "John"    }    }    
        iex>     Ash    .    create    (    MyApp.Post    ,         %{    title    :         "New Post"    }    ,         return_notifications?    :         true    )        {    :ok    ,         %    MyApp.Post    {    id    :         2    ,         title    :         "New Post"    }    ,         [    %    Ash.Notifier.Notification    {    }    ]    }

## ******See also**

+ `create!/3` for the raising version
+ `d:Ash.Resource.Dsl.actions.create` for defining create actions
+ `d:Ash.Resource.Dsl.attributes` for defining attributes
+ Create Actions Guide for understanding create operations
+ Actions Guide for general action concepts

## ******Options**

+ 
`:upsert?` \(`boolean/0`\) - If a conflict is found based on the primary key, the record is updated in the database \(requires upsert support\) The default value is `false`.

+ 
`:return_skipped_upsert?` \(`boolean/0`\) - If `true`, and a record was *not* upserted because its filter prevented the upsert, the original record \(which was *not* upserted\) will be returned. The default value is `false`.

+ 
`:upsert_identity` \(`atom/0`\) - The identity to use when detecting conflicts for `upsert?`, e.g. `upsert_identity: :full_name`. By default, the primary key is used. Has no effect if `upsert?: true` is not provided

+ 
`:upsert_fields` - The fields to upsert. If not set, the action's upsert\_fields is used, and if that is not set, then any fields not being set to defaults are written.

+ 
`:upsert_condition` \(`term/0`\) - An expression to check if the record should be updated when there's a conflict.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - A load statement to add onto the changeset





# create\!\(changeset\_or\_resource, params \\\\ %\{\}, opts \\\\ \[\]\)




    @spec     create!(
      changeset_or_resource ::     Ash.Changeset.t    () |     Ash.Resource.t    (),
      params_or_opts ::     map    () |     Keyword.t    (),
      opts ::     Keyword.t    ()
    ) ::
          Ash.Resource.record    ()
      | {    Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      |     no_return    ()


Create a record. See `create/2` for more information.

## ******Examples**

    iex>     Ash    .    create!    (    MyApp.Post    ,         %{    title    :         "Hello World"    ,         content    :         "..."    }    )        %    MyApp.Post    {    id    :         1    ,         title    :         "Hello World"    ,         content    :         "..."    }    
        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    ,         %{    name    :         "John"    }    )        iex>     Ash    .    create!    (    changeset    )        %    MyApp.User    {    id    :         1    ,         name    :         "John"    }    
        iex>     Ash    .    create!    (    MyApp.Post    ,         %{    title    :         "New Post"    }    ,         return_notifications?    :         true    )        {    %    MyApp.Post    {    id    :         2    ,         title    :         "New Post"    }    ,         [    %    Ash.Notifier.Notification    {    }    ]    }

## ******See also**

+ `create/3` for the non-raising version
+ Create Actions Guide for understanding create operations
+ Actions Guide for general action concepts





# data\_layer\_query\(query, opts \\\\ \[\]\)




    @spec     data_layer_query(    Ash.Query.t    (), opts ::     Keyword.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     Ash.Error.t    ()}


Gets the full query and any runtime calculations that would be loaded

## ******Examples**

    iex>     query         =         MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )        iex>     Ash    .    data_layer_query    (    query    )        {    :ok    ,         %{    query    :         #    Ecto.Query    <    ...    >    ,         ash_query    :         %    Ash.Query    {    }    ,         count    :         #    Function    <    ...    >    ,         run    :         #    Function    <    ...    >    ,         load    :         #    Function    <    ...    >    }    }    
        iex>     MyApp.Post         |>         Ash.Query    .    limit    (    10    )         |>         Ash    .    data_layer_query    (    )        {    :ok    ,         %{    query    :         #    Ecto.Query    <    ...    >    ,         ...    }    }

## ******See also**

+ `data_layer_query!/2` for the raising version





# data\_layer\_query\!\(query, opts \\\\ \[\]\)



Gets the full query and any runtime calculations that would be loaded, raising any errors.

## ******Examples**

    iex>     query         =         MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )        iex>     Ash    .    data_layer_query!    (    query    )        %{    query    :         #    Ecto.Query    <    ...    >    ,         ash_query    :         %    Ash.Query    {    }    ,         count    :         #    Function    <    ...    >    ,         run    :         #    Function    <    ...    >    ,         load    :         #    Function    <    ...    >    }    
        iex>     MyApp.Post         |>         Ash.Query    .    limit    (    10    )         |>         Ash    .    data_layer_query!    (    )        %{    query    :         #    Ecto.Query    <    ...    >    ,         ...    }

## ******See also**

+ `data_layer_query/2` for the non-raising version

See `data_layer_query/2` for more.





# destroy\(changeset\_or\_record, opts \\\\ \[\]\)




    @spec     destroy(    Ash.Changeset.t    () |     Ash.Resource.record    (), opts ::     Keyword.t    ()) ::
      :ok
      | {:ok,     Ash.Resource.record    ()}
      | {:ok, [    Ash.Notifier.Notification.t    ()]}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     term    ()}


Destroy a record.

## ******Examples**

    iex>     Ash    .    destroy    (    post    )        :ok    
        iex>     changeset         =         Ash.Changeset    .    for_destroy    (    user    ,         :archive    )        iex>     Ash    .    destroy    (    changeset    )        {    :ok    ,         :ok    }    
        iex>     Ash    .    destroy    (    post    ,         return_destroyed?    :         true    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         title    :         "Deleted Post"    }    }    
        iex>     Ash    .    destroy    (    user    ,         return_notifications?    :         true    )        {    :ok    ,         [    %    Ash.Notifier.Notification    {    }    ]    }

## ******See also**

+ `destroy!/2` for the raising version
+ `d:Ash.Resource.Dsl.actions.destroy` for defining destroy actions
+ Destroy Actions Guide for understanding destroy operations
+ Actions Guide for general action concepts

## ******Options**

+ 
`:return_destroyed?` \(`boolean/0`\) - If true, the destroyed record is included in the return result, e.g `{:ok, destroyed}` or `{:ok, destroyed, notifications}` The default value is `false`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - A load statement to add onto the changeset





# destroy\!\(changeset\_or\_record, opts \\\\ \[\]\)




    @spec     destroy!(    Ash.Changeset.t    () |     Ash.Resource.record    (), opts ::     Keyword.t    ()) ::
      :ok
      |     Ash.Resource.record    ()
      | [    Ash.Notifier.Notification.t    ()]
      | {    Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      |     no_return    ()


Destroy a record. See `destroy/2` for more information.

## ******Examples**

    iex>     Ash    .    destroy!    (    post    )        :ok    
        iex>     changeset         =         Ash.Changeset    .    for_destroy    (    user    ,         :archive    )        iex>     Ash    .    destroy!    (    changeset    )        :ok    
        iex>     Ash    .    destroy!    (    post    ,         return_destroyed?    :         true    )        %    MyApp.Post    {    id    :         1    ,         title    :         "Deleted Post"    }    
        iex>     Ash    .    destroy!    (    user    ,         return_notifications?    :         true    )        [    %    Ash.Notifier.Notification    {    }    ]

## ******See also**

+ `destroy/2` for the non-raising version
+ `d:Ash.Resource.Dsl.actions.destroy` for defining destroy actions
+ Destroy Actions Guide for understanding destroy operations
+ Actions Guide for general action concepts





# exists\(query, opts \\\\ \[\]\)




    @spec     exists(    Ash.Query.t    () |     Ash.Resource.t    (),     Keyword.t    ()) ::
      {:ok,     boolean    ()} | {:error,     Ash.Error.t    ()}


Returns whether or not the query would return any results.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    exists    (    )        {    :ok    ,         true    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         false    )         |>         Ash    .    exists    (    )        {    :ok    ,         false    }

## ******See also**

+ `exists?/2` for the raising version
+ `count/2` for getting the actual count
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations





# exists?\(query, opts \\\\ \[\]\)




    @spec     exists?(    Ash.Query.t    () |     Ash.Resource.t    (),     Keyword.t    ()) ::
          boolean    () |     no_return    ()


Returns whether or not the query would return any results, or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    exists?    (    )        true    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         false    )         |>         Ash    .    exists?    (    )        false

## ******See also**

+ `exists/2` for the non-raising version
+ `count!/2` for getting the actual count
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations





# first\(query, field, opts \\\\ \[\]\)




    @spec     first(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      {:ok,     term    ()} | {:error,     Ash.Error.t    ()}


Fetches the first value for a given field.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    first    (    :title    )        {    :ok    ,         "Hello World"    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    first    (    :view_count    )        {    :ok    ,         42    }

## ******See also**

+ `first!/3` for the raising version
+ `list/3` for getting all values of a field
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates





# first\!\(query, field, opts \\\\ \[\]\)




    @spec     first!(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
          term    () |     no_return    ()


Fetches the first value for a given field, or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    first!    (    :title    )        "Hello World"    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    first!    (    :view_count    )        42

## ******See also**

+ `first/3` for the non-raising version
+ `list!/3` for getting all values of a field
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates





# get\(resource, id, opts \\\\ \[\]\)




    @spec     get(    Ash.Resource.t    (),     term    (),     Keyword.t    ()) ::
      {:ok,     Ash.Resource.record    () | nil} | {:error,     term    ()}


Get a record by an identifier.

For a resource with a composite primary key, pass a keyword list or map, e.g `Ash.get(MyResource, %{first_key: 1, second_key: 2})`

Additionally, a keyword list or map of keys matching an identity can be provided.

## ******Examples**

    iex>     Ash    .    get    (    MyApp.Post    ,         1    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         title    :         "Hello World"    }    }    
        iex>     Ash    .    get    (    MyApp.User    ,         %{    email    :         "user@example.com"    }    )        {    :ok    ,         %    MyApp.User    {    id    :         5    ,         email    :         "user@example.com"    }    }    
        iex>     Ash    .    get    (    MyApp.Post    ,         %{    first_key    :         1    ,         second_key    :         2    }    )        {    :ok    ,         %    MyApp.Post    {    first_key    :         1    ,         second_key    :         2    }    }

## ******See also**

+ `get!/3` for the raising version
+ Read Actions Guide for understanding read operations

## ******Options**

+ 
`:error?` \(`boolean/0`\) - Whether or not an error should be returned or raised when the record is not found. If set to false, `nil` will be returned. The default value is `true`.

+ 
`:load` \(`term/0`\) - Fields or relationships to load in the query. See `Ash.Query.load/2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.





# get\!\(resource, id, opts \\\\ \[\]\)




    @spec     get!(    Ash.Resource.t    (),     term    (),     Keyword.t    ()) ::
          Ash.Resource.record    () | nil |     no_return    ()


Get a record by an identifier, or raises an error. See `get/3` for more.

## ******Examples**

    iex>     Ash    .    get!    (    MyApp.Post    ,         1    )        %    MyApp.Post    {    id    :         1    ,         title    :         "Hello World"    }    
        iex>     Ash    .    get!    (    MyApp.User    ,         %{    email    :         "user@example.com"    }    )        %    MyApp.User    {    id    :         5    ,         email    :         "user@example.com"    }    
        iex>     Ash    .    get!    (    MyApp.Post    ,         %{    first_key    :         1    ,         second_key    :         2    }    )        %    MyApp.Post    {    first_key    :         1    ,         second_key    :         2    }

## ******See also**

+ `get/3` for the non-raising version
+ Read Actions Guide for understanding read operations





# list\(query, field, opts \\\\ \[\]\)




    @spec     list(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      {:ok, [    term    ()]} | {:error,     Ash.Error.t    ()}


Fetches a list of all values of a given field.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    list    (    :title    )        {    :ok    ,         [    "Hello World"    ,         "Another Post"    ,         "Final Post"    ]    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    list    (    :view_count    )        {    :ok    ,         [    42    ,         15    ,         89    ]    }

## ******See also**

+ `list!/3` for the raising version
+ `first/3` for getting just the first value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# list\!\(query, field, opts \\\\ \[\]\)




    @spec     list!(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      [    term    ()] |     no_return    ()


Fetches a list of all values of a given field or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    list!    (    :title    )        [    "Hello World"    ,         "Another Post"    ,         "Final Post"    ]    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    list!    (    :view_count    )        [    42    ,         15    ,         89    ]

## ******See also**

+ `list/3` for the non-raising version
+ `first!/3` for getting just the first value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# load\(data, query, opts \\\\ \[\]\)




    @spec     load(
      record_or_records ::
            record_or_records    ()
        |     Ash.Page.page    ()
        | {:ok,     record_or_records    ()}
        | {:ok,     Ash.Page.page    ()}
        | {:error,     term    ()}
        | :ok
        | nil,
      query ::     load_statement    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.record    () | [    Ash.Resource.record    ()] | nil}
      | {:error,     term    ()}


Load fields or relationships on already fetched records.

Accepts a list of non-loaded fields and loads them on the provided records or a query, in which case the loaded fields of the query are used. Relationship loads can be nested, for example: `Ash.load(record, [posts: [:comments]])`.

## ******Examples**

    iex>     Ash    .    load    (    post    ,         :comments    )        {    :ok    ,         %    MyApp.Post    {    comments    :         [    %    MyApp.Comment    {    }    ,         ...    ]    }    }    
        iex>     Ash    .    load    (    posts    ,         [    :author    ,         :comments    ]    )        {    :ok    ,         [    %    MyApp.Post    {    author    :         %    MyApp.User    {    }    ,         comments    :         [    ...    ]    }    ,         ...    ]    }    
        iex>     Ash    .    load    (    user    ,         [    posts    :         [    :comments    ]    ]    )        {    :ok    ,         %    MyApp.User    {    posts    :         [    %    MyApp.Post    {    comments    :         [    ...    ]    }    ]    }    }

## ******See also**

+ `load!/3` for the raising version
+ `d:Ash.Resource.Dsl.relationships` for defining relationships to load
+ `d:Ash.Resource.Dsl.calculations` for defining calculations to load

## ******Options**

+ 
`:lazy?` \(`boolean/0`\) - If set to true, values will only be loaded if the related value isn't currently loaded. The default value is `false`.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.





# load\!\(data, query, opts \\\\ \[\]\)




    @spec     load!(
      record_or_records ::
            record_or_records    ()
        |     Ash.Page.page    ()
        | {:ok,     record_or_records    ()}
        | {:ok,     Ash.Page.page    ()}
        | {:error,     term    ()}
        | :ok
        | nil,
      query ::     load_statement    (),
      opts ::     Keyword.t    ()
    ) ::     Ash.Resource.record    () | [    Ash.Resource.record    ()] | nil |     no_return    ()


Load fields or relationships on already fetched records. See `load/3` for more information.

## ******Examples**

    iex>     Ash    .    load!    (    post    ,         :comments    )        %    MyApp.Post    {    comments    :         [    %    MyApp.Comment    {    }    ,         ...    ]    }    
        iex>     Ash    .    load!    (    posts    ,         [    :author    ,         :comments    ]    )        [    %    MyApp.Post    {    author    :         %    MyApp.User    {    }    ,         comments    :         [    ...    ]    }    ,         ...    ]    
        iex>     Ash    .    load!    (    user    ,         [    posts    :         [    :comments    ]    ]    )        %    MyApp.User    {    posts    :         [    %    MyApp.Post    {    comments    :         [    ...    ]    }    ]    }

## ******See also**

+ `load/3` for the non-raising version
+ `d:Ash.Resource.Dsl.relationships` for defining relationships to load
+ `d:Ash.Resource.Dsl.calculations` for defining calculations to load
+ Relationships Guide for understanding relationships
+ Calculations Guide for understanding calculations





# max\(query, field, opts \\\\ \[\]\)




    @spec     max(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      {:ok,     term    ()} | {:error,     Ash.Error.t    ()}


Fetches the greatest of all values of a given field.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    max    (    :view_count    )        {    :ok    ,         1542    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    max    (    :created_at    )        {    :ok    ,         ~U[2023-12-25 10:30:00Z]    }

## ******See also**

+ `max!/3` for the raising version
+ `min/3` for getting the minimum value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# max\!\(query, field, opts \\\\ \[\]\)




    @spec     max!(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
          term    () |     no_return    ()


Fetches the greatest of all values of a given field or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    max!    (    :view_count    )        1542    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    max!    (    :created_at    )        ~U[2023-12-25 10:30:00Z]

## ******See also**

+ `max/3` for the non-raising version
+ `min!/3` for getting the minimum value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# min\(query, field, opts \\\\ \[\]\)




    @spec     min(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      {:ok,     term    ()} | {:error,     Ash.Error.t    ()}


Fetches the least of all values of a given field.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    min    (    :view_count    )        {    :ok    ,         5    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    min    (    :created_at    )        {    :ok    ,         ~U[2023-01-01 08:00:00Z]    }

## ******See also**

+ `min!/3` for the raising version
+ `max/3` for getting the maximum value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# min\!\(query, field, opts \\\\ \[\]\)




    @spec     min!(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
          term    () |     no_return    ()


Fetches the least of all values of a given field or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    min!    (    :view_count    )        5    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    min!    (    :created_at    )        ~U[2023-01-01 08:00:00Z]

## ******See also**

+ `min/3` for the non-raising version
+ `max!/3` for getting the maximum value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# page\(page, n\)




    @spec     page(    Ash.Page.page    (),     page_request    ()) ::
      {:ok,     Ash.Page.page    ()} | {:error,     Ash.Error.t    ()}


Fetch a page relative to the provided page.

## ******Examples**

    iex>     Ash    .    page    (    page    ,         :next    )        {    :ok    ,         %    Ash.Page.Offset    {    results    :         [    ...    ]    ,         more?    :         true    }    }    
        iex>     Ash    .    page    (    page    ,         :prev    )        {    :ok    ,         %    Ash.Page.Offset    {    results    :         [    ...    ]    ,         more?    :         false    }    }    
        iex>     Ash    .    page    (    page    ,         3    )        {    :ok    ,         %    Ash.Page.Offset    {    results    :         [    ...    ]    ,         offset    :         40    }    }

## ******See also**

+ `page!/2` for the raising version





# page\!\(page, request\)




    @spec     page!(    Ash.Page.page    (),     page_request    ()) ::     Ash.Page.page    () |     no_return    ()


Fetch a page relative to the provided page or raises an error

## ******Examples**

    iex>     Ash    .    page!    (    page    ,         :next    )        %    Ash.Page.Offset    {    results    :         [    ...    ]    ,         more?    :         true    }    
        iex>     Ash    .    page!    (    page    ,         :prev    )        %    Ash.Page.Offset    {    results    :         [    ...    ]    ,         more?    :         false    }    
        iex>     Ash    .    page!    (    page    ,         3    )        %    Ash.Page.Offset    {    results    :         [    ...    ]    ,         offset    :         40    }

## ******See also**

+ `page/2` for the non-raising version





# read\(query, opts \\\\ \[\]\)




    @spec     read(    Ash.Query.t    () |     Ash.Resource.t    (),     Keyword.t    ()) ::
      {:ok, [    Ash.Resource.record    ()] |     Ash.Page.page    ()} | {:error,     term    ()}


Runs an `Ash.Query`.

For more information on building a query, see `Ash.Query`.

## ******Examples**

    iex>     Ash    .    read    (    MyApp.Post    )        {    :ok    ,         [    %    MyApp.Post    {    id    :         1    ,         title    :         "Hello"    }    ,         %    MyApp.Post    {    id    :         2    ,         title    :         "World"    }    ]    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    read    (    )        {    :ok    ,         [    %    MyApp.Post    {    id    :         1    ,         title    :         "Hello"    ,         published    :         true    }    ]    }    
        iex>     MyApp.Post         |>         Ash.Query    .    limit    (    5    )         |>         Ash    .    read    (    )        {    :ok    ,         [    %    MyApp.Post    {    }    ,         %    MyApp.Post    {    }    ,         ...    ]    }

## ******See also**

+ `read!/2` for the raising version
+ `d:Ash.Resource.Dsl.actions.read` for defining read actions
+ `d:Ash.Resource.Dsl.actions.read.pagination` for pagination configuration
+ Read Actions Guide for understanding read operations
+ Actions Guide for general action concepts

## ******Options**

+ 
`:page` - Pagination options, see `Ash.read/2` for more.

+ 
`:load` \(`term/0`\) - A load statement to add onto the query

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.


## ******Pagination**

#### Limit/offset pagination

+ 
`:offset` \(`non_neg_integer/0`\) - The number of records to skip from the beginning of the query

+ 
`:limit` \(`pos_integer/0`\) - The number of records to include in the page

+ 
`:filter` \(`term/0`\) - A filter to apply for pagination purposes, that should not be considered in the full count.  
This is used by the liveview paginator to only fetch the records that were *already* on the page when refreshing data, to avoid pages jittering.

+ 
`:count` \(`boolean/0`\) - Whether or not to return the page with a full count of all records


#### Keyset pagination

+ 
`:before` \(`String.t/0`\) - Get records that appear before the provided keyset \(mutually exclusive with `after`\)

+ 
`:after` \(`String.t/0`\) - Get records that appear after the provided keyset \(mutually exclusive with `before`\)

+ 
`:limit` \(`pos_integer/0`\) - How many records to include in the page

+ 
`:filter` \(`term/0`\) - See the `filter` option for offset pagination, this behaves the same.

+ 
`:count` \(`boolean/0`\) - Whether or not to return the page with a full count of all records





# read\!\(query, opts \\\\ \[\]\)




    @spec     read!(    Ash.Query.t    () |     Ash.Resource.t    (),     Keyword.t    ()) ::
      [    Ash.Resource.record    ()] |     Ash.Page.page    () |     no_return    ()


Run an `Ash.Query`. See `read/2` for more.

## ******Examples**

    iex>     Ash    .    read!    (    MyApp.Post    )        [    %    MyApp.Post    {    id    :         1    ,         title    :         "Hello"    }    ,         %    MyApp.Post    {    id    :         2    ,         title    :         "World"    }    ]    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    read!    (    )        [    %    MyApp.Post    {    id    :         1    ,         title    :         "Hello"    ,         published    :         true    }    ]    
        iex>     MyApp.Post         |>         Ash.Query    .    limit    (    5    )         |>         Ash    .    read!    (    )        [    %    MyApp.Post    {    }    ,         %    MyApp.Post    {    }    ,         ...    ]

## ******See also**

+ `read/2` for the non-raising version
+ Read Actions Guide for understanding read operations





# read\_first\(query, opts \\\\ \[\]\)




    @spec     read_first(
      resource_or_query ::     Ash.Query.t    () |     Ash.Resource.t    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.record    () | nil} | {:error,     Ash.Error.t    ()}


Runs a query on a resource, returning a first result, nil, or an error.

Query is automatically limited to only return one result, unlike `read_one/3`

## ******Examples**

    iex>     Ash    .    read_first    (    MyApp.Post    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         title    :         "First Post"    }    }    
        iex>     MyApp.Post         |>         Ash.Query    .    sort    (    :created_at    )         |>         Ash    .    read_first    (    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         created_at    :         ~U[2023-01-01 00:00:00Z]    }    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         false    )         |>         Ash    .    read_first    (    )        {    :ok    ,         nil    }

## ******See also**

+ `read_first!/2` for the raising version

## ******Options**

+ 
`:not_found_error?` \(`boolean/0`\) - Whether or not to return an `Ash.Error.Query.NotFound` if no record is found. The default value is `false`.

+ 
`:page` - Pagination options, see `Ash.read/2` for more.

+ 
`:load` \(`term/0`\) - A load statement to add onto the query

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.





# read\_first\!\(query, opts \\\\ \[\]\)




    @spec     read_first!(
      resource_or_query ::     Ash.Query.t    () |     Ash.Resource.t    (),
      opts ::     Keyword.t    ()
    ) ::
          Ash.Resource.record    () | nil


Runs an Ash query, returning the first result or nil, or raising an error. See `read_first/2` for more.

## ******Examples**

    iex>     Ash    .    read_first!    (    MyApp.Post    )        %    MyApp.Post    {    id    :         1    ,         title    :         "First Post"    }    
        iex>     MyApp.Post         |>         Ash.Query    .    sort    (    :created_at    )         |>         Ash    .    read_first!    (    )        %    MyApp.Post    {    id    :         1    ,         created_at    :         ~U[2023-01-01 00:00:00Z]    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         false    )         |>         Ash    .    read_first!    (    )        nil

## ******See also**

+ `read_first/2` for the non-raising version





# read\_one\(query, opts \\\\ \[\]\)




    @spec     read_one(
      resource_or_query ::     Ash.Query.t    () |     Ash.Resource.t    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.record    () | nil} | {:error,     Ash.Error.t    ()}


Runs a query on a resource, returning a single result, nil, or an error.

If more than one result would be returned, an error is returned instead.

## ******Examples**

    iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    read_one    (    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         published    :         true    }    }    
        iex>     MyApp.User         |>         Ash.Query    .    filter    (    email    :         "nonexistent@example.com"    )         |>         Ash    .    read_one    (    )        {    :ok    ,         nil    }

## ******See also**

+ `read_one!/2` for the raising version

## ******Options**

+ 
`:not_found_error?` \(`boolean/0`\) - Whether or not to return an `Ash.Error.Query.NotFound` if no record is found. The default value is `false`.

+ 
`:page` - Pagination options, see `Ash.read/2` for more.

+ 
`:load` \(`term/0`\) - A load statement to add onto the query

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.





# read\_one\!\(query, opts \\\\ \[\]\)




    @spec     read_one!(
      resource_or_query ::     Ash.Query.t    () |     Ash.Resource.t    (),
      opts ::     Keyword.t    ()
    ) ::
          Ash.Resource.record    () | nil


Runs an ash query, returning a single result or raise an error. See `read_one/2` for more.

## ******Examples**

    iex>     Ash    .    read_one!    (    MyApp.User    ,         email    :         "user@example.com"    )        %    MyApp.User    {    id    :         1    ,         email    :         "user@example.com"    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    read_one!    (    )        %    MyApp.Post    {    id    :         1    ,         published    :         true    }    
        iex>     MyApp.User         |>         Ash.Query    .    filter    (    email    :         "nonexistent@example.com"    )         |>         Ash    .    read_one!    (    )        nil

## ******See also**

+ `read_one/2` for the non-raising version





# reload\(record, opts \\\\ \[\]\)




    @spec     reload(record ::     Ash.Resource.record    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.record    ()} | {:error,     Ash.Error.t    ()}


Refetches a record by primary key. See `get/2` for more.

## ******Examples**

    iex>     Ash    .    reload    (    post    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         title    :         "Updated Title"    ,         updated_at    :         ~U[2023-12-25 10:30:00Z]    }    }    
        iex>     Ash    .    reload    (    user    ,         load    :         [    :posts    ]    )        {    :ok    ,         %    MyApp.User    {    id    :         1    ,         posts    :         [    %    MyApp.Post    {    }    ,         ...    ]    }    }

## ******See also**

+ `reload!/2` for the raising version





# reload\!\(record, opts \\\\ \[\]\)




    @spec     reload!(record ::     Ash.Resource.record    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.record    () |     no_return    ()


Refetches a record by primary key or raises an error. See `reload/2` for more.

## ******Examples**

    iex>     Ash    .    reload!    (    post    )        %    MyApp.Post    {    id    :         1    ,         title    :         "Updated Title"    ,         updated_at    :         ~U[2023-12-25 10:30:00Z]    }    
        iex>     Ash    .    reload!    (    user    ,         load    :         [    :posts    ]    )        %    MyApp.User    {    id    :         1    ,         posts    :         [    %    MyApp.Post    {    }    ,         ...    ]    }

## ******See also**

+ `reload/2` for the non-raising version
+ `d:Ash.Resource.Dsl.relationships` for defining relationships to load





# run\_action\(input, opts \\\\ \[\]\)




    @spec     run_action(input ::     Ash.ActionInput.t    (), opts ::     Keyword.t    ()) ::
      :ok | {:ok,     term    ()} | {:error,     Ash.Error.t    ()}


Runs a generic action.

## ******Examples**

    iex>     input         =         Ash.ActionInput    .    for_action    (    MyApp.Post    ,         :send_email    ,         %{    email    :         "test@example.com"    }    )        iex>     Ash    .    run_action    (    input    )        {    :ok    ,         :ok    }    
        iex>     input         =         Ash.ActionInput    .    for_action    (    MyApp.Calculator    ,         :calculate_tax    ,         %{    amount    :         100    }    )        iex>     Ash    .    run_action    (    input    )        {    :ok    ,         8.25    }

## ******See also**

+ `run_action!/2` for the raising version
+ `d:Ash.Resource.Dsl.actions.action` for defining generic actions
+ Generic Actions Guide for understanding generic actions
+ Actions Guide for general action concepts

## ******Options**

+ 
`:actor` \(`term/0`\) - The actor for handling `^actor/1` templates, supplied to calculation context.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol. Will overwrite any actor, tenant or context provided. See `Ash.Context` for more.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - The tenant, supplied to calculation context.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not the request should be authorized.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer, provided to the calculation context.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use for the action

+ 
`:context` \(`map/0`\) - Context to set on the action input

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.





# run\_action\!\(input, opts \\\\ \[\]\)




    @spec     run_action!(input ::     Ash.ActionInput.t    (), opts ::     Keyword.t    ()) ::
          term    () |     no_return    ()


Runs a generic action or raises an error. See `run_action/2` for more

## ******Examples**

    iex>     input         =         Ash.ActionInput    .    for_action    (    MyApp.Post    ,         :send_email    ,         %{    email    :         "test@example.com"    }    )        iex>     Ash    .    run_action!    (    input    )        :ok    
        iex>     input         =         Ash.ActionInput    .    for_action    (    MyApp.Calculator    ,         :calculate_tax    ,         %{    amount    :         100    }    )        iex>     Ash    .    run_action!    (    input    )        8.25

## ******See also**

+ `run_action/2` for the non-raising version
+ `d:Ash.Resource.Dsl.actions.action` for defining generic actions
+ Generic Actions Guide for understanding generic actions
+ Actions Guide for general action concepts





# stream\!\(query, opts \\\\ \[\]\)




    @spec     stream!(query ::     Ash.Query.t    () |     Ash.Resource.t    (), opts ::     Keyword.t    ()) ::
          Enumerable.t    (    Ash.Resource.record    ())


Streams the results of a query.

## ******Strategies**

There are three strategies supported, and the best one available is always chosen. They are, in order from best to worst:

+ `:keyset`
+ `:offset`
+ `:full_read`

By default, only `:keyset` is supported. If you want to allow worse strategies to be used, pass the worst one you wish to allow as the `allow_stream_with` option, i.e `allow_stream_with: :full_read`. If you wish to specify a specific strategy to use, pass `stream_with: :strategy_name`.

### ******Keyset**

This utilizes keyset pagination to accomplish this stream. The action must support keyset pagination. This is the most efficient way to stream a query, because it works by using filters which can benefit from indexes in the data layer.

### ******Offset**

This utilizes offset/limit to accomplish this stream. If the action supports offset pagination, that will be used. Otherwise, if the data layer supports limit/offset, then explicit limits/offsets will be used. This is a much less efficient way of streaming a resource than `keyset`. To use limit/offset to reliably stream, a sort must always be applied, and limit/offset in the data layer will generally require sorting the entire table to figure out what is in each batch.

### ******Full Read**

This reads the entire table into memory with no limit. This is, generally speaking, the least efficient.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    stream!    (    )         |>         Enum    .    take    (    10    )        [    %    MyApp.Post    {    }    ,         %    MyApp.Post    {    }    ,         ...    ]    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    stream!    (    strategy    :         :keyset    )         |>         Enum    .    map    (    &         &1    .    title    )        [    "Hello World"    ,         "Another Post"    ,         ...    ]    
        iex>     MyApp.Post         |>         Ash    .    stream!    (    strategy    :         :offset    ,         batch_size    :         50    )         |>         Stream    .    filter    (    &         &1    .    likes         >         10    )         |>         Enum    .    to_list    (    )        [    %    MyApp.Post    {    likes    :         15    }    ,         ...    ]

## ******See also**

+ `read/2` for non-streaming reads
+ `d:Ash.Resource.Dsl.actions.read` for defining read actions
+ `d:Ash.Resource.Dsl.actions.read.pagination` for pagination configuration

## ******Options**

+ 
`:batch_size` \(`integer/0`\) - How many records to request in each query run. Defaults to the pagination limits on the resource, or 250.

+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. Valid values are :keyset, :offset, :full\_read The default value is `:keyset`.

+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more. Valid values are :keyset, :offset, :full\_read

+ 
`:load` \(`term/0`\) - A load statement to add onto the query

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.





# sum\(query, field, opts \\\\ \[\]\)




    @spec     sum(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
      {:ok,     number    ()} | {:error,     Ash.Error.t    ()}


Fetches the sum of a given field.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    sum    (    :view_count    )        {    :ok    ,         1542    }    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    sum    (    :likes    )        {    :ok    ,         238    }

## ******See also**

+ `sum!/3` for the raising version
+ `avg/3` for getting the average value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources
+ Read Actions Guide for understanding read operations
+ Aggregates Guide for resource-level aggregates





# sum\!\(query, field, opts \\\\ \[\]\)




    @spec     sum!(    Ash.Query.t    () |     Ash.Resource.t    (),     atom    (),     Keyword.t    ()) ::
          number    () |     no_return    ()


Fetches the sum of a given field or raises an error.

## ******Examples**

    iex>     MyApp.Post         |>         Ash    .    sum!    (    :view_count    )        1542    
        iex>     MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )         |>         Ash    .    sum!    (    :likes    )        238

## ******See also**

+ `sum/3` for the non-raising version
+ `avg!/3` for getting the average value
+ `d:Ash.Resource.Dsl.aggregates` for defining aggregates on resources





# transaction\(resource\_or\_resources, func, opts \\\\ \[\]\)




    @spec     transaction(
      resource_or_resources ::     Ash.Resource.t    () | [    Ash.Resource.t    ()],
      func :: (->     term    ()),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     term    ()}
      | {:ok,     term    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     term    ()}


Wraps the execution of the function in a transaction with the resource's data\_layer. Collects notifications during the function's execution and sends them if the transaction was successful.

## ******Examples**

    iex>     Ash    .    transaction    (    MyApp.Post    ,         fn         ->        ...>           post         =         Ash    .    create!    (    MyApp.Post    ,         %{    title    :         "Hello"    }    )        ...>           Ash    .    update!    (    post    ,         %{    content    :         "World"    }    )        ...>     end    )        {    :ok    ,         %    MyApp.Post    {    title    :         "Hello"    ,         content    :         "World"    }    }    
        iex>     Ash    .    transaction    (    [    MyApp.User    ,         MyApp.Post    ]    ,         fn         ->        ...>           user         =         Ash    .    create!    (    MyApp.User    ,         %{    name    :         "John"    }    )        ...>           Ash    .    create!    (    MyApp.Post    ,         %{    title    :         "Hello"    ,         author_id    :         user    .    id    }    )        ...>     end    )        {    :ok    ,         %    MyApp.Post    {    title    :         "Hello"    }    }    
        iex>     Ash    .    transaction    (    MyApp.Post    ,         fn         ->        ...>           Ash    .    create!    (    MyApp.Post    ,         %{    title    :         "Test"    }    )        ...>     end    ,         return_notifications?    :         true    )        {    :ok    ,         %    MyApp.Post    {    title    :         "Test"    }    ,         [    %    Ash.Notifier.Notification    {    }    ]    }

## ******See also**

+ Actions Guide for understanding action concepts
+ Development Testing Guide for testing with transactions

## ******Options**

+ 
`:timeout` \(`timeout/0`\) - The time in milliseconds \(as an integer\) to wait for the transaction to finish or `:infinity` to wait indefinitely.  
If not specified then default behaviour is adapter specific - for `Ecto`-based data layers it will be `15_000`.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you want to manually handle sending notifications.  
If true the returned tuple will contain notifications list as the last element.  
To send notifications use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.





# update\(changeset\_or\_record, params\_or\_opts \\\\ %\{\}, opts \\\\ \[\]\)




    @spec     update(
      changeset_or_record ::     Ash.Changeset.t    () |     Ash.Resource.record    (),
      params_or_opts ::     map    () |     Keyword.t    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     term    ()}


Update a record.

## ******Examples**

    iex>     Ash    .    update    (    post    ,         %{    title    :         "Updated Title"    }    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         title    :         "Updated Title"    }    }    
        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :update    ,         %{    name    :         "Jane"    }    )        iex>     Ash    .    update    (    changeset    )        {    :ok    ,         %    MyApp.User    {    id    :         1    ,         name    :         "Jane"    }    }    
        iex>     Ash    .    update    (    post    ,         %{    content    :         "New content"    }    ,         return_notifications?    :         true    )        {    :ok    ,         %    MyApp.Post    {    id    :         1    ,         content    :         "New content"    }    ,         [    %    Ash.Notifier.Notification    {    }    ]    }

## ******See also**

+ `update!/3` for the raising version
+ `d:Ash.Resource.Dsl.actions.update` for defining update actions
+ `d:Ash.Resource.Dsl.changes` for defining changes
+ Update Actions Guide for understanding update operations
+ Actions Guide for general action concepts

## ******Options**

+ 
`:params` \(`map/0`\) - Parameters to supply, ignored if the input is a changeset, only used when an identifier is given.

+ 
`:atomic_upgrade?` \(`boolean/0`\) - If true the action will be done atomically if it can \(and is configured to do so\), ignoring the in memory transformations and validations. You should not generally need to disable this. The default value is `true`.

+ 
`:domain` \(`Ash.Domain`\) - The domain to use.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - A load statement to add onto the changeset





# update\!\(changeset\_or\_record, params\_or\_opts \\\\ %\{\}, opts \\\\ \[\]\)




    @spec     update!(
      changeset_or_record ::     Ash.Changeset.t    () |     Ash.Resource.record    (),
      params_or_opts ::     map    () |     Keyword.t    (),
      opts ::     Keyword.t    ()
    ) ::
          Ash.Resource.record    ()
      | {    Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      |     no_return    ()


Update a record. See `update/2` for more information.

## ******Examples**

    iex>     Ash    .    update!    (    post    ,         %{    title    :         "Updated Title"    }    )        %    MyApp.Post    {    id    :         1    ,         title    :         "Updated Title"    }    
        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :update    ,         %{    name    :         "Jane"    }    )        iex>     Ash    .    update!    (    changeset    )        %    MyApp.User    {    id    :         1    ,         name    :         "Jane"    }    
        iex>     Ash    .    update!    (    post    ,         %{    content    :         "New content"    }    ,         return_notifications?    :         true    )        {    %    MyApp.Post    {    id    :         1    ,         content    :         "New content"    }    ,         [    %    Ash.Notifier.Notification    {    }    ]    }

## ******See also**

+ `update/3` for the non-raising version
+ `d:Ash.Resource.Dsl.actions.update` for defining update actions
+ Update Actions Guide for understanding update operations
+ Actions Guide for general action concepts





# Ash.ActionInput 

Input for a custom action

Much like an `Ash.Query` and `Ash.Changeset` are used to provide inputs into CRUD actions, this struct provides the inputs required to execute a generic action.





# Summary


## **Types** 


after\_action\_fun\(\) 


Function type for after action hooks.




after\_transaction\_fun\(\) 


Function type for after transaction hooks.




around\_transaction\_fun\(\) 


Function type for around transaction hooks.




before\_action\_fun\(\) 


Function type for before action hooks.




before\_transaction\_fun\(\) 


Function type for before transaction hooks.




t\(\) 


An action input struct for generic \(non-CRUD\) actions.





## **Functions** 


add\_error\(input, errors, path \\\\ \[\]\) 


Adds an error to the errors list and marks the action input as invalid.




after\_action\(input, func, opts \\\\ \[\]\) 


Adds an after\_action hook to the action input.




after\_transaction\(input, func, opts \\\\ \[\]\) 


Adds an after transaction hook to the action input.




around\_transaction\(input, func, opts \\\\ \[\]\) 


Adds an around transaction hook to the action input.




before\_action\(input, func, opts \\\\ \[\]\) 


Adds a before\_action hook to the action input.




before\_transaction\(input, func, opts \\\\ \[\]\) 


Adds a before transaction hook to the action input.




delete\_argument\(input, argument\_or\_arguments\) 


Deletes one or more arguments from the subject.




fetch\_argument\(input, argument\) 


Fetches the value of an argument provided to the input.




for\_action\(resource\_or\_input, action, params, opts \\\\ \[\]\) 


Creates a new input for a generic action.




get\_argument\(input, argument\) 


Gets the value of an argument provided to the input.




new\(resource, domain \\\\ nil\) 


Creates a new action input from a resource.




set\_argument\(input, argument, value\) 


Sets an argument value on the action input.




set\_context\(input, map\) 


Deep merges the provided map into the input context.




set\_private\_argument\(input, name, value\) 


Sets a private argument value on the action input.




set\_tenant\(input, tenant\) 


Sets the tenant to use when calling the action.




# Types




# after\_action\_fun\(\)




    @type     after_action_fun() :: (    t    (),     term    () ->
                             {:ok,     term    ()}
                             | {:ok,     term    (), [    Ash.Notifier.Notification.t    ()]}
                             | {:error,     any    ()})


Function type for after action hooks.

Receives the action input and the result of the action, and can return the result optionally with notifications, or an error.





# after\_transaction\_fun\(\)




    @type     after_transaction_fun() :: (    t    (), {:ok,     term    ()} | {:error,     any    ()} ->
                                  {:ok,     term    ()} | {:error,     any    ()})


Function type for after transaction hooks.

Receives the action input and the result of the transaction, and returns the result \(potentially modified\) or an error.





# around\_transaction\_fun\(\)




    @type     around_transaction_fun() :: (    t    (), (    t    () -> {:ok,     term    ()} | {:error,     any    ()}) ->
                                   {:ok,     term    ()} | {:error,     any    ()})


Function type for around transaction hooks.

Receives an action input and a callback function that executes the transaction, and returns the result of calling the callback or an error.





# before\_action\_fun\(\)




    @type     before_action_fun() :: (    t    () ->
                                  t    ()
                              | {    t    (),
                                 %{notifications: [    Ash.Notifier.Notification.t    ()]}})


Function type for before action hooks.

Receives an action input and returns a modified action input, optionally with notifications.





# before\_transaction\_fun\(\)




    @type     before_transaction_fun() :: (    t    () ->     t    () | {:error,     any    ()})


Function type for before transaction hooks.

Receives an action input and returns a modified action input or an error.





# t\(\)




    @type     t() :: %Ash.ActionInput{
      action:     Ash.Resource.Actions.Action.t    () | nil,
      after_action: [    after_action_fun    ()],
      after_transaction: [    after_transaction_fun    ()],
      arguments:     map    (),
      around_transaction: [    around_transaction_fun    ()],
      before_action: [    before_action_fun    ()],
      before_transaction: [    before_transaction_fun    ()],
      context:     map    (),
      domain:     Ash.Domain.t    (),
      errors: [    Ash.Error.t    ()],
      invalid_keys:     MapSet.t    (),
      params:     map    (),
      resource:     Ash.Resource.t    (),
      tenant:     term    (),
      to_tenant:     term    (),
      valid?:     boolean    ()
    }


An action input struct for generic \(non-CRUD\) actions.

Contains all the information needed to execute a generic action including arguments, context, tenant information, validation state, and lifecycle hooks. Built using `for_action/4` and modified with functions like `set_argument/3` and `set_context/2`.





# Functions




# add\_error\(input, errors, path \\\\ \[\]\)




    @spec     add_error(
          t    (),
          Ash.Error.error_input    () | [    Ash.Error.error_input    ()],
          Ash.Error.path_input    ()
    ) ::     t    ()


Adds an error to the errors list and marks the action input as invalid.

This function allows you to add validation errors or other issues to the action input. Once an error is added, the input will be marked as invalid and action execution will be prevented.

## ******Examples**

    # Add a simple string error        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    add_error    (    "Missing required configuration"    )        iex>     input    .    valid?        false    
        # Add an error with a specific path        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :process_data    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    add_error    (    "Invalid format"    ,         [    :data    ,         :format    ]    )        iex>     input    .    errors         |>         List    .    first    (    )         |>         Map    .    get    (    :path    )        [    :data    ,         :format    ]    
        # Add multiple errors        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :complex_action    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    add_error    (    [    "Error 1"    ,         "Error 2"    ]    )        iex>     length    (    input    .    errors    )        2    
        # Add structured error with keyword list        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :validate_input    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    add_error    (    field    :         :email    ,         message    :         "is invalid"    )

## ******See also**

+ `Ash.Error.to_ash_error/3` for more on supported error values
+ Action implementations can use this to add custom validation errors
+ `set_argument/3` automatically adds errors for invalid argument values





# after\_action\(input, func, opts \\\\ \[\]\)




    @spec     after_action(
      input ::     t    (),
      fun ::     after_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an after\_action hook to the action input.

After action hooks are called with the action input and the result returned from the action. They can modify the result, perform side effects, or return errors to halt processing. The hook can return notifications alongside the result.

## ******Examples**

    # Transform the result after action        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :calculate_stats    ,         %{    data    :         [    1    ,         2    ,         3    ]    }    )        ...>     |>         Ash.ActionInput    .    after_action    (    fn         input    ,         result         ->        ...>           enhanced_result         =         Map    .    put    (    result    ,         :calculated_at    ,         DateTime    .    utc_now    (    )    )        ...>           {    :ok    ,         enhanced_result    }        ...>     end    )    
        # Log successful actions        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :important_action    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    after_action    (    fn         inp    ,         result         ->        ...>           Logger    .    info    (    "Action completed successfully"    )        ...>           {    :ok    ,         result    }        ...>     end    )    
        # Return notifications        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :notify_users    ,         %{    message    :         "Hello"    }    )        ...>     |>         Ash.ActionInput    .    after_action    (    fn         input    ,         result         ->        ...>           notification         =         %    Ash.Notifier.Notification    {        ...>             resource    :         input    .    resource    ,        ...>             action    :         input    .    action    ,        ...>             data    :         result        ...>           }        ...>           {    :ok    ,         result    ,         [    notification    ]    }        ...>     end    )    
        # Handle errors        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :risky_action    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    after_action    (    fn         input    ,         result         ->        ...>           if         is_error_result?    (    result    )         do        ...>             {    :error    ,         "Action failed with custom error"    }        ...>           else        ...>             {    :ok    ,         result    }        ...>           end        ...>     end    )

## ******See also**

+ `before_action/3` for hooks that run before the action executes
+ `for_action/4` for creating action inputs
+ `Ash.run_action/2` for executing the action with the input





# after\_transaction\(input, func, opts \\\\ \[\]\)




    @spec     after_transaction(
      input ::     t    (),
      fun ::     after_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an after transaction hook to the action input.

After transaction hooks are executed after the transaction completes, regardless of success or failure. They receive both the input and the transaction result, and can modify the result.

## ******Examples**

    # Add cleanup after transaction        iex>     input        ...>     |>         Ash.ActionInput    .    after_transaction    (    fn         input    ,         result         ->        ...>           cleanup_resources    (    )        ...>           result        ...>     end    )

## ******See also**

+ `before_transaction/2` for hooks that run before the transaction
+ `around_transaction/2` for hooks that wrap the entire transaction
+ `after_action/2` for hooks that run after the action \(inside transaction\)





# around\_transaction\(input, func, opts \\\\ \[\]\)




    @spec     around_transaction(
      input ::     t    (),
      fun ::     around_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an around transaction hook to the action input.

Around transaction hooks wrap the entire transaction execution. They receive a callback function that they must call to execute the transaction, allowing them to add logic both before and after the transaction.

## ******Examples**

    # Add retry logic around transaction        iex>     input        ...>     |>         Ash.ActionInput    .    around_transaction    (    fn         input    ,         callback         ->        ...>           case         callback    .    (    input    )         do        ...>             {    :ok    ,         result    }         ->         {    :ok    ,         result    }        ...>             {    :error    ,         %{    retryable?    :         true    }    }         ->         callback    .    (    input    )         # Retry once        ...>             error         ->         error        ...>           end        ...>     end    )

## ******See also**

+ `before_transaction/2` for hooks that run before the transaction
+ `after_transaction/2` for hooks that run after the transaction
+ `before_action/3` and `after_action/2` for hooks that run inside the transaction





# before\_action\(input, func, opts \\\\ \[\]\)




    @spec     before_action(
      input ::     t    (),
      fun ::     before_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before\_action hook to the action input.

Before action hooks are called with the action input and can modify it before the action executes. They can also add errors to halt processing or return notifications to be processed later.

## ******Examples**

    # Validate arguments before action        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    message    :         "Hello"    }    )        ...>     |>         Ash.ActionInput    .    before_action    (    fn         input         ->        ...>           if         String    .    length    (    input    .    arguments    .    message    )         >         100         do        ...>             Ash.ActionInput    .    add_error    (    input    ,         "Message too long"    )        ...>           else        ...>             input        ...>           end        ...>     end    )    
        # Set computed arguments        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :process_data    ,         %{    data    :         "test"    }    )        ...>     |>         Ash.ActionInput    .    before_action    (    fn         input         ->        ...>           Ash.ActionInput    .    set_argument    (    input    ,         :processed_at    ,         DateTime    .    utc_now    (    )    )        ...>     end    )    
        # Return notifications        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :audit_action    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    before_action    (    fn         input         ->        ...>           notification         =         %    Ash.Notifier.Notification    {        ...>             resource    :         input    .    resource    ,        ...>             action    :         input    .    action    ,        ...>             data    :         %{    audit    :         "before_action"    }        ...>           }        ...>           {    input    ,         %{    notifications    :         [    notification    ]    }    }        ...>     end    )

## ******Options**

+ `prepend?` - If `true`, adds the hook to the beginning of the list instead of the end

## ******See also**

+ `after_action/2` for hooks that run after the action completes
+ `for_action/4` for creating action inputs
+ `add_error/2` for adding validation errors in hooks





# before\_transaction\(input, func, opts \\\\ \[\]\)




    @spec     before_transaction(
      input ::     t    (),
      fun ::     before_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before transaction hook to the action input.

Before transaction hooks are executed before the transaction begins \(if the action is transactional\). They can modify the action input or halt execution by returning an error.

## ******Examples**

    # Add logging before transaction        iex>     input        ...>     |>         Ash.ActionInput    .    before_transaction    (    fn         input         ->        ...>           IO    .    puts    (    "Starting transaction for action"    )        ...>           input        ...>     end    )

## ******See also**

+ `after_transaction/2` for hooks that run after the transaction
+ `around_transaction/2` for hooks that wrap the entire transaction
+ `before_action/3` for hooks that run before the action \(inside transaction\)





# delete\_argument\(input, argument\_or\_arguments\)




    @spec     delete_argument(
      input ::     t    (),
      argument_or_arguments ::     atom    () |     String.t    () | [    atom    () |     String.t    ()]
    ) ::     t    ()


Deletes one or more arguments from the subject.

## ******Parameters**

+ `subject` - The subject to delete arguments from
+ `arguments` - Single argument name or list of argument names to delete





# fetch\_argument\(input, argument\)




    @spec     fetch_argument(    t    (),     atom    () |     String.t    ()) :: {:ok,     term    ()} | :error


Fetches the value of an argument provided to the input.

Returns `{:ok, value}` if the argument exists, or `:error` if not found. This is the safer alternative to `get_argument/2` when you need to distinguish between a `nil` value and a missing argument.

## ******Examples**

    # Fetch an argument that exists        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    priority    :         :high    }    )        ...>     |>         Ash.ActionInput    .    fetch_argument    (    :priority    )        {    :ok    ,         :high    }    
        # Fetch an argument that doesn't exist        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    fetch_argument    (    :missing_arg    )        :error    
        # Distinguish between nil and missing arguments        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    optional_field    :         nil    }    )        ...>     |>         Ash.ActionInput    .    fetch_argument    (    :optional_field    )        {    :ok    ,         nil    }    
        # Use in conditional logic        iex>     input         =         MyApp.Post         |>         Ash.ActionInput    .    for_action    (    :process    ,         %{    }    )        iex>     case         Ash.ActionInput    .    fetch_argument    (    input    ,         :mode    )         do        ...>           {    :ok    ,         mode    }         ->         "Processing in     #{    mode    }     mode"        ...>           :error         ->         "Using default processing mode"        ...>     end        "Using default processing mode"

## ******See also**

+ `get_argument/2` for simpler argument access
+ `set_argument/3` for setting argument values
+ `for_action/4` for providing initial arguments





# for\_action\(resource\_or\_input, action, params, opts \\\\ \[\]\)




    @spec     for_action(
      resource_or_input ::     Ash.Resource.t    () |     t    (),
      action ::     atom    (),
      params ::     map    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Creates a new input for a generic action.

This is the primary way to create action inputs for generic actions. It validates the action exists, sets up the input with proper defaults, and validates any provided arguments according to the action's argument definitions.

## ******Examples**

    # Create input for a simple action        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    message    :         "Hello"    }    )        %    Ash.ActionInput    {    action    :         %{    name    :         :send_notification    }    ,         arguments    :         %{    message    :         "Hello"    }    ,         ...    }    
        # Create input with options        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :complex_action    ,         %{    data    :         "test"    }    ,        ...>           actor    :         current_user    ,         authorize?    :         true    )        %    Ash.ActionInput    {    arguments    :         %{    data    :         "test"    }    ,         ...    }    
        # Create input and then modify it        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_context    (    %{    source    :         "api"    }    )        iex>     input    .    action    .    name        :example

## ******Options**

+ 
`:domain` \(`Ash.Domain`\) - The domain to use for the action. The resource's domain is used by default.

+ 
`:context` \(`map/0`\) - Context to set on the action input. The default value is `%{}`.

+ 
`:authorize?` - Whether or not to run authorization on the action. Default behavior of this option is controlled by the domain.

+ 
`:tenant` \(`term/0`\) - The tenant to use for the action.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:actor` \(`term/0`\) - The actor performing the action

+ 
`:skip_unknown_inputs` - A list of unknown inputs to skip. Use `:*` to skip all unknown inputs.

+ 
`:tracer` \(`term/0`\) - A tracer or list of tracers to trace action execution.

+ 
`:private_arguments` \(`map/0`\) - A list of private arguments to be set before the action is invoked. The default value is `%{}`.


## ******See also**

+ `new/2` for creating basic inputs
+ `set_argument/3` for adding arguments after creation
+ `Ash.run_action/2` for executing the action with the input
+ `d:Ash.Resource.Dsl.actions.action` for defining generic actions
+ Generic Actions Guide for understanding generic actions
+ Actions Guide for general action concepts





# get\_argument\(input, argument\)




    @spec     get_argument(    t    (),     atom    () |     String.t    ()) ::     term    ()


Gets the value of an argument provided to the input.

Returns the argument value if found, or `nil` if not found. Arguments are validated and cast according to the action's argument definitions when set.

## ******Examples**

    # Get an argument that exists        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_email    ,         %{    recipient    :         "user@example.com"    }    )        ...>     |>         Ash.ActionInput    .    get_argument    (    :recipient    )        "user@example.com"    
        # Get an argument that doesn't exist returns nil        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_email    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    get_argument    (    :missing_arg    )        nil    
        # Arguments can be accessed by string or atom key        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    "message"         =>         "hello"    }    )        ...>     |>         Ash.ActionInput    .    get_argument    (    :message    )        "hello"

## ******See also**

+ `fetch_argument/2` for safer argument access with explicit error handling
+ `set_argument/3` for setting argument values
+ `for_action/4` for providing initial arguments





# new\(resource, domain \\\\ nil\)




    @spec     new(    Ash.Resource.t    (),     Ash.Domain.t    ()) ::     t    ()


Creates a new action input from a resource.

This creates a basic action input struct that can be used as a starting point for building inputs for generic actions. Use `for_action/4` to create an input bound to a specific action.

## ******Examples**

    # Create a new action input for a resource        iex>     Ash.ActionInput    .    new    (    MyApp.Post    )        %    Ash.ActionInput    {    resource    :         MyApp.Post    ,         domain    :         nil    ,         ...    }    

        # Usually you'll want to use for_action/4 instead        iex>     MyApp.Post         |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    message    :         "Hello"    }    )        %    Ash.ActionInput    {    action    :         %{    name    :         :send_notification    }    ,         arguments    :         %{    message    :         "Hello"    }    ,         ...    }

## ******See also**

+ `for_action/4` for creating action-specific inputs
+ `set_argument/3` for adding arguments
+ `set_context/2` for adding context





# set\_argument\(input, argument, value\)




    @spec     set_argument(input ::     t    (), name ::     atom    () |     String.t    (), value ::     term    ()) ::     t    ()


Sets an argument value on the action input.

The argument value is validated and cast according to the action's argument definition. If validation fails, errors will be added to the input and it will be marked as invalid.

## ******Examples**

    # Set a simple argument        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_argument    (    :message    ,         "Hello World"    )        ...>     |>         Ash.ActionInput    .    get_argument    (    :message    )        "Hello World"    
        # Set multiple arguments by chaining        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :complex_action    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_argument    (    :priority    ,         :high    )        ...>     |>         Ash.ActionInput    .    set_argument    (    :batch_size    ,         100    )        iex>     Ash.ActionInput    .    get_argument    (    input    ,         :priority    )        :high    
        # Arguments are validated according to type        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :schedule_job    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_argument    (    :run_at    ,         ~U[2024-01-01 10:00:00Z]    )        iex>     input    .    valid?        true

## ******See also**

+ `get_argument/2` for retrieving argument values
+ `set_private_argument/3` for setting private arguments
+ `for_action/4` for providing initial arguments





# set\_context\(input, map\)




    @spec     set_context(    t    (),     map    () | nil) ::     t    ()


Deep merges the provided map into the input context.

Context is used to pass additional information through the action pipeline that can be accessed by action implementations, changes, and validations. The context is merged deeply, so nested maps will be combined rather than replaced.

Do not use the `private` key in your custom context, as that is reserved for internal use.

## ******Examples**

    # Set simple context values        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    new    (    )        ...>     |>         Ash.ActionInput    .    set_context    (    %{    source    :         "api"    ,         user_id    :         123    }    )        ...>     |>         then    (    &         &1    .    context    .    source    )        "api"    
        # Context is merged deeply        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    new    (    )        ...>     |>         Ash.ActionInput    .    set_context    (    %{    metadata    :         %{    version    :         1    }    }    )        ...>     |>         Ash.ActionInput    .    set_context    (    %{    metadata    :         %{    trace_id    :         "abc123"    }    }    )        iex>     input    .    context    .    metadata        %{    version    :         1    ,         trace_id    :         "abc123"    }    
        # Use context in action implementations        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :process_data    ,         %{    data    :         "test"    }    )        ...>     |>         Ash.ActionInput    .    set_context    (    %{        ...>           request_id    :         "req_456"    ,        ...>           feature_flags    :         %{    new_algorithm    :         true    }        ...>     }    )

## ******See also**

+ `for_action/4` for setting context when creating inputs
+ Action implementations can access context for custom logic
+ `set_tenant/2` for tenant-specific context





# set\_private\_argument\(input, name, value\)




    @spec     set_private_argument(input ::     t    (), name ::     atom    (), value ::     term    ()) ::     t    ()


Sets a private argument value on the action input.

Private arguments are not exposed in the public API and can only be set internally. This function will only work for arguments marked as `public?: false` in the action definition.

## ******Examples**

    # Set a private argument (assuming :internal_flag is private)        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_private_argument    (    :internal_flag    ,         true    )        ...>     |>         Ash.ActionInput    .    get_argument    (    :internal_flag    )        true    
        # Attempting to set a public argument as private will error        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_private_argument    (    :public_arg    ,         "value"    )        iex>     input    .    valid?        false    
        # Use in action implementations for internal state        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :complex_workflow    ,         %{    data    :         "user_data"    }    )        ...>     |>         Ash.ActionInput    .    set_private_argument    (    :workflow_step    ,         1    )

## ******See also**

+ `set_argument/3` for setting public arguments
+ `get_argument/2` for retrieving argument values
+ Action argument definitions with `public?: false`





# set\_tenant\(input, tenant\)




    @spec     set_tenant(    t    (),     Ash.ToTenant.t    ()) ::     t    ()


Sets the tenant to use when calling the action.

In multitenant applications, this configures which tenant's data the action should operate on. The tenant value is used for data isolation and access control.

## ******Examples**

    # Set tenant using a string identifier        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    new    (    )        ...>     |>         Ash.ActionInput    .    set_tenant    (    "org_123"    )        ...>     |>         then    (    &         &1    .    tenant    )        "org_123"    
        # Set tenant using a struct that implements Ash.ToTenant        iex>     org         =         %    MyApp.Organization    {    id    :         456    }        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :send_notification    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_tenant    (    org    )        iex>     input    .    tenant         ==         org        true    
        # Use with action execution        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :cleanup    ,         %{    }    )        ...>     |>         Ash.ActionInput    .    set_tenant    (    "tenant_456"    )        ...>     |>         Ash    .    run_action    (    )

## ******See also**

+ `for_action/4` for setting tenant when creating inputs
+ `Ash.ToTenant` protocol for custom tenant conversion
+ `set_context/2` for adding tenant to action context





# Ash.Changeset 

Changesets are used to create and update data in Ash.

Create a changeset with `new/1` or `new/2`, and alter the attributes and relationships using the functions provided in this module. Nothing in this module actually incurs changes in a data layer. To commit a changeset, see `Ash.create/2` and `Ash.update/2`.

# Changeset lifecycle

## Action Lifecycle

The following example illustrates the hook lifecycle of a changeset.

    defmodule         AshChangesetLifeCycleExample         do    
          def         change    (    changeset    ,         _    ,         _    )         do    
            changeset    
            # execute code both before and after the transaction    
            |>         Ash.Changeset    .    around_transaction    (    fn         changeset    ,         callback         ->    
              callback    .    (    changeset    )    
            end    )    
            # execute code before the transaction is started. Use for things like external calls    
            |>         Ash.Changeset    .    before_transaction    (    fn         changeset         ->         changeset         end    )    
            # execute code in the transaction, before and after the data layer is called    
            |>         Ash.Changeset    .    around_action    (    fn         changeset    ,         callback         ->    
              callback    .    (    changeset    )    
            end    )    
            # execute code in the transaction, before the data layer is called    
            |>         Ash.Changeset    .    before_action    (    fn         changeset         ->         changeset         end    )    
            # execute code in the transaction, after the data layer is called, only if the action is successful    
            |>         Ash.Changeset    .    after_action    (    fn         changeset    ,         result         ->         {    :ok    ,         result    }         end    )    
            # execute code after the transaction, both in success and error cases    
            |>         Ash.Changeset    .    after_transaction    (    fn         changeset    ,         success_or_error_result         ->         success_or_error_result         end    
          end        end





# Summary


## **Types** 


after\_action\_fun\(\) 


Function type for after action hooks.




after\_transaction\_fun\(\) 


Function type for after transaction hooks.




around\_action\_callback\(\) 


Callback function type for around action hooks.




around\_action\_fun\(\) 


Function type for around action hooks.




around\_action\_result\(\) 


Result type for around action callbacks.




around\_transaction\_callback\(\) 


Callback function type for around transaction hooks.




around\_transaction\_fun\(\) 


Function type for around transaction hooks.




around\_transaction\_result\(\) 


Result type for around transaction callbacks.




before\_action\_fun\(\) 


Function type for before action hooks.




before\_transaction\_fun\(\) 


Function type for before transaction hooks.




error\_info\(\) 



manage\_relationship\_type\(\) 


The type of relationship management strategy to use.




phase\(\) 


The current phase of changeset processing.




t\(\) 


The changeset struct containing all the information about a pending action.





## **Functions** 


accessing\(changeset, types \\\\ \[:attributes, :relationships, :calculations, :attributes\], only\_public? \\\\ true\) 


Returns a list of attributes, aggregates, relationships, and calculations that are being loaded




add\_error\(changeset, errors, path \\\\ \[\]\) 


Add an error to the errors list and mark the changeset as invalid.




after\_action\(changeset, func, opts \\\\ \[\]\) 


Adds an after\_action hook to the changeset.




after\_transaction\(changeset, func, opts \\\\ \[\]\) 


Adds an after\_transaction hook to the changeset. Cannot be called within other hooks.




apply\_attributes\(changeset, opts \\\\ \[\]\) 


Returns the original data with attribute changes merged, if the changeset is valid.




around\_action\(changeset, func, opts \\\\ \[\]\) 


Adds an around\_action hook to the changeset.




around\_transaction\(changeset, func, opts \\\\ \[\]\) 


Adds an around\_transaction hook to the changeset.




atomic\_defaults\(changeset\) 



atomic\_ref\(changeset, field\) 


Gets a reference to a field, or the current atomic update expression of that field.




atomic\_update\(changeset, atomics\) 


Adds multiple atomic changes to the changeset




atomic\_update\(changeset, key, value\) 


Adds an atomic change to the changeset.




attribute\_present?\(changeset, attribute\) 


Checks if an attribute is not nil, either in the original data, or that it is not being changed to a `nil` value if it is changing.




before\_action\(changeset, func, opts \\\\ \[\]\) 


Adds a before\_action hook to the changeset.




before\_transaction\(changeset, func, opts \\\\ \[\]\) 


Adds a before\_transaction hook to the changeset.




change\_attribute\(changeset, attribute, value\) 


Adds a change to the changeset, unless the value matches the existing value.




change\_attributes\(changeset, changes\) 


Calls `change_attribute/3` for each key/value pair provided.




change\_default\_attribute\(changeset, attribute, value\) 


The same as `change_attribute`, but annotates that the attribute is currently holding a default value.




change\_new\_attribute\(changeset, attribute, value\) 


Change an attribute only if is not currently being changed




change\_new\_attribute\_lazy\(changeset, attribute, func\) 


Change an attribute if is not currently being changed, by calling the provided function.




changing\_attribute?\(changeset, attribute\) 


Returns true if an attribute exists in the changes.




changing\_attributes?\(changeset\) 


Returns true if any attributes on the resource are being changed.




changing\_relationship?\(changeset, relationship\) 


Returns true if a relationship exists in the changes




clear\_change\(changeset, field\) 


Clears an attribute or relationship change off of the changeset.




delete\_argument\(changeset, argument\_or\_arguments\) 


Remove an argument from the changeset




deselect\(changeset, fields\) 


Ensure the the specified attributes are `nil` in the changeset results.




ensure\_selected\(changeset, fields\) 


Ensures that the given attributes are selected.




expand\_upsert\_fields\(fields, resource\) 


Turns the special case \{:replace, fields\}, :replace\_all and \{:replace\_all\_except, fields\} upsert\_fields options into a list of fields




fetch\_argument\(changeset, argument\) 


Fetches the value of an argument provided to the changeset or `:error`.




fetch\_argument\_or\_attribute\(changeset, argument\_or\_attribute\) 


Fetches the value of an argument provided to the changeset, falling back to `Ash.Changeset.fetch_attribute/2` if nothing was provided.




fetch\_argument\_or\_change\(changeset, attribute\) 


Gets the value of an argument provided to the changeset, falling back to `Ash.Changeset.fetch_change/2` if nothing was provided.




fetch\_attribute\(changeset, attribute\) 


Fetches the changing value or the original value of an attribute.




fetch\_change\(changeset, attribute\) 


Gets the new value for an attribute, or `:error` if it is not being changed.




fetch\_data\(changeset, attribute\) 


Gets the original value for an attribute, or `:error` if it is not available.




filter\(changeset, expr\) 


Adds a filter for a record being updated or destroyed.




for\_action\(initial, action, params \\\\ %\{\}, opts \\\\ \[\]\) 


Constructs a changeset for a given action, and validates it.




for\_create\(initial, action, params \\\\ %\{\}, opts \\\\ \[\]\) 


Constructs a changeset for a given create action, and validates it.




for\_destroy\(initial, action\_or\_name, params \\\\ %\{\}, opts \\\\ \[\]\) 


Constructs a changeset for a given destroy action, and validates it.




for\_update\(initial, action, params \\\\ %\{\}, opts \\\\ \[\]\) 


Constructs a changeset for a given update action, and validates it.




force\_change\_attribute\(changeset, attribute, value\) 


Changes an attribute even if it isn't writable




force\_change\_attributes\(changeset, changes\) 


Calls `force_change_attribute/3` for each key/value pair provided.




force\_change\_new\_attribute\(changeset, attribute, value\) 


Force change an attribute if it is not currently being changed.




force\_change\_new\_attribute\_lazy\(changeset, attribute, func\) 


Force change an attribute if it is not currently being changed, by calling the provided function.




force\_delete\_argument\(changeset, argument\_or\_arguments\) 


Remove an argument from the changeset, not warning if the changeset has already been validated.




force\_set\_argument\(changeset, argument, value\) 


Add an argument to the changeset, which will be provided to the action.




force\_set\_arguments\(changeset, map\) 


Merge a map of arguments to the arguments list.




fully\_atomic\_changeset\(resource, action, params, opts \\\\ \[\]\) 



get\_argument\(changeset, argument\) 


Gets the value of an argument provided to the changeset.




get\_argument\_or\_attribute\(changeset, attribute\) 


Gets the value of an argument provided to the changeset, falling back to `Ash.Changeset.get_attribute/2` if nothing was provided.




get\_attribute\(changeset, attribute\) 


Gets the changing value or the original value of an attribute.




get\_data\(changeset, attribute\) 


Gets the original value for an attribute




handle\_errors\(changeset, func\) 


Sets a custom error handler on the changeset.




is\_valid\(changeset\) 


A guard which checks if the Changeset is valid.




load\(changeset, load\) 


Calls the provided load statement on the result of the action at the very end of the action.




loading?\(changeset, path\) 


Returns true if the field/relationship or path to field/relationship is being loaded.




manage\_relationship\(changeset, relationship, input, opts \\\\ \[\]\) 


Manages the related records by creating, updating, or destroying them as necessary.




new\(record\_or\_resource\) 


Returns a new changeset over a resource.




prepare\_changeset\_for\_action\(changeset, action, opts\) 



present?\(changeset, attribute\) 


Checks if an argument is not nil or an attribute is not nil, either in the original data, or that it is not being changed to a `nil` value if it is changing.




put\_context\(changeset, key, value\) 


Puts a key/value in the changeset context that can be used later.




run\_before\_transaction\_hooks\(changeset\) 



select\(changeset, fields, opts \\\\ \[\]\) 


Ensure that only the specified attributes are present in the results.




selecting?\(changeset, field\) 



set\_argument\(changeset, argument, value\) 


Add an argument to the changeset, which will be provided to the action.




set\_arguments\(changeset, map\) 


Merge a map of arguments to the arguments list.




set\_context\(changeset, map\) 


Deep merges the provided map into the changeset context that can be used later.




set\_private\_argument\(changeset, argument, value\) 


Add a private argument to the changeset, which will be provided to the action.




set\_result\(changeset, result\) 


Set the result of the action. This will prevent running the underlying datalayer behavior




set\_tenant\(changeset, tenant\) 



timeout\(changeset, timeout, default \\\\ nil\) 



update\_change\(changeset, attribute, fun\) 


Updates an existing attribute change by applying a function to it.




with\_hooks\(changeset, func, opts \\\\ \[\]\) 


Wraps a function in the before/after action hooks of a changeset.




# Types




# after\_action\_fun\(\)




    @type     after_action_fun() :: (    t    (),     Ash.Resource.record    () ->
                             {:ok,     Ash.Resource.record    ()}
                             | {:ok,     Ash.Resource.record    (),
                                [    Ash.Notifier.Notification.t    ()]}
                             | {:error,     any    ()})


Function type for after action hooks.

Receives the changeset and the successfully created/updated record, and can return the record optionally with notifications, or an error.





# after\_transaction\_fun\(\)




    @type     after_transaction_fun() :: (    t    (),
                                {:ok,     Ash.Resource.record    ()}
                                | {:error,     any    ()} ->
                                  {:ok,     Ash.Resource.record    ()} | {:error,     any    ()})


Function type for after transaction hooks.

Receives the changeset and the result \(success or failure\) of the action, and returns the result \(potentially modified\).





# around\_action\_callback\(\)




    @type     around_action_callback() :: (    t    () ->     around_action_result    ())


Callback function type for around action hooks.

A function that takes a changeset and returns an around action result.





# around\_action\_fun\(\)




    @type     around_action_fun() :: (    t    (),     around_action_callback    () ->     around_action_result    ())


Function type for around action hooks.

Receives a changeset and a callback function that must be called with the changeset.





# around\_action\_result\(\)




    @type     around_action_result() ::
      {:ok,     Ash.Resource.record    (),     t    (),
       %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:error,     Ash.Error.t    ()}


Result type for around action callbacks.

Contains the successful result with record, changeset, and notifications, or an error.





# around\_transaction\_callback\(\)




    @type     around_transaction_callback() :: (    t    () ->     around_transaction_result    ())


Callback function type for around transaction hooks.

A function that takes a changeset and returns an around transaction result.





# around\_transaction\_fun\(\)




    @type     around_transaction_fun() :: (    t    (),     around_transaction_callback    () ->
                                       around_transaction_result    ())


Function type for around transaction hooks.

Receives a changeset and a callback function that must be called with the changeset.





# around\_transaction\_result\(\)




    @type     around_transaction_result() :: {:ok,     Ash.Resource.record    ()} | {:error,     any    ()}


Result type for around transaction callbacks.

Contains either a successful result with the record or an error.





# before\_action\_fun\(\)




    @type     before_action_fun() :: (    t    () ->
                                  t    ()
                              | {    t    (),
                                 %{notifications: [    Ash.Notifier.Notification.t    ()]}})


Function type for before action hooks.

Receives a changeset and returns a modified changeset, optionally with notifications.





# before\_transaction\_fun\(\)




    @type     before_transaction_fun() :: (    t    () ->     t    ())


Function type for before transaction hooks.

Receives a changeset and returns a modified changeset.





# error\_info\(\)




    @type     error_info() ::     Ash.Error.error_input    ()





# manage\_relationship\_type\(\)




    @type     manage_relationship_type() ::
      :append_and_remove | :append | :remove | :direct_control | :create


The type of relationship management strategy to use.

Defines how related records should be handled when managing relationships.





# phase\(\)




    @type     phase() ::
      :around_transaction
      | :around_action
      | :after_transaction
      | :before_transaction
      | :after_action
      | :before_action
      | :validate
      | :pending
      | :atomic


The current phase of changeset processing.

Represents where the changeset is in its lifecycle, from pending through various hook phases.





# t\(\)




    @type     t() :: %Ash.Changeset{
      __validated_for_action__:     atom    () | nil,
      action:     Ash.Resource.Actions.action    () | nil,
      action_failed?:     boolean    (),
      action_select:     term    (),
      action_type:     Ash.Resource.Actions.action_type    () | nil,
      added_filter:     Ash.Filter.t    () | nil,
      after_action: [    after_action_fun    () | {    after_action_fun    (),     map    ()}],
      after_transaction: [
            after_transaction_fun    () | {    after_transaction_fun    (),     map    ()}
      ],
      arguments: %{optional(    atom    ()) =>     any    ()},
      around_action: [    around_action_fun    () | {    around_action_fun    (),     map    ()}],
      around_transaction: [
            around_transaction_fun    () | {    around_transaction_fun    (),     map    ()}
      ],
      atomic_after_action:     term    (),
      atomic_changes:     term    (),
      atomic_validations:     term    (),
      atomics:     Keyword.t    (),
      attribute_changes:     term    (),
      attributes: %{optional(    atom    ()) =>     any    ()},
      before_action: [    before_action_fun    () | {    before_action_fun    (),     map    ()}],
      before_transaction: [
            before_transaction_fun    () | {    before_transaction_fun    (),     map    ()}
      ],
      casted_arguments:     term    (),
      casted_attributes:     term    (),
      context:     map    (),
      context_changes:     term    (),
      data:     Ash.Resource.record    () | nil,
      defaults: [    atom    ()],
      dirty_hooks:     term    (),
      domain:     module    () | nil,
      errors: [    Ash.Error.t    ()],
      filter:     Ash.Filter.t    () | nil,
      handle_errors:
        nil
        | (    t    (), error ::     any    () ->
             :ignore |     t    () | (error ::     any    ()) | {error ::     any    (),     t    ()}),
      invalid_keys:     MapSet.t    (),
      load:     keyword    (    keyword    ()),
      no_atomic_constraints:     term    (),
      params: %{optional(    atom    () |     binary    ()) =>     any    ()},
      phase:     phase    (),
      relationships: %{
        optional(    atom    ()) =>
          %{optional(    atom    () |     binary    ()) =>     any    ()}
          | [%{optional(    atom    () |     binary    ()) =>     any    ()}]
      },
      resource:     module    (),
      select: [    atom    ()] | nil,
      tenant:     term    (),
      timeout:     pos_integer    () | nil,
      to_tenant:     term    (),
      valid?:     boolean    ()
    }


The changeset struct containing all the information about a pending action.

This struct tracks changes to attributes, arguments for the action, validation state, hooks to run at various points, and other metadata needed to execute an action.





# Functions




# accessing\(changeset, types \\\\ \[:attributes, :relationships, :calculations, :attributes\], only\_public? \\\\ true\)



Returns a list of attributes, aggregates, relationships, and calculations that are being loaded

Provide a list of field types to narrow down the returned results.





# add\_error\(changeset, errors, path \\\\ \[\]\)




    @spec     add_error(    t    (),     Ash.Error.error_input    (), path ::     Ash.Error.path_input    ()) ::     t    ()


Add an error to the errors list and mark the changeset as invalid.

See `Ash.Error.to_ash_error/3` for more on supported values for `error`





# after\_action\(changeset, func, opts \\\\ \[\]\)




    @spec     after_action(
      changeset ::     t    (),
      fun ::     after_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an after\_action hook to the changeset.

After action hooks run within the database transaction after the data layer action succeeds. They are perfect for:

+ Creating related records that depend on the main action's result
+ Sending notifications with the final record data
+ Updating derived data or maintaining referential integrity
+ Triggering business logic that needs the persisted record
+ Creating audit trails with the actual saved data

The hook receives both the changeset and the successfully created/updated record. Any errors returned will roll back the entire transaction.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Examples**

    # Create related audit record with the final data        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :update_profile    ,         %{    email    :         "new@example.com"    }    )        iex>     changeset         =         Ash.Changeset    .    after_action    (    changeset    ,         fn         changeset    ,         updated_user         ->        ...>           {    :ok    ,         _audit    }         =         MyApp.AuditLog    .    create    (    %{        ...>             action    :         "profile_updated"    ,        ...>             user_id    :         updated_user    .    id    ,        ...>             changes    :         changeset    .    attributes    ,        ...>             actor_id    :         changeset    .    context    .    actor    .    id    ,        ...>             timestamp    :         DateTime    .    utc_now    (    )        ...>           }    )        ...>           {    :ok    ,         updated_user    }        ...>     end    )    
        # Send notification with the final record        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Order    ,         :create    ,         %{    total    :         100.00    }    )        iex>     changeset         =         Ash.Changeset    .    after_action    (    changeset    ,         fn         _changeset    ,         order         ->        ...>           NotificationService    .    send_order_confirmation    (    %{        ...>             order_id    :         order    .    id    ,        ...>             customer_email    :         order    .    customer_email    ,        ...>             total    :         order    .    total    ,        ...>             order_number    :         order    .    number          # Generated by the database        ...>           }    )        ...>           {    :ok    ,         order    }        ...>     end    )    
        # Update related records that depend on the main record        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :publish    ,         %{    title    :         "My Post"    }    )        iex>     changeset         =         Ash.Changeset    .    after_action    (    changeset    ,         fn         _changeset    ,         post         ->        ...>           # Update author's post count        ...>           {    :ok    ,         _author    }         =         MyApp.User        ...>           |>         Ash.Changeset    .    for_update    (    :increment_post_count    ,         %{    }    )        ...>           |>         Ash    .    update    (    )        ...>        ...>           {    :ok    ,         post    }        ...>     end    )

## ******See also**

+ `before_action/3` for hooks that run before the data layer action
+ `after_transaction/3` for hooks that run after the transaction commits
+ `around_action/2` for hooks that wrap the data layer action





# after\_transaction\(changeset, func, opts \\\\ \[\]\)




    @spec     after_transaction(
      changeset ::     t    (),
      fun ::     after_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an after\_transaction hook to the changeset. Cannot be called within other hooks.

After transaction hooks run outside the database transaction and are called regardless of whether the action succeeded or failed. They are essential for:

+ Cleanup operations that must happen regardless of success/failure
+ External service notifications that shouldn't be rolled back
+ Logging final outcomes for auditing purposes
+ Releasing external resources or locks
+ Sending emails or notifications that should persist even if the action failed

The hook receives the changeset and either `{:ok, result}` or `{:error, error}`, allowing you to handle both success and failure cases appropriately.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Examples**

    # Send notification regardless of order creation success/failure        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Order    ,         :create    ,         %{    total    :         100.00    }    )        iex>     changeset         =         Ash.Changeset    .    after_transaction    (    changeset    ,         fn         changeset    ,         result         ->        ...>           case         result         do        ...>             {    :ok    ,         order    }         ->        ...>               NotificationService    .    order_created_successfully    (    order    .    id    ,         changeset    .    context    .    actor    )        ...>             {    :error    ,         _error    }         ->        ...>               NotificationService    .    order_creation_failed    (    changeset    .    attributes    ,         changeset    .    context    .    actor    )        ...>           end        ...>           result          # Always return the original result        ...>     end    )    
        # Release external resources or cleanup        iex>     changeset         =         Ash.Changeset    .    for_update    (    file    ,         :process    ,         %{    status    :         "processing"    }    )        iex>     changeset         =         Ash.Changeset    .    after_transaction    (    changeset    ,         fn         changeset    ,         result         ->        ...>           # Always release the file lock, regardless of processing outcome        ...>           ExternalFileService    .    release_lock    (    changeset    .    data    .    file_path    )        ...>        ...>           case         result         do        ...>             {    :ok    ,         processed_file    }         ->        ...>               Logger    .    info    (    "File processing completed successfully:     #{    processed_file    .    id    }    "    )        ...>             {    :error    ,         error    }         ->        ...>               Logger    .    error    (    "File processing failed:     #{    inspect    (    error    )    }    "    )        ...>               # Could trigger retry mechanism here        ...>           end        ...>           result        ...>     end    )    
        # Audit final outcome for compliance        iex>     changeset         =         Ash.Changeset    .    for_update    (    sensitive_record    ,         :update    ,         %{    classification    :         "top_secret"    }    )        iex>     changeset         =         Ash.Changeset    .    after_transaction    (    changeset    ,         fn         changeset    ,         result         ->        ...>           outcome         =         case         result         do        ...>             {    :ok    ,         _    }         ->         "success"        ...>             {    :error    ,         _    }         ->         "failure"        ...>           end        ...>        ...>           ComplianceLogger    .    log_security_action    (    %{        ...>             action    :         :update_classification    ,        ...>             actor    :         changeset    .    context    .    actor    ,        ...>             resource_id    :         changeset    .    data    .    id    ,        ...>             outcome    :         outcome    ,        ...>             timestamp    :         DateTime    .    utc_now    (    )        ...>           }    )        ...>           result        ...>     end    )

## ******See also**

+ `after_action/3` for hooks that run within the transaction on success only
+ `before_transaction/3` for hooks that run before the transaction starts
+ `around_transaction/2` for hooks that wrap the entire transaction





# apply\_attributes\(changeset, opts \\\\ \[\]\)




    @spec     apply_attributes(    t    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.record    ()} | {:error,     t    ()}


Returns the original data with attribute changes merged, if the changeset is valid.

Options:

+ force? - applies current attributes even if the changeset is not valid





# around\_action\(changeset, func, opts \\\\ \[\]\)




    @spec     around_action(
      changeset ::     t    (),
      fun ::     around_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an around\_action hook to the changeset.

Around action hooks wrap the data layer action execution within the transaction. This is a specialized hook primarily useful for:

+ Debugging and development tooling that needs to wrap action execution
+ Action timing and performance monitoring for profiling
+ Testing frameworks that need to intercept action execution
+ Advanced error handling that requires wrapping the action itself

Your function receives the changeset and a callback that must be called with a changeset. The callback returns `{:ok, result, changeset, instructions}` or `{:error, error}`. You can modify these values, but must return the same structure.

**Warning**: This is an advanced hook that runs within the database transaction. You *must* call the callback function. For most use cases, `before_action/3` and `after_action/3` are simpler and more appropriate.

## ******Examples**

    # Monitor action execution time for debugging        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Order    ,         :create    ,         %{    total    :         100.00    }    )        iex>     changeset         =         Ash.Changeset    .    around_action    (    changeset    ,         fn         changeset    ,         callback         ->        ...>           start_time         =         System    .    monotonic_time    (    :microsecond    )        ...>           result         =         callback    .    (    changeset    )        ...>           duration         =         System    .    monotonic_time    (    :microsecond    )         -         start_time        ...>        ...>           Logger    .    debug    (    "Action     #{    changeset    .    action    .    name    }     took     #{    duration    }    μs"    )        ...>           result        ...>     end    )

## ******See also**

+ `before_action/3` and `after_action/3` for most workflow needs
+ `around_transaction/2` for wrapping the entire transaction
+ Multi-step actions guide for complex workflow patterns





# around\_transaction\(changeset, func, opts \\\\ \[\]\)




    @spec     around_transaction(
      changeset ::     t    (),
      fun ::     around_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an around\_transaction hook to the changeset.

Around transaction hooks wrap the entire database transaction execution. This is a specialized hook primarily useful for:

+ Debugging and development tooling that needs to wrap transaction execution
+ Transaction timing and monitoring for performance analysis
+ Testing frameworks that need to intercept transaction behavior
+ Advanced transaction management that requires wrapping all hook execution

Your function receives the changeset and a callback that must be called with a changeset. The callback returns `{:ok, result}` or `{:error, error}`. You can modify these values, but must return the same structure.

**Warning**: This is an advanced hook that controls transaction execution. You *must* call the callback function. For most use cases, `before_transaction/3` and `after_transaction/3` are simpler and more appropriate.

## ******Examples**

    # Monitor transaction execution time        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Order    ,         :create    ,         %{    total    :         100.00    }    )        iex>     changeset         =         Ash.Changeset    .    around_transaction    (    changeset    ,         fn         changeset    ,         callback         ->        ...>           tx_start         =         System    .    monotonic_time    (    :microsecond    )        ...>           result         =         callback    .    (    changeset    )        ...>           tx_duration         =         System    .    monotonic_time    (    :microsecond    )         -         tx_start        ...>        ...>           Logger    .    debug    (    "Transaction for     #{    changeset    .    action    .    name    }     took     #{    tx_duration    }    μs"    )        ...>           result        ...>     end    )

## ******See also**

+ `before_transaction/3` and `after_transaction/3` for most workflow needs
+ `around_action/2` for wrapping the data layer action
+ Multi-step actions guide for complex workflow patterns





# atomic\_defaults\(changeset\)





# atomic\_ref\(changeset, field\)



Gets a reference to a field, or the current atomic update expression of that field.





# atomic\_update\(changeset, atomics\)




    @spec     atomic_update(    t    (),     map    () |     Keyword.t    ()) ::     t    ()


Adds multiple atomic changes to the changeset

See `atomic_update/3` for more information.





# atomic\_update\(changeset, key, value\)




    @spec     atomic_update(    t    (),     atom    (), {:atomic,     Ash.Expr.t    ()} |     Ash.Expr.t    ()) ::     t    ()


Adds an atomic change to the changeset.

Atomic changes are applied by the data layer, and as such have guarantees that are not given by changes that are based on looking at the previous value and updating it. Here is an example of a change that is not safe to do concurrently:

    change         fn         changeset    ,         _         ->    
          Ash.Changeset    .    change_attribute    (    changeset    ,         :score    ,         changeset    .    data    .    score         +         1    )        end

If two processes run this concurrently, they will both read the same value of `score`, and set the new score to the same value. This means that one of the increments will be lost. If you were to instead do this using `atomic_update`, you would get the correct result:

    Ash.Changeset    .    atomic_update    (    changeset    ,         :score    ,         expr    (    score         +         1    )    )

There are drawbacks/things to consider, however. The first is that atomic update results are not known until after the action is run. The following functional validation would not be able to enforce the score being less than 10, because the atomic happens after the validation.

    validate         fn         changeset    ,         _         ->    
          if         Ash.Changeset    .    get_attribute    (    changeset    ,         :score    )         <         10         do    
            :ok    
          else    
            {    :error    ,         field    :         :score    ,         message    :         "must be less than 10"    }    
          end        end

If you want to use atomic updates, it is suggested to write module-based validations & changes, and implement the appropriate atomic callbacks on those modules. All builtin validations and changes implement these callbacks in addition to the standard callbacks. Validations will only be run atomically when the entire action is being run atomically or if one of the relevant fields is being updated atomically.

## ******Examples**

    # Basic atomic increment        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    )        iex>     changeset         =         Ash.Changeset    .    atomic_update    (    changeset    ,         :view_count    ,         expr    (    view_count         +         1    )    )        iex>     changeset    .    atomics        [    view_count    :         %    Ash.Expr    {    ...    }    ]    
        # Multiple atomic updates        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :update    )        iex>     changeset         =         changeset        ...>     |>         Ash.Changeset    .    atomic_update    (    :login_count    ,         expr    (    login_count         +         1    )    )        ...>     |>         Ash.Changeset    .    atomic_update    (    :last_login    ,         expr    (    now    (    )    )    )        iex>     length    (    changeset    .    atomics    )        2    
        # Atomic update with conditional logic        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    )        iex>     changeset         =         Ash.Changeset    .    atomic_update    (    changeset    ,         :status    ,        ...>           expr    (    if         view_count         >         1000    ,         do    :         "popular"    ,         else    :         "normal"    )    )    
        # Using the map/keyword syntax for multiple atomics        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :update    )        iex>     changeset         =         Ash.Changeset    .    atomic_update    (    changeset    ,         %{        ...>           login_count    :         expr    (    login_count         +         1    )    ,        ...>           last_seen    :         expr    (    now    (    )    )        ...>     }    )

## ******See also**

+ `atomic_ref/2` for referencing atomic values in expressions
+ `fully_atomic_changeset/4` for creating fully atomic changesets
+ `change_attribute/3` for regular \(non-atomic\) attribute changes





# attribute\_present?\(changeset, attribute\)



Checks if an attribute is not nil, either in the original data, or that it is not being changed to a `nil` value if it is changing.

This also accounts for the `accessing_from` context that is set when using `manage_relationship`, so it is aware that a particular value *will* be set by `manage_relationship` even if it isn't currently being set.





# before\_action\(changeset, func, opts \\\\ \[\]\)




    @spec     before_action(
      changeset ::     t    (),
      fun ::     before_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before\_action hook to the changeset.

Before action hooks are essential for multi-step workflows where you need to:

+ Validate complex business logic that requires database queries
+ Set computed attributes based on other changes
+ Prepare data for external service calls
+ Implement conditional logic that depends on the current state

The hook runs after validations and changes but before the data layer action is executed. This gives you access to the final validated changeset while still being able to modify it.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Examples**

    # Set computed fields based on other attributes        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Order    ,         :create    ,         %{    items    :         [    %{    price    :         10    }    ,         %{    price    :         15    }    ]    }    )        iex>     changeset         =         Ash.Changeset    .    before_action    (    changeset    ,         fn         changeset         ->        ...>           total         =         changeset    .    attributes    .    items         |>         Enum    .    map    (    &         &1    .    price    )         |>         Enum    .    sum    (    )        ...>           tax         =         total         *         0.08        ...>           changeset        ...>           |>         Ash.Changeset    .    change_attribute    (    :subtotal    ,         total    )        ...>           |>         Ash.Changeset    .    change_attribute    (    :tax    ,         tax    )        ...>           |>         Ash.Changeset    .    change_attribute    (    :total    ,         total         +         tax    )        ...>     end    )    
        # Assign resources based on complex business logic        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Ticket    ,         :create    ,         %{    title    :         "Help needed"    ,         priority    :         :urgent    }    )        iex>     changeset         =         Ash.Changeset    .    before_action    (    changeset    ,         fn         changeset         ->        ...>           case         changeset    .    attributes    .    priority         do        ...>             :urgent         ->        ...>               # Query for available senior agents        ...>               agent         =         MyApp.Agent         |>         MyApp.Query    .    for_read    (    :available_senior    )         |>         MyApp    .    read_one!    (    )        ...>               Ash.Changeset    .    change_attribute    (    changeset    ,         :assigned_agent_id    ,         agent    .    id    )        ...>             _         ->        ...>               changeset        ...>           end        ...>     end    )    
        # Validate complex business rules that require database access        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :upgrade_plan    ,         %{    plan    :         :premium    }    )        iex>     changeset         =         Ash.Changeset    .    before_action    (    changeset    ,         fn         changeset         ->        ...>           existing_subscription         =         MyApp.Subscription        ...>           |>         MyApp.Query    .    filter    (    user_id         ==         ^    user    .    id    ,         status         ==         :active    )        ...>           |>         MyApp    .    read_one    (    )        ...>        ...>           case         existing_subscription         do        ...>             {    :ok    ,         %{    plan    :         :premium    }    }         ->        ...>               Ash.Changeset    .    add_error    (    changeset    ,         field    :         :plan    ,         message    :         "already on premium plan"    )        ...>             _         ->        ...>               changeset        ...>           end        ...>     end    )

## ******See also**

+ `after_action/3` for hooks that run after the action succeeds
+ `around_action/2` for hooks that wrap the entire action
+ `before_transaction/3` for hooks that run before the database transaction
+ Multi-step actions guide for complex workflow patterns





# before\_transaction\(changeset, func, opts \\\\ \[\]\)




    @spec     before_transaction(
      changeset ::     t    (),
      fun ::     before_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before\_transaction hook to the changeset.

Before transaction hooks run outside the database transaction and are ideal for:

+ Making external API calls that shouldn't be rolled back
+ Validating external resources or permissions
+ Setting up external state that the action depends on
+ Logging or auditing that should happen regardless of transaction success
+ Preparing data from external services

These hooks run before any database transaction is started, so they can't access the final result but can prepare the changeset with external data.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Examples**

    # Validate external service availability before processing        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Order    ,         :create    ,         %{    items    :         [    %{    sku    :         "ABC123"    }    ]    }    )        iex>     changeset         =         Ash.Changeset    .    before_transaction    (    changeset    ,         fn         changeset         ->        ...>           case         ExternalInventoryService    .    check_availability    (    changeset    .    attributes    .    items    )         do        ...>             {    :ok    ,         _    }         ->        ...>               changeset        ...>             {    :error    ,         :out_of_stock    }         ->        ...>               Ash.Changeset    .    add_error    (    changeset    ,         field    :         :items    ,         message    :         "items out of stock"    )        ...>           end        ...>     end    )    
        # Fetch and set data from external service        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    ,         %{    email    :         "user@example.com"    }    )        iex>     changeset         =         Ash.Changeset    .    before_transaction    (    changeset    ,         fn         changeset         ->        ...>           case         UserService    .    get_profile_data    (    changeset    .    attributes    .    email    )         do        ...>             {    :ok    ,         profile    }         ->        ...>               changeset        ...>               |>         Ash.Changeset    .    change_attribute    (    :display_name    ,         profile    .    name    )        ...>               |>         Ash.Changeset    .    change_attribute    (    :avatar_url    ,         profile    .    avatar    )        ...>             {    :error    ,         _    }         ->        ...>               changeset          # Continue without external data        ...>           end        ...>     end    )

## ******See also**

+ `before_action/3` for hooks that run within the transaction
+ `after_transaction/3` for hooks that run after the transaction completes
+ `around_transaction/2` for hooks that wrap the entire transaction





# change\_attribute\(changeset, attribute, value\)




    @spec     change_attribute(    t    (),     atom    (),     any    ()) ::     t    ()


Adds a change to the changeset, unless the value matches the existing value.

## ******Examples**

    # Basic attribute change        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attribute    (    changeset    ,         :title    ,         "New Title"    )        iex>     changeset    .    attributes        %{    title    :         "New Title"    }    
        # Change multiple attributes in sequence        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    )        iex>     changeset         =         changeset        ...>     |>         Ash.Changeset    .    change_attribute    (    :name    ,         "John Doe"    )        ...>     |>         Ash.Changeset    .    change_attribute    (    :email    ,         "john@example.com"    )        iex>     changeset    .    attributes        %{    name    :         "John Doe"    ,         email    :         "john@example.com"    }    
        # Value is cast according to the attribute type        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attribute    (    changeset    ,         :view_count    ,         "42"    )        iex>     changeset    .    attributes        %{    view_count    :         42    }

## ******See also**

+ `change_attributes/2` for changing multiple attributes at once
+ `force_change_attribute/3` for writing attributes not accepted by the action, or changing attributes in hooks
+ `change_new_attribute/3` for changing an attribute unless its already being changed
+ `update_change/3` for updating existing changes





# change\_attributes\(changeset, changes\)




    @spec     change_attributes(    t    (),     map    () |     Keyword.t    ()) ::     t    ()


Calls `change_attribute/3` for each key/value pair provided.

## ******Examples**

    # Change multiple attributes with a map        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attributes    (    changeset    ,         %{    title    :         "Hello World"    ,         content    :         "Post content"    }    )        iex>     changeset    .    attributes        %{    title    :         "Hello World"    ,         content    :         "Post content"    }    
        # Change multiple attributes with a keyword list        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attributes    (    changeset    ,         [    name    :         "John Doe"    ,         email    :         "john@example.com"    ,         age    :         30    ]    )        iex>     changeset    .    attributes        %{    name    :         "John Doe"    ,         email    :         "john@example.com"    ,         age    :         30    }    
        # Values are cast according to their attribute types        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attributes    (    changeset    ,         %{    view_count    :         "42"    ,         published    :         "true"    }    )        iex>     changeset    .    attributes        %{    view_count    :         42    ,         published    :         true    }

## ******See also**

+ `change_attribute/3` for changing individual attributes
+ `force_change_attribute/3` for writing attributes not accepted by the action, or changing attributes in hooks
+ `set_arguments/2` for setting action arguments





# change\_default\_attribute\(changeset, attribute, value\)




    @spec     change_default_attribute(    t    (),     atom    (),     any    ()) ::     t    ()


The same as `change_attribute`, but annotates that the attribute is currently holding a default value.

This information can be used in changes to see if a value was explicitly set or if it was set by being the default. Additionally, this is used in `upsert` actions to not overwrite existing values with the default.





# change\_new\_attribute\(changeset, attribute, value\)




    @spec     change_new_attribute(    t    (),     atom    (),     term    ()) ::     t    ()


Change an attribute only if is not currently being changed





# change\_new\_attribute\_lazy\(changeset, attribute, func\)




    @spec     change_new_attribute_lazy(    t    (),     atom    (), (->     any    ())) ::     t    ()


Change an attribute if is not currently being changed, by calling the provided function.

Use this if you want to only perform some expensive calculation for an attribute value only if there isn't already a change for that attribute.





# changing\_attribute?\(changeset, attribute\)




    @spec     changing_attribute?(    t    (),     atom    ()) ::     boolean    ()


Returns true if an attribute exists in the changes.

## ******Examples**

    # Check if an attribute is being changed        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attribute    (    changeset    ,         :title    ,         "New Title"    )        iex>     Ash.Changeset    .    changing_attribute?    (    changeset    ,         :title    )        true        iex>     Ash.Changeset    .    changing_attribute?    (    changeset    ,         :content    )        false    
        # Works with atomic updates too        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    )        iex>     changeset         =         Ash.Changeset    .    atomic_update    (    changeset    ,         :view_count    ,         {    :atomic    ,         expr    (    view_count         +         1    )    }    )        iex>     Ash.Changeset    .    changing_attribute?    (    changeset    ,         :view_count    )        true    
        # Check multiple attributes        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    change_attributes    (    changeset    ,         %{    name    :         "John"    ,         email    :         "john@example.com"    }    )        iex>     Ash.Changeset    .    changing_attribute?    (    changeset    ,         :name    )        true        iex>     Ash.Changeset    .    changing_attribute?    (    changeset    ,         :age    )        false

## ******See also**

+ `changing_attributes?/1` for checking if any attributes are changing
+ `changing_relationship?/2` for checking relationship changes
+ `present?/2` for checking if a value is present
+ `fetch_change/2` for getting the changed value





# changing\_attributes?\(changeset\)




    @spec     changing_attributes?(    t    ()) ::     boolean    ()


Returns true if any attributes on the resource are being changed.





# changing\_relationship?\(changeset, relationship\)




    @spec     changing_relationship?(    t    (),     atom    ()) ::     boolean    ()


Returns true if a relationship exists in the changes





# clear\_change\(changeset, field\)



Clears an attribute or relationship change off of the changeset.





# delete\_argument\(changeset, argument\_or\_arguments\)



Remove an argument from the changeset





# deselect\(changeset, fields\)




    @spec     deselect(    t    (), [    atom    ()] |     atom    ()) ::     t    ()


Ensure the the specified attributes are `nil` in the changeset results.





# ensure\_selected\(changeset, fields\)




    @spec     ensure_selected(    t    (), [    atom    ()] |     atom    ()) ::     t    ()


Ensures that the given attributes are selected.

The first call to `select/2` will *limit* the fields to only the provided fields. Use `ensure_selected/2` to say "select this field \(or these fields\) without deselecting anything else".

See `select/2` for more.





# expand\_upsert\_fields\(fields, resource\)



Turns the special case \{:replace, fields\}, :replace\_all and \{:replace\_all\_except, fields\} upsert\_fields options into a list of fields





# fetch\_argument\(changeset, argument\)




    @spec     fetch_argument(    t    (),     atom    ()) :: {:ok,     term    ()} | :error


Fetches the value of an argument provided to the changeset or `:error`.





# fetch\_argument\_or\_attribute\(changeset, argument\_or\_attribute\)




    @spec     fetch_argument_or_attribute(    t    (),     atom    ()) :: {:ok,     term    ()} | :error


Fetches the value of an argument provided to the changeset, falling back to `Ash.Changeset.fetch_attribute/2` if nothing was provided.

## ******Example**

    iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    ,         %{    title    :         "New Title"    }    )        iex>     Ash.Changeset    .    fetch_argument_or_attribute    (    changeset    ,         :title    )        {    :ok    ,         "New Title"    }        iex>     Ash.Changeset    .    fetch_argument_or_attribute    (    changeset    ,         :content    )        :error





# fetch\_argument\_or\_change\(changeset, attribute\)




    @spec     fetch_argument_or_change(    t    (),     atom    ()) :: {:ok,     any    ()} | :error


Gets the value of an argument provided to the changeset, falling back to `Ash.Changeset.fetch_change/2` if nothing was provided.





# fetch\_attribute\(changeset, attribute\)




    @spec     fetch_attribute(    t    (),     atom    ()) :: {:ok,     term    ()} | :error


Fetches the changing value or the original value of an attribute.

## ******Example**

    iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    ,         %{    title    :         "New Title"    }    )        iex>     Ash.Changeset    .    fetch_attribute    (    changeset    ,         :title    )        {    :ok    ,         "New Title"    }        iex>     Ash.Changeset    .    fetch_attribute    (    changeset    ,         :content    )        :error





# fetch\_change\(changeset, attribute\)




    @spec     fetch_change(    t    (),     atom    ()) :: {:ok,     any    ()} | :error


Gets the new value for an attribute, or `:error` if it is not being changed.





# fetch\_data\(changeset, attribute\)




    @spec     fetch_data(    t    (),     atom    ()) :: {:ok,     term    ()} | :error


Gets the original value for an attribute, or `:error` if it is not available.

## ******Example**

    iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    ,         %{    title    :         "New Title"    }    )        iex>     Ash.Changeset    .    fetch_data    (    changeset    ,         :title    )        {    :ok    ,         "Original Title"    }        iex>     Ash.Changeset    .    fetch_data    (    changeset    ,         :content    )        :error





# filter\(changeset, expr\)




    @spec     filter(    t    (),     Ash.Expr.t    ()) ::     t    ()


Adds a filter for a record being updated or destroyed.

Used by optimistic locking. See `Ash.Resource.Change.Builtins.optimistic_lock/1` for more.





# for\_action\(initial, action, params \\\\ %\{\}, opts \\\\ \[\]\)



Constructs a changeset for a given action, and validates it.

Calls `for_create/4`, `for_update/4` or `for_destroy/4` based on the type of action passed in.

See those functions for more explanation.





# for\_create\(initial, action, params \\\\ %\{\}, opts \\\\ \[\]\)



Constructs a changeset for a given create action, and validates it.

Anything that is modified prior to `for_create/4` is validated against the rules of the action, while *anything after it is not*. This runs any `change`s contained on your action. To have your logic execute *only* during the action, you can use `after_action/2` or `before_action/2`.

Multitenancy is *not* validated until an action is called. This allows you to avoid specifying a tenant until just before calling the domain action.

### ******Params**

`params` may be attributes, relationships, or arguments. You can safely pass user/form input directly into this function. Only public attributes and relationships are supported. If you want to change private attributes as well, see the Customization section below. `params` are stored directly as given in the `params` field of the changeset, which can be used to retrieve the originally input value.

## ******Options**

+ 
`:require?` \(`boolean/0`\) - If set to `false`, values are only required when the action is run \(instead of immediately\). The default value is `false`.

+ 
`:actor` \(`term/0`\) - set the actor, which can be used in any `Ash.Resource.Change`s configured on the action. \(in the `context` argument\)

+ 
`:authorize?` \(`term/0`\) - set authorize?, which can be used in any `Ash.Resource.Change`s configured on the action. \(in the `context` argument\)

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer to use. Will be carried over to the action. For more information see `Ash.Tracer`.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - set the tenant on the changeset

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - Data to load on the result after running the action.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:private_arguments` \(`map/0`\) - Private argument values to set before validations and changes. The default value is `%{}`.

+ 
`:return_skipped_upsert?` \(`boolean/0`\) - If `true`, and a record was *not* upserted because its filter prevented the upsert, the original record \(which was *not* upserted\) will be returned. The default value is `false`.


### ******Customization**

A changeset can be provided as the first argument, instead of a resource, to allow setting specific attributes ahead of time.

For example:

    MyResource        |>         Ash.Changeset    .    new    (    )        |>         Ash.Changeset    .    change_attribute    (    :foo    ,         1    )        |>         Ash.Changeset    .    for_create    (    :create    ,         ...    opts    )

Once a changeset has been validated by `for_create/4` \(or `for_update/4`\), it isn't validated again in the action. New changes added are validated individually, though. This allows you to create a changeset according to a given action, and then add custom changes if necessary.

### ******What does this function do?**

The following steps are run when calling `Ash.Changeset.for_create/4`.

+ 
Cast input params | This is any arguments in addition to any accepted attributes

+ Set argument defaults
+ Require any missing arguments
+ Validate all provided attributes are accepted
+ Require any accepted attributes that are `allow_nil?` false
+ Set any default values for attributes
+ Run action changes & validations
+ Run validations, or add them in `before_action` hooks if using `d:Ash.Resource.Dsl.actions.create.validate|before_action?`. Any global validations are skipped if the action has `skip_global_validations?` set to `true`.

## ******Examples**

    # Basic create changeset with attributes        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    ,         %{    title    :         "Hello World"    ,         content    :         "This is my first post"    }    )        iex>     changeset    .    valid?        true    
        # Create changeset with custom actor and tenant        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Comment    ,         :create    ,        ...>           %{    body    :         "Great post!"    }    ,        ...>           actor    :         current_user    ,        ...>           tenant    :         "org_123"        ...>     )        iex>     changeset    .    tenant        "org_123"

## ******See also**

+ `for_action/4` for a generic action constructor
+ `for_update/4` for updating existing records
+ `for_destroy/4` for destroying records
+ `Ash.create/2` to execute the changeset
+ `d:Ash.Resource.Dsl.actions.create` for defining create actions
+ Create Actions Guide for understanding create operations
+ Actions Guide for general action concepts





# for\_destroy\(initial, action\_or\_name, params \\\\ %\{\}, opts \\\\ \[\]\)



Constructs a changeset for a given destroy action, and validates it.

### ******Opts**

+ `:actor` - set the actor, which can be used in any `Ash.Resource.Change`s configured on the action. \(in the `context` argument\)
+ `:tenant` - set the tenant on the changeset
+ `:private_arguments` - set private arguments on the changeset before validations and changes are run

Anything that is modified prior to `for_destroy/4` is validated against the rules of the action, while *anything after it is not*.

Once a changeset has been validated by `for_destroy/4`, it isn't validated again in the action. New changes added are validated individually, though. This allows you to create a changeset according to a given action, and then add custom changes if necessary.

### ******What does this function do?**

The following steps are run when calling `Ash.Changeset.for_destroy/4`.

+ 
Cast input params | This is any arguments in addition to any accepted attributes

+ Set argument defaults
+ Require any missing arguments
+ Validate all provided attributes are accepted
+ Require any accepted attributes that are `allow_nil?` false
+ Set any default values for attributes
+ Run action changes & validations
+ Run validations, or add them in `before_action` hooks if using `d:Ash.Resource.Dsl.actions.destroy.validate|before_action?`. Any global validations are skipped if the action has `skip_global_validations?` set to `true`.

## ******Examples**

    # Basic destroy changeset        iex>     post         =         %    MyApp.Post    {    id    :         1    ,         title    :         "My Post"    ,         content    :         "Content"    }        iex>     changeset         =         Ash.Changeset    .    for_destroy    (    post    ,         :destroy    )        iex>     changeset    .    valid?        true    
        # Destroy changeset with inputs for the action        iex>     user         =         %    MyApp.User    {    id    :         1    ,         name    :         "John"    ,         email    :         "john@example.com"    }        iex>     changeset         =         Ash.Changeset    .    for_destroy    (    user    ,         :archive    ,         %{    reason    :         "User requested deletion"    }    ,         actor    :         current_user    )    
        # Soft delete changeset (if action is configured as soft)        iex>     comment         =         %    MyApp.Comment    {    id    :         1    ,         body    :         "My comment"    ,         post_id    :         1    }        iex>     changeset         =         Ash.Changeset    .    for_destroy    (    comment    ,         :soft_delete    ,         %{    }    ,         actor    :         current_user    ,         tenant    :         "org_123"    )        iex>     changeset    .    tenant        "org_123"

## ******See also**

+ `for_action/4` for a generic action constructor
+ `for_create/4` for creating new records
+ `for_update/4` for updating records
+ `Ash.destroy/2` to execute the changeset
+ `d:Ash.Resource.Dsl.actions.destroy` for defining destroy actions
+ Destroy Actions Guide for understanding destroy operations
+ Actions Guide for general action concepts





# for\_update\(initial, action, params \\\\ %\{\}, opts \\\\ \[\]\)



Constructs a changeset for a given update action, and validates it.

Anything that is modified prior to `for_update/4` is validated against the rules of the action, while *anything after it is not*.

### ******What does this function do?**

The following steps are run when calling `Ash.Changeset.for_update/4`.

+ 
Cast input params | This is any arguments in addition to any accepted attributes

+ Set argument defaults
+ Require any missing arguments
+ Validate all provided attributes are accepted
+ Require any accepted attributes that are `allow_nil?` false
+ Set any default values for attributes
+ Run action changes & validations
+ Run validations, or add them in `before_action` hooks if using `d:Ash.Resource.Dsl.actions.update.validate|before_action?`. Any global validations are skipped if the action has `skip_global_validations?` set to `true`.

## ******Examples**

    # Basic update changeset with attributes        iex>     post         =         %    MyApp.Post    {    id    :         1    ,         title    :         "Original Title"    ,         content    :         "Original content"    }        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    ,         %{    title    :         "Updated Title"    }    )        iex>     changeset    .    valid?        true    
        # Update changeset with custom actor and load related data        iex>     comment         =         %    MyApp.Comment    {    id    :         1    ,         body    :         "Original comment"    ,         post_id    :         1    }        iex>     changeset         =         Ash.Changeset    .    for_update    (    comment    ,         :update    ,        ...>           %{    body    :         "Updated comment"    }    ,        ...>           actor    :         current_user    ,        ...>           load    :         [    :post    ,         :author    ]        ...>     )        iex>     changeset    .    load        [    :post    ,         :author    ]

## ******See also**

+ `for_action/4` for a generic action constructor
+ `for_create/4` for creating new records
+ `for_destroy/4` for destroying records
+ `Ash.update/2` to execute the changeset
+ `d:Ash.Resource.Dsl.actions.update` for defining update actions
+ Update Actions Guide for understanding update operations
+ Actions Guide for general action concepts





# force\_change\_attribute\(changeset, attribute, value\)




    @spec     force_change_attribute(    t    (),     atom    (),     any    ()) ::     t    ()


Changes an attribute even if it isn't writable





# force\_change\_attributes\(changeset, changes\)




    @spec     force_change_attributes(    t    (),     map    () |     Keyword.t    ()) ::     t    ()


Calls `force_change_attribute/3` for each key/value pair provided.





# force\_change\_new\_attribute\(changeset, attribute, value\)




    @spec     force_change_new_attribute(    t    (),     atom    (),     term    ()) ::     t    ()


Force change an attribute if it is not currently being changed.

See `change_new_attribute/3` for more.





# force\_change\_new\_attribute\_lazy\(changeset, attribute, func\)




    @spec     force_change_new_attribute_lazy(    t    (),     atom    (), (->     any    ())) ::     t    ()


Force change an attribute if it is not currently being changed, by calling the provided function.

See `change_new_attribute_lazy/3` for more.





# force\_delete\_argument\(changeset, argument\_or\_arguments\)



Remove an argument from the changeset, not warning if the changeset has already been validated.





# force\_set\_argument\(changeset, argument, value\)



Add an argument to the changeset, which will be provided to the action.

Does not show a warning when used in before/after action hooks.





# force\_set\_arguments\(changeset, map\)



Merge a map of arguments to the arguments list.

Does not show a warning when used in before/after action hooks.





# fully\_atomic\_changeset\(resource, action, params, opts \\\\ \[\]\)




    @spec     fully_atomic_changeset(
      resource ::     Ash.Resource.t    (),
      action ::     atom    () |     Ash.Resource.Actions.action    (),
      params ::     map    (),
      opts ::     Keyword.t    ()
    ) ::     t    () | {:not_atomic,     String.t    ()}





# get\_argument\(changeset, argument\)




    @spec     get_argument(    t    (),     atom    ()) ::     term    ()


Gets the value of an argument provided to the changeset.

## ******Examples**

    # Get an argument that was set        iex>     changeset         =         MyApp.Post        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    set_argument    (    :auto_publish    ,         true    )        iex>     Ash.Changeset    .    get_argument    (    changeset    ,         :auto_publish    )        true    
        # Get an argument that doesn't exist (returns nil)        iex>     changeset         =         Ash.Changeset    .    new    (    MyApp.Post    )        iex>     Ash.Changeset    .    get_argument    (    changeset    ,         :nonexistent    )        nil    
        # Get argument with string key        iex>     changeset         =         MyApp.User        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    set_argument    (    :send_email    ,         false    )        iex>     Ash.Changeset    .    get_argument    (    changeset    ,         "send_email"    )        false

## ******See also**

+ `set_argument/3` for setting argument values
+ `fetch_argument/2` for getting arguments with error handling
+ `get_argument_or_attribute/2` for fallback to attributes





# get\_argument\_or\_attribute\(changeset, attribute\)




    @spec     get_argument_or_attribute(    t    (),     atom    ()) ::     term    ()


Gets the value of an argument provided to the changeset, falling back to `Ash.Changeset.get_attribute/2` if nothing was provided.





# get\_attribute\(changeset, attribute\)




    @spec     get_attribute(    t    (),     atom    ()) ::     term    ()


Gets the changing value or the original value of an attribute.





# get\_data\(changeset, attribute\)




    @spec     get_data(    t    (),     atom    ()) ::     term    ()


Gets the original value for an attribute





# handle\_errors\(changeset, func\)




    @spec     handle_errors(
          t    (),
      (    t    (), error ::     term    () ->
         :ignore |     t    () | (error ::     term    ()) | {error ::     term    (),     t    ()})
      | {    module    (),     atom    (), [    term    ()]}
    ) ::     t    ()


Sets a custom error handler on the changeset.

The error handler should be a two argument function or an mfa, in which case the first two arguments will be set to the changeset and the error, w/ the supplied arguments following those. The changeset will be marked as invalid regardless of the outcome of this callback.

Any errors generated are passed to `handle_errors`, which can return any of the following:

+ `:ignore` - the error is discarded.
+ `changeset` - a new \(or the same\) changeset. The error is not added.
+ `{changeset, error}` - a new \(or the same\) error and changeset. The error is added to the changeset.
+ `anything_else` - is treated as a new, transformed version of the error. The result is added as an error to the changeset.





# is\_valid\(changeset\)
\(macro\)   



    @spec     is_valid(    t    ()) ::     Macro.output    ()


A guard which checks if the Changeset is valid.





# load\(changeset, load\)




    @spec     load(    t    (),     term    ()) ::     t    ()


Calls the provided load statement on the result of the action at the very end of the action.

## ******Examples**

    # Load a single relationship        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    ,         %{    title    :         "My Post"    }    )        iex>     changeset         =         Ash.Changeset    .    load    (    changeset    ,         :comments    )        iex>     changeset    .    load        [    :comments    ]    
        # Load multiple relationships        iex>     changeset         =         Ash.Changeset    .    for_update    (    user    ,         :update    ,         %{    name    :         "John Doe"    }    )        iex>     changeset         =         Ash.Changeset    .    load    (    changeset    ,         [    :posts    ,         :profile    ]    )        iex>     changeset    .    load        [    :posts    ,         :profile    ]    
        # Load nested relationships        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Comment    ,         :create    ,         %{    body    :         "Great post!"    }    )        iex>     changeset         =         Ash.Changeset    .    load    (    changeset    ,         [    post    :         [    :author    ,         :comments    ]    ]    )        iex>     changeset    .    load        [    [    post    :         [    :author    ,         :comments    ]    ]    ]    
        # Chain multiple load calls (they accumulate)        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    ,         %{    title    :         "Updated Title"    }    )        iex>     changeset         =         changeset        ...>     |>         Ash.Changeset    .    load    (    :author    )        ...>     |>         Ash.Changeset    .    load    (    :comments    )        iex>     changeset    .    load        [    :author    ,         :comments    ]

## ******See also**

+ `select/3` for controlling which attributes are returned
+ `loading?/2` for checking if something is being loaded
+ `Ash.Query.load/2` for loading in queries





# loading?\(changeset, path\)



Returns true if the field/relationship or path to field/relationship is being loaded.

It accepts an atom or a list of atoms, which is treated for as a "path", i.e:

    Resource         |>         Ash.Changeset    .    load    (    friends    :         [    enemies    :         [    :score    ]    ]    )         |>         Ash.Changeset    .    loading?    (    [    :friends    ,         :enemies    ,         :score    ]    )        iex>     true    
        Resource         |>         Ash.Changeset    .    load    (    friends    :         [    enemies    :         [    :score    ]    ]    )         |>         Ash.Changeset    .    loading?    (    [    :friends    ,         :score    ]    )        iex>     false    
        Resource         |>         Ash.Changeset    .    load    (    friends    :         [    enemies    :         [    :score    ]    ]    )         |>         Ash.Changeset    .    loading?    (    :friends    )        iex>     true





# manage\_relationship\(changeset, relationship, input, opts \\\\ \[\]\)



Manages the related records by creating, updating, or destroying them as necessary.

Keep in mind that the default values for all `on_*` are `:ignore`, meaning nothing will happen unless you provide instructions.

The input provided to `manage_relationship` should be a map, in the case of to\_one relationships, or a list of maps in the case of to\_many relationships. The following steps are followed for each input provided:

+ The input is checked against the currently related records to find any matches. The primary key and unique identities are used to find matches.
+ For any input that had a match in the current relationship, the `:on_match` behavior is triggered
+ For any input that does not have a match:
	+ if there is `on_lookup` behavior:
		+ we try to find the record in the data layer.
		+ if the record is found, the on\_lookup behavior is triggered
		+ if the record is not found, the `on_no_match` behavior is triggered

	+ if there is no `on_lookup` behavior:
		+ the `on_no_match` behavior is triggered


+ finally, for any records present in the *current relationship* that had no match *in the input*, the `on_missing` behavior is triggered

## ******Options**

+ 
`:type` - If the `type` is specified, the default values of each option is modified to match that `type` of operation.  
This allows for specifying certain operations much more succinctly. The defaults that are modified are listed below: 

	+ `:append_and_remove` 
    [    
          on_lookup    :         :relate    ,    
          on_no_match    :         :error    ,    
          on_match    :         :ignore    ,    
          on_missing    :         :unrelate        ]      

	+ `:append` 
    [    
          on_lookup    :         :relate    ,    
          on_no_match    :         :error    ,    
          on_match    :         :ignore    ,    
          on_missing    :         :ignore        ]      

	+ `:remove` 
    [    
          on_no_match    :         :error    ,    
          on_match    :         :unrelate    ,    
          on_missing    :         :ignore        ]      

	+ `:direct_control` 
    [    
          on_lookup    :         :ignore    ,    
          on_no_match    :         :create    ,    
          on_match    :         :update    ,    
          on_missing    :         :destroy        ]      

	+ `:create` 
    [    
          on_no_match    :         :create    ,    
          on_match    :         :ignore        ]
Valid values are :append\_and\_remove, :append, :remove, :direct\_control, :create

+ 
`:authorize?` \(`boolean/0`\) - Authorize reads and changes to the destination records, if the primary change is being authorized as well. The default value is `true`.

+ 
`:eager_validate_with` \(`atom/0`\) - Validates that any referenced entities exist *before* the action is being performed, using the provided domain for the read. The default value is `false`.

+ 
`:on_no_match` \(`term/0`\) - Instructions for handling records where no matching record existed in the relationship. 

	+ `:ignore` \(default\) - those inputs are ignored
	+ `:match` - For `has_one` and `belongs_to` only, any input is treated as a match for an existing value. For `has_many` and `many_to_many`, this is the same as `:ignore`.
	+ `:create` - the records are created using the destination's primary create action
	+ `{:create, :action_name}` - the records are created using the specified action on the destination resource
	+ `{:create, :action_name, :join_table_action_name, [:list, :of, :join_table, :params]}` - Same as `{:create, :action_name}` but takes the list of params specified out and applies them when creating the join record, with the provided join\_table\_action\_name.
	+ `:error` - an error is returned indicating that a record would have been created
		+  If `on_lookup` is set, and the data contained a primary key or identity, then the error is a `NotFound` error
		+ Otherwise, an `InvalidRelationship` error is returned The default value is `:ignore`.


+ 
`:value_is_key` \(`atom/0`\) - Configures what key to use when a single value is provided.  
This is useful when you use things like a list of strings i.e `friend_emails` to manage the relationship, instead of a list of maps.  
By default, we assume it is the primary key of the destination resource, unless it is a composite primary key.

+ 
`:order_is_key` \(`atom/0`\) - If set, the order that each input appears in the list will be added to the input as this key.  
This is useful when you want to accept an ordered list of related records and write that order to the entity. This should only currently be used with `type: :direct_control` or `type: :create` when there are no currently existing related records \(like when creating the source record\).  
If you have an identity on the field and relationship id on the destination, and you are using AshPostgres, you will want to use the `deferrable` option to ensure that conflicting orders are temporarily allowed within a single transaction.

+ 
`:identity_priority` \(list of `atom/0`\) - The list, in priority order, of identities to use when looking up records for `on_lookup`, and matching records with `on_match`.  
Use `:_primary_key` to prioritize checking a match with the primary key. All identities, along with `:_primary_key` are checked regardless, this only allows ensuring that some are checked first. Defaults to the list provided by `use_identities`, so you typically won't need this option.

+ 
`:use_identities` \(list of `atom/0`\) - A list of identities that may be used to look up and compare records. Use `:_primary_key` to include the primary key. By default, only `[:_primary_key]` is used.

+ 
`:on_lookup` \(`term/0`\) - Before creating a record \(because no match was found in the relationship\), the record can be looked up and related. 

	+ `:ignore` \(default\) - Does not look for existing entries \(matches in the current relationship are still considered updates\)
	+ `:relate` - Same as calling `{:relate, primary_action_name}`
	+ `{:relate, :action_name}` - the records are looked up by primary key/the first identity that is found \(using the primary read action\), and related. The action should be:
		+ `many_to_many` - a create action on the join resource
		+ `has_many` - an update action on the destination resource
		+ `has_one` - an update action on the destination resource
		+ `belongs_to` - an update action on the source resource

	+ `{:relate, :action_name, :read_action_name}` - Same as the above, but customizes the read action called to search for matches.
	+ `:relate_and_update` - Same as `:relate`, but the remaining parameters from the lookup are passed into the action that is used to change the relationship key
	+ `{:relate_and_update, :action_name}` - Same as the above, but customizes the action used. The action should be:
		+ `many_to_many` - a create action on the join resource
		+ `has_many` - an update action on the destination resource
		+ `has_one` - an update action on the destination resource
		+ `belongs_to` - an update action on the source resource

	+ `{:relate_and_update, :action_name, :read_action_name}` - Same as the above, but customizes the read action called to search for matches.
	+ `{:relate_and_update, :action_name, :read_action_name, [:list, :of, :join_table, :params]}` - Same as the above, but uses the provided list of parameters when creating the join row \(only relevant for many to many relationships\). Use `:*` to *only* update the join record, and pass all parameters to its action The default value is `:ignore`.

+ 
`:on_match` \(`term/0`\) - Instructions for handling records where a matching record existed in the relationship already. 

	+ `:ignore` \(default\) - those inputs are ignored
	+ `:update` - the record is updated using the destination's primary update action
	+ `{:update, :action_name}` - the record is updated using the specified action on the destination resource
	+ `{:update, :action_name, :join_table_action_name, [:list, :of, :params]}` - Same as `{:update, :action_name}` but takes the list of params specified out and applies them as an update to the join record \(only valid for many to many\)
	+ `:update_join` - update only the join record \(only valid for many to many\)
	+ `{:update_join, :join_table_action_name}` - use the specified update action on a join resource
	+ `{:update_join, :join_table_action_name, [:list, :of, :params]}` - pass specified params from input into a join resource update action
	+ `{:destroy, :action_name}` - the record is destroyed using the specified action on the destination resource. The action should be:
		+ `many_to_many` - a destroy action on the join record
		+ `has_many` - a destroy action on the destination resource
		+ `has_one` - a destroy action on the destination resource
		+ `belongs_to` - a destroy action on the destination resource

	+ `:error` - an error is returned indicating that a record would have been updated
	+ `:no_match` - follows the `on_no_match` instructions with these records
	+ `:missing` - follows the `on_missing` instructions with these records
	+ `:unrelate` - the related item is not destroyed, but the data is "unrelated". The action should be:
		+ `many_to_many` - the join resource row is destroyed
		+ `has_many` - the `destination_attribute` \(on the related record\) is set to `nil`
		+ `has_one` - the `destination_attribute` \(on the related record\) is set to `nil`
		+ `belongs_to` - the `source_attribute` \(on this record\) is set to `nil`

	+ `{:unrelate, :action_name}` - the record is unrelated using the provided update action. The action should be:
		+ `many_to_many` - a destroy action on the join resource
		+ `has_many` - an update action on the destination resource
		+ `has_one` - an update action on the destination resource
		+ `belongs_to` - an update action on the source resource The default value is `:ignore`.


+ 
`:on_missing` \(`term/0`\) - Instructions for handling records that existed in the current relationship but not in the input. 

	+ `:ignore` \(default\) - those inputs are ignored
	+ `:destroy` - the record is destroyed using the destination's primary destroy action
	+ `{:destroy, :action_name}` - the record is destroyed using the specified action on the destination resource
	+ `{:destroy, :action_name, :join_resource_action_name}` - the record is destroyed using the specified action on the destination resource, but first the join resource is destroyed with its specified action
	+ `:error` - an error is returned indicating that a record would have been updated
	+ `:unrelate` - the related item is not destroyed, but the data is "unrelated". The action should be:
		+ `many_to_many` - the join resource row is destroyed
		+ `has_many` - the `destination_attribute` \(on the related record\) is set to `nil`
		+ `has_one` - the `destination_attribute` \(on the related record\) is set to `nil`
		+ `belongs_to` - the `source_attribute` \(on this record\) is set to `nil`

	+ `{:unrelate, :action_name}` - the record is unrelated using the provided update action. The action should be:
		+ `many_to_many` - a destroy action on the join resource
		+ `has_many` - an update action on the destination resource
		+ `has_one` - an update action on the destination resource
		+ `belongs_to` - an update action on the source resource The default value is `:ignore`.


+ 
`:error_path` \(`term/0`\) - By default, errors added to the changeset will use the path `[:relationship_name]`, or `[:relationship_name, <index>]`. If you want to modify this path, you can specify `error_path`, e.g if had a `change` on an action that takes an argument and uses that argument data to call `manage_relationship`, you may want any generated errors to appear under the name of that argument, so you could specify `error_path: :argument_name` when calling `manage_relationship`.

+ 
`:join_keys` \(list of `atom/0`\) - For many to many relationships specifies the parameters to pick from the input and pass into a join resource action. Applicable in cases like `on_no_match: :create`, `on_match: :update` and `on_lookup: :relate`. Can be overwritten by a full form instruction tuple which contains join parameters at the end.

+ 
`:meta` \(`term/0`\) - Freeform data that will be retained along with the options, which can be used to track/manage the changes that are added to the `relationships` key. Use the `meta[:order]` option to specify the order in which multiple calls to `manage_relationship` should be executed.

+ 
`:ignore?` \(`term/0`\) - This tells Ash to ignore the provided inputs when actually running the action. This can be useful for building up a set of instructions that you intend to handle manually. The default value is `false`.

+ 
`:debug?` \(`boolean/0`\) - Logs queries executed by relationship. The default value is `false`.


Each call to this function adds new records that will be handled according to their options. For example, if you tracked "tags to add" and "tags to remove" in separate fields, you could input them like so:

    changeset        |>         Ash.Changeset    .    manage_relationship    (    
          :tags    ,    
          [    %{    name    :         "backend"    }    ]    ,    
          on_lookup    :         :relate    ,         #relate that tag if it exists in the database    
          on_no_match    :         :error         # error if a tag with that name doesn't exist        )        |>         Ash.Changeset    .    manage_relationship    (    
          :tags    ,    
          [    %{    name    :         "frontend"    }    ]    ,    
          on_no_match    :         :error    ,         # error if a tag with that name doesn't exist in the relationship    
          on_match    :         :unrelate         # if a tag with that name is related, unrelate it        )

When calling this multiple times with the `on_missing` option set, the list of records that are considered missing are checked after each set of inputs is processed. For example, if you manage the relationship once with `on_missing: :unrelate`, the records missing from your input will be removed, and *then* your next call to `manage_relationship` will be resolved \(with those records unrelated\). For this reason, it is suggested that you don't call this function multiple times with an `on_missing` instruction, as you may be surprised by the result.

If you want the input to update existing entities, you need to ensure that the primary key \(or unique identity\) is provided as part of the input. See the example below:

    changeset        |>         Ash.Changeset    .    manage_relationship    (    
          :comments    ,    
          [    %{    rating    :         10    ,         contents    :         "foo"    }    ]    ,    
          on_no_match    :         {    :create    ,         :create_action    }    ,    
          on_missing    :         :ignore        )        |>         Ash.Changeset    .    manage_relationship    (    
          :comments    ,    
          [    %{    id    :         10    ,         rating    :         10    ,         contents    :         "foo"    }    ]    ,    
          on_match    :         {    :update    ,         :update_action    }    ,    
          on_no_match    :         {    :create    ,         :create_action    }    )

This is a simple way to manage a relationship. If you need custom behavior, you can customize the action that is called, which allows you to add arguments/changes. However, at some point you may want to forego this function and make the changes yourself. For example:

    input         =         [    %{    id    :         10    ,         rating    :         10    ,         contents    :         "foo"    }    ]    
        changeset        |>         Ash.Changeset    .    after_action    (    fn         _changeset    ,         result         ->    
          # An example of updating comments based on a result of other changes    
          for         comment         <-         input         do    
            comment         =         Ash    .    get    (    Comment    ,         comment    .    id    )    

            comment    
            |>         Map    .    update    (    :rating    ,         0    ,         &    (    &1         *         result    .    rating_weight    )    )    
            |>         Ash    .    update!    (    )    
          end    

          {    :ok    ,         result    }        end    )

## ******Using records as input**

Records can be supplied as the input values. If you do:

+ if it would be looked up due to `on_lookup`, the record is used as-is
+ if it would be created due to `on_no_match`, the record is used as-is
+ Instead of specifying `join_keys`, those keys must go in `__metadata__.join_keys`. If `join_keys` is specified in the options, it is ignored.

For example:

    post1         =    
          changeset    
          |>         Ash    .    create!    (    )    
          |>         Ash.Resource    .    put_metadata    (    :join_keys    ,         %{    type    :         "a"    }    )    
        post2         =    
          changeset2    
          |>         Ash    .    create!    (    )    
          |>         Ash.Resource    .    put_metadata    (    :join_keys    ,         %{    type    :         "b"    }    )    
        author         =         Ash    .    create!    (    author_changeset    )    
        Ash.Changeset    .    manage_relationship    (    
          author    ,    
          :posts    ,    
          [    post1    ,         post2    ]    ,    
          on_lookup    :         :relate        )





# new\(record\_or\_resource\)




    @spec     new(    Ash.Resource.t    () |     Ash.Resource.record    ()) ::     t    ()


Returns a new changeset over a resource.

*Warning*: You almost always want to use `for_action` or `for_create`, etc. over this function if possible.

You can use this to start a changeset and make changes prior to calling `for_action`. This is not typically necessary, but can be useful as an escape hatch.

## ******Examples**

    # Create a changeset for a new record        iex>     changeset         =         Ash.Changeset    .    new    (    MyApp.Post    )        iex>     changeset    .    action_type        :create    
        # Create a changeset for updating an existing record        iex>     post         =         %    MyApp.Post    {    id    :         1    ,         title    :         "Original Title"    }        iex>     changeset         =         Ash.Changeset    .    new    (    post    )        iex>     changeset    .    action_type        :update    
        # Use as an escape hatch before calling for_action        iex>     MyApp.Post        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    change_attribute    (    :title    ,         "Draft Title"    )        ...>     |>         Ash.Changeset    .    for_action    (    :create    ,         %{    content    :         "Post content"    }    )

## ******See also**

+ `for_action/4` for the recommended way to create changesets
+ `for_create/4` for creating new records
+ `for_update/4` for updating existing records
+ `for_destroy/4` for destroying records





# prepare\_changeset\_for\_action\(changeset, action, opts\)





# present?\(changeset, attribute\)



Checks if an argument is not nil or an attribute is not nil, either in the original data, or that it is not being changed to a `nil` value if it is changing.

This also accounts for the `accessing_from` context that is set when using `manage_relationship`, so it is aware that a particular value *will* be set by `manage_relationship` even if it isn't currently being set.

## ******Examples**

    # Check if attribute is present in original data        iex>     post         =         %    MyApp.Post    {    id    :         1    ,         title    :         "My Post"    ,         content    :         nil    }        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    )        iex>     Ash.Changeset    .    present?    (    changeset    ,         :title    )        true        iex>     Ash.Changeset    .    present?    (    changeset    ,         :content    )        false    
        # Check if attribute is being changed to a non-nil value        iex>     post         =         %    MyApp.Post    {    id    :         1    ,         title    :         nil    ,         content    :         "Content"    }        iex>     changeset         =         Ash.Changeset    .    for_update    (    post    ,         :update    ,         %{    title    :         "New Title"    }    )        iex>     Ash.Changeset    .    present?    (    changeset    ,         :title    )        true    
        # Check if argument is present        iex>     changeset         =         MyApp.User        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    set_argument    (    :send_email    ,         true    )        iex>     Ash.Changeset    .    present?    (    changeset    ,         :send_email    )        true        iex>     Ash.Changeset    .    present?    (    changeset    ,         :other_arg    )        false

## ******See also**

+ `attribute_present?/2` for checking only attributes \(not arguments\)
+ `changing_attribute?/2` for checking if an attribute is being changed
+ `get_argument/2` and `get_attribute/2` for retrieving values





# put\_context\(changeset, key, value\)




    @spec     put_context(    t    (),     atom    (),     term    ()) ::     t    ()


Puts a key/value in the changeset context that can be used later.

Do not use the `private` key in your custom context, as that is reserved for internal use.





# run\_before\_transaction\_hooks\(changeset\)





# select\(changeset, fields, opts \\\\ \[\]\)




    @spec     select(    t    (), [    atom    ()] |     atom    (),     Keyword.t    ()) ::     t    ()


Ensure that only the specified attributes are present in the results.

The first call to `select/2` will replace the default behavior of selecting all attributes. Subsequent calls to `select/2` will combine the provided fields unless the `replace?` option is provided with a value of `true`.

If a field has been deselected, selecting it again will override that \(because a single list of fields is tracked for selection\)

Primary key attributes always selected and cannot be deselected.

When attempting to load a relationship \(or manage it with `Ash.Changeset.manage_relationship/3`\), if the source field is not selected on the query/provided data an error will be produced. If loading a relationship with a query, an error is produced if the query does not select the destination field of the relationship.

Datalayers currently are not notified of the `select` for a changeset\(unlike queries\), and creates/updates select all fields when they are performed. A select provided on a changeset sets the unselected fields to `nil` before returning the result.

Use `ensure_selected/2` if you wish to make sure a field has been selected, without deselecting any other fields.

## ******Examples**

    # Select specific fields        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         Ash.Changeset    .    select    (    changeset    ,         [    :title    ,         :content    ]    )        iex>     changeset    .    select        [    :title    ,         :content    ]    
        # Combine multiple select calls (default behavior)        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.User    ,         :create    )        iex>     changeset         =         changeset        ...>     |>         Ash.Changeset    .    select    (    [    :name    ,         :email    ]    )        ...>     |>         Ash.Changeset    .    select    (    [    :created_at    ]    )        iex>     changeset    .    select        [    :name    ,         :email    ,         :created_at    ]    
        # Replace previous selection        iex>     changeset         =         Ash.Changeset    .    for_create    (    MyApp.Post    ,         :create    )        iex>     changeset         =         changeset        ...>     |>         Ash.Changeset    .    select    (    [    :title    ,         :content    ]    )        ...>     |>         Ash.Changeset    .    select    (    [    :title    ,         :published_at    ]    ,         replace?    :         true    )        iex>     changeset    .    select        [    :title    ,         :published_at    ]

## ******See also**

+ `ensure_selected/2` for adding fields without replacing existing selection
+ `deselect/2` for removing fields from selection
+ `selecting?/2` for checking if a field is selected
+ `load/2` for loading relationships and calculations





# selecting?\(changeset, field\)





# set\_argument\(changeset, argument, value\)



Add an argument to the changeset, which will be provided to the action.

Arguments can be set on a changeset before calling `for_action/4` \(or the specific `for_*` functions\). When `for_action/4` is called, arguments are validated and cast according to the action's argument definitions. Use this function to set arguments that will be available during the action's execution.

## ******Examples**

    # Set arguments before calling for_action        iex>     changeset         =         MyApp.Post        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    set_argument    (    :auto_publish    ,         true    )        ...>     |>         Ash.Changeset    .    set_argument    (    :slug_prefix    ,         "blog"    )        iex>     changeset    .    arguments        %{    auto_publish    :         true    ,         slug_prefix    :         "blog"    }    
        # Arguments are validated and cast when for_action is called        iex>     changeset         =         MyApp.User        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    set_argument    (    :age    ,         "25"    )          # String will be cast to integer        ...>     |>         Ash.Changeset    .    for_action    (    :create    ,         %{    name    :         "John"    }    )        iex>     changeset    .    arguments        %{    age    :         25    }    
        # Chain argument setting with attribute changes        iex>     changeset         =         MyApp.Post        ...>     |>         Ash.Changeset    .    new    (    )        ...>     |>         Ash.Changeset    .    set_argument    (    :generate_excerpt    ,         true    )        ...>     |>         Ash.Changeset    .    change_attribute    (    :title    ,         "My Post"    )        ...>     |>         Ash.Changeset    .    for_action    (    :create    ,         %{    content    :         "Post content"    }    )

## ******See also**

+ `set_arguments/2` for setting multiple arguments at once
+ `get_argument/2` for retrieving argument values
+ `force_set_argument/3` for setting arguments in hooks without warnings
+ `delete_argument/2` for removing arguments





# set\_arguments\(changeset, map\)



Merge a map of arguments to the arguments list.





# set\_context\(changeset, map\)




    @spec     set_context(    t    (),     map    () | nil) ::     t    ()


Deep merges the provided map into the changeset context that can be used later.

Do not use the `private` key in your custom context, as that is reserved for internal use.





# set\_private\_argument\(changeset, argument, value\)




    @spec     set_private_argument(    t    (),     atom    (),     term    ()) ::     t    ()


Add a private argument to the changeset, which will be provided to the action.





# set\_result\(changeset, result\)




    @spec     set_result(    t    (),     term    ()) ::     t    ()


Set the result of the action. This will prevent running the underlying datalayer behavior





# set\_tenant\(changeset, tenant\)




    @spec     set_tenant(    t    (),     Ash.ToTenant.t    ()) ::     t    ()





# timeout\(changeset, timeout, default \\\\ nil\)




    @spec     timeout(    t    (), nil |     pos_integer    (), nil |     pos_integer    ()) ::     t    ()





# update\_change\(changeset, attribute, fun\)




    @spec     update_change(    t    (),     atom    (), (    any    () ->     any    ())) ::     t    ()


Updates an existing attribute change by applying a function to it.

This is useful for applying some kind of normalization to the attribute.

    Ash.Changeset    .    update_change    (    changeset    ,         :serial    ,         &    String    .    downcase    /    1    )

The update function gets called with the value already cast to the correct type.

    changeset        |>         Ash.Changeset    .    change_attribute    (    :integer_attribute    ,         "3"    )        |>         Ash.Changeset    .    update_change    (    :integer_attribute    ,         fn         x         ->         x         +         1         end    )

## ******Invalid value handling**

If `update_change` is called with a changeset that has not been validated yet, the update function must handle potentially invalid and `nil` values.

To only deal with valid values, you can call `update_change` in a `before_action` hook.





# with\_hooks\(changeset, func, opts \\\\ \[\]\)




    @spec     with_hooks(
          t    (),
      (    t    () ->
         {:ok,     term    (), %{notifications: [    Ash.Notifier.Notification.t    ()]}}
         | {:error,     term    ()}),
          Keyword.t    ()
    ) ::
      {:ok,     term    (),     t    (), %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:error,     term    ()}


Wraps a function in the before/after action hooks of a changeset.

The function takes a changeset and if it returns `{:ok, result}`, the result will be passed through the after action hooks.





# Ash.Query 

A data structure for reading data from a resource.

Queries are run by calling `Ash.read/2`.

Examples:

    require         Ash.Query    
        MyApp.Post        |>         Ash.Query    .    filter    (    likes         >         10    )        |>         Ash.Query    .    sort    (    [    :title    ]    )        |>         Ash    .    read!    (    )    
        MyApp.Author        |>         Ash.Query    .    aggregate    (    :published_post_count    ,         :posts    ,         query    :         [    filter    :         [    published    :         true    ]    ]    )        |>         Ash.Query    .    sort    (    published_post_count    :         :desc    )        |>         Ash.Query    .    limit    (    10    )        |>         Ash    .    read!    (    )    
        MyApp.Author        |>         Ash.Query    .    load    (    [    :post_count    ,         :comment_count    ]    )        |>         Ash.Query    .    load    (    posts    :         [    :comments    ]    )        |>         Ash    .    read!    (    )

To see more examples of what you can do with `Ash.Query` and read actions in general, see the writing queries how-to guide.

## Capabilities & Limitations

Ash Framework provides a comprehensive suite of querying tools designed to address common application development needs. While powerful and flexible, these tools are focused on domain-driven design rather than serving as a general-purpose ORM.

Ash's query tools support:

+ Filtering records based on complex conditions
+ Sorting results using single or multiple criteria
+ Setting result limits and offsets
+ Pagination, with offset/limit and keysets
+ Selecting distinct records to eliminate duplicates
+ Computing dynamic properties at query time
+ Aggregating data from related resources

While Ash's query tools often eliminate the need for direct database queries, Ash is not itself designed to be a comprehensive ORM or database query builder.

For specialized querying needs that fall outside Ash's standard capabilities, the framework provides escape hatches. These mechanisms allow developers to implement custom query logic when necessary.

### Important Considerations

1. Ash is primarily a domain modeling framework, not a database abstraction layer
2. While comprehensive, the tooling is intentionally constrained to resource-oriented access
3. Escape hatches exist for cases that require custom query logic

For complex queries that fall outside these tools, consider whether they represent domain concepts that could be modeled differently, or if they truly require custom implementation through escape hatches.

## Escape Hatches

Many of the tools in `Ash.Query` are surprisingly deep and capable, covering everything you need to build your domain logic. With that said, these tools are *not* designed to encompass *every kind of query* that you could possibly want to write over your data. `Ash` is *not* an ORM or a database query tool, despite the fact that its query building tools often make those kinds of tools unnecessary in all but the rarest of cases. Not every kind of query that you could ever wish to write can be expressed with Ash.Query. Elixir has a best-in-class library for working directly with databases, called Ecto, and if you end up building a certain type of feature like analytics or reporting dashboards, you may find yourself working directly with Ecto. Data layers like AshPostgres are built on top of Ecto. In fact, every `Ash.Resource` is an `Ecto.Schema`\!

### Choose escape hatches wisely

You should choose to use Ash builtin functionality wherever possible. Barring that, you should choose the *least powerful* escape hatch that can solve your problem. The options below are presented in the order that you should prefer them, but you should only use *any of them* if no builtin tooling will suffice.

### Fragments

Fragments only barely count as an escape hatch. You will often find yourself wanting to use a function or operator specific to your data layer, and fragments are purpose built to this end. You can use data-layer-specific expressions in your expressions for filters, calculations, etc. For example:

    Resource        |>         Ash.Query    .    filter    (    expr    (    fragment    (    "lower(?)"    ,         name    )         ==         "fred"    )    )        |>         Ash.Query    .    filter    (    expr    (    fragment    (    "? @> ?"    ,         tags    ,         [    "important"    ]    )    )    )

### Manual Read Actions

See the manual read actions guide.

### **`d:Ash.Resource.Dsl|actions.read.modify_query`**

When running read actions, you can modify the underlying data layer query directly, which can solve for cases when you cannot express your query using the standard Ash query interface.

    actions         do    
          read         :complex_search         do    
            argument    
            modify_query         {    SearchMod    ,         :modify    ,         [    ]    }    
          end        end

    defmodule         SearchMod         do    
          def         modify    (    ash_query    ,         data_layer_query    )         do    
            # Here you can modify the underlying data layer query directly    
            # For example, with AshPostgres you get access to the Ecto query    
            {    :ok    ,         Ecto.Query    .    where    (    data_layer_query    ,         [    p    ]    ,         fragment    (    "? @@ plainto_tsquery(?)"    ,         p    .    search_vector    ,         ^    ash_query    .    arguments    .    search_text    )    )    }    
          end        end

### Using Ecto directly

For data layers like `AshPostgres`, you can interact directly with `Ecto`. You can do this by using the `Ash.Resource` as its corresponding `Ecto.Schema`, like so:

    import         Ecto.Query    
        query         =    
          from         p         in         MyApp.Post    ,    
            where    :         p    .    likes         >         100    ,    
            select    :         p    

         MyApp.Repo    .    all    (    query    )

Or you can build an `Ash.Query`, and get the corresponding ecto query:

    MyApp.Post        |>         Ash.Query    .    for_read    (    :read    )        |>         Ash    .    data_layer_query    (    )        |>         case         do    
          {    :ok    ,         %{    query    :         ecto_query    }    }         ->    
            ecto_query    
            |>         Ecto.Query    .    where    (    [    p    ]    ,         p    .    likes         >         100    )    
            |>         MyApp.Repo    .    all    (    )    

          {    :error    ,         error    }         ->    
            {    :error    ,         error    }        end





# Summary


## **Types** 


after\_transaction\_fun\(\) 


Function type for after\_transaction hooks that run after query execution.




around\_result\(\) 


Result type for around\_transaction hooks, containing either successful records or an error.




around\_transaction\_fun\(\) 


Function type for around\_transaction hooks that wrap query execution in a transaction.




before\_transaction\_fun\(\) 


Function type for before\_transaction hooks that run before query execution.




t\(\) 


A query struct for reading data from a resource.





## **Functions** 


accessing\(query, types \\\\ \[:attributes, :relationships, :calculations, :aggregates\], only\_public? \\\\ true\) 


Returns a list of attributes, aggregates, relationships, and calculations that are being loaded




add\_error\(query, path \\\\ \[\], error\) 


Add an error to the errors list and mark the query as invalid.




after\_action\(query, func\) 


Adds an after\_action hook to the query.




after\_transaction\(query, func, opts \\\\ \[\]\) 


Adds an after\_transaction hook to the query.




aggregate\(query, name, kind, relationship\) 


Adds an aggregation to the query.




aggregate\(query, name, kind, relationship, opts\) 



apply\_to\(query, records, opts \\\\ \[\]\) 


Applies a query to a list of records in memory.




around\_transaction\(query, func, opts \\\\ \[\]\) 


Adds an around\_transaction hook to the query.




before\_action\(query, func, opts \\\\ \[\]\) 


Adds a before\_action hook to the query.




before\_transaction\(query, func, opts \\\\ \[\]\) 


Adds a before\_transaction hook to the query.




build\(resource, domain \\\\ nil, keyword\) 


Builds a query from a keyword list.




calculate\(query, name, type, module\_and\_opts, arguments \\\\ %\{\}, constraints \\\\ \[\], extra\_context \\\\ %\{\}, new\_calculation\_opts \\\\ \[\]\) 


Adds a calculation to the query.




clear\_result\(query\) 


Removes a result set previously with `set_result/2`




combination\_of\(query, combinations\) 


Produces a query that is the combination of multiple queries.




data\_layer\_query\(ash\_query, opts \\\\ \[\]\) 


Return the underlying data layer query for an ash query




default\_sort\(query, sorts, opts \\\\ \[\]\) 


Apply a sort only if no sort has been specified yet.




delete\_argument\(query, argument\_or\_arguments\) 


Remove an argument from the query




deselect\(query, fields\) 


Ensures that the specified attributes are `nil` in the query results.




distinct\(query, distincts\) 


Get results distinct on the provided fields.




distinct\_sort\(query, sorts, opts \\\\ \[\]\) 


Set a sort to determine how distinct records are selected.




ensure\_selected\(query, fields\) 


Ensures that the given attributes are selected.




equivalent\_to\(query, expr\) 


Determines if the filter statement of a query is equivalent to the provided expression.




equivalent\_to?\(query, expr\) 


Same as `equivalent_to/2` but always returns a boolean. `:maybe` returns `false`.




fetch\_argument\(query, argument\) 


Fetches the value of an argument provided to the query.




filter\(query, filter\) 


Attach a filter statement to the query.




filter\_input\(query, filter\) 


Attach a filter statement to the query labelled as user input.




for\_read\(query, action\_name, args \\\\ %\{\}, opts \\\\ \[\]\) 


Creates a query for a given read action and prepares it.




get\_argument\(query, argument\) 


Gets the value of an argument provided to the query.




limit\(query, limit\) 


Limits the number of results returned from the query.




load\(query, load\_statement, opts \\\\ \[\]\) 


Loads relationships, calculations, or aggregates on the resource.




load\_calculation\_as\(query, calc\_name, as\_name, opts\_or\_args \\\\ %\{\}, opts \\\\ \[\]\) 


Adds a resource calculation to the query as a custom calculation with the provided name.




load\_through\(query, type, name, load\) 


Adds a load statement to the result of an attribute or calculation.




loading?\(query, item\) 


Returns true if the field/relationship or path to field/relationship is being loaded.




lock\(query, lock\_type\) 


Lock the query results.




merge\_query\_load\(left, right, context\) 


Merges two query's load statements, for the purpose of handling calculation requirements.




new\(resource, opts \\\\ \[\]\) 


Creates a new query for the given resource.




offset\(query, offset\) 


Skips the first n records in the query results.




page\(query, page\_opts\) 


Sets the pagination options of the query.




put\_context\(query, key, value\) 


Sets a specific context key to a specific value.




select\(query, fields, opts \\\\ \[\]\) 


Ensure that only the specified *attributes* are present in the results.




selecting?\(query, field\) 


Checks if a specific field is currently selected in the query.




set\_argument\(query, argument, value\) 


Adds an argument to the query.




set\_arguments\(query, map\) 


Merge a map of arguments to the arguments list




set\_context\(query, map\) 


Merge a map of values into the query context




set\_domain\(query, domain\) 


Set the query's domain, and any loaded query's domain




set\_result\(query, result\) 


Set the result of the action. This will prevent running the underlying datalayer behavior




set\_tenant\(query, tenant\) 


Sets the tenant for the query.




sort\(query, sorts, opts \\\\ \[\]\) 


Sort the results based on attributes, aggregates or calculations.




sort\_input\(query, sorts, opts \\\\ \[\]\) 


Attach a sort statement to the query labelled as user input.




subset\_of\(query, expr\) 


Determines if the provided expression would return data that is a subset of the data returned by the filter on the query.




subset\_of?\(query, expr\) 


Same as `subset_of/2` but always returns a boolean. `:maybe` returns `false`.




superset\_of\(query, expr\) 


Determines if the provided expression would return data that is a subset of the data returned by the filter on the query.




superset\_of?\(query, expr\) 


Same as `superset_of/2` but always returns a boolean. `:maybe` returns `false`.




timeout\(query, timeout\) 


Set a timeout for the query.




unload\(query, fields\) 


Removes a field from the list of fields to load




unset\(query, keys\) 


Removes specified keys from the query, resetting them to their default values.




# Types




# after\_transaction\_fun\(\)




    @type     after_transaction_fun() :: (    t    (),
                                {:ok, [    Ash.Resource.record    ()]}
                                | {:error,     any    ()} ->
                                  {:ok, [    Ash.Resource.record    ()]} | {:error,     any    ()})


Function type for after\_transaction hooks that run after query execution.





# around\_result\(\)




    @type     around_result() :: {:ok, [    Ash.Resource.record    ()]} | {:error,     Ash.Error.t    ()}


Result type for around\_transaction hooks, containing either successful records or an error.





# around\_transaction\_fun\(\)




    @type     around_transaction_fun() :: (    t    () ->
                                   {:ok,     Ash.Resource.record    ()} | {:error,     any    ()})


Function type for around\_transaction hooks that wrap query execution in a transaction.





# before\_transaction\_fun\(\)




    @type     before_transaction_fun() :: (    t    () ->     t    () | {:error,     any    ()})


Function type for before\_transaction hooks that run before query execution.





# t\(\)




    @type     t() :: %Ash.Query{
      __validated_for_action__:     atom    () | nil,
      action:     Ash.Resource.Actions.Read.t    () | nil,
      action_failed?:     boolean    (),
      after_action: [
        (    t    (), [    Ash.Resource.record    ()] ->
           {:ok, [    Ash.Resource.record    ()]}
           | {:ok, [    Ash.Resource.record    ()], [    Ash.Notifier.Notification.t    ()]}
           | {:error,     any    ()})
      ],
      after_transaction: [    after_transaction_fun    ()],
      aggregates: %{optional(    atom    ()) =>     Ash.Filter.t    ()},
      arguments: %{optional(    atom    ()) =>     any    ()},
      around_transaction: [    around_transaction_fun    ()],
      authorize_results: [
        (    t    (), [    Ash.Resource.record    ()] ->
           {:ok, [    Ash.Resource.record    ()]} | {:error,     any    ()})
      ],
      before_action: [(    t    () ->     t    ())],
      before_transaction: [    before_transaction_fun    ()],
      calculations: %{optional(    atom    ()) => :wat},
      combination_of: [    Ash.Query.Combination.t    ()],
      context:     map    (),
      distinct: [    atom    ()],
      distinct_sort:     term    (),
      domain:     module    () | nil,
      errors: [    Ash.Error.t    ()],
      filter:     Ash.Filter.t    () | nil,
      invalid_keys:     term    (),
      limit: nil |     non_neg_integer    (),
      load:     keyword    (    keyword    ()),
      load_through:     term    (),
      lock:     term    (),
      offset:     non_neg_integer    (),
      page:     keyword    () | nil | false,
      params: %{optional(    atom    () |     binary    ()) =>     any    ()},
      phase: :preparing | :before_action | :after_action | :executing,
      resource:     module    (),
      select: nil | [    atom    ()],
      sort: [    atom    () | {    atom    (), :asc | :desc}],
      sort_input_indices:     term    (),
      tenant:     term    (),
      timeout:     pos_integer    () | nil,
      to_tenant:     term    (),
      valid?:     boolean    ()
    }


A query struct for reading data from a resource.

Contains all the configuration needed to read data including filters, sorting, pagination, field selection, and relationship loading. Built incrementally through functions like `filter/2`, `sort/2`, `load/2`, etc.





# Functions




# accessing\(query, types \\\\ \[:attributes, :relationships, :calculations, :aggregates\], only\_public? \\\\ true\)



Returns a list of attributes, aggregates, relationships, and calculations that are being loaded

Provide a list of field types to narrow down the returned results.





# add\_error\(query, path \\\\ \[\], error\)




    @spec     add_error(    t    (), path ::     Ash.Error.path_input    (),     Ash.Error.error_input    ()) ::     t    ()


Add an error to the errors list and mark the query as invalid.

See `Ash.Error.to_ash_error/3` for more on supported values for `error`

## ******Inconsistencies**

The `path` argument is the second argument here, but the third argument in `Ash.ActionInput.add_error/2` and `Ash.Changeset.add_error/2`. This will be fixed in 4.0.





# after\_action\(query, func\)




    @spec     after_action(
      query ::     t    (),
      fun :: (    t    (), [    Ash.Resource.record    ()] ->
                {:ok, [    Ash.Resource.record    ()]}
                | {:ok, [    Ash.Resource.record    ()], [    Ash.Notifier.Notification.t    ()]}
                | {:error,     term    ()})
    ) ::     t    ()


Adds an after\_action hook to the query.

After action hooks are called with the query and the list of records returned from the action. They can modify the records, perform side effects, or return errors to halt processing. The hook can return notifications alongside the records.

## ******Examples**

    # Transform records after loading        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    after_action    (    fn         query    ,         records         ->        ...>           enriched_records         =         Enum    .    map    (    records    ,         &    add_computed_field    /    1    )        ...>           {    :ok    ,         enriched_records    }        ...>     end    )    
        # Log successful reads        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    after_action    (    fn         query    ,         records         ->        ...>           IO    .    puts    (    "Successfully loaded     #{    length    (    records    )    }     posts"    )        ...>           {    :ok    ,         records    }        ...>     end    )    
        # Add notifications after the action        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    after_action    (    fn         query    ,         records         ->        ...>           notifications         =         create_read_notifications    (    records    )        ...>           {    :ok    ,         records    ,         notifications    }        ...>     end    )    
        # Validate results and potentially error        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    after_action    (    fn         query    ,         records         ->        ...>           if         Enum    .    any?    (    records    ,         &    restricted?    /    1    )         do        ...>             {    :error    ,         "Access denied to restricted posts"    }        ...>           else        ...>             {    :ok    ,         records    }        ...>           end        ...>     end    )

## ******See also**

+ `before_action/3` for hooks that run before the action executes
+ `around_transaction/2` for hooks that wrap the entire transaction
+ `Ash.read/2` for executing queries with hooks





# after\_transaction\(query, func, opts \\\\ \[\]\)




    @spec     after_transaction(
      query ::     t    (),
      fun ::     after_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an after\_transaction hook to the query.

The after\_transaction hook runs after the database transaction completes, regardless of success or failure. It receives the query and the result, and can modify the result or perform cleanup operations.

## ******Examples**

    # Add cleanup after transaction        iex>     query         =         MyApp.Post         |>         Ash.Query    .    after_transaction    (    fn         query    ,         result         ->        ...>           cleanup_resources    (    )        ...>           result        ...>     end    )

## ******See also**

+ `before_transaction/2` for hooks that run before the transaction
+ `around_transaction/2` for hooks that wrap the entire transaction
+ `after_action/2` for hooks that run after the action \(inside transaction\)





# aggregate\(query, name, kind, relationship\)




    @spec     aggregate(    t    () |     Ash.Resource.t    (),     atom    () |     String.t    (),     atom    (),     atom    ()) ::     t    ()


Adds an aggregation to the query.

Aggregations are made available on the `aggregates` field of the records returned. They allow you to compute values from related data without loading entire relationships, making them very efficient for statistical operations.

## ******Examples**

    # Count related records        iex>     Ash.Query    .    aggregate    (    MyApp.Author    ,         :post_count    ,         :count    ,         :posts    )        %    Ash.Query    {    aggregates    :         %{    post_count    :         %    Ash.Query.Aggregate    {    ...    }    }    ,         ...    }    
        # Sum values from related records        iex>     Ash.Query    .    aggregate    (    MyApp.Author    ,         :total_likes    ,         :sum    ,         :posts    ,         field    :         :like_count    )        %    Ash.Query    {    aggregates    :         %{    total_likes    :         %    Ash.Query.Aggregate    {    ...    }    }    ,         ...    }    
        # Average with filtered aggregation        iex>     published_query         =         Ash.Query    .    filter    (    MyApp.Post    ,         published    :         true    )        iex>     Ash.Query    .    aggregate    (    MyApp.Author    ,         :avg_published_likes    ,         :avg    ,         :posts    ,        ...>           field    :         :like_count    ,         query    :         published_query    )        %    Ash.Query    {    aggregates    :         %{    avg_published_likes    :         %    Ash.Query.Aggregate    {    ...    }    }    ,         ...    }    
        # Count with default value        iex>     Ash.Query    .    aggregate    (    MyApp.Author    ,         :post_count    ,         :count    ,         :posts    ,         default    :         0    )        %    Ash.Query    {    aggregates    :         %{    post_count    :         %    Ash.Query.Aggregate    {    ...    }    }    ,         ...    }

## ******Options**

+ `query` - The query over the destination resource to use as a base for aggregation
+ `field` - The field to use for the aggregate. Not necessary for all aggregate types
+ `default` - The default value to use if the aggregate returns nil
+ `filterable?` - Whether or not this aggregate may be referenced in filters
+ `type` - The type of the aggregate
+ `constraints` - Type constraints for the aggregate's type
+ `implementation` - An implementation used when the aggregate kind is custom
+ `read_action` - The read action to use on the destination resource
+ `authorize?` - Whether or not to authorize access to this aggregate
+ `join_filters` - A map of relationship paths to filter expressions

## ******See also**

+ Resource DSL aggregates documentation for more information
+ `load/3` for loading relationships instead of aggregating
+ `calculate/8` for custom calculations
+ `Ash.read/2` for executing queries with aggregates





# aggregate\(query, name, kind, relationship, opts\)




    @spec     aggregate(
          t    () |     Ash.Resource.t    (),
          atom    () |     String.t    (),
          atom    (),
          atom    (),
          Keyword.t    ()
    ) ::     t    ()





# apply\_to\(query, records, opts \\\\ \[\]\)




    @spec     apply_to(    t    (), records :: [    Ash.Resource.record    ()], opts ::     Keyword.t    ()) ::
      {:ok, [    Ash.Resource.record    ()]}


Applies a query to a list of records in memory.

This function takes a query and applies its filters, sorting, pagination, and loading operations to an existing list of records in memory rather than querying the data layer. Useful for post-processing records or applying query logic to data from multiple sources.

## ******Examples**

    # Apply filtering to records in memory        iex>     records         =         [    %    MyApp.Post    {    title    :         "A"    ,         published    :         true    }    ,         %    MyApp.Post    {    title    :         "B"    ,         published    :         false    }    ]        iex>     query         =         MyApp.Post         |>         Ash.Query    .    filter    (    published    :         true    )        iex>     Ash.Query    .    apply_to    (    query    ,         records    )        {    :ok    ,         [    %    MyApp.Post    {    title    :         "A"    ,         published    :         true    }    ]    }    
        # Apply sorting and limiting        iex>     records         =         [    %    MyApp.Post    {    title    :         "C"    ,         likes    :         5    }    ,         %    MyApp.Post    {    title    :         "A"    ,         likes    :         10    }    ]        iex>     query         =         MyApp.Post         |>         Ash.Query    .    sort    (    likes    :         :desc    )         |>         Ash.Query    .    limit    (    1    )        iex>     Ash.Query    .    apply_to    (    query    ,         records    )        {    :ok    ,         [    %    MyApp.Post    {    title    :         "A"    ,         likes    :         10    }    ]    }    
        # Apply with loading relationships        iex>     records         =         [    %    MyApp.Post    {    id    :         1    }    ,         %    MyApp.Post    {    id    :         2    }    ]        iex>     query         =         MyApp.Post         |>         Ash.Query    .    load    (    :author    )        iex>     Ash.Query    .    apply_to    (    query    ,         records    ,         domain    :         MyApp.Blog    )        {    :ok    ,         [    %    MyApp.Post    {    id    :         1    ,         author    :         %    MyApp.User    {    ...    }    }    ,         ...    ]    }

## ******Options**

+ `domain` - The domain to use for loading relationships
+ `actor` - The actor for authorization during loading
+ `tenant` - The tenant for multitenant operations
+ `parent` - Parent context for nested operations

## ******See also**

+ `Ash.read/2` for querying the data layer directly
+ `load/3` for configuring relationship loading
+ `filter/2` for adding filter conditions





# around\_transaction\(query, func, opts \\\\ \[\]\)




    @spec     around_transaction(
      query ::     t    (),
      fun ::     around_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an around\_transaction hook to the query.

Your function will get the query, and a callback that must be called with a query \(that may be modified\). The callback will return `{:ok, results}` or `{:error, error}`. You can modify these values, but the return value must be one of those types.

The around\_transaction calls happen first, and then \(after they each resolve their callbacks\) the `before_action` hooks are called, followed by the `after_action` hooks being run. Then, the code that appeared *after* the callbacks were called is then run.

## ******Examples**

    # Add logging around the transaction        iex>     query         =         MyApp.Post         |>         Ash.Query    .    around_transaction    (    fn         query    ,         callback         ->        ...>           IO    .    puts    (    "Starting transaction for     #{    inspect    (    query    .    resource    )    }    "    )        ...>           result         =         callback    .    (    query    )        ...>           IO    .    puts    (    "Transaction completed:     #{    inspect    (    result    )    }    "    )        ...>           result        ...>     end    )    
        # Add error handling and retry logic        iex>     query         =         MyApp.Post         |>         Ash.Query    .    around_transaction    (    fn         query    ,         callback         ->        ...>           case         callback    .    (    query    )         do        ...>             {    :ok    ,         results    }         =         success         ->         success        ...>             {    :error    ,         %{    retryable?    :         true    }    }         ->        ...>               callback    .    (    query    )          # Retry once        ...>             error         ->         error        ...>           end        ...>     end    )

## ******Warning**

Using this without understanding how it works can cause big problems. You *must* call the callback function that is provided to your hook, and the return value must contain the same structure that was given to you, i.e `{:ok, result_of_action}`.

## ******See also**

+ `before_transaction/2` for hooks that run before the transaction
+ `after_transaction/2` for hooks that run after the transaction
+ `before_action/3` for hooks that run before the action executes
+ `after_action/2` for hooks that run after the action completes
+ `Ash.read/2` for executing queries with hooks





# before\_action\(query, func, opts \\\\ \[\]\)




    @spec     before_action(
      query ::     t    (),
      fun :: (    t    () ->     t    () | {    t    (), [    Ash.Notifier.Notification.t    ()]}),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before\_action hook to the query.

Before action hooks are called after preparations but before the actual data layer query is executed. They receive the prepared query and can modify it or perform side effects before the action runs.

## ******Examples**

    # Add validation before the query runs        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    before_action    (    fn         query         ->        ...>           if         Enum    .    empty?    (    query    .    sort    )         do        ...>             Ash.Query    .    sort    (    query    ,         :created_at    )        ...>           else        ...>             query        ...>           end        ...>     end    )    
        # Add logging before the action        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    before_action    (    fn         query         ->        ...>           IO    .    puts    (    "Executing query for     #{    length    (    query    .    filter         ||         [    ]    )    }     filters"    )        ...>           query        ...>     end    )    
        # Prepend a hook to run first        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    before_action    (    &    setup_query    /    1    )        ...>     |>         Ash.Query    .    before_action    (    &    early_validation    /    1    ,         prepend?    :         true    )

## ******Options**

+ `prepend?` - when `true`, places the hook before all other hooks instead of after

## ******See also**

+ `after_action/2` for hooks that run after the action completes
+ `around_transaction/2` for hooks that wrap the entire transaction
+ `Ash.read/2` for executing queries with hooks





# before\_transaction\(query, func, opts \\\\ \[\]\)




    @spec     before_transaction(
      query ::     t    (),
      fun ::     before_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before\_transaction hook to the query.

The before\_transaction hook runs before the database transaction begins. It receives the query and must return either a modified query or an error.

## ******Examples**

    # Add logging before transaction        iex>     query         =         MyApp.Post         |>         Ash.Query    .    before_transaction    (    fn         query         ->        ...>           IO    .    puts    (    "Starting transaction for     #{    inspect    (    query    .    resource    )    }    "    )        ...>           query        ...>     end    )

## ******See also**

+ `after_transaction/2` for hooks that run after the transaction
+ `around_transaction/2` for hooks that wrap the entire transaction
+ `before_action/3` for hooks that run before the action \(inside transaction\)





# build\(resource, domain \\\\ nil, keyword\)




    @spec     build(    Ash.Resource.t    () |     t    (),     Ash.Domain.t    () | nil,     Keyword.t    ()) ::     t    ()


Builds a query from a keyword list.

This is used by certain query constructs like aggregates. It can also be used to manipulate a data structure before passing it to an ash query. It allows for building an entire query struct using only a keyword list.

For example:

    Ash.Query    .    build    (    MyResource    ,         filter    :         [    name    :         "fred"    ]    ,         sort    :         [    name    :         :asc    ]    ,         load    :         [    :foo    ,         :bar    ]    ,         offset    :         10    )

If you want to use the expression style filters, you can use `expr/1`.

For example:

    import         Ash.Expr    ,         only    :         [    expr    :         1    ]    
        Ash.Query    .    build    (    Myresource    ,         filter    :         expr    (    name         ==         "marge"    )    )

## ******Options**

+ 
`:filter` \(`term/0`\) - A filter keyword, map or expression

+ 
`:filter_input` \(`term/0`\) - A filter keyword or map, provided as input from an external source

+ 
`:sort` \(`term/0`\) - A sort list or keyword

+ 
`:sort_input` \(`term/0`\) - A sort list or keyword, provided as input from an external source

+ 
`:default_sort` \(`term/0`\) - A sort list or keyword to apply only if no other sort is specified, So if you apply any `sort`, this will be ignored.

+ 
`:distinct_sort` \(`term/0`\) - A distinct\_sort list or keyword

+ 
`:limit` \(`integer/0`\) - A limit to apply

+ 
`:offset` \(`integer/0`\) - An offset to apply

+ 
`:load` \(`term/0`\) - A load statement to add to the query

+ 
`:strict_load` \(`term/0`\) - A load statement to add to the query with the `strict?` option set to `true`

+ 
`:select` \(`term/0`\) - A select statement to add to the query

+ 
`:ensure_selected` \(`term/0`\) - An ensure\_selected statement to add to the query

+ 
`:aggregate` \(`term/0`\) - A custom aggregate to add to the query. Can be `{name, type, relationship}` or `{name, type, relationship, build_opts}`

+ 
`:calculate` \(`term/0`\) - A custom calculation to add to the query. Can be `{name, module_and_opts}` or `{name, module_and_opts, context}`

+ 
`:distinct` \(list of `atom/0`\) - A distinct clause to add to the query

+ 
`:context` \(`map/0`\) - A map to merge into the query context





# calculate\(query, name, type, module\_and\_opts, arguments \\\\ %\{\}, constraints \\\\ \[\], extra\_context \\\\ %\{\}, new\_calculation\_opts \\\\ \[\]\)




    @spec     calculate(
          t    () |     Ash.Resource.t    (),
          atom    (),
          Ash.Type.t    (),
          module    () | {    module    (),     Keyword.t    ()},
          map    (),
          Keyword.t    (),
          map    (),
          Keyword.t    ()
    ) ::     t    ()


Adds a calculation to the query.

Calculations are made available on the `calculations` field of the records returned. They allow you to compute dynamic values based on record data, other fields, or external information at query time.

The `module_and_opts` argument accepts either a `module` or a `{module, opts}`. For more information on what that module should look like, see `Ash.Resource.Calculation`.

## ******Examples**

    # Add a simple calculation        iex>     Ash.Query    .    calculate    (    MyApp.User    ,         :display_name    ,         :string    ,        ...>           {    MyApp.Calculations.DisplayName    ,         [    ]    }    )        %    Ash.Query    {    calculations    :         %{    display_name    :         %{    ...    }    }    ,         ...    }    
        # Add calculation with arguments        iex>     Ash.Query    .    calculate    (    MyApp.Post    ,         :word_count    ,         :integer    ,        ...>           {    MyApp.Calculations.WordCount    ,         [    ]    }    ,         %{    field    :         :content    }    )        %    Ash.Query    {    calculations    :         %{    word_count    :         %{    ...    }    }    ,         ...    }    
        # Add calculation with constraints and context        iex>     Ash.Query    .    calculate    (    MyApp.Product    ,         :discounted_price    ,         :decimal    ,        ...>           {    MyApp.Calculations.Discount    ,         [    ]    }    ,         %{    rate    :         0.1    }    ,        ...>           [    precision    :         2    ,         scale    :         2    ]    ,         %{    currency    :         "USD"    }    )        %    Ash.Query    {    calculations    :         %{    discounted_price    :         %{    ...    }    }    ,         ...    }

## ******See also**

+ `Ash.Resource.Calculation` for implementing custom calculations
+ `aggregate/5` for computing values from related records
+ `load/3` for loading predefined calculations from the resource
+ `select/3` for controlling which fields are returned alongside calculations





# clear\_result\(query\)




    @spec     clear_result(    t    ()) ::     t    ()


Removes a result set previously with `set_result/2`





# combination\_of\(query, combinations\)




    @spec     combination_of(    t    (),     Ash.Query.Combination.t    () | [    Ash.Query.Combination.t    ()]) ::
          t    ()


Produces a query that is the combination of multiple queries.

All aspects of the parent query are applied to the combination in total.

See `Ash.Query.Combination` for more on creating combination queries.

### ******Example**

    # Top ten users not on a losing streak and top ten users who are not on a winning streak        User        |>         Ash.Query    .    filter    (    active         ==         true    )        |>         Ash.Query    .    combination_of    (    [    
          # must always begin with a base combination    
          Ash.Query.Combination    .    base    (    
            sort    :         [    score    :         :desc    ]    ,    
            filter    :         expr    (    not    (    on_a_losing_streak    )    )    ,    
            limit    :         10    
          )    ,    
          Ash.Query.Combination    .    union    (    
            sort    :         [    score    :         :asc    ]    ,    
            filter    :         expr    (    not    (    on_a_winning_streak    )    )    ,    
            limit    :         10    
          )        ]    )        |>         Ash    .    read!    (    )

### ******Select and calculations**

There is no `select` available for combinations, instead the select of the outer query is used for each combination. However, you can use the `calculations` field in `Ash.Query.Combination` to add expression calculations. Those calculations can "overwrite" a selected attribute, or can introduce a new field. Note that, for SQL data layers, all combinations will be required to have the same number of fields in their SELECT statement, which means that if one combination adds a calculation, all of the others must also add that calculation.

In this example, we compute separate match scores

    query         =         "fred"    
        User        |>         Ash.Query    .    filter    (    active         ==         true    )        |>         Ash.Query    .    combination_of    (    [    
          # must always begin with a base combination    
          Ash.Query.Combination    .    base    (    
            filter    :         expr    (    trigram_similarity    (    user_name    ,         ^    query    )         >=         0.5    )    ,    
            calculate    :         %{    
              match_score    :         trigram_similarity    (    user_name    ,         ^    query    )    
            }    ,    
            sort    :         [    
              calc    (    trigram_similarity    (    user_name    ,         ^    query    )    ,         :desc    )    
            ]    ,    
            limit    :         10    
          )    ,    
          Ash.Query.Combination    .    union    (    
            filter    :         expr    (    trigram_similarity    (    email    ,         ^    query    )         >=         0.5    )    ,    
            calculate    :         %{    
              match_score    :         trigram_similarity    (    email    ,         ^    query    )    
            }    ,    
            sort    :         [    
              calc    (    trigram_similarity    (    email    ,         ^    query    )    ,         :desc    )    
            ]    ,    
            limit    :         10    
          )        ]    )        |>         Ash    .    read!    (    )





# data\_layer\_query\(ash\_query, opts \\\\ \[\]\)



Return the underlying data layer query for an ash query





# default\_sort\(query, sorts, opts \\\\ \[\]\)




    @spec     default_sort(    t    () |     Ash.Resource.t    (),     Ash.Sort.t    (), opts ::     Keyword.t    ()) ::     t    ()


Apply a sort only if no sort has been specified yet.

This is useful for providing default sorts that can be overridden.

## ******Examples**

    # This will sort by name if no sort has been specified        Ash.Query    .    default_sort    (    query    ,         :name    )    
        # This will sort by name descending if no sort has been specified        Ash.Query    .    default_sort    (    query    ,         name    :         :desc    )





# delete\_argument\(query, argument\_or\_arguments\)



Remove an argument from the query





# deselect\(query, fields\)




    @spec     deselect(    t    () |     Ash.Resource.t    (), [    atom    ()]) ::     t    ()


Ensures that the specified attributes are `nil` in the query results.

This function removes specified fields from the selection, causing them to be excluded from the query results. If no fields are currently selected \(meaning all fields would be returned by default\), this will first select all default fields and then remove the specified ones.

## ******Examples**

    # Remove specific fields from results        iex>     MyApp.Post         |>         Ash.Query    .    deselect    (    [    :content    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :created_at    ,         ...    ]    ,         ...    }    
        # Remove multiple fields        iex>     MyApp.Post         |>         Ash.Query    .    deselect    (    [    :content    ,         :metadata    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :created_at    ,         ...    ]    ,         ...    }    
        # Deselect from existing selection        iex>     MyApp.Post        ...>     |>         Ash.Query    .    select    (    [    :title    ,         :content    ,         :author_id    ]    )        ...>     |>         Ash.Query    .    deselect    (    [    :content    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :author_id    ]    ,         ...    }    
        # Deselect empty list (no-op)        iex>     MyApp.Post         |>         Ash.Query    .    deselect    (    [    ]    )        %    Ash.Query    {    ...    }

## ******See also**

+ `select/3` for explicitly controlling field selection
+ `ensure_selected/2` for adding fields without removing others
+ Primary key fields cannot be deselected and will always be included





# distinct\(query, distincts\)




    @spec     distinct(    t    () |     Ash.Resource.t    (),     Ash.Sort.t    ()) ::     t    ()


Get results distinct on the provided fields.

Takes a list of fields to distinct on. Each call is additive, so to remove the `distinct` use `unset/2`.

Examples:

    Ash.Query    .    distinct    (    query    ,         [    :first_name    ,         :last_name    ]    )    
        Ash.Query    .    distinct    (    query    ,         :email    )





# distinct\_sort\(query, sorts, opts \\\\ \[\]\)



Set a sort to determine how distinct records are selected.

If none is set, any sort applied to the query will be used.

This is useful if you want to control how the `distinct` records are selected without affecting \(necessarily, it may affect it if there is no sort applied\) the overall sort of the query





# ensure\_selected\(query, fields\)




    @spec     ensure_selected(    t    () |     Ash.Resource.t    (), [    atom    ()] |     atom    ()) ::     t    ()


Ensures that the given attributes are selected.

The first call to `select/2` will *limit* the fields to only the provided fields. Use `ensure_selected/2` to say "select this field \(or these fields\) without deselecting anything else". This function is additive - it will not remove any fields that are already selected.

## ******Examples**

    # Ensure specific fields are selected (additive)        iex>     MyApp.Post         |>         Ash.Query    .    ensure_selected    (    [    :title    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :content    ,         :created_at    ]    ,         ...    }    
        # Add to existing selection        iex>     MyApp.Post        ...>     |>         Ash.Query    .    select    (    [    :title    ]    )        ...>     |>         Ash.Query    .    ensure_selected    (    [    :content    ,         :author_id    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :content    ,         :author_id    ]    ,         ...    }    
        # Ensure fields for relationship loading        iex>     MyApp.Post        ...>     |>         Ash.Query    .    ensure_selected    (    [    :author_id    ]    )        ...>     |>         Ash.Query    .    load    (    :author    )        %    Ash.Query    {    select    :         [    ...    ,         :author_id    ]    ,         load    :         [    author    :         [    ]    ]    ,         ...    }

## ******See also**

+ `select/3` for explicitly controlling field selection
+ `deselect/2` for removing specific fields from selection
+ `load/3` for loading relationships that may require specific fields





# equivalent\_to\(query, expr\)
\(macro\)   


Determines if the filter statement of a query is equivalent to the provided expression.

This uses the satisfiability solver that is used when solving for policy authorizations. In complex scenarios, or when using custom database expressions, \(like fragments in ash\_postgres\), this function may return `:maybe`. Use `supserset_of?` to always return a boolean.





# equivalent\_to?\(query, expr\)
\(macro\)   


Same as `equivalent_to/2` but always returns a boolean. `:maybe` returns `false`.





# fetch\_argument\(query, argument\)




    @spec     fetch_argument(    t    (),     atom    () |     String.t    ()) :: {:ok,     term    ()} | :error


Fetches the value of an argument provided to the query.

Returns `{:ok, value}` if the argument exists, or `:error` if not found. This is the safer alternative to `get_argument/2` when you need to distinguish between a `nil` value and a missing argument.

## ******Examples**

    # Fetch an argument that exists        iex>     query         =         Ash.Query    .    for_read    (    MyApp.Post    ,         :published    ,         %{    since    :         ~D[2023-01-01]    }    )        iex>     Ash.Query    .    fetch_argument    (    query    ,         :since    )        {    :ok    ,         ~D[2023-01-01]    }    
        # Fetch an argument that doesn't exist        iex>     query         =         Ash.Query    .    for_read    (    MyApp.Post    ,         :published    ,         %{    }    )        iex>     Ash.Query    .    fetch_argument    (    query    ,         :since    )        :error    
        # Distinguish between nil and missing arguments        iex>     query         =         Ash.Query    .    for_read    (    MyApp.Post    ,         :search    ,         %{    query    :         nil    }    )        iex>     Ash.Query    .    fetch_argument    (    query    ,         :query    )        {    :ok    ,         nil    }

## ******See also**

+ `get_argument/2` for simpler argument access
+ `set_argument/3` for adding arguments to queries
+ `for_read/4` for creating queries with arguments





# filter\(query, filter\)
\(macro\)   


Attach a filter statement to the query.

The filter is applied as an "and" to any filters currently on the query. Filters allow you to specify conditions that records must meet to be included in the query results. Multiple filters on the same query are combined with "and" logic.

## ******Examples**

    # Filter with simple equality        MyApp.Post        |>         Ash.Query    .    filter    (    published    :         true    )    
        # Filter with comparison operators        MyApp.Post        |>         Ash.Query    .    filter    (    view_count         >         100    )    
        # Filter with complex expressions using do block        MyApp.Post        |>         Ash.Query    .    filter         do    
          published         ==         true         and         view_count         >         100        end

## ******See also**

+ `Ash.Filter` for comprehensive filter documentation
+ `sort/3` for ordering query results
+ `Ash.read/2` for executing filtered queries





# filter\_input\(query, filter\)



Attach a filter statement to the query labelled as user input.

Filters added as user input \(or filters constructed with `Ash.Filter.parse_input`\) will honor any field policies on resources by replacing any references to the field with `nil` in cases where the actor should not be able to see the given field.

This function does not expect the expression style filter \(because an external source could never reasonably provide that\). Instead, use the keyword/map style syntax. For example:

`expr(name == "fred")`

could be any of

+ map syntax: `%{"name" => %{"eq" => "fred"}}`
+ keyword syntax: `[name: [eq: "fred"]]`

See `Ash.Filter` for more.





# for\_read\(query, action\_name, args \\\\ %\{\}, opts \\\\ \[\]\)




    @spec     for_read(    t    () |     Ash.Resource.t    (),     atom    (),     map    () |     Keyword.t    (),     Keyword.t    ()) ::
          t    ()


Creates a query for a given read action and prepares it.

This function configures the query to use a specific read action with the provided arguments and options. The query will be validated and prepared according to the action's configuration, including applying preparations and action filters.

Multitenancy is *not* validated until an action is called. This allows you to avoid specifying a tenant until just before calling the domain action.

## ******Examples**

    # Create a query for a simple read action        iex>     Ash.Query    .    for_read    (    MyApp.Post    ,         :read    )        %    Ash.Query    {    action    :         %{    name    :         :read    }    ,         ...    }    
        # Create a query with arguments for a parameterized action        iex>     Ash.Query    .    for_read    (    MyApp.Post    ,         :published    ,         %{    since    :         ~D[2023-01-01]    }    )        %    Ash.Query    {    action    :         %{    name    :         :published    }    ,         arguments    :         %{    since    :         ~D[2023-01-01]    }    ,         ...    }    
        # Create a query with options        iex>     Ash.Query    .    for_read    (    MyApp.Post    ,         :read    ,         %{    }    ,         actor    :         current_user    ,         authorize?    :         true    )        %    Ash.Query    {    action    :         %{    name    :         :read    }    ,         ...    }

## ******Options**

+ 
`:actor` \(`term/0`\) - set the actor, which can be used in any `Ash.Resource.Change`s configured on the action. \(in the `context` argument\)

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:authorize?` \(`boolean/0`\) - set authorize?, which can be used in any `Ash.Resource.Change`s configured on the action. \(in the `context` argument\)

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer to use. Will be carried over to the action. For more information see `Ash.Tracer`.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - set the tenant on the query

+ 
`:load` \(`term/0`\) - A load statement to apply to the query

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:context` \(`map/0`\) - A map of context to set on the query. This will be merged with any context set on the query itself.


## ******See also**

+ `Ash.read/2` for executing the prepared query
+ `new/2` for creating basic queries without specific actions
+ `load/3` for adding relationship loading to queries
+ `d:Ash.Resource.Dsl.actions.read` for defining read actions
+ Read Actions Guide for understanding read operations
+ Actions Guide for general action concepts





# get\_argument\(query, argument\)




    @spec     get_argument(    t    (),     atom    () |     String.t    ()) ::     term    ()


Gets the value of an argument provided to the query.

Returns the argument value if found, or `nil` if not found. Arguments can be provided when creating queries with `for_read/4` and are used by action logic such as preparations and filters.

## ******Examples**

    # Get an argument that exists        iex>     query         =         Ash.Query    .    for_read    (    MyApp.Post    ,         :published    ,         %{    since    :         ~D[2023-01-01]    }    )        iex>     Ash.Query    .    get_argument    (    query    ,         :since    )        ~D[2023-01-01]    
        # Get an argument that doesn't exist        iex>     query         =         Ash.Query    .    for_read    (    MyApp.Post    ,         :published    ,         %{    }    )        iex>     Ash.Query    .    get_argument    (    query    ,         :since    )        nil    
        # Arguments can be accessed by string or atom key        iex>     query         =         Ash.Query    .    for_read    (    MyApp.Post    ,         :search    ,         %{    "query"         =>         "elixir"    }    )        iex>     Ash.Query    .    get_argument    (    query    ,         :query    )        "elixir"

## ******See also**

+ `fetch_argument/2` for safer argument access with explicit error handling
+ `set_argument/3` for adding arguments to queries
+ `for_read/4` for creating queries with arguments





# limit\(query, limit\)




    @spec     limit(    t    () |     Ash.Resource.t    (), nil |     integer    ()) ::     t    ()


Limits the number of results returned from the query.

This function sets the maximum number of records that will be returned when the query is executed. Useful for pagination and preventing large result sets from consuming too much memory.

## ******Examples**

    # Limit to 10 results        iex>     MyApp.Post         |>         Ash.Query    .    limit    (    10    )        %    Ash.Query    {    limit    :         10    ,         ...    }    
        # Remove existing limit        iex>     query         |>         Ash.Query    .    limit    (    nil    )        %    Ash.Query    {    limit    :         nil    ,         ...    }    
        # Use with other query functions        iex>     MyApp.Post        ...>     |>         Ash.Query    .    filter    (    published    :         true    )        ...>     |>         Ash.Query    .    sort    (    :created_at    )        ...>     |>         Ash.Query    .    limit    (    5    )        %    Ash.Query    {    limit    :         5    ,         ...    }

## ******See also**

+ `offset/2` for skipping records \(pagination\)
+ `page/2` for keyset pagination
+ `sort/3` for ordering results before limiting





# load\(query, load\_statement, opts \\\\ \[\]\)




    @spec     load(
          t    () |     Ash.Resource.t    (),
          atom    ()
      |     Ash.Query.Calculation.t    ()
      |     Ash.Query.Aggregate.t    ()
      | [    atom    () |     Ash.Query.Calculation.t    () |     Ash.Query.Aggregate.t    ()]
      | [{    atom    () |     Ash.Query.Calculation.t    () |     Ash.Query.Aggregate.t    (),     term    ()}],
          Keyword.t    ()
    ) ::     t    ()


Loads relationships, calculations, or aggregates on the resource.

By default, loading attributes has no effect, as all attributes are returned. See the section below on "Strict Loading" for more.

## ******Examples**

    # Load simple relationships        iex>     Ash.Query    .    load    (    MyApp.Post    ,         :author    )        %    Ash.Query    {    load    :         [    author    :         [    ]    ]    ,         ...    }    
        # Load nested relationships        iex>     Ash.Query    .    load    (    MyApp.Post    ,         [    comments    :         [    :author    ,         :ratings    ]    ]    )        %    Ash.Query    {    load    :         [    comments    :         [    author    :         [    ]    ,         ratings    :         [    ]    ]    ]    ,         ...    }    
        # Load relationships with custom queries        iex>     author_query         =         Ash.Query    .    filter    (    MyApp.User    ,         active    :         true    )        iex>     Ash.Query    .    load    (    MyApp.Post    ,         [    comments    :         [    author    :         author_query    ]    ]    )        %    Ash.Query    {    load    :         [    comments    :         [    author    :         %    Ash.Query    {    ...    }    ]    ]    ,         ...    }    
        # Load calculations with arguments        iex>     Ash.Query    .    load    (    MyApp.User    ,         full_name    :         %{    format    :         :last_first    }    )        %    Ash.Query    {    calculations    :         %{    full_name    :         %    Ash.Query.Calculation    {    ...    }    }    ,         ...    }

## ******Strict Loading**

By passing `strict?: true`, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.

    # Only load specific fields on relationships        iex>     Ash.Query    .    load    (    MyApp.Category    ,         [    :name    ,         posts    :         [    :title    ,         :published_at    ]    ]    ,         strict?    :         true    )        %    Ash.Query    {    load    :         [    posts    :         [    :title    ,         :published_at    ]    ]    ,         ...    }

When using `strict?: true` and loading nested relationships, you must specify all the attributes you want to load alongside the nested relationships:

    # Must include needed attributes when loading nested relationships strictly        iex>     Ash.Query    .    load    (    MyApp.Post    ,         [    :title    ,         :published_at    ,         category    :         [    :name    ]    ]    ,         strict?    :         true    )        %    Ash.Query    {    ...    }

## ******See also**

+ `select/3` for controlling which attributes are returned
+ `ensure_selected/2` for ensuring specific fields are selected
+ `Ash.read/2` for executing queries with loaded data
+ Relationships Guide for understanding relationships
+ Calculations Guide for understanding calculations





# load\_calculation\_as\(query, calc\_name, as\_name, opts\_or\_args \\\\ %\{\}, opts \\\\ \[\]\)



Adds a resource calculation to the query as a custom calculation with the provided name.

Example:

    Ash.Query    .    load_calculation_as    (    query    ,         :calculation    ,         :some_name    ,         args    :         %{    }    ,         load_through    :         [    :foo    ]    )





# load\_through\(query, type, name, load\)



Adds a load statement to the result of an attribute or calculation.

Uses `Ash.Type.load/5` to request that the type load nested data.





# loading?\(query, item\)



Returns true if the field/relationship or path to field/relationship is being loaded.

It accepts an atom or a list of atoms, which is treated for as a "path", i.e:

    Resource         |>         Ash.Query    .    load    (    friends    :         [    enemies    :         [    :score    ]    ]    )         |>         Ash.Query    .    loading?    (    [    :friends    ,         :enemies    ,         :score    ]    )        iex>     true    
        Resource         |>         Ash.Query    .    load    (    friends    :         [    enemies    :         [    :score    ]    ]    )         |>         Ash.Query    .    loading?    (    [    :friends    ,         :score    ]    )        iex>     false    
        Resource         |>         Ash.Query    .    load    (    friends    :         [    enemies    :         [    :score    ]    ]    )         |>         Ash.Query    .    loading?    (    :friends    )        iex>     true





# lock\(query, lock\_type\)




    @spec     lock(    t    () |     Ash.Resource.t    (),     Ash.DataLayer.lock_type    ()) ::     t    ()


Lock the query results.

This must be run while in a transaction, and is not supported by all data layers.





# merge\_query\_load\(left, right, context\)



Merges two query's load statements, for the purpose of handling calculation requirements.

This should only be used if you are writing a custom type that is loadable. See the callback documentation for `Ash.Type.merge_load/4` for more.





# new\(resource, opts \\\\ \[\]\)




    @spec     new(    Ash.Resource.t    () |     t    (), opts ::     Keyword.t    ()) ::     t    ()


Creates a new query for the given resource.

This is the starting point for building queries. The query will automatically include the resource's base filter and default context.

## ******Examples**

    # Create a new query for a resource        iex>     Ash.Query    .    new    (    MyApp.Post    )        %    Ash.Query    {    resource    :         MyApp.Post    ,         ...    }    
        # Create a query with options        iex>     Ash.Query    .    new    (    MyApp.Post    ,         domain    :         MyApp.Blog    )        %    Ash.Query    {    resource    :         MyApp.Post    ,         domain    :         MyApp.Blog    ,         ...    }    
        # Pass an existing query (returns the query unchanged)        iex>     query         =         Ash.Query    .    new    (    MyApp.Post    )        iex>     Ash.Query    .    new    (    query    )        %    Ash.Query    {    resource    :         MyApp.Post    ,         ...    }

## ******See also**

+ `for_read/4` for creating queries bound to specific read actions
+ `filter/2` for adding filter conditions
+ `sort/3` for adding sort criteria
+ Read Actions Guide for understanding read operations
+ Actions Guide for general action concepts





# offset\(query, offset\)




    @spec     offset(    t    () |     Ash.Resource.t    (), nil |     integer    ()) ::     t    ()


Skips the first n records in the query results.

This function is often used for offset-based pagination, allowing you to skip a specified number of records from the beginning of the result set. Often used together with `limit/2` to implement pagination.

## ******Examples**

    # Skip the first 20 records        iex>     MyApp.Post         |>         Ash.Query    .    offset    (    20    )        %    Ash.Query    {    offset    :         20    ,         ...    }    
        # Remove existing offset        iex>     query         |>         Ash.Query    .    offset    (    nil    )        %    Ash.Query    {    offset    :         0    ,         ...    }    
        # Pagination example: page 3 with 10 items per page        iex>     MyApp.Post        ...>     |>         Ash.Query    .    sort    (    :created_at    )        ...>     |>         Ash.Query    .    offset    (    20    )          # Skip first 20 (pages 1-2)        ...>     |>         Ash.Query    .    limit    (    10    )           # Take next 10 (page 3)        %    Ash.Query    {    offset    :         20    ,         limit    :         10    ,         ...    }

## ******See also**

+ `limit/2` for limiting the number of results
+ `page/2` for keyset pagination \(more efficient for large datasets\)
+ `sort/3` for ordering results before offsetting





# page\(query, page\_opts\)




    @spec     page(    t    () |     Ash.Resource.t    (),     Keyword.t    () | nil | false) ::     t    ()


Sets the pagination options of the query.

This function configures how results should be paginated when the query is executed. Ash supports both offset-based pagination \(limit/offset\) and keyset-based pagination \(cursor-based\), with keyset being more efficient for large datasets.

## ******Examples**

    # Offset-based pagination (page 2, 10 items per page)        iex>     MyApp.Post        ...>     |>         Ash.Query    .    page    (    limit    :         10    ,         offset    :         10    )        %    Ash.Query    {    page    :         [    limit    :         10    ,         offset    :         10    ]    ,         ...    }    
        # Keyset pagination with before/after cursors        iex>     MyApp.Post        ...>     |>         Ash.Query    .    sort    (    :created_at    )        ...>     |>         Ash.Query    .    page    (    limit    :         20    ,         after    :         "cursor_string"    )        %    Ash.Query    {    page    :         [    limit    :         20    ,         after    :         "cursor_string"    ]    ,         ...    }    
        # Disable pagination (return all results)        iex>     MyApp.Post         |>         Ash.Query    .    page    (    nil    )        %    Ash.Query    {    page    :         nil    ,         ...    }    
        # Pagination with counting        iex>     MyApp.Post         |>         Ash.Query    .    page    (    limit    :         10    ,         count    :         true    )        %    Ash.Query    {    page    :         [    limit    :         10    ,         count    :         true    ]    ,         ...    }

## ******Pagination Types**

### ******Limit/offset pagination**

+ 
`:offset` \(`non_neg_integer/0`\) - The number of records to skip from the beginning of the query

+ 
`:limit` \(`pos_integer/0`\) - The number of records to include in the page

+ 
`:filter` \(`term/0`\) - A filter to apply for pagination purposes, that should not be considered in the full count.  
This is used by the liveview paginator to only fetch the records that were *already* on the page when refreshing data, to avoid pages jittering.

+ 
`:count` \(`boolean/0`\) - Whether or not to return the page with a full count of all records


### ******Keyset pagination**

+ 
`:before` \(`String.t/0`\) - Get records that appear before the provided keyset \(mutually exclusive with `after`\)

+ 
`:after` \(`String.t/0`\) - Get records that appear after the provided keyset \(mutually exclusive with `before`\)

+ 
`:limit` \(`pos_integer/0`\) - How many records to include in the page

+ 
`:filter` \(`term/0`\) - See the `filter` option for offset pagination, this behaves the same.

+ 
`:count` \(`boolean/0`\) - Whether or not to return the page with a full count of all records


## ******See also**

+ `limit/2` and `offset/2` for simple pagination without page metadata
+ `sort/3` for ordering results \(required for keyset pagination\)
+ `Ash.read/2` for executing paginated queries





# put\_context\(query, key, value\)




    @spec     put_context(    t    () |     Ash.Resource.t    (),     atom    (),     term    ()) ::     t    ()


Sets a specific context key to a specific value.

Context is used to pass additional information through the query pipeline that can be accessed by preparations, calculations, and other query logic. This function adds or updates a single key in the query's context map.

## ******Examples**

    # Add actor information to context        iex>     query         =         MyApp.Post         |>         Ash.Query    .    put_context    (    :actor    ,         current_user    )        %    Ash.Query    {    context    :         %{    actor    :         %    User    {    ...    }    }    ,         ...    }    
        # Add custom metadata for preparations        iex>     query         =         MyApp.Post         |>         Ash.Query    .    put_context    (    :source    ,         "api"    )        %    Ash.Query    {    context    :         %{    source    :         "api"    }    ,         ...    }    
        # Chain multiple context additions        iex>     MyApp.Post        ...>     |>         Ash.Query    .    put_context    (    :tenant    ,         "org_123"    )        ...>     |>         Ash.Query    .    put_context    (    :locale    ,         "en_US"    )        %    Ash.Query    {    context    :         %{    tenant    :         "org_123"    ,         locale    :         "en_US"    }    ,         ...    }

## ******See also**

+ `set_context/2` for setting the entire context map
+ `for_read/4` for passing context when creating queries
+ Preparations and calculations can access context for custom logic





# select\(query, fields, opts \\\\ \[\]\)




    @spec     select(    t    () |     Ash.Resource.t    (), [    atom    ()] |     atom    (),     Keyword.t    ()) ::     t    ()


Ensure that only the specified *attributes* are present in the results.

The first call to `select/2` will replace the default behavior of selecting all attributes. Subsequent calls to `select/2` will combine the provided fields unless the `replace?` option is provided with a value of `true`.

If a field has been deselected, selecting it again will override that \(because a single list of fields is tracked for selection\)

Primary key attributes are always selected and cannot be deselected.

When attempting to load a relationship \(or manage it with `Ash.Changeset.manage_relationship/3`\), if the source field is not selected on the query/provided data an error will be produced. If loading a relationship with a query, an error is produced if the query does not select the destination field of the relationship.

Use `ensure_selected/2` if you wish to make sure a field has been selected, without deselecting any other fields.

## ******Examples**

    # Select specific attributes        iex>     MyApp.Post         |>         Ash.Query    .    select    (    [    :title    ,         :content    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :content    ]    ,         ...    }    
        # Select additional attributes (combines with existing selection)        iex>     MyApp.Post        ...>     |>         Ash.Query    .    select    (    [    :title    ]    )        ...>     |>         Ash.Query    .    select    (    [    :content    ]    )        %    Ash.Query    {    select    :         [    :id    ,         :title    ,         :content    ]    ,         ...    }    
        # Replace existing selection        iex>     MyApp.Post        ...>     |>         Ash.Query    .    select    (    [    :title    ]    )        ...>     |>         Ash.Query    .    select    (    [    :content    ]    ,         replace?    :         true    )        %    Ash.Query    {    select    :         [    :id    ,         :content    ]    ,         ...    }

## ******See also**

+ `ensure_selected/2` for adding fields without deselecting others
+ `deselect/2` for removing specific fields from selection
+ `load/3` for loading relationships and calculations





# selecting?\(query, field\)




    @spec     selecting?(    t    (),     atom    ()) ::     boolean    ()


Checks if a specific field is currently selected in the query.

Returns `true` if the field will be included in the query results, either because it's explicitly selected, it's selected by default, or it's a primary key field \(which are always selected\).

## ******Examples**

    # Check selection when no explicit select is set (uses defaults)        iex>     query         =         MyApp.Post         |>         Ash.Query    .    new    (    )        iex>     Ash.Query    .    selecting?    (    query    ,         :title    )        true    
        # Check selection with explicit select        iex>     query         =         MyApp.Post         |>         Ash.Query    .    select    (    [    :title    ,         :content    ]    )        iex>     Ash.Query    .    selecting?    (    query    ,         :title    )        true        iex>     Ash.Query    .    selecting?    (    query    ,         :metadata    )        false    
        # Primary key fields are always selected        iex>     query         =         MyApp.Post         |>         Ash.Query    .    select    (    [    :title    ]    )        iex>     Ash.Query    .    selecting?    (    query    ,         :id    )          # assuming :id is primary key        true

## ******See also**

+ `select/3` for controlling field selection
+ `ensure_selected/2` for adding fields to selection
+ `load/3` for loading relationships that may require specific fields





# set\_argument\(query, argument, value\)



Adds an argument to the query.

Arguments are used by action logic such as preparations, filters, and other query modifications. They become available in filter templates and can be referenced in action configurations. Setting an argument after a query has been validated for an action will result in an error.

## ******Examples**

    # Set an argument for use in action filters        iex>     query         =         Ash.Query    .    new    (    MyApp.Post    )        iex>     Ash.Query    .    set_argument    (    query    ,         :author_id    ,         123    )        %    Ash.Query    {    arguments    :         %{    author_id    :         123    }    ,         ...    }    
        # Set multiple arguments by chaining        iex>     MyApp.Post        ...>     |>         Ash.Query    .    set_argument    (    :category    ,         "tech"    )        ...>     |>         Ash.Query    .    set_argument    (    :published    ,         true    )        %    Ash.Query    {    arguments    :         %{    category    :         "tech"    ,         published    :         true    }    ,         ...    }    
        # Arguments are used in action preparations and filters        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    for_read    (    :by_author    ,         %{    author_id    :         123    }    )        ...>     |>         Ash.Query    .    set_argument    (    :include_drafts    ,         false    )        %    Ash.Query    {    arguments    :         %{    author_id    :         123    ,         include_drafts    :         false    }    ,         ...    }

## ******See also**

+ `get_argument/2` for retrieving argument values
+ `fetch_argument/2` for safe argument retrieval
+ `for_read/4` for creating queries with initial arguments





# set\_arguments\(query, map\)



Merge a map of arguments to the arguments list





# set\_context\(query, map\)




    @spec     set_context(    t    () |     Ash.Resource.t    (),     map    () | nil) ::     t    ()


Merge a map of values into the query context





# set\_domain\(query, domain\)



Set the query's domain, and any loaded query's domain





# set\_result\(query, result\)




    @spec     set_result(    t    (),     term    ()) ::     t    ()


Set the result of the action. This will prevent running the underlying datalayer behavior





# set\_tenant\(query, tenant\)




    @spec     set_tenant(    t    () |     Ash.Resource.t    (),     Ash.ToTenant.t    ()) ::     t    ()


Sets the tenant for the query.

In multitenant applications, this function configures which tenant's data the query should operate on. The tenant value is used to filter data and ensure proper data isolation between tenants.

## ******Examples**

    # Set tenant using a string identifier        iex>     MyApp.Post         |>         Ash.Query    .    set_tenant    (    "org_123"    )        %    Ash.Query    {    tenant    :         "org_123"    ,         ...    }    
        # Set tenant using a struct that implements Ash.ToTenant        iex>     org         =         %    MyApp.Organization    {    id    :         456    }        iex>     MyApp.Post         |>         Ash.Query    .    set_tenant    (    org    )        %    Ash.Query    {    tenant    :         %    MyApp.Organization    {    id    :         456    }    ,         ...    }    
        # Use with other query functions        iex>     MyApp.Post        ...>     |>         Ash.Query    .    set_tenant    (    "org_123"    )        ...>     |>         Ash.Query    .    filter    (    published    :         true    )        %    Ash.Query    {    tenant    :         "org_123"    ,         ...    }

## ******See also**

+ `for_read/4` for setting tenant when creating queries
+ `Ash.ToTenant` protocol for custom tenant conversion
+ `put_context/3` for adding tenant to query context





# sort\(query, sorts, opts \\\\ \[\]\)




    @spec     sort(    t    () |     Ash.Resource.t    (),     Ash.Sort.t    (), opts ::     Keyword.t    ()) ::     t    ()


Sort the results based on attributes, aggregates or calculations.

## ******Format**

Your sort can be an atom, list of atoms, a keyword list, or a string. When an order is not specified, `:asc` is the default. See Sort Orders below for more on the available orders.

    # sort by name ascending        Ash.Query    .    sort    (    query    ,         :name    )    
        # sort by name descending        Ash.Query    .    sort    (    query    ,         name    :         :desc    )    
        # sort by name descending with nils at the end        Ash.Query    .    sort    (    query    ,         name    :         :desc_nils_last    )    
        # sort by name descending, and title ascending        Ash.Query    .    sort    (    query    ,         name    :         :desc    ,         title    :         :asc    )    
        # sort by name ascending        Ash.Query    .    sort    (    query    ,         "name"    )    
        # sort by name descending, and title ascending        Ash.Query    .    sort    (    query    ,         "-name,title"    )    
        # sort by name descending with nils at the end        Ash.Query    .    sort    (    query    ,         "--name"    )

## ******Related Fields**

You can refer to related fields using the shorthand of `"rel1.rel2.field"`. For example:

    # sort by the username of the comment's author.        Ash.Query    .    sort    (    query    ,         "comment.author.username"    )    
        # Use as an atom for keyword lists        Ash.Query    .    sort    (    query    ,         "comment.author.username"    :         :desc    )

## ******Expression Sorts**

You can use the `Ash.Expr.calc/2` macro to sort on expressions:

    import         Ash.Expr    
        # Sort on an expression        Ash.Query    .    sort    (    query    ,         calc    (    count    (    friends    )    ,         :desc    )    )    
        # Specify a type (required in some cases when we can't determine a type)        Ash.Query    .    sort    (    query    ,         [    {    calc    (    fragment    (    "some_sql(?)"    ,         field    ,         type    :         :string    )    ,         :desc    }    ]    )

## ******Sort Strings**

A comma separated list of fields to sort on, each with an optional prefix.

The prefixes are:

+ "\+" - Same as no prefix. Sorts `:asc`.
+ "\+\+" - Sorts `:asc_nils_first`
+ "-" - Sorts `:desc`
+ "--" - Sorts `:desc_nils_last`

For example

    "foo,-bar,++baz,--buz"

## ******A list of sort strings**

Same prefix rules as above, but provided as a list.

For example:

    [    "foo"    ,         "-bar"    ,         "++baz"    ,         "--buz"    ]

## ******Calculations**

Calculation inputs can be provided by providing a map. To provide both inputs and an order, use a tuple with the first element being the inputs, and the second element being the order.

    Ash.Query    .    sort    (    query    ,         full_name    :         %{    separator    :         " "    }    )    
        Ash.Query    .    sort    (    query    ,         full_name    :         {    %{    separator    :         " "    }    ,         :asc    }    )

## ******Sort Orders**

The available orders are:

+ `:asc` - Sort values ascending, with lowest first and highest last, and `nil` values at the end
+ `:desc` - Sort values descending, with highest first and lowest last, and `nil` values at the beginning
+ `:asc_nils_first` - Sort values ascending, with lowest first and highest last, and `nil` values at the beginning
+ `:desc_nils_last` - Sort values descending, with highest first and lowest last, and `nil` values at the end

## ******Examples**

    Ash.Query    .    sort    (    query    ,         [    :foo    ,         :bar    ]    )    
        Ash.Query    .    sort    (    query    ,         [    :foo    ,         bar    :         :desc    ]    )    
        Ash.Query    .    sort    (    query    ,         [    foo    :         :desc    ,         bar    :         :asc    ]    )

See the guide on calculations for more.

## ******Options**

+ `prepend?` - set to `true` to put your sort at the front of the list of a sort is already specified





# sort\_input\(query, sorts, opts \\\\ \[\]\)



Attach a sort statement to the query labelled as user input.

Sorts added as user input \(or filters constructed with `Ash.Filter.parse_input`\) will honor any field policies on resources by replacing any references to the field with `nil` in cases where the actor should not be able to see the given field.

See `Ash.Query.sort/3` for more information on accepted formats.





# subset\_of\(query, expr\)
\(macro\)   


Determines if the provided expression would return data that is a subset of the data returned by the filter on the query.

This uses the satisfiability solver that is used when solving for policy authorizations. In complex scenarios, or when using custom database expressions, \(like fragments in ash\_postgres\), this function may return `:maybe`. Use `subset_of?` to always return a boolean.





# subset\_of?\(query, expr\)
\(macro\)   


Same as `subset_of/2` but always returns a boolean. `:maybe` returns `false`.





# superset\_of\(query, expr\)
\(macro\)   


Determines if the provided expression would return data that is a subset of the data returned by the filter on the query.

This uses the satisfiability solver that is used when solving for policy authorizations. In complex scenarios, or when using custom database expressions, \(like fragments in ash\_postgres\), this function may return `:maybe`. Use `supserset_of?` to always return a boolean.





# superset\_of?\(query, expr\)
\(macro\)   


Same as `superset_of/2` but always returns a boolean. `:maybe` returns `false`.





# timeout\(query, timeout\)




    @spec     timeout(    t    (),     pos_integer    () | :infinity | nil) ::     t    ()


Set a timeout for the query.

For more information, see the timeouts guide





# unload\(query, fields\)




    @spec     unload(    t    (), [    atom    ()]) ::     t    ()


Removes a field from the list of fields to load





# unset\(query, keys\)




    @spec     unset(    Ash.Resource.t    () |     t    (),     atom    () | [    atom    ()]) ::     t    ()


Removes specified keys from the query, resetting them to their default values.

This function allows you to "unset" or reset parts of a query back to their initial state. Useful when you want to remove filters, sorts, loads, or other query modifications while keeping the rest of the query intact.

## ******Examples**

    # Remove multiple query aspects at once        iex>     query         =         MyApp.Post        ...>     |>         Ash.Query    .    filter    (    published    :         true    )        ...>     |>         Ash.Query    .    sort    (    :created_at    )        ...>     |>         Ash.Query    .    limit    (    10    )        iex>     Ash.Query    .    unset    (    query    ,         [    :filter    ,         :sort    ,         :limit    ]    )        %    Ash.Query    {    filter    :         nil    ,         sort    :         [    ]    ,         limit    :         nil    ,         ...    }    
        # Remove just the sort from a query        iex>     query         =         MyApp.Post         |>         Ash.Query    .    sort    (    [    :title    ,         :created_at    ]    )        iex>     Ash.Query    .    unset    (    query    ,         :sort    )        %    Ash.Query    {    sort    :         [    ]    ,         ...    }    
        # Remove load statements        iex>     query         =         MyApp.Post         |>         Ash.Query    .    load    (    [    :author    ,         :comments    ]    )        iex>     Ash.Query    .    unset    (    query    ,         :load    )        %    Ash.Query    {    load    :         [    ]    ,         ...    }    
        # Reset pagination settings        iex>     query         =         MyApp.Post         |>         Ash.Query    .    limit    (    20    )         |>         Ash.Query    .    offset    (    10    )        iex>     Ash.Query    .    unset    (    query    ,         [    :limit    ,         :offset    ]    )        %    Ash.Query    {    limit    :         nil    ,         offset    :         0    ,         ...    }

## ******See also**

+ `new/2` for creating fresh queries
+ `select/3`, `filter/2`, `sort/3` for building queries





# Ash.CodeInterface 

Used to define the functions of a code interface for a resource.





# Summary


## **Functions** 


define\_interface\(domain, resource, definitions \\\\ nil\) 


Defines the code interface for a given resource \+ domain combination in the current module. For example




params\_and\_opts\(params\_or\_opts, maybe\_opts, post\_process\_opts\_fn\) 


See `params_and_opts/2`.




# Functions




# define\_interface\(domain, resource, definitions \\\\ nil\)
\(macro\)   


Defines the code interface for a given resource \+ domain combination in the current module. For example:

    defmodule         MyApp.Accounting         do    
          require         Ash.CodeInterface    

          Ash.CodeInterface    .    define_interface    (    MyApp.Accounting    ,         MyApp.Accounting.Transaction    )    
          Ash.CodeInterface    .    define_interface    (    MyApp.Accounting    ,         MyApp.Accounting.Account    )    
          Ash.CodeInterface    .    define_interface    (    MyApp.Accounting    ,         MyApp.Accounting.Invoice    )        end





# params\_and\_opts\(params\_or\_opts, maybe\_opts, post\_process\_opts\_fn\)




    @spec     params_and_opts(
      params_or_opts ::     map    () | [    map    ()] |     keyword    (),
          keyword    (),
      (    keyword    () ->     keyword    ())
    ) :: {params ::     map    () | [    map    ()], opts ::     keyword    ()}


See `params_and_opts/2`.

Adds a post process function that can takes the opts and can further process, validate, or transform them.





# Ash.Domain **behaviour** 

A domain allows you to interact with your resources, and holds domain-wide configuration.

For example, the json domain extension adds a domain extension that lets you toggle authorization on/off for all resources in a given domain. You include resources in your domain like so:

    defmodule         MyApp.MyDomain         do    
          use         Ash.Domain    

          resources         do    
            resource         OneResource    
            resource         SecondResource    
          end        end

### Options

+ 
`:validate_config_inclusion?` \(`boolean/0`\) - Whether or not to validate that this domain is included in the configuration. The default value is `true`.

+ 
`:backwards_compatible_interface?` \(`boolean/0`\) - Whether or not to include the 2.0 backwards compatible interface, which includes all of the interaction functions which are now defined on the `Ash` module The default value is `true`.

+ 
`:extensions` \(list of module that adopts `Spark.Dsl.Extension`\) - A list of DSL extensions to add to the `Spark.Dsl`

+ 
`:authorizers` \(one or a list of module that adopts `Ash.Authorizer`\) - authorizers extensions to add to the `Spark.Dsl` The default value is `[]`.

+ 
`:otp_app` \(`atom/0`\) - The otp\_app to use for any application configurable options

+ 
`:fragments` \(list of `module/0`\) - Fragments to include in the `Spark.Dsl`. See the fragments guide for more.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() ::     module    ()





# Ash.Notifier **behaviour** 

A notifier is an extension that receives various events





# Summary


## **Callbacks** 


notify\(t\) 



requires\_original\_data?\(t, action\) 




## **Functions** 


notify\(resource\_notifications\) 


Sends any notifications that can be sent, and returns the rest.




# Callbacks




# notify\(t\)




    @callback     notify(    Ash.Notifier.Notification.t    ()) :: :ok





# requires\_original\_data?\(t, action\)




    @callback     requires_original_data?(    Ash.Resource.t    (),     Ash.Resource.Actions.action    ()) ::
          boolean    ()





# Functions




# notify\(resource\_notifications\)




    @spec     notify([    Ash.Notifier.Notification.t    ()] |     Ash.Notifier.Notification.t    ()) :: [
          Ash.Notifier.Notification.t    ()
    ]


Sends any notifications that can be sent, and returns the rest.

A notification can only be sent if you are not currently in a transaction for the resource in question.





# Ash.Notifier.Notification 

Represents a notification that will be handled by a resource's notifiers

Set the `for` key to a notifier or a list of notifiers to route the notification to them. This allows you to produce notifications inside of a `change` module and target specific notifiers with them.

`metadata` is freeform data to be set however you want. `resource`, `action`, `data`, `changeset` and `actor` are all set by default based on the details of the action, so they can be omitted.

When creating a notification, a resource is required to ensure that the notification isn't sent until the current transaction for that resource is closed. If you don't need this behavior you can explicitly supply `nil` for the resource. If you supply `nil` for the resource, however, you must manually set the `for` option, e.g: `for: Notifier` or `for: [Notifier1, Notifier2]`





# Summary


## **Types** 


t\(\) 




## **Functions** 


new\(resource, opts\) 



# Types




# t\(\)




    @type     t() :: %Ash.Notifier.Notification{
      action:     term    (),
      actor:     term    (),
      changeset:     term    (),
      data:     term    (),
      domain:     term    (),
      for:     term    (),
      from:     term    (),
      metadata:     term    (),
      resource:     term    ()
    }





# Functions




# new\(resource, opts\)





# Ash.Resource.Calculation **behaviour** 

The behaviour for defining a module calculation, and the struct for storing a defined calculation.





# Summary


## **Types** 


opts\(\) 



ref\(\) 



t\(\) 




## **Callbacks** 


calculate\(records, opts, context\) 



describe\(opts\) 



expression\(opts, context\) 



has\_expression?\(\) 



init\(opts\) 



load\(query, opts, context\) 



strict\_loads?\(\) 




## **Functions** 


init\(module, opts\) 



schema\(\) 



# Types




# opts\(\)




    @type     opts() ::     Keyword.t    ()





# ref\(\)




    @type     ref() :: {    module    (),     Keyword.t    ()} |     module    ()





# t\(\)




    @type     t() :: %Ash.Resource.Calculation{
      allow_nil?:     boolean    (),
      arguments: [    Ash.Resource.Calculation.Argument.t    ()],
      async?:     boolean    (),
      calculation:     module    () | {    module    (),     keyword    ()},
      constraints:     keyword    (),
      description: nil |     String.t    (),
      filterable?:     boolean    (),
      load:     keyword    (),
      name:     atom    (),
      public?:     boolean    (),
      sensitive?:     term    (),
      sortable?:     boolean    (),
      type: nil |     Ash.Type.t    ()
    }





# Callbacks




# calculate\(records, opts, context\)
\(optional\)   



    @callback     calculate(
      records :: [    Ash.Resource.record    ()],
      opts ::     opts    (),
      context ::     Ash.Resource.Calculation.Context.t    ()
    ) :: {:ok, [    term    ()]} | [    term    ()] | {:error,     term    ()} | :unknown





# describe\(opts\)




    @callback     describe(opts ::     opts    ()) ::     String.t    ()





# expression\(opts, context\)
\(optional\)   



    @callback     expression(opts ::     opts    (), context ::     Ash.Resource.Calculation.Context.t    ()) ::
          any    ()





# has\_expression?\(\)




    @callback     has_expression?() ::     boolean    ()





# init\(opts\)




    @callback     init(opts ::     opts    ()) :: {:ok,     opts    ()} | {:error,     term    ()}





# load\(query, opts, context\)




    @callback     load(
      query ::     Ash.Query.t    (),
      opts ::     opts    (),
      context ::     Ash.Resource.Calculation.Context.t    ()
    ) ::
          atom    () | [    atom    ()] |     Keyword.t    ()





# strict\_loads?\(\)




    @callback     strict_loads?() ::     boolean    ()





# Functions




# init\(module, opts\)




    @spec     init(    module    (),     opts    ()) :: {:ok,     opts    ()} | {:error,     term    ()}





# schema\(\)





# Ash.Resource.Calculation.Builtins 

Built in calculations that are automatically imported in the calculations section





# Summary


## **Functions** 


concat\(keys, separator \\\\ ""\) 


An example concatenation calculation, that accepts the delimiter as an argument




# Functions




# concat\(keys, separator \\\\ ""\)




    @spec     concat(keys :: [    atom    ()], separator ::     String.t    ()) ::
          Ash.Resource.Calculation.ref    ()


An example concatenation calculation, that accepts the delimiter as an argument

## ******Examples**

    calculate         :full_name    ,         :string    ,         concat    (    [    :first_name    ,         :last_name    ]    ,         " "    )





# Ash.Resource.ManualCreate **behaviour** 

A module to implement manual create actions.





# Summary


## **Callbacks** 


bulk\_create\(changesets, opts, context\) 



create\(changeset, opts, context\) 



# Callbacks




# bulk\_create\(changesets, opts, context\)
\(optional\)   



    @callback     bulk_create(
      changesets ::     Enumerable.t    (    Ash.Changeset.t    ()),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualCreate.Context.t    ()
    ) :: [
      :ok
      | {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (),
         %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     Ash.Error.t    ()}
      | {:notifications, [    Ash.Notifier.Notification.t    ()]}
    ]





# create\(changeset, opts, context\)




    @callback     create(
      changeset ::     Ash.Changeset.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualCreate.Context.t    ()
    ) ::
      {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (),
         %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:error,     term    ()}





# Ash.Resource.ManualDestroy **behaviour** 

A module to implement manual destroy actions.

Note that in the returns of these functions you must return the destroyed record or records.





# Summary


## **Callbacks** 


bulk\_destroy\(changesets, opts, context\) 



destroy\(changeset, opts, context\) 



# Callbacks




# bulk\_destroy\(changesets, opts, context\)
\(optional\)   



    @callback     bulk_destroy(
      changesets ::     Enumerable.t    (    Ash.Changeset.t    ()),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualDestroy.Context.t    ()
    ) :: [
      :ok
      | {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (),
         %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     Ash.Error.t    ()}
      | {:notifications, [    Ash.Notifier.Notification.t    ()]}
    ]





# destroy\(changeset, opts, context\)




    @callback     destroy(
      changeset ::     Ash.Changeset.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualDestroy.Context.t    ()
    ) ::
      {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     term    ()}





# Ash.Resource.ManualRead **behaviour** 

A module to implement manual read actions.





# Summary


## **Types** 


context\(\) 



extra\_info\(\) 




## **Callbacks** 


load\_relationships\(query, results, opts, context, lazy?\) 



read\(query, data\_layer\_query, opts, context\) 



# Types




# context\(\)




    @type     context() :: %{
      optional(:actor) =>     term    (),
      optional(:tenant) =>     term    (),
      optional(:authorize?) =>     boolean    (),
      optional(:domain) =>     module    (),
      optional(    any    ()) =>     any    ()
    }





# extra\_info\(\)




    @type     extra_info() :: %{optional(:full_count) =>     non_neg_integer    ()}





# Callbacks




# load\_relationships\(query, results, opts, context, lazy?\)
\(optional\)   



    @callback     load_relationships(
      query ::     Ash.Query.t    (),
      results :: [    Ash.Resource.record    ()],
      opts ::     Keyword.t    (),
      context ::     context    (),
      lazy? ::     boolean    ()
    ) ::
      {:ok, [    Ash.Resource.record    ()]}
      | {:ok, [    Ash.Resource.record    ()],     extra_info    ()}
      | {:error,     term    ()}





# read\(query, data\_layer\_query, opts, context\)




    @callback     read(
      query ::     Ash.Query.t    (),
      data_layer_query ::     term    (),
      opts ::     Keyword.t    (),
      context ::     context    ()
    ) ::
      {:ok, [    Ash.Resource.record    ()]}
      | {:ok, [    Ash.Resource.record    ()],     extra_info    ()}
      | {:error,     term    ()}





# Ash.Resource.ManualRelationship **behaviour** 

A module to implement manual relationships.





# Summary


## **Callbacks** 


load\(list, opts, context\) 



select\(opts\) 



# Callbacks




# load\(list, opts, context\)




    @callback     load(
      [    Ash.Resource.record    ()],
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualRelationship.Context.t    ()
    ) :: {:ok,     map    ()} | {:error,     term    ()}





# select\(opts\)




    @callback     select(opts ::     Keyword.t    ()) :: [    atom    ()]





# Ash.Resource.ManualUpdate **behaviour** 

A module to implement manual update actions.





# Summary


## **Callbacks** 


bulk\_update\(changesets, opts, context\) 



update\(changeset, opts, context\) 



# Callbacks




# bulk\_update\(changesets, opts, context\)
\(optional\)   



    @callback     bulk_update(
      changesets ::     Enumerable.t    (    Ash.Changeset.t    ()),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualUpdate.Context.t    ()
    ) :: [
      :ok
      | {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (),
         %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:ok,     Ash.Resource.record    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     Ash.Error.t    ()}
      | {:notifications, [    Ash.Notifier.Notification.t    ()]}
    ]





# update\(changeset, opts, context\)




    @callback     update(
      changeset ::     Ash.Changeset.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.ManualUpdate.Context.t    ()
    ) ::
      {:ok,     Ash.Resource.record    ()}
      | {:ok,     Ash.Resource.record    (),
         %{notifications: [    Ash.Notifier.Notification.t    ()]}}
      | {:error,     term    ()}





# Ash.Query.Aggregate 

Represents an aggregated association value





# Summary


## **Types** 


kind\(\) 



t\(\) 




## **Functions** 


default\_value\(atom\) 



new\(resource, name, kind, opts \\\\ \[\]\) 


Create a new aggregate, used with `Query.aggregate` or `Ash.aggregate`




new\!\(resource, name, kind, opts \\\\ \[\]\) 


Create a new aggregate, used with `Query.aggregate` or `Ash.aggregate`, raising on errors.




# Types




# kind\(\)




    @type     kind() ::
      :custom | :exists | :avg | :min | :max | :list | :sum | :first | :count





# t\(\)




    @type     t() :: %Ash.Query.Aggregate{
      agg_name:     term    (),
      authorize?:     term    (),
      constraints:     term    (),
      context:     term    (),
      default_value:     term    (),
      field:     term    (),
      filterable?:     term    (),
      implementation:     term    (),
      include_nil?:     term    (),
      join_filters:     term    (),
      kind:     term    (),
      load:     term    (),
      name:     term    (),
      query:     term    (),
      read_action:     term    (),
      relationship_path:     term    (),
      resource:     term    (),
      sensitive?:     term    (),
      sortable?:     term    (),
      type:     term    (),
      uniq?:     term    ()
    }





# Functions




# default\_value\(atom\)





# new\(resource, name, kind, opts \\\\ \[\]\)



Create a new aggregate, used with `Query.aggregate` or `Ash.aggregate`

### ******Options**

+ 
`:path` \(list of `atom/0`\) - The relationship path to aggregate over. Only used when adding aggregates to a query. The default value is `[]`.

+ 
`:query` \(`term/0`\) - A base query to use for the aggregate, or a keyword list to be passed to `Ash.Query.build/2`

+ 
`:field` - The field to use for the aggregate. Not necessary for all aggregate types.

+ 
`:expr` \(`term/0`\) - An expression to aggregate, cannot be used with `field`.

+ 
`:expr_type` - The type of the expression, required if `expr` is used.

+ 
`:arguments` \(`map/0`\) - Arguments to pass to the field, if field is a calculation.

+ 
`:default` \(`term/0`\) - A default value to use for the aggregate if it returns `nil`.

+ 
`:filterable?` \(`boolean/0`\) - Whether or not this aggregate may be used in filters. The default value is `true`.

+ 
`:sortable?` \(`boolean/0`\) - Whether or not this aggregate may be used in sorts. The default value is `true`.

+ 
`:type` \(`term/0`\) - A type to use for the aggregate.

+ 
`:constraints` \(`term/0`\) - Type constraints to use for the aggregate. The default value is `[]`.

+ 
`:implementation` \(`term/0`\) - The implementation for any custom aggregates.

+ 
`:read_action` \(`atom/0`\) - The read action to use for the aggregate, defaults to the primary read action.

+ 
`:uniq?` \(`boolean/0`\) - Whether or not to only consider unique values. Only relevant for `count` and `list` aggregates. The default value is `false`.

+ 
`:include_nil?` \(`boolean/0`\) - Whether or not to include `nil` values in the aggregate. Only relevant for `list` and `first` aggregates. The default value is `false`.

+ 
`:join_filters` \(map of one or a list of `atom/0` keys and `term/0` values\) - A map of relationship paths \(an atom or list of atoms\), to an expression to apply when fetching the aggregate data. See the aggregates guide for more. The default value is `%{}`.

+ 
`:sensitive?` \(`boolean/0`\) - Whether or not references to this aggregate will be considered sensitive The default value is `false`.

+ 
`:tenant` \(`term/0`\) - The tenant to use for the aggregate, if applicable. The default value is `nil`.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not the aggregate query should authorize based on the target action.  
See `d:Ash.Resource.Dsl.aggregates|count` for more information. The default value is `true`.





# new\!\(resource, name, kind, opts \\\\ \[\]\)



Create a new aggregate, used with `Query.aggregate` or `Ash.aggregate`, raising on errors.

See `new/4` for more information.

### ******Options**

+ 
`:path` \(list of `atom/0`\) - The relationship path to aggregate over. Only used when adding aggregates to a query. The default value is `[]`.

+ 
`:query` \(`term/0`\) - A base query to use for the aggregate, or a keyword list to be passed to `Ash.Query.build/2`

+ 
`:field` - The field to use for the aggregate. Not necessary for all aggregate types.

+ 
`:expr` \(`term/0`\) - An expression to aggregate, cannot be used with `field`.

+ 
`:expr_type` - The type of the expression, required if `expr` is used.

+ 
`:arguments` \(`map/0`\) - Arguments to pass to the field, if field is a calculation.

+ 
`:default` \(`term/0`\) - A default value to use for the aggregate if it returns `nil`.

+ 
`:filterable?` \(`boolean/0`\) - Whether or not this aggregate may be used in filters. The default value is `true`.

+ 
`:sortable?` \(`boolean/0`\) - Whether or not this aggregate may be used in sorts. The default value is `true`.

+ 
`:type` \(`term/0`\) - A type to use for the aggregate.

+ 
`:constraints` \(`term/0`\) - Type constraints to use for the aggregate. The default value is `[]`.

+ 
`:implementation` \(`term/0`\) - The implementation for any custom aggregates.

+ 
`:read_action` \(`atom/0`\) - The read action to use for the aggregate, defaults to the primary read action.

+ 
`:uniq?` \(`boolean/0`\) - Whether or not to only consider unique values. Only relevant for `count` and `list` aggregates. The default value is `false`.

+ 
`:include_nil?` \(`boolean/0`\) - Whether or not to include `nil` values in the aggregate. Only relevant for `list` and `first` aggregates. The default value is `false`.

+ 
`:join_filters` \(map of one or a list of `atom/0` keys and `term/0` values\) - A map of relationship paths \(an atom or list of atoms\), to an expression to apply when fetching the aggregate data. See the aggregates guide for more. The default value is `%{}`.

+ 
`:sensitive?` \(`boolean/0`\) - Whether or not references to this aggregate will be considered sensitive The default value is `false`.

+ 
`:tenant` \(`term/0`\) - The tenant to use for the aggregate, if applicable. The default value is `nil`.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not the aggregate query should authorize based on the target action.  
See `d:Ash.Resource.Dsl.aggregates|count` for more information. The default value is `true`.





# Ash.Query.Calculation 

Represents a calculated attribute requested on a query





# Summary


## **Types** 


t\(\) 




## **Functions** 


from\_resource\_calculation\(resource, name, opts \\\\ \[\]\) 


Creates a new query calculation from a resource calculation.




from\_resource\_calculation\!\(resource, name, opts \\\\ \[\]\) 


Creates a new query calculation from a resource calculation, raising any errors.




new\(name, module, calc\_opts, type, constraints, opts \\\\ \[\]\) 


Creates a new query calculation.




# Types




# t\(\)




    @type     t() :: %Ash.Query.Calculation{
      async?:     term    (),
      calc_name:     term    (),
      constraints:     term    (),
      context:     term    (),
      filterable?:     term    (),
      load:     term    (),
      module:     term    (),
      name:     term    (),
      opts:     term    (),
      required_loads:     term    (),
      select:     term    (),
      sensitive?:     term    (),
      sortable?:     term    (),
      type:     term    ()
    }





# Functions




# from\_resource\_calculation\(resource, name, opts \\\\ \[\]\)



Creates a new query calculation from a resource calculation.

## ******Options**

+ 
`:args` \(`map/0`\) - Arguments to pass to the calculation The default value is `%{}`.

+ 
`:source_context` \(`map/0`\) - Context from the source query or changeset. The default value is `%{}`.





# from\_resource\_calculation\!\(resource, name, opts \\\\ \[\]\)



Creates a new query calculation from a resource calculation, raising any errors.

See `from_resource_calculation/3` for more.





# new\(name, module, calc\_opts, type, constraints, opts \\\\ \[\]\)



Creates a new query calculation.

## ******Options**

+ 
`:arguments` \(`map/0`\) - Arguments to pass to the calculation The default value is `%{}`.

+ 
`:async?` \(`boolean/0`\) - Whether or not this calculation should be run asynchronously The default value is `false`.

+ 
`:filterable?` \(`boolean/0`\) - Whether or not this calculation can be filtered on The default value is `true`.

+ 
`:sortable?` \(`boolean/0`\) - Whether or not this calculation can be sorted on The default value is `true`.

+ 
`:sensitive?` \(`boolean/0`\) - Whether or not references to this calculation will be considered sensitive The default value is `false`.

+ 
`:load` \(`term/0`\) - Loads that are required for the calculation.

+ 
`:actor` \(`term/0`\) - The actor performing the calculation.

+ 
`:tenant` \(`term/0`\) - The tenant performing the calculation.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not authorization is being performed

+ 
`:tracer` \(`term/0`\) - The tracer or tracers used in the calculation.

+ 
`:source_context` \(`map/0`\) - Context from the source query or changeset. The default value is `%{}`.





# Ash.Resource.Preparation **behaviour** 

The behaviour for an action-specific query preparation.

`init/1` is defined automatically by `use Ash.Resource.Preparation`, but can be implemented if you want to validate/transform any options passed to the module.

The main function is `prepare/3`. It takes the query, any options that were provided when this preparation was configured on a resource, and the context, which currently only has the actor.

To access any query arguments from within a preparation, make sure you are using `Ash.Query.get_argument/2` as the argument keys may be strings or atoms.





# Summary


## **Types** 


ref\(\) 



t\(\) 




## **Callbacks** 


init\(opts\) 



prepare\(query\_or\_input, opts, context\) 



supports\(opts\) 




## **Functions** 


prepare\(module, query\_or\_input, opts, context\) 



# Types




# ref\(\)




    @type     ref() :: {    module    (),     Keyword.t    ()} |     module    ()





# t\(\)




    @type     t() :: %Ash.Resource.Preparation{
      on: [    atom    ()],
      only_when_valid?:     boolean    (),
      preparation:     ref    (),
      where: [    Ash.Resource.Validation.ref    ()]
    }





# Callbacks




# init\(opts\)




    @callback     init(opts ::     Keyword.t    ()) :: {:ok,     Keyword.t    ()} | {:error,     term    ()}





# prepare\(query\_or\_input, opts, context\)




    @callback     prepare(
      query_or_input ::     Ash.Query.t    () |     Ash.ActionInput.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Preparation.Context.t    ()
    ) ::     Ash.Query.t    () |     Ash.ActionInput.t    ()





# supports\(opts\)




    @callback     supports(opts ::     Keyword.t    ()) :: [    module    ()]





# Functions




# prepare\(module, query\_or\_input, opts, context\)





# Ash.Resource.Preparation.Builtins 

Builtin query preparations





# Summary


## **Functions** 


after\_action\(callback\) 


Directly attach an `after_action` function to the query.




before\_action\(callback\) 


Directly attach a `before_action` function to the query.




build\(options\) 


Passes the given keyword list to `Ash.Query.build/2` with the query being prepared.




set\_context\(context\) 


Merges the given query context.




# Functions




# after\_action\(callback\)
\(macro\)   


Directly attach an `after_action` function to the query.

This function will be called by `Ash.Query.after_action/2`, with an additional `context` argument.

## ******Example**

    prepare         after_action    (    fn         query    ,         records    ,         _context         ->    
          Logger    .    debug    (    "Query for     #{    query    .    action    .    name    }     on resource     #{    inspect    (    query    .    resource    )    }     returned     #{    length    (    records    )    }     records"    )    

          {    :ok    ,         records    }        end    )





# before\_action\(callback\)
\(macro\)   


Directly attach a `before_action` function to the query.

This function will be called by `Ash.Query.before_action/2`, with an additional `context` argument.

## ******Example**

    prepare         before_action    (    fn         query    ,         _context         ->    
          Logger    .    debug    (    "About to execute query for     #{    query    .    action    .    name    }     on     #{    inspect    (    query    .    resource    )    }    "    )    

          query        end    )





# build\(options\)




    @spec     build(    Keyword.t    ()) ::     Ash.Resource.Preparation.ref    ()


Passes the given keyword list to `Ash.Query.build/2` with the query being prepared.

This allows declaring simple query modifications in-line.

To see the available options, see `Ash.Query.build/2`

## ******Examples**

    prepare         build    (    sort    :         [    song_rank    :         :desc    ]    ,         limit    :         10    )        prepare         build    (    load    :         [    :friends    ]    )





# set\_context\(context\)




    @spec     set_context(context ::     map    () |     mfa    ()) ::     Ash.Resource.Preparation.ref    ()


Merges the given query context.

If an MFA is provided, it will be called with the changeset. The MFA should return `{:ok, context_to_be_merged}` or `{:error, term}`

## ******Examples**

    change         set_context    (    %{    something_used_internally    :         true    }    )        change         set_context    (    {    MyApp.Context    ,         :set_context    ,         [    ]    }    )





# Ash.Resource.Change **behaviour** 

The behaviour for an action-specific resource change.

`init/1` is defined automatically by `use Ash.Resource.Change`, but can be implemented if you want to validate/transform any options passed to the module.

The main function is `change/3`. It takes the changeset, any options that were provided when this change was configured on a resource, and the context, which currently only has the actor.





# Summary


## **Types** 


context\(\) 



ref\(\) 



t\(\) 




## **Callbacks** 


after\_batch\(changesets\_and\_results, opts, context\) 


Runs on each batch result after it is dispatched to the data layer.




atomic\(changeset, opts, context\) 



atomic?\(\) 



batch\_callbacks?\(changesets\_or\_query, opts, context\) 


Whether or not batch callbacks should be run \(if they are defined\). Defaults to `true`.




batch\_change\(changesets, opts, context\) 


Replaces `change/3` for batch actions, allowing to optimize changes for bulk actions.




before\_batch\(changesets, opts, context\) 


Runs on each batch before it is dispatched to the data layer.




change\(changeset, opts, context\) 



has\_after\_batch?\(\) 



has\_batch\_change?\(\) 



has\_before\_batch?\(\) 



has\_change?\(\) 



init\(opts\) 



# Types




# context\(\)




    @type     context() ::     Ash.Resource.Change.Context.t    ()





# ref\(\)




    @type     ref() :: {    module    (),     Keyword.t    ()} |     module    ()





# t\(\)




    @type     t() :: %Ash.Resource.Change{
      always_atomic?:     term    (),
      change:     term    (),
      description:     term    (),
      on:     term    (),
      only_when_valid?:     term    (),
      where:     term    ()
    }





# Callbacks




# after\_batch\(changesets\_and\_results, opts, context\)
\(optional\)   



    @callback     after_batch(
      changesets_and_results :: [{    Ash.Changeset.t    (),     Ash.Resource.record    ()}],
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Change.Context.t    ()
    ) ::
      :ok
      | Enumerable.t(
          {:ok,     Ash.Resource.record    ()}
          | {:error,     Ash.Error.t    ()}
          |     Ash.Notifier.Notification.t    ()
        )


Runs on each batch result after it is dispatched to the data layer.





# atomic\(changeset, opts, context\)
\(optional\)   



    @callback     atomic(
      changeset ::     Ash.Changeset.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Change.Context.t    ()
    ) ::
      {:ok,     Ash.Changeset.t    ()}
      | {:atomic, %{optional(    atom    ()) =>     Ash.Expr.t    () | {:atomic,     Ash.Expr.t    ()}}}
      | {:atomic,     Ash.Changeset.t    (), %{optional(    atom    ()) =>     Ash.Expr.t    ()}}
      | {:atomic,     Ash.Changeset.t    (), %{optional(    atom    ()) =>     Ash.Expr.t    ()},
         [
           {:atomic, involved_fields :: [    atom    ()] | :*,
            condition_expr ::     Ash.Expr.t    (), error_expr ::     Ash.Expr.t    ()}
         ]}
      | {:atomic, %{optional(    atom    ()) =>     Ash.Expr.t    ()},
         [
           {:atomic, involved_fields :: [    atom    ()] | :*,
            condition_expr ::     Ash.Expr.t    (), error_expr ::     Ash.Expr.t    ()}
         ]}
      | {:not_atomic,     String.t    ()}
      | :ok
      | {:error,     term    ()}





# atomic?\(\)




    @callback     atomic?() ::     boolean    ()





# batch\_callbacks?\(changesets\_or\_query, opts, context\)




    @callback     batch_callbacks?(
      changesets_or_query :: [    Ash.Changeset.t    ()] |     Ash.Query.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Change.Context.t    ()
    ) ::     boolean    ()


Whether or not batch callbacks should be run \(if they are defined\). Defaults to `true`.





# batch\_change\(changesets, opts, context\)
\(optional\)   



    @callback     batch_change(
      changesets :: [    Ash.Changeset.t    ()],
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Change.Context.t    ()
    ) ::     Enumerable.t    (    Ash.Changeset.t    ())


Replaces `change/3` for batch actions, allowing to optimize changes for bulk actions.

You can define only `batch_change/3`, and it will be used for both single and batch actions. It cannot, however, be used in place of the `atomic/3` callback.





# before\_batch\(changesets, opts, context\)
\(optional\)   



    @callback     before_batch(
      changesets :: [    Ash.Changeset.t    ()],
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Change.Context.t    ()
    ) ::     Enumerable.t    (    Ash.Changeset.t    () |     Ash.Notifier.Notification.t    ())


Runs on each batch before it is dispatched to the data layer.





# change\(changeset, opts, context\)
\(optional\)   



    @callback     change(
      changeset ::     Ash.Changeset.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Change.Context.t    ()
    ) ::     Ash.Changeset.t    ()





# has\_after\_batch?\(\)




    @callback     has_after_batch?() ::     boolean    ()





# has\_batch\_change?\(\)




    @callback     has_batch_change?() ::     boolean    ()





# has\_before\_batch?\(\)




    @callback     has_before_batch?() ::     boolean    ()





# has\_change?\(\)




    @callback     has_change?() ::     boolean    ()





# init\(opts\)




    @callback     init(opts ::     Keyword.t    ()) :: {:ok,     Keyword.t    ()} | {:error,     term    ()}





# Ash.Resource.Change.Builtins 

Built in changes that are available to all resources

The functions in this module are imported by default in the actions section.





# Summary


## **Functions** 


after\_action\(callback, opts \\\\ \[\]\) 


Directly attach an `after_action` function to the current change.




after\_transaction\(callback, opts \\\\ \[\]\) 


Directly attach an `after_transaction` function to the current change.




atomic\_update\(attribute, expr, opts \\\\ \[\]\) 


Updates an attribute using an expression. See `Ash.Changeset.atomic_update/3` for more.




before\_action\(callback, opts \\\\ \[\]\) 


Directly attach a `before_action` function to the current change.




before\_transaction\(callback, opts \\\\ \[\]\) 


Directly attach a `before_transaction` function to the current change.




cascade\_destroy\(relationship, opts \\\\ \[\]\) 


Cascade this resource's destroy action to a related resource's destroy action.




cascade\_update\(relationship, opts \\\\ \[\]\) 


Cascade a resource's update action to a related resource's update action.




debug\_log\(label \\\\ nil\) 



ensure\_selected\(value\) 


Passes the provided value into `Ash.Changeset.ensure_selected/2`




filter\(filter\) 


Applies a filter to the changeset. Has no effect for create actions.




get\_and\_lock\(lock, opts \\\\ \[\]\) 


Re-fetches the record being updated and locks it with the given type.




get\_and\_lock\_for\_update\(opts \\\\ \[\]\) 


Re-fetches the record being updated and locks it for update.




increment\(attribute, opts \\\\ \[\]\) 


Increments an attribute's value by the amount specified, which defaults to 1.




load\(value\) 


Passes the provided value into `Ash.load` after the action has completed.




manage\_relationship\(argument, relationship\_name \\\\ nil, opts\) 


Calls `Ash.Changeset.manage_relationship/4` with the changeset and relationship provided, using the value provided for the named argument.




optimistic\_lock\(attribute\) 


Apply an "optimistic lock" on a record being updated or destroyed.




prevent\_change\(attribute\) 


Clears a change off of the changeset before the action runs.




relate\_actor\(relationship, opts \\\\ \[\]\) 


Relates the actor to the data being changed, as the provided relationship.




select\(value\) 


Passes the provided value into `Ash.Changeset.select/3`




set\_attribute\(attribute, value, opts \\\\ \[\]\) 


Sets the attribute to the value provided.




set\_context\(context\) 


Merges the given query context.




set\_new\_attribute\(attribute, value\) 


Sets the attribute to the value provided if the attribute is not already being changed.




update\_change\(attribute, function\) 


Updates an existing attribute change by applying a function to it.




# Functions




# after\_action\(callback, opts \\\\ \[\]\)
\(macro\)   


Directly attach an `after_action` function to the current change.

See `Ash.Changeset.after_action/3` for more information.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Example**

    change         after_action    (    fn         changeset    ,         record    ,         _context         ->    
          Logger    .    debug    (    "Successfully executed action     #{    changeset    .    action    .    name    }     on     #{    inspect    (    changeset    .    resource    )    }    "    )    
          {    :ok    ,         record    }        end    )





# after\_transaction\(callback, opts \\\\ \[\]\)
\(macro\)   


Directly attach an `after_transaction` function to the current change.

See `Ash.Changeset.after_transaction/3` for more information.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Example**

    change         after_transaction    (    fn    
          changeset    ,         {    :ok    ,         record    }    ,         _context         ->    
            Logger    .    debug    (    "Successfully executed transaction for action     #{    changeset    .    action    .    name    }     on     #{    inspect    (    changeset    .    resource    )    }    "    )    
            {    :ok    ,         record    }    
          changeset    ,         {    :error    ,         reason    }    ,         _context         ->    
            Logger    .    debug    (    "Failed to execute transaction for action     #{    changeset    .    action    .    name    }     on     #{    inspect    (    changeset    .    resource    )    }    , reason:     #{    inspect    (    reason    )    }    "    )    
            {    :error    ,         reason    }        end    )





# atomic\_update\(attribute, expr, opts \\\\ \[\]\)




    @spec     atomic_update(attribute ::     atom    (), expr ::     Ash.Expr.t    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.Change.ref    ()


Updates an attribute using an expression. See `Ash.Changeset.atomic_update/3` for more.

Options:

+ `:cast_atomic?` - set to `false` to ignore atomic type casting logic. Defaults to `true`.





# before\_action\(callback, opts \\\\ \[\]\)
\(macro\)   


Directly attach a `before_action` function to the current change.

See `Ash.Changeset.before_action/3` for more information.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Example**

    change         before_action    (    fn         changeset    ,         _context         ->    
          Logger    .    debug    (    "About to execute     #{    changeset    .    action    .    name    }     on     #{    inspect    (    changeset    .    resource    )    }    "    )    

          changeset        end    )





# before\_transaction\(callback, opts \\\\ \[\]\)
\(macro\)   


Directly attach a `before_transaction` function to the current change.

See `Ash.Changeset.before_transaction/3` for more information.

Provide the option `prepend?: true` to place the hook before all other hooks instead of after.

## ******Example**

    change         before_transaction    (    fn         changeset    ,         _context         ->    
          Logger    .    debug    (    "About to execute transaction for     #{    changeset    .    action    .    name    }     on     #{    inspect    (    changeset    .    resource    )    }    "    )    

          changeset        end    )





# cascade\_destroy\(relationship, opts \\\\ \[\]\)



Cascade this resource's destroy action to a related resource's destroy action.

Adds an after-action hook that explicitly calls destroy on any records related via the named relationship. It will optimise for bulk destroys where possible.

#### Beware database constraints

Think carefully before using this change with data layers which enforce referential integrity \(ie PostgreSQL and SQLite\) and you may need to defer constraints for the relationship in question.

See also:

1. `postgres.references.reference.deferrable` DSL
2. `sqlite.references.reference.deferrable` DSL
3. PostgreSQL's `SET CONSTRAINTS` documentation
4. SQLite's `PRAGMA defer_foreign_keys` documentation

#### Cascading notifications

By default notifications are disabled for the related destroy. This is to avoid potentially sending a **lot** of notifications for high-cardinality relationships.

## ******Options**

+ 
`:relationship` \(`atom/0`\) - Required. The name of the relationship to work on

+ 
`:action` \(`atom/0`\) - The name of the destroy action to call on the related resource. Uses the primary destroy by default.

+ 
`:read_action` \(`atom/0`\) - The name of the read action to call on the related resource to find results to be destroyed

+ 
`:return_notifications?` \(`boolean/0`\) - Return notifications for all destroyed records? The default value is `false`.

+ 
`:after_action?` \(`boolean/0`\) - If true, cascade destroys are done in after\_action hooks. If false, they run as before\_action hooks. Defaults to true for atomic action compatibility The default value is `true`.

+ 
`:domain` \(`Ash.Domain`\) - 


## ******Example**

    change         cascade_destroy    (    :relationship    )





# cascade\_update\(relationship, opts \\\\ \[\]\)



Cascade a resource's update action to a related resource's update action.

Adds an after-action hook that explicitly calls update on any records related via the named relationship. It will optimise for bulk updates where possible.

Allows you to copy fields from the arguments or changes to the destination, this way you can cascade a bunch of changes downstream.

#### Beware database constraints

Think carefully before using this change with data layers which enforce referential integrity \(ie PostgreSQL and SQLite\) and you may need to defer constraints for the relationship in question.

See also:

1. `postgres.references.reference.deferrable` DSL
2. `sqlite.references.reference.deferrable` DSL
3. PostgreSQL's `SET CONSTRAINTS` documentation
4. SQLite's `PRAGMA defer_foreign_keys` documentation

#### Cascading notifications

By default notifications are disabled for the related updates. This is to avoid potentially sending a **lot** of notifications for high-cardinality relationships.

## ******Options**

+ 
`:relationship` \(`atom/0`\) - Required. The name of the relationship to work on

+ 
`:action` \(`atom/0`\) - The name of the update action to call on the related resource. Uses the primary update by default.

+ 
`:copy_inputs` \(list of `atom/0`\) - A list of fields to copy & pass on to the downstream update. The source action cannot be atomic. The default value is `[]`.

+ 
`:read_action` \(`atom/0`\) - The name of the read action to call on the related resource to find results to be updated

+ 
`:return_notifications?` \(`boolean/0`\) - Return notifications for all updated records? The default value is `false`.

+ 
`:domain` \(`Ash.Domain`\) - 


## ******Example**

    change         cascade_update    (    :relationship1    )        change         cascade_update    (    :relationship2    ,         copy_inputs    :         [    :field1    ,         :field2    ]    )





# debug\_log\(label \\\\ nil\)




    @spec     debug_log(label ::     String.t    () | nil) ::     Ash.Resource.Change.ref    ()





# ensure\_selected\(value\)




    @spec     ensure_selected(select ::     atom    () | [    atom    ()]) ::     Ash.Resource.Change.ref    ()


Passes the provided value into `Ash.Changeset.ensure_selected/2`

If the value is not already selected, this makes sure it is. Does not deselect anything else.

## ******Example**

    change         ensure_selected    (    [    :necessary_field    ]    )





# filter\(filter\)




    @spec     filter(expr ::     Ash.Expr.t    ()) ::     Ash.Resource.Change.ref    ()


Applies a filter to the changeset. Has no effect for create actions.

This ensures that only things matching the provided filter are updated or destroyed.





# get\_and\_lock\(lock, opts \\\\ \[\]\)



Re-fetches the record being updated and locks it with the given type.

This happens in a `before_action` hook \(so that it is done as part of the transaction\).

If your resource has global validations \(in the top level `validations` block\), you may want to add `delay_global_validations? true` to your action to ensure they happen on the locked record.

## ******Options**

+ `:skip_atomic?` - set to `true` to skip in the case that the update is done atomically. Defaults to `false`.





# get\_and\_lock\_for\_update\(opts \\\\ \[\]\)




    @spec     get_and_lock_for_update(opts ::     Keyword.t    ()) ::     Ash.Resource.Change.ref    ()


Re-fetches the record being updated and locks it for update.

Only usable with data layers that support locking `:for_update`.

This happens in a `before_action` hook \(so that it is done as part of the transaction\).

If your resource has global validations \(in the top level `validations` block\), you may want to add `delay_global_validations? true` to your action to ensure they happen on the locked record.

## ******Options**

+ `:skip_atomic?` - set to `true` to skip in the case that the update is done atomically. Defaults to `false`.





# increment\(attribute, opts \\\\ \[\]\)




    @spec     increment(attribute ::     atom    (), opts ::     Keyword.t    ()) ::     Ash.Resource.Change.ref    ()


Increments an attribute's value by the amount specified, which defaults to 1.

Options:

+ `:amount` - Defaults to 1
+ `:overflow_limit` - Defaults to `nil`. If the value is over the overflow limit it will roll-over to the amount being incremented by \(for common database limit support\)





# load\(value\)




    @spec     load(load ::     term    ()) ::     Ash.Resource.Change.ref    ()


Passes the provided value into `Ash.load` after the action has completed.

## ******Example**

    change         load    (    :comments    )        change         load    (    [    :friend_count    ,         :friends    ]    )





# manage\_relationship\(argument, relationship\_name \\\\ nil, opts\)




    @spec     manage_relationship(
      argument ::     atom    (),
      relationship_name ::     atom    () | nil,
      opts ::     Keyword.t    ()
    ) ::     Ash.Resource.Change.ref    ()


Calls `Ash.Changeset.manage_relationship/4` with the changeset and relationship provided, using the value provided for the named argument.

If relationship\_name is not specified, it is assumed to be the same as the argument.

For information on the available options, see `Ash.Changeset.manage_relationship/4`.

## ******Examples**

    change         manage_relationship    (    :comments    ,         type    :         :append    )        change         manage_relationship    (    :remove_comments    ,         :comments    ,         type    :         :remove    )





# optimistic\_lock\(attribute\)



Apply an "optimistic lock" on a record being updated or destroyed.

See `Ash.Resource.Change.OptimisticLock` for more.





# prevent\_change\(attribute\)




    @spec     prevent_change(attribute ::     atom    ()) ::     Ash.Resource.Change.ref    ()


Clears a change off of the changeset before the action runs.

Does not fail if it is being changed, but ensures it is cleared just before the action.

Can be useful if a change is only used in validations but shouldn't ultimately be written to the data layer.

## ******Examples**

    change         prevent_change    (    :email    )





# relate\_actor\(relationship, opts \\\\ \[\]\)




    @spec     relate_actor(relationship ::     atom    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.Change.ref    ()


Relates the actor to the data being changed, as the provided relationship.

## ******Options**

+ 
`:allow_nil?` \(`boolean/0`\) - Whether or not to allow the actor to be nil, in which case nothing will happen. The default value is `false`.

+ 
`:field` \(`atom/0`\) - The field of the actor to set the relationship to


## ******Examples**

    change         relate_actor    (    :owner    ,         allow_nil?    :         true    )





# select\(value\)




    @spec     select(select ::     atom    () | [    atom    ()]) ::     Ash.Resource.Change.ref    ()


Passes the provided value into `Ash.Changeset.select/3`

Keep in mind, this will *limit* the fields that are selected. You may want `ensure_selected/1` if you want to make sure that something is selected, without deselecting anything else.

Selecting in changesets does not actually do a select in the data layer. It nils out any fields that were not selected after completing the action. This can be useful if you are writing policies that have to do with specific fields being selected.

## ******Example**

    change         select    (    [    :name    ]    )





# set\_attribute\(attribute, value, opts \\\\ \[\]\)




    @spec     set_attribute(
      attribute ::     atom    (),
      (->     term    ()) | {:_arg, :status} |     term    (),
      opts ::     Keyword.t    ()
    ) ::     Ash.Resource.Change.ref    ()


Sets the attribute to the value provided.

If a zero argument function is provided, it is called to determine the value.

Use `arg(:argument_name)` to use the value of the given argument. If the argument is not supplied then nothing happens.

## ******Options**

+ 
`:set_when_nil?` \(`boolean/0`\) - When false, decline setting the attribute if it is nil. The default value is `true`.

+ 
`:new?` \(`boolean/0`\) - When true, sets the attribute to the value provided if the attribute is not already being changed. The default value is `false`.


## ******Examples**

    change         set_attribute    (    :active    ,         false    )        change         set_attribute    (    :opened_at    ,         &    DateTime    .    utc_now    /    0    )        change         set_attribute    (    :status    ,         arg    (    :status    )    )        change         set_attribute    (    :encrypted_data    ,         arg    (    :data    )    ,         set_when_nil?    :         false    )





# set\_context\(context\)




    @spec     set_context(context ::     map    () |     mfa    ()) ::     Ash.Resource.Change.ref    ()


Merges the given query context.

If an MFA is provided, it will be called with the changeset. The MFA should return `{:ok, context_to_be_merged}` or `{:error, term}`

## ******Examples**

    change         set_context    (    %{    something_used_internally    :         true    }    )        change         set_context    (    {    MyApp.Context    ,         :set_context    ,         [    ]    }    )





# set\_new\_attribute\(attribute, value\)




    @spec     set_new_attribute(
      relationship ::     atom    (),
      (->     term    ()) | {:_arg, :status} |     term    ()
    ) ::
          Ash.Resource.Change.ref    ()


Sets the attribute to the value provided if the attribute is not already being changed.

If a zero argument function is provided, it is called to determine the value.

Use `arg(:argument_name)` to use the value of the given argument. If the argument is not supplied then nothing happens.

## ******Examples**

    change         set_new_attribute    (    :active    ,         false    )        change         set_new_attribute    (    :opened_at    ,         &    DateTime    .    utc_now    /    0    )        change         set_new_attribute    (    :status    ,         arg    (    :status    )    )





# update\_change\(attribute, function\)
\(macro\)   


Updates an existing attribute change by applying a function to it.

The update function gets called with the value already cast to the correct type, and only gets called on valid changesets, so the value is guaranteed to have passed validations and constraints.





# Ash.Resource.Validation **behaviour** 

Represents a validation in Ash.

See `Ash.Resource.Validation.Builtins` for a list of builtin validations.

To write your own validation, define a module that implements the `init/1` callback to validate options at compile time, and `validate/3` callback to do the validation.

Then, in a resource, you can say:

    validations         do    
          validate         {    MyValidation    ,         [    foo    :         :bar    ]    }        end





# Summary


## **Types** 


path\(\) 



ref\(\) 



t\(\) 




## **Callbacks** 


atomic\(changeset\_query\_or\_input, opts, context\) 



atomic?\(\) 



describe\(opts\) 



has\_validate?\(\) 



init\(opts\) 



supports\(opts\) 



validate\(changeset\_query\_or\_input, opts, context\) 




## **Functions** 


action\_schema\(\) 



opt\_schema\(\) 



validation\_type\(\) 



# Types




# path\(\)




    @type     path() :: [    atom    () |     integer    ()]





# ref\(\)




    @type     ref() :: {    module    (),     Keyword.t    ()} |     module    ()





# t\(\)




    @type     t() :: %Ash.Resource.Validation{
      always_atomic?:     term    (),
      before_action?:     term    (),
      description:     String.t    () | nil,
      message:     term    (),
      module:     atom    (),
      on: [    atom    ()],
      only_when_valid?:     boolean    (),
      opts: [    atom    ()],
      validation: {    atom    (), [    atom    ()]},
      where: [{    atom    (), [    atom    ()]}]
    }





# Callbacks




# atomic\(changeset\_query\_or\_input, opts, context\)
\(optional\)   



    @callback     atomic(
      changeset_query_or_input ::     Ash.Changeset.t    () |     Ash.ActionInput.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Validation.Context.t    ()
    ) ::
      :ok
      | {:atomic, involved_fields :: [    atom    ()] | :*, condition_expr ::     Ash.Expr.t    (),
         error_expr ::     Ash.Expr.t    ()}
      | [
          {:atomic, involved_fields :: [    atom    ()] | :*,
           condition_expr ::     Ash.Expr.t    (), error_expr ::     Ash.Expr.t    ()}
        ]
      | {:not_atomic,     String.t    ()}
      | {:error,     term    ()}





# atomic?\(\)




    @callback     atomic?() ::     boolean    ()





# describe\(opts\)
\(optional\)   



    @callback     describe(opts ::     Keyword.t    ()) ::
          String.t    () | [message:     String.t    (), vars:     Keyword.t    ()]





# has\_validate?\(\)




    @callback     has_validate?() ::     boolean    ()





# init\(opts\)




    @callback     init(opts ::     Keyword.t    ()) :: {:ok,     Keyword.t    ()} | {:error,     String.t    ()}





# supports\(opts\)




    @callback     supports(opts ::     Keyword.t    ()) :: [Ash.Changeset | Ash.Query | Ash.ActionInput]





# validate\(changeset\_query\_or\_input, opts, context\)
\(optional\)   



    @callback     validate(
      changeset_query_or_input ::     Ash.Changeset.t    () |     Ash.ActionInput.t    (),
      opts ::     Keyword.t    (),
      context ::     Ash.Resource.Validation.Context.t    ()
    ) :: :ok | {:error,     term    ()}





# Functions




# action\_schema\(\)





# opt\_schema\(\)





# validation\_type\(\)





# Ash.Resource.Validation.Builtins 

Built in validations that are available to all resources

The functions in this module are imported by default in the validations section.





# Summary


## **Functions** 


absent\(attributes, opts \\\\ \[\]\) 


Validates that the given attribute or argument or list of attributes or arguments are `nil`.




action\_is\(action\) 


Validates that the action name matches the provided action name or names. Primarily meant for use in `where`.




argument\_does\_not\_equal\(argument, value\) 


Validates that an argument is not being changed to a specific value, or does not equal the given value if it is not being changed.




argument\_equals\(argument, value\) 


Validates that an argument is being changed to a specific value, or equals the given value if it is not being changed.




argument\_in\(argument, list\) 


Validates that an argument is being changed to one of a set of specific values, or is in the the given list if it is not being changed.




attribute\_does\_not\_equal\(attribute, value\) 


Validates that an attribute is not being changed to a specific value, or does not equal the given value if it is not being changed.




attribute\_equals\(attribute, value\) 


Validates that an attribute is being changed to a specific value, or equals the given value if it is not being changed.




attribute\_in\(attribute, list\) 


Validates that an attribute is being changed to one of a set of specific values, or is in the the given list if it is not being changed.




attributes\_absent\(attributes, opts \\\\ \[\]\) 


Validates that the attribute or list of attributes are `nil`. See `absent/2` for more information.




attributes\_present\(attributes, opts \\\\ \[\]\) 


Validates that the attribute or list of attributes are not `nil`. See `present/2` for more information.




changing\(field, opts \\\\ \[\]\) 


Validates that an attribute or relationship is being changed




compare\(attribute, opts \\\\ \[\]\) 


Validates that an attribute or argument meets the given comparison criteria.




confirm\(field, confirmation\) 


Validates that a field or argument matches another field or argument




match\(attribute, match\) 


Validates that an attribute's value matches a given regex.




negate\(validation\) 


Validates that other validation does not pass




numericality\(attribute, opts \\\\ \[\]\) 


Validates that an attribute or argument meets the given comparison criteria.




one\_of\(attribute, values\) 


Validates that an attribute's value is in a given list




present\(attributes, opts \\\\ \[\]\) 


Validates that the given attribute or argument or list of attributes or arguments are not `nil`.




string\_length\(attribute, opts \\\\ \[\]\) 


Validates that an attribute on the original record meets the given length criteria




# Functions




# absent\(attributes, opts \\\\ \[\]\)




    @spec     absent(attributes_or_arguments ::     atom    () | [    atom    ()], opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that the given attribute or argument or list of attributes or arguments are `nil`.

This is the inverse of `present/2`.

Use options to specify how many must be `nil`. If no options are provided, validates that they are all absent.

Keep in mind that some types cast certain values to `nil`, and validations are applied after all inputs have been cast. For example, a `:string` type attribute with the default constraints will cast `""` as `nil`, meaning an input of `""` would pass the `absent` validation.

## ******Options**

+ 
`:at_least` \(`non_neg_integer/0`\) - At least this many must be absent. Defaults to the number of attributes provided

+ 
`:at_most` \(`non_neg_integer/0`\) - At most this many must be absent. Defaults to the number of attributes provided

+ 
`:exactly` \(`non_neg_integer/0`\) - Exactly this many must be absent


## ******Examples**

    validate         absent    (    :unsettable_option    )    
        validate         absent    (    [    :first_name    ,         :last_name    ]    )    ,         where    :         [    present    (    :full_name    )    ]    
        validate         absent    (    [    :is_admin    ,         :is_normal_user    ]    ,         at_least    :         1    )





# action\_is\(action\)




    @spec     action_is(action ::     atom    () | [    atom    ()]) ::     Ash.Resource.Validation.ref    ()


Validates that the action name matches the provided action name or names. Primarily meant for use in `where`.

## ******Examples**

    validate         present    (    :foo    )    ,         where    :         [    action_is    (    :bar    )    ]    
        validate         present    (    :foo    )    ,         where    :         action_is    (    [    :bar    ,         :baz    ]    )





# argument\_does\_not\_equal\(argument, value\)




    @spec     argument_does_not_equal(argument ::     atom    (), value ::     term    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an argument is not being changed to a specific value, or does not equal the given value if it is not being changed.

## ******Examples**

    validate         argument_does_not_equal    (    :admin    ,         true    )    
        # Or to only check for changing to a given value        validate         argument_does_not_equal    (    :admin    ,         true    )    ,         where    :         [    changing    (    :admin    )    ]





# argument\_equals\(argument, value\)




    @spec     argument_equals(argument ::     atom    (), value ::     term    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an argument is being changed to a specific value, or equals the given value if it is not being changed.

## ******Examples**

    validate         argument_equals    (    :admin    ,         true    )    
        # Or to only check for changing to a given value        validate         argument_equals    (    :admin    ,         true    )    ,         where    :         [    changing    (    :admin    )    ]





# argument\_in\(argument, list\)




    @spec     argument_in(argument ::     atom    (), list :: [    term    ()]) ::
          Ash.Resource.Validation.ref    ()


Validates that an argument is being changed to one of a set of specific values, or is in the the given list if it is not being changed.

## ******Examples**

    validate         argument_in    (    :state    ,         [    1    ,         2    ,         3    ]    )    
        # Or to only check for changing to a something in a given list        validate         argument_in    (    :state    ,         [    1    ,         2    ,         3    ]    )    ,         where    :         [    changing    (    :state    )    ]





# attribute\_does\_not\_equal\(attribute, value\)




    @spec     attribute_does_not_equal(attribute ::     atom    (), value ::     term    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute is not being changed to a specific value, or does not equal the given value if it is not being changed.

## ******Examples**

    validate         attribute_does_not_equal    (    :admin    ,         true    )    
        # Or to only check for changing to a given value        validate         attribute_does_not_equal    (    :admin    ,         true    )    ,         where    :         [    changing    (    :admin    )    ]





# attribute\_equals\(attribute, value\)




    @spec     attribute_equals(attribute ::     atom    (), value ::     term    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute is being changed to a specific value, or equals the given value if it is not being changed.

## ******Examples**

    validate         attribute_equals    (    :admin    ,         true    )    
        # Or to only check for changing to a given value        validate         attribute_equals    (    :admin    ,         true    )    ,         where    :         [    changing    (    :admin    )    ]





# attribute\_in\(attribute, list\)




    @spec     attribute_in(attribute ::     atom    (), list :: [    term    ()]) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute is being changed to one of a set of specific values, or is in the the given list if it is not being changed.

## ******Examples**

    validate         attribute_in    (    :state    ,         [    1    ,         2    ,         3    ]    )    
        # Or to only check for changing to a something in a given list        validate         attribute_in    (    :state    ,         [    1    ,         2    ,         3    ]    )    ,         where    :         [    changing    (    :state    )    ]





# attributes\_absent\(attributes, opts \\\\ \[\]\)




    @spec     attributes_absent(attributes ::     atom    () | [    atom    ()], opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that the attribute or list of attributes are `nil`. See `absent/2` for more information.

## ******Options**

+ 
`:at_least` \(`non_neg_integer/0`\) - At least this many must be absent. Defaults to the number of attributes provided

+ 
`:at_most` \(`non_neg_integer/0`\) - At most this many must be absent. Defaults to the number of attributes provided

+ 
`:exactly` \(`non_neg_integer/0`\) - Exactly this many must be absent





# attributes\_present\(attributes, opts \\\\ \[\]\)




    @spec     attributes_present(attributes ::     atom    () | [    atom    ()], opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that the attribute or list of attributes are not `nil`. See `present/2` for more information.

## ******Options**

+ 
`:at_least` \(`non_neg_integer/0`\) - At least this many must be present. Defaults to the number of attributes provided

+ 
`:at_most` \(`non_neg_integer/0`\) - At most this many must be present. Defaults to the number of attributes provided

+ 
`:exactly` \(`non_neg_integer/0`\) - Exactly this many must be present





# changing\(field, opts \\\\ \[\]\)




    @spec     changing(attribute_or_relationship ::     atom    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute or relationship is being changed

## ******Examples**

    validate         changing    (    :first_name    )        validate         changing    (    :comments    )        validate         changing    (    :comments    ,         touching?    :         true    )

## ******Options**

+ 
`:field` \(`atom/0`\) - Required. The attribute or relationship to check for changes. Using a relationship does not compare old and new value, returning `true` if the value is being touched\)

+ 
`:touching?` \(`atom/0`\) - Whether to consider a field as changing if it is just being touched \(i.e consider it changed even if it is being changed to its current value\) The default value is `false`.





# compare\(attribute, opts \\\\ \[\]\)




    @spec     compare(attribute ::     atom    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute or argument meets the given comparison criteria.

The values provided for each option may be a literal value, attribute, argument, or a zero argument function.

## ******Options**

+ 
`:greater_than` - The value that the attribute should be greater than.

+ 
`:greater_than_or_equal_to` - The value that the attribute should be greater than or equal to

+ 
`:less_than` - The value that the attribute should be less than

+ 
`:less_than_or_equal_to` - The value that the attribute should be less than or equal to

+ 
`:is_equal` - The value that the attribute should be equal to

+ 
`:is_not_equal` - The value that the attribute should not be equal to

+ 
`:is_nil` \(`boolean/0`\) - Whether the attribute should be nil \(true\) or not nil \(false\)


## ******Examples**

    validate         compare    (    :age    ,         greater_than_or_equal_to    :         18    )    ,    
          where    :         [    attribute_equals    (    :show_adult_content    ,         true    )    ]    ,    
          message    :         "must be over %{greater_than_or_equal_to} to enable adult content."    
        validate         compare    (    :points    ,         greater_than    :         0    ,         less_than_or_equal_to    :         100    )





# confirm\(field, confirmation\)




    @spec     confirm(
      attribute_or_argument ::     atom    (),
      confirmation_attribute_or_argument ::     atom    ()
    ) ::
          Ash.Resource.Validation.ref    ()


Validates that a field or argument matches another field or argument

## ******Examples**

    validate         confirm    (    :password    ,         :password_confirmation    )        validate         confirm    (    :email    ,         :email_confirmation    )





# match\(attribute, match\)




    @spec     match(attribute ::     atom    (), match ::     Regex.t    ()) ::     Ash.Resource.Validation.ref    ()


Validates that an attribute's value matches a given regex.

`String.match?/2` is used to determine if the value matches.

## ******Examples**

    validate         match    (    :slug    ,         "^[0-9a-z-_]+$"    )





# negate\(validation\)




    @spec     negate(validation ::     Ash.Resource.Validation.ref    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that other validation does not pass

## ******Examples**

    validate         negate    (    one_of    (    :status    ,         [    :closed    ,         :finished    ]    )    )





# numericality\(attribute, opts \\\\ \[\]\)




    @spec     numericality(attribute ::     atom    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute or argument meets the given comparison criteria.

The values provided for each option may be a literal value, attribute, argument, or a zero argument function.

## ******Options**

+ 
`:greater_than` - The value that the attribute should be greater than.

+ 
`:greater_than_or_equal_to` - The value that the attribute should be greater than or equal to

+ 
`:less_than` - The value that the attribute should be less than

+ 
`:less_than_or_equal_to` - The value that the attribute should be less than or equal to

+ 
`:is_equal` - The value that the attribute should be equal to

+ 
`:is_not_equal` - The value that the attribute should not be equal to

+ 
`:is_nil` \(`boolean/0`\) - Whether the attribute should be nil \(true\) or not nil \(false\)


## ******Examples**

    validate         numericality    (    :age    ,         greater_than_or_equal_to    :         18    )    ,    
          where    :         [    attribute_equals    (    :show_adult_content    ,         true    )    ]    ,    
          message    :         "must be over %{greater_than_or_equal_to} to enable adult content."    
        validate         numericality    (    :points    ,         greater_than    :         0    ,         less_than_or_equal_to    :         100    )





# one\_of\(attribute, values\)




    @spec     one_of(attribute ::     atom    (), [    any    ()]) ::     Ash.Resource.Validation.ref    ()


Validates that an attribute's value is in a given list

## ******Examples**

    validate         one_of    (    :status    ,         [    :closed_won    ,         :closed_lost    ]    )





# present\(attributes, opts \\\\ \[\]\)




    @spec     present(attributes_or_arguments ::     atom    () | [    atom    ()], opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that the given attribute or argument or list of attributes or arguments are not `nil`.

Use options to specify how many must not be `nil`. If no options are provided, validates that they are all present.

Keep in mind that some types cast certain values to `nil`, and validations are applied after all inputs have been cast. For example, a `:string` type attribute with the default constraints will cast `""` as `nil`, meaning an input of `""` would fail the `present` validation.

## ******Options**

+ 
`:at_least` \(`non_neg_integer/0`\) - At least this many must be present. Defaults to the number of attributes provided

+ 
`:at_most` \(`non_neg_integer/0`\) - At most this many must be present. Defaults to the number of attributes provided

+ 
`:exactly` \(`non_neg_integer/0`\) - Exactly this many must be present


## ******Examples**

    validate         present    (    :name    )    
        validate         present    (    [    :first_name    ,         :last_name    ]    )    ,         where    :         [    absent    (    :full_name    )    ]    
        validate         present    (    [    :is_admin    ,         :is_normal_user    ]    ,         at_most    :         1    )





# string\_length\(attribute, opts \\\\ \[\]\)




    @spec     string_length(attribute ::     atom    (), opts ::     Keyword.t    ()) ::
          Ash.Resource.Validation.ref    ()


Validates that an attribute on the original record meets the given length criteria

## ******Options**

+ 
`:min` \(`non_neg_integer/0`\) - String must be this length at least

+ 
`:max` \(`non_neg_integer/0`\) - String must be this length at most

+ 
`:exact` \(`non_neg_integer/0`\) - String must be this length exactly


## ******Examples**

    validate         string_length    (    :slug    ,         exact    :         8    )        validate         string_length    (    :password    ,         min    :         6    )        validate         string_length    (    :secret    ,         min    :         4    ,         max    :         12    )





# Ash.Authorizer **behaviour** 

The interface for an ash authorizer

These will typically be implemented by an extension, but a custom one can be implemented by defining an extension that also adopts this behaviour.

Then you can extend a resource with `authorizers: [YourAuthorizer]`





# Summary


## **Types** 


context\(\) 



state\(\) 




## **Callbacks** 


add\_calculations\(arg1, state, context\) 



alter\_filter\(filter, state, context\) 



alter\_results\(state, list, context\) 



check\(state, context\) 



check\_context\(state\) 



exception\(atom, state\) 



initial\_state\(t, record, action, t\) 



strict\_check\(state, context\) 



strict\_check\_context\(state\) 




## **Functions** 


add\_calculations\(module, query\_or\_changeset, state, context\) 



alter\_filter\(module, state, filter, context\) 



alter\_results\(module, state, records, context\) 



alter\_sort\(module, state, sort, context\) 



check\(module, state, context\) 



check\_context\(module, state\) 



exception\(module, reason, state\) 



initial\_state\(module, actor, resource, action, domain\) 



strict\_check\(module, state, context\) 



strict\_check\_context\(module, state\) 



# Types




# context\(\)




    @type     context() ::     map    ()





# state\(\)




    @type     state() ::     map    ()





# Callbacks




# add\_calculations\(arg1, state, context\)
\(optional\)   



    @callback     add_calculations(    Ash.Query.t    () |     Ash.Changeset.t    (),     state    (),     context    ()) ::
      {:ok,     Ash.Query.t    () |     Ash.Changeset.t    (),     state    ()} | {:error,     Ash.Error.t    ()}





# alter\_filter\(filter, state, context\)
\(optional\)   



    @callback     alter_filter(filter ::     Ash.Filter.t    (),     state    (),     context    ()) ::
      {:ok,     Ash.Filter.t    ()} | {:error,     Ash.Error.t    ()}





# alter\_results\(state, list, context\)
\(optional\)   



    @callback     alter_results(    state    (), [    Ash.Resource.record    ()],     context    ()) ::
      {:ok, [    Ash.Resource.record    ()]} | {:error,     Ash.Error.t    ()}





# check\(state, context\)




    @callback     check(    state    (),     context    ()) ::
      :authorized
      | {:data, [    Ash.Resource.record    ()]}
      | {:error, :forbidden,     state    ()}
      | {:error,     Ash.Error.t    ()}





# check\_context\(state\)




    @callback     check_context(    state    ()) :: [    atom    ()]





# exception\(atom, state\)
\(optional\)   



    @callback     exception(    atom    (),     state    ()) ::     no_return    ()





# initial\_state\(t, record, action, t\)




    @callback     initial_state(
          Ash.Resource.t    (),
          Ash.Resource.record    (),
          Ash.Resource.Actions.action    (),
          Ash.Domain.t    ()
    ) ::     state    ()





# strict\_check\(state, context\)




    @callback     strict_check(    state    (),     context    ()) ::
      {:authorized,     state    ()}
      | {:continue,     state    ()}
      | {:filter,     Keyword.t    ()}
      | {:filter,     Keyword.t    (),     state    ()}
      | {:filter_and_continue,     Keyword.t    (),     state    ()}
      | {:error,     term    ()}





# strict\_check\_context\(state\)




    @callback     strict_check_context(    state    ()) :: [    atom    ()]





# Functions




# add\_calculations\(module, query\_or\_changeset, state, context\)





# alter\_filter\(module, state, filter, context\)





# alter\_results\(module, state, records, context\)





# alter\_sort\(module, state, sort, context\)





# check\(module, state, context\)





# check\_context\(module, state\)





# exception\(module, reason, state\)





# initial\_state\(module, actor, resource, action, domain\)





# strict\_check\(module, state, context\)





# strict\_check\_context\(module, state\)





# Ash.Policy.Check **behaviour** 

A behaviour for declaring checks, which can be used to easily construct authorization rules.

If a check can be expressed simply, i.e as a function of the actor, or the context of the request, see `Ash.Policy.SimpleCheck` for an easy way to write that check. If a check can be expressed with a filter statement, see `Ash.Policy.FilterCheck` for an easy way to write that check.





# Summary


## **Types** 


actor\(\) 



authorizer\(\) 



check\_type\(\) 



options\(\) 



ref\(\) 



t\(\) 




## **Callbacks** 


auto\_filter\(actor, authorizer, options\) 


An optional callback, that allows the check to work with policies set to `access_type :filter`




check\(actor, list, map, options\) 


An optional callback, that allows the check to work with policies set to `access_type :runtime`




describe\(options\) 


Describe the check in human readable format, given the options




eager\_evaluate?\(\) 



expand\_description\(actor, authorizer, options\) 


Expands the description of the check, given the actor and subject




prefer\_expanded\_description?\(\) 


Whether or not the expanded description should replace the basic description in breakdowns




requires\_original\_data?\(authorizer, options\) 


Whether or not your check requires the original data of a changeset \(if applicable\)




strict\_check\(actor, authorizer, options\) 


Strict checks should be cheap, and should never result in external calls \(like database or domain\)




type\(\) 


The type of the check





## **Functions** 


defines\_auto\_filter?\(module\) 



defines\_check?\(module\) 



# Types




# actor\(\)




    @type     actor() ::     any    ()





# authorizer\(\)




    @type     authorizer() ::     Ash.Policy.Authorizer.t    ()





# check\_type\(\)




    @type     check_type() :: :simple | :filter | :manual





# options\(\)




    @type     options() ::     Keyword.t    ()





# ref\(\)




    @type     ref() :: {    module    (),     Keyword.t    ()} |     module    ()





# t\(\)




    @type     t() :: %Ash.Policy.Check{
      check:     term    (),
      check_module:     term    (),
      check_opts:     term    (),
      type:     term    ()
    }





# Callbacks




# auto\_filter\(actor, authorizer, options\)
\(optional\)   



    @callback     auto_filter(    actor    (),     authorizer    (),     options    ()) ::     Keyword.t    () |     Ash.Expr.t    ()


An optional callback, that allows the check to work with policies set to `access_type :filter`

Return a keyword list filter that will be applied to the query being made, and will scope the results to match the rule





# check\(actor, list, map, options\)
\(optional\)   



    @callback     check(    actor    (), [    Ash.Resource.record    ()],     map    (),     options    ()) :: [
          Ash.Resource.record    ()
    ]


An optional callback, that allows the check to work with policies set to `access_type :runtime`

Takes a list of records, and returns the subset of authorized records.





# describe\(options\)




    @callback     describe(    options    ()) ::     String.t    ()


Describe the check in human readable format, given the options





# eager\_evaluate?\(\)




    @callback     eager_evaluate?() ::     boolean    ()





# expand\_description\(actor, authorizer, options\)
\(optional\)   



    @callback     expand_description(
          actor    (),
          authorizer    (),
          options    ()
    ) :: {:ok,     String.t    ()} | :none


Expands the description of the check, given the actor and subject





# prefer\_expanded\_description?\(\)




    @callback     prefer_expanded_description?() ::     boolean    ()


Whether or not the expanded description should replace the basic description in breakdowns





# requires\_original\_data?\(authorizer, options\)




    @callback     requires_original_data?(    authorizer    (),     options    ()) ::     boolean    ()


Whether or not your check requires the original data of a changeset \(if applicable\)





# strict\_check\(actor, authorizer, options\)




    @callback     strict_check(    actor    (),     authorizer    (),     options    ()) ::
      {:ok,     boolean    () | :unknown} | {:error,     term    ()}


Strict checks should be cheap, and should never result in external calls \(like database or domain\)

It should return `{:ok, true}` if it can tell that the request is authorized, and `{:ok, false}` if it can tell that it is not. If unsure, it should return `{:ok, :unknown}`





# type\(\)




    @callback     type() ::     check_type    ()


The type of the check

`:manual` checks must be written by hand as standard check modules `:filter` checks can use `Ash.Policy.FilterCheck` for simplicity `:simple` checks can use `Ash.Policy.SimpleCheck` for simplicity





# Functions




# defines\_auto\_filter?\(module\)





# defines\_check?\(module\)





# Ash.Policy.FilterCheck **behaviour** 

A type of check that is represented by a filter statement

You can customize what the "negative" filter looks like by defining `reject/3`. This is important for filters over related data. For example, given an `owner` relationship and a data layer like `ash_postgres` where `column != NULL` does *not* evaluate to true \(see postgres docs on NULL for more\):

    # The opposite of        `    owner    .    id         ==         1    `        # in most cases is not        `    not    (    owner    .    id         ==         1    )    `        # because in postgres that would be `NOT (owner.id = NULL)` in cases where there was no owner        # A better opposite would be        `    owner    .    id         !=         1         or         is_nil    (    owner    .    id    )    `        # alternatively        `    not    (    owner    .    id         ==         1    )         or         is_nil    (    owner    .    id    )    `

By being able to customize the `reject` filter, you can use related filters in your policies. Without it, they will likely have undesired effects.





# Summary


## **Types** 


context\(\) 



options\(\) 




## **Callbacks** 


filter\(actor, context, options\) 



reject\(actor, context, options\) 




## **Functions** 


is\_filter\_check?\(module\) 



# Types




# context\(\)




    @type     context() :: %{
      :action =>     Ash.Resource.Actions.action    (),
      :resource =>     Ash.Resource.t    (),
      :domain =>     Ash.Domain.t    (),
      optional(:query) =>     Ash.Query.t    (),
      optional(:changeset) =>     Ash.Changeset.t    (),
      optional(:action_input) =>     Ash.ActionInput.t    (),
      optional(    any    ()) =>     any    ()
    }





# options\(\)




    @type     options() ::     Keyword.t    ()





# Callbacks




# filter\(actor, context, options\)




    @callback     filter(actor ::     term    (),     context    (),     options    ()) ::     Keyword.t    () |     Ash.Expr.t    ()





# reject\(actor, context, options\)
\(optional\)   



    @callback     reject(actor ::     term    (),     context    (),     options    ()) ::     Keyword.t    () |     Ash.Expr.t    ()





# Functions




# is\_filter\_check?\(module\)





# Ash.Policy.SimpleCheck **behaviour** 

A type of check that operates only on request context, never on the data

Define `match?/3`, which gets the actor, request context, and opts, and returns true or false

## Example

This is a simple check that checks if the user is changing anything other than the provided list.

    defmodule         ChangingNothingExcept         do    
          use         Ash.Policy.SimpleCheck    

          def         match?    (    _actor    ,         %{    subject    :         %    Ash.Changeset    {    }         =         changeset    }    ,         opts    )         do    
            allowed         =         opts    [    :attributes    ]    
            {    :ok    ,         Enum    .    all?    (    Map    .    keys    (    changeset    .    attributes    )    ,         &    (    &1         in         allowed    )    )    }    
          end    

          def         match?    (    _    ,         _    ,         _    )    ,         do    :         {    :ok    ,         true    }        end

You could then use this like

    policy         actor_attribute_equals    (    :role    ,         :foobar    )         do    
          authorize_if         {    ChangingNothingExcept    ,         attributes    :         [    :foo    ,         :bar    ]    }        end





# Summary


## **Types** 


actor\(\) 



context\(\) 



options\(\) 




## **Callbacks** 


match?\(actor, context, options\) 


Whether or not the request matches the check




# Types




# actor\(\)




    @type     actor() ::     Ash.Policy.Check.actor    ()





# context\(\)




    @type     context() ::     Ash.Policy.Authorizer.t    ()





# options\(\)




    @type     options() ::     Keyword.t    ()





# Callbacks




# match?\(actor, context, options\)




    @callback     match?(    actor    (),     context    (),     options    ()) ::
          boolean    () | {:ok,     boolean    ()} | {:error,     term    ()}


Whether or not the request matches the check





# Ash.Policy.Check.Builtins 

The global authorization checks built into ash





# Summary


## **Functions** 


accessing\_from\(resource, relationship\) 


This check is true when the current action is being run "through" a relationship.




action\(action\) 


This check is true when the action name matches the provided action name or names.




action\_type\(action\_type\) 


This check is true when the action type matches the provided type




actor\_absent\(\) 


This check is false when there is an actor specified, and true when the actor is `nil`.




actor\_attribute\_equals\(attribute, value\) 


This check is true when the value of the specified attribute of the actor equals the specified value.




actor\_present\(\) 


This check is true when there is an actor specified, and false when the actor is `nil`.




always\(\) 


This check always passes.




changing\_attributes\(opts\) 


This check is true when attribute changes correspond to the provided options.




changing\_relationship\(relationship\) 


This check is true when the specified relationship is changing




changing\_relationships\(relationships\) 


This check is true when the specified relationships are changing




context\_equals\(key, value\) 


This check is true when the value of the specified key or path in the changeset or query context equals the specified value.




filtering\_on\(path \\\\ \[\], field\) deprecated 


This check is true when the field provided is being referenced anywhere in a filter statement.




just\_created\_with\_action\(action\_name\) 



loading\(field\) 


This check is true when the field or relationship, or path to field, is being loaded and false when it is not.




matches\(description, func\) 


This check is true when the specified function returns true




never\(\) 


This check never passes.




relates\_to\_actor\_via\(relationship\_path, opts \\\\ \[\]\) 


This check passes if the data relates to the actor via the specified relationship or path of relationships.




relating\_to\_actor\(relationship\) 


This check is true when the specified relationship is being changed to the current actor.




resource\(resource\) 


This check is true when the resource name matches the provided resource name or names.




selecting\(attribute\) 


This check is true when the field is being selected and false when it is not.




# Functions




# accessing\_from\(resource, relationship\)




    @spec     accessing_from(    Ash.Resource.t    (),     atom    ()) ::     Ash.Policy.Check.ref    ()


This check is true when the current action is being run "through" a relationship.

Cases where this happens:

1. Loading related data
2. Managing relationships
3. Aggregating data
4. Filtering on relationships





# action\(action\)




    @spec     action(    atom    () | [    atom    ()]) ::     Ash.Policy.Check.ref    ()


This check is true when the action name matches the provided action name or names.

This is a very common pattern, allowing action-specific policies.





# action\_type\(action\_type\)




    @spec     action_type(    Ash.Resource.Actions.action_type    ()) ::     Ash.Policy.Check.ref    ()


This check is true when the action type matches the provided type

This is useful for writing policies that apply to all actions of a given type.

For example:

    policy         action_type    (    :read    )         do    
          authorize_if         relates_to_actor_via    (    :owner    )        end





# actor\_absent\(\)




    @spec     actor_absent() ::     Ash.Policy.Check.ref    ()


This check is false when there is an actor specified, and true when the actor is `nil`.





# actor\_attribute\_equals\(attribute, value\)




    @spec     actor_attribute_equals(    atom    (),     any    ()) ::     Ash.Policy.Check.ref    ()


This check is true when the value of the specified attribute of the actor equals the specified value.

This check will *never* pass if the actor does not have the specified key. For example, `actor_attribute_equals(:missing_key, nil)`





# actor\_present\(\)




    @spec     actor_present() ::     Ash.Policy.Check.ref    ()


This check is true when there is an actor specified, and false when the actor is `nil`.





# always\(\)




    @spec     always() ::     Ash.Policy.Check.ref    ()


This check always passes.

Can be useful for "deny-list" style authorization. For example:

    policy         action_type    (    :read    )         do    
          forbid_if         actor_attribute_equals    (    :disabled    ,         true    )    
          forbid_if         actor_attribute_equals    (    :active    ,         false    )    
          authorize_if         always    (    )        end

Without that last clause, the policy would never pass.





# changing\_attributes\(opts\)



This check is true when attribute changes correspond to the provided options.

Provide a keyword list of options or just an atom representing the attribute.

For example:

    # if you are changing both first name and last name        changing_attributes    (    [    :first_name    ,         :last_name    ]    )    
        # if you are changing first name to fred        changing_attributes    (    first_name    :         [    to    :         "fred"    ]    )    
        # if you are changing last name from bob        changing_attributes    (    last_name    :         [    from    :         "bob"    ]    )    
        # if you are changing :first_name at all, last_name from "bob" and middle name from "tom" to "george"        changing_attributes    (    [    :first_name    ,         last_name    :         [    from    :         "bob"    ]    ,         middle_name    :         [    from    :         "tom"    ,         to    :         "george"    ]    ]    )





# changing\_relationship\(relationship\)



This check is true when the specified relationship is changing





# changing\_relationships\(relationships\)



This check is true when the specified relationships are changing





# context\_equals\(key, value\)



This check is true when the value of the specified key or path in the changeset or query context equals the specified value.

Note that the context is not shared with other queries \(e.g. loads\).

For example:

    # Given this check on Profile        authorize_if         context_equals    (    :allow_this?    ,         true    )    
        # This load will not have the context and will not be authorized        Ash    .    load!    (    user    ,         :profile    ,         context    :         %{    allow_this?    :         true    }    )    
        # But this will have the context and will be authorized        Ash    .    load!    (    user    ,         [    profile    :         Ash.Query    .    set_context    (    Profile    ,         %{    allow_this?    :         true    }    )    ]    )





# filtering\_on\(path \\\\ \[\], field\)



This function is deprecated. \`filtering\_on/2\` check is deprecated. Instead, add arguments and add policies that said arguments are set. For complex queries, policies on what is being filtered on require multiple authorization passes of the same resource, leading to a large amount of typically unnecessary complexity. Additionally, they could yield false negatives in some scenarios, and more work would be needed to ensure that they don't. . 


    @spec     filtering_on(    atom    () | [    atom    ()],     atom    ()) ::     Ash.Policy.Check.ref    ()


This check is true when the field provided is being referenced anywhere in a filter statement.

This applies to related filters as well. For example:

    policy         actor_attribute_equals    (    :is_admin    ,         false    )         do    
          forbid_if         filtering_on    (    :email    )    
          # a path can be provided as well    
          forbid_if         filtering_on    (    [    :owner    ]    ,         :email    )        end

The first will return true in situations like:

    Ash.Query    .    filter    (    User    ,         email         ==         "blah"    )        Ash.Query    .    filter    (    Tweet    ,         author    .    email         ==         "blah"    )

The second will return true on queries like:

    Ash.Query    .    filter    (    Post    ,         owner    .    email         ==         "blah"    )        Ash.Query    .    filter    (    Comment    ,         post    .    owner    .    email         ==         "blah"    )





# just\_created\_with\_action\(action\_name\)




    @spec     just_created_with_action(    atom    ()) ::     Ash.Policy.Check.ref    ()





# loading\(field\)




    @spec     loading(    atom    ()) ::     Ash.Policy.Check.ref    ()


This check is true when the field or relationship, or path to field, is being loaded and false when it is not.

This is always false for `create`/`update`/`destroy` actions, because you cannot load fields on those action types.





# matches\(description, func\)
\(macro\)   


This check is true when the specified function returns true





# never\(\)




    @spec     never() ::     Ash.Policy.Check.ref    ()


This check never passes.

There is, generally speaking, no reason to use this, but it exists for completeness sake.





# relates\_to\_actor\_via\(relationship\_path, opts \\\\ \[\]\)




    @spec     relates_to_actor_via(
          atom    (),
          keyword    ()
    ) ::     Ash.Policy.Check.ref    ()


This check passes if the data relates to the actor via the specified relationship or path of relationships.

For `update` & `destroy` actions, this check will apply to *the original data* before the changes are applied.

For `create` actions this check is very unlikely to pass. This is because relationships are modified *after* authorization happens, not before.

For example:

    policy         action_type    (    :read    )         do    
          authorize_if         relates_to_actor_via    (    :owner    )    

          # Path of relationships:    
          authorize_if         relates_to_actor_via    (    [    :account    ,         :user    ]    )    

          # When the resource relates to a field of the actor:    
          authorize_if         relates_to_actor_via    (    :roles    ,         field    :         :role    )        end





# relating\_to\_actor\(relationship\)



This check is true when the specified relationship is being changed to the current actor.

This only supports `belongs_to` relationships at the moment, and will detect two cases:

1. the `source_attribute` is being changed directly
2. the relationship is being changed with `on_lookup?: :relate`, and a single input is being provided.





# resource\(resource\)




    @spec     resource(    atom    () | [    atom    ()]) ::     Ash.Policy.Check.ref    ()


This check is true when the resource name matches the provided resource name or names.





# selecting\(attribute\)




    @spec     selecting(    atom    ()) ::     Ash.Policy.Check.ref    ()


This check is true when the field is being selected and false when it is not.

This won't affect filters placed on this resource, so you may also want to either:

+ Mark the given field as `filterable? false`
+ Add another check for `filtering_on(:field)`

For example:

    policy         action_type    (    :read    )         do    
          # The actor can read and filter on their own email    
          authorize_if         expr    (    id         ==         ^    actor    (    :id    )    )    

          # No one else can select or filter on their email    
          forbid_if         selecting    (    :email    )    
          forbid_if         filtering_on    (    :email    )    

          # Otherwise, the policy passes    
          authorize_if         always    (    )        end





# Ash.DataLayer.Ets 

An ETS \(Erlang Term Storage\) backed Ash Datalayer, for testing and lightweight usage.

Remember, this does not have support for transactions\! This is not recommended for production use, especially in multi-user applications. It can, however, be great for prototyping.





# Summary


## **Functions** 


do\_add\_calculations\(records, resource, calculations, domain\) 



ets\(body\) 



stop\(resource, tenant \\\\ nil\) 


Stops the storage for a given resource/tenant \(deleting all of the data\)




# Functions




# do\_add\_calculations\(records, resource, calculations, domain\)





# ets\(body\)
\(macro\)   





# stop\(resource, tenant \\\\ nil\)



Stops the storage for a given resource/tenant \(deleting all of the data\)





# Ash.DataLayer.Mnesia 

An Mnesia backed Ash Datalayer.

In your application initialization, you will need to call `Mnesia.create_schema([node()])`.

Additionally, you will want to create your mnesia tables there.

This data layer is *unoptimized*, fetching all records from a table and filtering them in memory. For that reason, it is not recommended to use it with large amounts of data. It can be great for prototyping or light usage, though.





# Summary


## **Functions** 


mnesia\(body\) 



start\(domain, resources \\\\ \[\]\) 


Creates the table for each mnesia resource in a domain




# Functions




# mnesia\(body\)
\(macro\)   





# start\(domain, resources \\\\ \[\]\)



Creates the table for each mnesia resource in a domain





# Ash.DataLayer.Simple 

A data layer that returns structs.

This is the data layer that is used under the hood by embedded resources, and resources without data layers.





# Summary


## **Functions** 


bulk\_create\(resource, stream, options\) 


Callback implementation for `Ash.DataLayer.bulk_create/3`.




set\_data\(query, data\) 


Sets the data for a query against a data-layer-less resource




# Functions




# bulk\_create\(resource, stream, options\)



Callback implementation for `Ash.DataLayer.bulk_create/3`.





# set\_data\(query, data\)



Sets the data for a query against a data-layer-less resource





# Ash.Notifier.PubSub 

A builtin notifier to help you publish events over any kind of pub-sub tooling.

This is plug and play with `Phoenix.PubSub`, but could be used with any pubsub system.

You configure a module that defines a `broadcast/3` function, and then add some "publications" which configure under what conditions an event should be sent and what the topic should be.

## Example

    defmodule         MyApp.User         do    
          use         Ash.Resource    ,    
            # ...    
            notifiers    :         [    Ash.Notifier.PubSub    ]    

          # ...    

          pub_sub         do    
            module         MyAppWeb.Endpoint    

            prefix         "user"    
            publish         :update    ,         [    "updated"    ,         :_pkey    ]    
          end        end

## Debugging PubSub

It can be quite frustrating when setting up pub\_sub when everything appears to be set up properly, but you aren't receiving events. This usually means some kind of mismatch between the event names produced by the resource/config of your publications, and you can use the following flag to display debug information about all pub sub events.

    config         :ash    ,         :pub_sub    ,         debug?    :         true

## Topic Templates

Often you want to include some piece of data in the thing being changed, like the `:id` attribute. This is done by providing a list as the topic, and using atoms which will be replaced by their corresponding values. They will ultimately be joined with `:`.

For example:

    prefix         "user"    
        publish         :create    ,         [    "created"    ,         :user_id    ]

This might publish a message to "user:created:1" for example.

For updates, if the field in the template is being changed, a message is sent to *both* values. So if you change `user 1` to `user 2`, the same message would be published to `user:updated:1` and `user:updated:2`. If there are multiple attributes in the template, and they are all being changed, a message is sent for every combination of substitutions.

## Important

If the previous value was `nil` or the field was not selected on the data passed into the action, then a notification is not sent for the previous value.

If the new value is `nil` then a notification is not sent for the new value.

## Template parts

Templates may contain lists, in which case all combinations of values in the list will be used. Add `nil` to the list if you want to produce a pattern where that entry is omitted.

The atom `:_tenant` may be used. If the changeset has a tenant set on it, that value will be used, otherwise that combination of values is ignored.

The atom `:_pkey` may be used. It will be a stringified, concatenation of the primary key fields, or just the primary key if there is only one primary key field.

The atom `nil` may be used. It only makes sense to use it in the context of a list of alternatives, and adds a pattern where that part is skipped.

    publish         :updated    ,         [    [    :team_id    ,         :_tenant    ]    ,         "updated"    ,         [    :id    ,         nil    ]    ]

Would produce the following messages, given a `team_id` of 1, a `tenant` of `org_1`, and an `id` of `50`:

    "1:updated:50"        "1:updated"        "org_1:updated:50"        "org_1:updated"

## Custom Delimiters

It's possible to change the default delimiter used when generating topics. This is useful when working with message brokers like RabbitMQ, which rely on a different set of delimiters for routing.

    pub_sub         do    
          delimiter         "."        end

## Named Pubsub modules

If you are using a phoenix `Endpoint` module for pubsub then this is unnecessary. If you want to use a custom pub sub started with something like `{Phoenix.PubSub, name: MyName}`, then you can provide `MyName` to here.

## Broadcast Types

Configured with `broadcast_type`.

+ `:notification` just sends the notification
+ `:phoenix_broadcast` sends a `%Phoenix.Socket.Broadcast{}` \(see above\)
+ `:broadcast` sends `%{topic: (topic), event: (event), payload: (notification)}`





# Summary


## **Functions** 


pub\_sub\(body\) 



to\_payload\(topic, event, notification, value\) 



# Functions




# pub\_sub\(body\)
\(macro\)   





# to\_payload\(topic, event, notification, value\)





# Ash.Policy.Authorizer 

An authorization extension for ash resources.

To add this extension to a resource, add it to the list of `authorizers` like so:

    use         Ash.Resource    ,    
          ...    ,    
          authorizers    :         [    
            Ash.Policy.Authorizer    
          ]

A resource can be given a set of policies, which are enforced on each call to a resource action.

For reads, policies can be configured to filter out data that the actor shouldn't see, as opposed to resulting in a forbidden error.

See the policies guide for practical examples.

Policies are solved/managed via a boolean satisfiability solver. To read more about boolean satisfiability, see this page: https://en.wikipedia.org/wiki/Boolean\_satisfiability\_problem. At the end of the day, however, it is not necessary to understand exactly how Ash takes your authorization requirements and determines if a request is allowed. The important thing to understand is that Ash may or may not run any/all of your authorization rules as they may be deemed unnecessary. As such, authorization checks should have no side effects. Ideally, the checks built-in to ash should cover the bulk of your needs.





# Summary


## **Types** 


t\(\) 




## **Functions** 


alter\_sort\(sort, authorizer, context\) 



expr\_check\(expr\) 



field\_policies\(body\) 



install\(igniter, module, type, path, argv\) 



policies\(body\) 



print\_tuple\_boolean\(v\) 



template\_var\(expr\) 



# Types




# t\(\)




    @type     t() :: %Ash.Policy.Authorizer{
      action:     Ash.Resource.Actions.Action.t    (),
      action_input:     Ash.ActionInput.t    () | nil,
      actor:     term    (),
      changeset:     Ash.Changeset.t    () | nil,
      check_scenarios: [    map    ()],
      context:     map    (),
      data:     term    (),
      data_facts:     map    (),
      domain:     Ash.Domain.t    (),
      facts:     map    (),
      for_fields:     term    (),
      policies: [    term    ()],
      query:     Ash.Query.t    () | nil,
      real_scenarios: [    map    ()],
      resource:     Ash.Resource.t    (),
      scenarios: [    map    ()],
      solver_statement:     term    (),
      subject:     Ash.Query.t    () |     Ash.Changeset.t    () |     Ash.ActionInput.t    ()
    }





# Functions




# alter\_sort\(sort, authorizer, context\)





# expr\_check\(expr\)





# field\_policies\(body\)
\(macro\)   





# install\(igniter, module, type, path, argv\)





# policies\(body\)
\(macro\)   





# print\_tuple\_boolean\(v\)





# template\_var\(expr\)





# Ash.Reactor 

`Ash.Reactor` is a `Reactor` extension which provides steps for working with Ash resources and actions.

See the Ash Reactor Guide for more information.





# Summary


## **Types** 


action\(\) 




## **Functions** 


ash\(body\) 



# Types




# action\(\)




    @type     action() ::
          Ash.Reactor.Dsl.Action.t    ()
      |     Ash.Reactor.Dsl.AshStep.t    ()
      |     Ash.Reactor.Dsl.BulkCreate.t    ()
      |     Ash.Reactor.Dsl.BulkUpdate.t    ()
      |     Ash.Reactor.Dsl.Create.t    ()
      |     Ash.Reactor.Dsl.Destroy.t    ()
      |     Ash.Reactor.Dsl.Load.t    ()
      |     Ash.Reactor.Dsl.Read.t    ()
      |     Ash.Reactor.Dsl.ReadOne.t    ()
      |     Ash.Reactor.Dsl.Update.t    ()





# Functions




# ash\(body\)
\(macro\)   





# Ash.Resource 

A resource is a static definition of an entity in your system.

Resource DSL documentation

### Options

+ 
`:simple_notifiers` \(list of module that adopts `Ash.Notifier`\) - Notifiers with no DSL.

+ 
`:validate_domain_inclusion?` \(`boolean/0`\) - Whether or not to validate that this resource is included in a domain. The default value is `true`.

+ 
`:primary_read_warning?` \(`boolean/0`\) - Set to `false` to silence warnings about arguments, preparations and filters on the primary read action. The default value is `true`.

+ 
`:domain` \(module that adopts `Ash.Domain`\) - The domain to use when interacting with this resource. Also sets defaults for various options that ask for a domain.

+ 
`:embed_nil_values?` \(`boolean/0`\) - Whether or not to include keys with `nil` values in an embedded representation. Has no effect unless resource is an embedded resource. The default value is `true`.

+ 
`:extensions` \(list of module that adopts `Spark.Dsl.Extension`\) - A list of DSL extensions to add to the `Spark.Dsl`

+ 
`:data_layer` \(module that adopts `Ash.DataLayer`\) - data\_layer extensions to add to the `Spark.Dsl` The default value is `Ash.DataLayer.Simple`.

+ 
`:authorizers` \(one or a list of module that adopts `Ash.Authorizer`\) - authorizers extensions to add to the `Spark.Dsl` The default value is `[]`.

+ 
`:notifiers` \(one or a list of module that adopts `Ash.Notifier`\) - notifiers extensions to add to the `Spark.Dsl` The default value is `[]`.

+ 
`:otp_app` \(`atom/0`\) - The otp\_app to use for any application configurable options

+ 
`:fragments` \(list of `module/0`\) - Fragments to include in the `Spark.Dsl`. See the fragments guide for more.





# Summary


## **Types** 


record\(\) 



t\(\) 




## **Functions** 


get\_metadata\(record, key\_or\_path\) 



loaded?\(data, path, opts \\\\ \[\]\) 


Returns true if the load or path to load has been loaded




put\_metadata\(record, key, term\) 



selected?\(record, field, opts \\\\ \[\]\) 


Returns true if the given field has been selected on a record




set\_metadata\(record, map\) 



timestamps\(opts \\\\ \[\]\) 


Defines create and update timestamp attributes.




unload\(page, path\) 


Sets a loaded key or path to a key back to its original unloaded stated




unload\_many\(data, paths\) 


Sets a list of loaded key or paths to a key back to their original unloaded stated




# Types




# record\(\)




    @type     record() ::     struct    ()





# t\(\)




    @type     t() ::     module    ()





# Functions




# get\_metadata\(record, key\_or\_path\)




    @spec     get_metadata(    record    (),     atom    () | [    atom    ()]) ::     term    ()





# loaded?\(data, path, opts \\\\ \[\]\)




    @spec     loaded?(
      nil | [    record    ()] |     record    () |     Ash.Page.page    (),
          atom    () |     Ash.Query.Calculation.t    () |     Ash.Query.Aggregate.t    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) ::     boolean    ()


Returns true if the load or path to load has been loaded

## ******Options**

+ `lists`: set to `:any` to have this return true if any record in a list that appears has the value loaded. Default is `:all`.
+ `unknown`: set to `true` to have unknown paths \(like nil values or non-resources\) return true. Defaults to `false`
+ `strict?`: set to `true` to return false if a calculation with arguments is being checked





# put\_metadata\(record, key, term\)




    @spec     put_metadata(    record    (),     atom    (),     term    ()) ::     record    ()





# selected?\(record, field, opts \\\\ \[\]\)



Returns true if the given field has been selected on a record

## ******Options**

+ `forbidden_means_selected?`: set to `true` to return `true` if the field is marked as forbidden





# set\_metadata\(record, map\)




    @spec     set_metadata(    record    (),     map    ()) ::     record    ()





# timestamps\(opts \\\\ \[\]\)
\(macro\)   


Defines create and update timestamp attributes.

Shorthand for `d:Ash.Resource.Dsl.attributes.create_timestamp` and `d:Ash.Resource.Dsl.attributes.update_timestamp` with the attribute names `:inserted_at` and `:updated_at` respectively. Any options passed to this helper are passed to both timestamp macros.





# unload\(page, path\)




    @spec     unload(
      nil | [    record    ()] |     record    () |     Ash.Page.page    (),
          atom    () | [    atom    ()]
    ) :: nil | [    record    ()] |     record    () |     Ash.Page.page    ()


Sets a loaded key or path to a key back to its original unloaded stated





# unload\_many\(data, paths\)




    @spec     unload_many(
      nil | [    record    ()] |     record    () |     Ash.Page.page    (),
      [    atom    ()] | [[    atom    ()]]
    ) :: nil | [    record    ()] |     record    () |     Ash.Page.page    ()


Sets a list of loaded key or paths to a key back to their original unloaded stated





# Ash.DataLayer.Ets.Info 

Introspection helpers for the Ets data layer





# Summary


## **Functions** 


private?\(resource\) 


Whether or not the ets table for the resource should be private




table\(resource\) 


The ets table name for a resource




# Functions




# private?\(resource\)




    @spec     private?(    Ash.Resource.t    () |     Spark.Dsl.t    ()) ::     boolean    ()


Whether or not the ets table for the resource should be private





# table\(resource\)




    @spec     table(    Ash.Resource.t    () |     Spark.Dsl.t    ()) ::     boolean    ()


The ets table name for a resource





# Ash.DataLayer.Mnesia.Info 

Introspection helpers for Ash.DataLayer.Mnesia





# Summary


## **Functions** 


table\(resource\) 


The mnesia table for a resource




# Functions




# table\(resource\)



The mnesia table for a resource





# Ash.Domain.Info 

Introspection tools for Ash.Domain





# Summary


## **Functions** 


allow\(domain\) 


The allow MFA for a domain




allow\_unregistered?\(domain\) 


Whether or not the domain allows unregistered resources to be used with it




authorize\(domain\) 


When authorization should happen for a given domain




depend\_on\_resources\(domain\) deprecated 


Gets the resources of a domain module. Can be used at compile time.




description\(domain\) 


The description of the domain




find\_manage\_relationships\_with\_identity\_not\_configured\(otp\_app\) 



related\_domain\(subject, relationship, default \\\\ nil\) 


Determine what domain to use when interacting with a related resource.




require\_actor?\(domain\) 


Whether or not the actor is always required for a domain




resource\(domain, resource\) 


Returns `{:ok, resource}` if the resource can be used by the domain, or `{:error, error}`.




resource\_references\(domain\) 


Gets the resource references of a domain module. DO NOT USE AT COMPILE TIME.




resources\(domain\) 


Gets the resources of a domain module.




short\_name\(domain\) 


The short name for a domain




span\_name\(domain, resource, action\) 


The span\_name for a domain and resource combination




telemetry\_event\_name\(domain, name\) 


Names a telemetry event for a given domain/resource combo




timeout\(domain\) 


The execution timeout for a domain




trace\_name\(domain\) 


The trace name for a domain




# Functions




# allow\(domain\)




    @spec     allow(    Ash.Domain.t    () |     Spark.Dsl.t    ()) ::     mfa    () | nil


The allow MFA for a domain





# allow\_unregistered?\(domain\)




    @spec     allow_unregistered?(    Ash.Domain.t    () |     Spark.Dsl.t    ()) ::     atom    () | nil


Whether or not the domain allows unregistered resources to be used with it





# authorize\(domain\)




    @spec     authorize(    Ash.Domain.t    ()) :: :always | :by_default | :when_requested


When authorization should happen for a given domain





# depend\_on\_resources\(domain\)
\(macro\)   


This macro is deprecated. Use \`Ash.Domain.Info.resources/1\` instead. This macro is no longer necessary. 


    @spec     depend_on_resources(    Macro.t    ()) ::     Macro.t    ()


Gets the resources of a domain module. Can be used at compile time.

Liberal use of this can greatly increase compile times, or even cause compiler deadlocks. Use with care.





# description\(domain\)




    @spec     description(    Spark.Dsl.t    () |     Ash.Domain.t    ()) ::     String.t    () | nil


The description of the domain





# find\_manage\_relationships\_with\_identity\_not\_configured\(otp\_app\)





# related\_domain\(subject, relationship, default \\\\ nil\)




    @spec     related_domain(
          Ash.Resource.t    () |     Ash.Query.t    () |     Ash.Changeset.t    () |     Ash.ActionInput.t    (),
          atom    ()
      |     Ash.Resource.Relationships.relationship    ()
      | [    atom    () |     Ash.Resource.Relationships.relationship    ()],
          Ash.Domain.t    () | nil
    ) ::     Ash.Domain.t    ()


Determine what domain to use when interacting with a related resource.

We choose the first domain found in the following order:

+ `relationship.domain`, i.e an explicitly configured domain for a relationship
+ `resource.domain`, i.e. the domain the resource declares
+ `subject.domain`, i.e. the domain of the query, changeset or action input \(if it has one\)
+ `default`, the default domain provided as the third argument





# require\_actor?\(domain\)




    @spec     require_actor?(    Ash.Domain.t    ()) ::     boolean    ()


Whether or not the actor is always required for a domain





# resource\(domain, resource\)



Returns `{:ok, resource}` if the resource can be used by the domain, or `{:error, error}`.





# resource\_references\(domain\)




    @spec     resource_references(    Spark.Dsl.t    () |     Ash.Domain.t    ()) :: [
          Ash.Domain.Dsl.ResourceReference.t    ()
    ]


Gets the resource references of a domain module. DO NOT USE AT COMPILE TIME.

If you need the resource list at compile time, use `depend_on_resources/1`





# resources\(domain\)




    @spec     resources(    Spark.Dsl.t    () |     Ash.Domain.t    ()) :: [    Ash.Resource.t    ()]


Gets the resources of a domain module.





# short\_name\(domain\)




    @spec     short_name(    Ash.Domain.t    ()) ::     atom    ()


The short name for a domain





# span\_name\(domain, resource, action\)




    @spec     span_name(    Ash.Domain.t    (),     Ash.Resource.t    (), action ::     atom    () |     binary    ()) ::
          String.t    ()


The span\_name for a domain and resource combination





# telemetry\_event\_name\(domain, name\)




    @spec     telemetry_event_name(    Ash.Domain.t    (),     atom    () | [    atom    ()]) :: [    atom    ()]


Names a telemetry event for a given domain/resource combo





# timeout\(domain\)




    @spec     timeout(    Ash.Domain.t    ()) :: nil | :infinity |     integer    ()


The execution timeout for a domain





# trace\_name\(domain\)




    @spec     trace_name(    Ash.Domain.t    ()) ::     String.t    ()


The trace name for a domain





# Ash.Notifier.PubSub.Info 

Introspection helpers for Ash.Notifier.PubSub





# Summary


## **Functions** 


broadcast\_type\(resource\) 


The broadcast type for a resource




delimiter\(resource\) 


The delimiter to use when generating message topics




filter\(resource\) 


The pubsub filter for a resource




module\(resource\) 


The pubsub module for a resource




name\(resource\) 


The pubsub name for a resource




prefix\(resource\) 


The topic prefix for a resource




publications\(resource\) 


The list of publications for a resource




transform\(resource\) 


The transform for a resource




# Functions




# broadcast\_type\(resource\)



The broadcast type for a resource





# delimiter\(resource\)



The delimiter to use when generating message topics





# filter\(resource\)



The pubsub filter for a resource





# module\(resource\)



The pubsub module for a resource





# name\(resource\)



The pubsub name for a resource





# prefix\(resource\)



The topic prefix for a resource





# publications\(resource\)



The list of publications for a resource





# transform\(resource\)



The transform for a resource





# Ash.Policy.Info 

An authorization extension for ash resources.

For more information, see `Ash.Policy.Authorizer`





# Summary


## **Functions** 


default\_access\_type\(resource\) 



describe\_resource\(domain, resource\) 



field\_policies\(resource\) 



field\_policies\_for\_field\(resource, field\) 


Gets the field policies relevant to a given field




log\_policy\_breakdowns\(\) 


The log level at which Ash policy authorizer logs policy breakdowns. Defaults to none.




log\_successful\_policy\_breakdowns\(\) 


The log level at which Ash policy authorizer logs successful policy breakdowns. Defaults to none.




policies\(domain \\\\ nil, resource\) 



private\_fields\_policy\(resource\) 



show\_policy\_breakdowns?\(\) 


Whether or not Ash policy authorizer is configured to show policy breakdowns in error messages




strict\_check\(actor, query, domain\) 


A utility to determine if a given query/changeset would pass authorization.




# Functions




# default\_access\_type\(resource\)





# describe\_resource\(domain, resource\)





# field\_policies\(resource\)





# field\_policies\_for\_field\(resource, field\)



Gets the field policies relevant to a given field





# log\_policy\_breakdowns\(\)



The log level at which Ash policy authorizer logs policy breakdowns. Defaults to none.





# log\_successful\_policy\_breakdowns\(\)



The log level at which Ash policy authorizer logs successful policy breakdowns. Defaults to none.





# policies\(domain \\\\ nil, resource\)





# private\_fields\_policy\(resource\)





# show\_policy\_breakdowns?\(\)



Whether or not Ash policy authorizer is configured to show policy breakdowns in error messages





# strict\_check\(actor, query, domain\)



A utility to determine if a given query/changeset would pass authorization.

*This is still experimental.*





# Ash.Resource.Info 

Introspection for resources





# Summary


## **Functions** 


action\(resource, name, type \\\\ nil\) 


Returns the action with the matching name and type on the resource




action\_input?\(resource, action, input\) 


Returns true or false if the input is accepted by the action, as an argument or an attribute




action\_inputs\(resource, action\) 


Returns the list of possible accepted keys by an action




action\_select\(resource, action\) 


Returns the list of attributes that must be selected for an action invocation




actions\(resource\) 


Returns all actions of a resource




aggregate\(resource, name\) 


Get an aggregate by name




aggregate\_type\(resource, aggregate\) 


Gets the type of an aggregate for a given resource.




aggregates\(resource\) 


Returns all aggregates of a resource




always\_selected\_attribute\_names\(resource\) 



attribute\(resource, name\) 


Get an attribute name from the resource




attribute\_names\(resource\) 



attributes\(resource\) 


Returns all attributes of a resource




attributes\_to\_require\(resource\) 



attributes\_to\_require\(resource, action\_name\) 



authorizers\(resource\) 


A list of authorizers to be used when accessing




base\_filter\(resource\) 


The base filter of the resource




calculation\(resource, name\) 


Get a calculation by name




calculation\_interface\(resource, name\) 


Get an calculation interface by name from the resource




calculation\_interfaces\(resource\) 


The list of code interface calculation definitions.




calculations\(resource\) 


Returns all calculations of a resource




changes\(resource\) 


A list of all changes for the resource




changes\(resource, type\) 


A list of all changes for the resource for a given action type




code\_interface\_domain\(resource\) 


The domain to define the interface for, when defining it in the resource




data\_layer\(resource\) 


The data layer of the resource, or nil if it does not have one




default\_actions\(resource\) 


Returns the configured default actions




default\_context\(resource\) 


The default context of the resource




define\_interface?\(resource\) 


Whether or not to define the interface on the resource




description\(resource\) 


The description of the resource




domain\(resource\) 


Returns the statically configured domain for the resource.




embedded?\(resource\) 


Whether or not the resource is an embedded resource




field\(resource, name\) 


Get a field from a resource by name




fields\(resource, types \\\\ \[:attributes, :aggregates, :calculations, :relationships\]\) 


Returns all attributes, aggregates, calculations and relationships of a resource




hide\_inspect\_fields\(resource\) 


A deny-list of fields to hide from the inspect output. Takes precedence over `show_inspect_fields`.




identities\(resource\) 


A list of identities for the resource




identity\(resource, name\) 


Get an identity by name from the resource




inspect\_private\_fields?\(resource\) 


Whether to include private fields in the inspect output. `show_inspect_fields` takes precedence over this option.




interface\(resource, name\) 


Get an interface by name from the resource




interfaces\(resource\) 


The list of code interface definitions.




lazy\_matching\_default\_attributes\(resource, atom\) 


Returns all attributes of a resource with lazy matching defaults




lazy\_non\_matching\_default\_attributes\(resource, atom\) 


Returns all attributes of a resource with lazy non-matching-defaults




multitenancy\_attribute\(resource\) 


The multitenancy attribute for a resource




multitenancy\_global?\(resource\) 


The MFA to parse the tenant from the attribute




multitenancy\_parse\_attribute\(resource\) 


The function to parse the tenant from the attribute




multitenancy\_strategy\(resource\) 


The multitenancy strategy for a resource




multitenancy\_template\(resource\) 


The template for creating the tenant name




notifiers\(resource\) 


A list of notifiers to be used when accessing




plural\_name\(resource\) 


The plural\_name of the resource




preparations\(resource, type \\\\ :read\) 



primary\_action\(resource, type\) 


Returns the primary action of a given type




primary\_action\!\(resource, type\) 


Returns the primary action of the given type




primary\_key\(resource\) 


A list of field names corresponding to the primary key




primary\_key\_simple\_equality?\(resource\) 


Whether or not all primary key attributes can be compared with simple\_equality




public\_aggregate\(resource, name\) 


Get an aggregate by name




public\_aggregates\(resource\) 


Returns all public aggregates of a resource




public\_attribute\(resource, name\) 


Get a public attribute name from the resource




public\_attributes\(resource\) 


Returns all public attributes of a resource




public\_calculation\(resource, name\) 


Get a public calculation by name




public\_calculations\(resource\) 


Returns all public calculations of a resource




public\_field\(resource, name\) 


Get a public field from a resource by name




public\_fields\(resource\) 


Returns all public attributes, aggregates, calculations and relationships of a resource




public\_relationship\(resource, relationship\_name\) 


Get a public relationship by name or path




public\_relationships\(resource\) 


Returns all public relationships of a resource




related\(resource, relationship\) 



relationship\(resource, relationship\_name\) 


Get a relationship by name or path




relationships\(resource\) 


Returns all relationships of a resource




required\_belongs\_to\_relationships\(resource\) 


The required belongs\_to relationships




resource?\(module\) 


Whether or not a given module is a resource module




reverse\_relationship\(resource, path, acc \\\\ \[\]\) 


Retrieves a relationship path from the resource related by path, to the provided resource.




selected\_by\_default\_attribute\_names\(resource\) 



short\_name\(resource\) 


The short\_name of the resource




show\_inspect\_fields\(resource\) 


An allow-list of fields to show in the inspect output.




simple\_notifiers\(resource\) 


A list of simple notifiers \(require no DSL, used to avoid compile time dependencies\)




sortable?\(resource, name, opts \\\\ \[\]\) 


Determine if a field is sortable by name




static\_default\_attributes\(resource, atom\) 


Returns all attributes of a resource with static defaults




trace\_name\(resource\) 


The trace\_name of the resource




unique\_keys\(resource\) 


A list of unique keys and information for a resource




validations\(resource\) 


A list of all validations for the resource




validations\(resource, type\) 


A list of all validations for the resource for a given action type




# Functions




# action\(resource, name, type \\\\ nil\)




    @spec     action(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
          atom    (),
          Ash.Resource.Actions.action_type    () | nil
    ) ::
          Ash.Resource.Actions.action    () | nil


Returns the action with the matching name and type on the resource





# action\_input?\(resource, action, input\)




    @spec     action_input?(    Ash.Resource.t    (), action ::     atom    (), input ::     atom    () |     String.t    ()) ::
          boolean    ()


Returns true or false if the input is accepted by the action, as an argument or an attribute





# action\_inputs\(resource, action\)




    @spec     action_inputs(    Ash.Resource.t    (), action ::     atom    ()) ::     MapSet.t    ()


Returns the list of possible accepted keys by an action





# action\_select\(resource, action\)




    @spec     action_select(
          Ash.Resource.t    (),
      action ::     atom    () |     Ash.Resource.Actions.action    ()
    ) ::
      [    atom    ()] | nil


Returns the list of attributes that must be selected for an action invocation





# actions\(resource\)




    @spec     actions(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Actions.action    ()]


Returns all actions of a resource





# aggregate\(resource, name\)




    @spec     aggregate(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    () |     String.t    ()) ::
          Ash.Resource.Aggregate.t    () | nil


Get an aggregate by name





# aggregate\_type\(resource, aggregate\)




    @spec     aggregate_type(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
          Ash.Resource.Aggregate.t    () |     atom    ()
    ) ::
      {:ok,     Ash.Type.t    ()} | {:error,     String.t    ()}


Gets the type of an aggregate for a given resource.





# aggregates\(resource\)




    @spec     aggregates(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Aggregate.t    ()]


Returns all aggregates of a resource





# always\_selected\_attribute\_names\(resource\)




    @spec     always_selected_attribute_names(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     MapSet.t    ()





# attribute\(resource, name\)




    @spec     attribute(    Spark.Dsl.t    () |     Ash.Resource.t    (),     String.t    () |     atom    ()) ::
          Ash.Resource.Attribute.t    () | nil


Get an attribute name from the resource





# attribute\_names\(resource\)




    @spec     attribute_names(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     MapSet.t    ()





# attributes\(resource\)




    @spec     attributes(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Attribute.t    ()]


Returns all attributes of a resource





# attributes\_to\_require\(resource\)





# attributes\_to\_require\(resource, action\_name\)





# authorizers\(resource\)




    @spec     authorizers(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    module    ()]


A list of authorizers to be used when accessing





# base\_filter\(resource\)




    @spec     base_filter(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     term    ()


The base filter of the resource





# calculation\(resource, name\)




    @spec     calculation(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    () |     String.t    ()) ::
          Ash.Resource.Calculation.t    () | nil


Get a calculation by name





# calculation\_interface\(resource, name\)




    @spec     calculation_interface(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    ()) ::
          Ash.Resource.CalculationInterface.t    () | nil


Get an calculation interface by name from the resource





# calculation\_interfaces\(resource\)




    @spec     calculation_interfaces(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.CalculationInterface.t    ()
    ]


The list of code interface calculation definitions.





# calculations\(resource\)




    @spec     calculations(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Calculation.t    ()]


Returns all calculations of a resource





# changes\(resource\)




    @spec     changes(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Validation.t    () |     Ash.Resource.Change.t    ()
    ]


A list of all changes for the resource





# changes\(resource, type\)




    @spec     changes(    Spark.Dsl.t    () |     Ash.Resource.t    (), :create | :update | :destroy) :: [
          Ash.Resource.Validation.t    () |     Ash.Resource.Change.t    ()
    ]


A list of all changes for the resource for a given action type





# code\_interface\_domain\(resource\)




    @spec     code_interface_domain(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     atom    () | nil


The domain to define the interface for, when defining it in the resource





# data\_layer\(resource\)




    @spec     data_layer(    Ash.Resource.t    ()) ::     Ash.DataLayer.t    () | nil


The data layer of the resource, or nil if it does not have one





# default\_actions\(resource\)




    @spec     default_actions(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
      :create | :read | :update | :destroy
    ]


Returns the configured default actions





# default\_context\(resource\)




    @spec     default_context(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     term    ()


The default context of the resource





# define\_interface?\(resource\)




    @spec     define_interface?(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     boolean    ()


Whether or not to define the interface on the resource





# description\(resource\)




    @spec     description(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     String.t    () | nil


The description of the resource





# domain\(resource\)



Returns the statically configured domain for the resource.





# embedded?\(resource\)




    @spec     embedded?(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     boolean    ()


Whether or not the resource is an embedded resource





# field\(resource, name\)




    @spec     field(    Spark.Dsl.t    () |     Ash.Resource.t    (),     String.t    () |     atom    ()) ::
          Ash.Resource.Attribute.t    ()
      |     Ash.Resource.Aggregate.t    ()
      |     Ash.Resource.Calculation.t    ()
      |     Ash.Resource.Relationships.relationship    ()
      | nil


Get a field from a resource by name





# fields\(resource, types \\\\ \[:attributes, :aggregates, :calculations, :relationships\]\)




    @spec     fields(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
      types :: [:attributes | :aggregates | :calculations | :relationships]
    ) :: [
          Ash.Resource.Attribute.t    ()
      |     Ash.Resource.Aggregate.t    ()
      |     Ash.Resource.Calculation.t    ()
      |     Ash.Resource.Relationships.relationship    ()
    ]


Returns all attributes, aggregates, calculations and relationships of a resource





# hide\_inspect\_fields\(resource\)




    @spec     hide_inspect_fields(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    atom    ()]


A deny-list of fields to hide from the inspect output. Takes precedence over `show_inspect_fields`.





# identities\(resource\)




    @spec     identities(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Identity.t    ()]


A list of identities for the resource





# identity\(resource, name\)




    @spec     identity(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    ()) ::
          Ash.Resource.Identity.t    () | nil


Get an identity by name from the resource





# inspect\_private\_fields?\(resource\)




    @spec     inspect_private_fields?(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     boolean    ()


Whether to include private fields in the inspect output. `show_inspect_fields` takes precedence over this option.





# interface\(resource, name\)




    @spec     interface(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    ()) ::
          Ash.Resource.Interface.t    () | nil


Get an interface by name from the resource





# interfaces\(resource\)




    @spec     interfaces(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Interface.t    ()]


The list of code interface definitions.





# lazy\_matching\_default\_attributes\(resource, atom\)




    @spec     lazy_matching_default_attributes(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
      type :: :create | :update
    ) :: [    Ash.Resource.Attribute.t    ()]


Returns all attributes of a resource with lazy matching defaults





# lazy\_non\_matching\_default\_attributes\(resource, atom\)




    @spec     lazy_non_matching_default_attributes(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
      type :: :create | :update
    ) :: [    Ash.Resource.Attribute.t    ()]


Returns all attributes of a resource with lazy non-matching-defaults





# multitenancy\_attribute\(resource\)




    @spec     multitenancy_attribute(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     atom    () | nil


The multitenancy attribute for a resource





# multitenancy\_global?\(resource\)




    @spec     multitenancy_global?(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     atom    () | nil


The MFA to parse the tenant from the attribute





# multitenancy\_parse\_attribute\(resource\)




    @spec     multitenancy_parse_attribute(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::
      {    atom    (),     atom    (), [    any    ()]}


The function to parse the tenant from the attribute





# multitenancy\_strategy\(resource\)




    @spec     multitenancy_strategy(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::
      :context | :attribute | nil


The multitenancy strategy for a resource





# multitenancy\_template\(resource\)




    @spec     multitenancy_template(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     atom    () | nil


The template for creating the tenant name





# notifiers\(resource\)




    @spec     notifiers(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    module    ()]


A list of notifiers to be used when accessing





# plural\_name\(resource\)



The plural\_name of the resource





# preparations\(resource, type \\\\ :read\)




    @spec     preparations(    Spark.Dsl.t    () |     Ash.Resource.t    (), action_type :: :read | :action) ::
      [
            Ash.Resource.Preparation.t    ()
      ]





# primary\_action\(resource, type\)




    @spec     primary_action(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
          Ash.Resource.Actions.action_type    ()
    ) ::
          Ash.Resource.Actions.action    () | nil


Returns the primary action of a given type





# primary\_action\!\(resource, type\)




    @spec     primary_action!(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
          Ash.Resource.Actions.action_type    ()
    ) ::
          Ash.Resource.Actions.action    () |     no_return    ()


Returns the primary action of the given type





# primary\_key\(resource\)




    @spec     primary_key(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    atom    ()]


A list of field names corresponding to the primary key





# primary\_key\_simple\_equality?\(resource\)




    @spec     primary_key_simple_equality?(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     boolean    ()


Whether or not all primary key attributes can be compared with simple\_equality





# public\_aggregate\(resource, name\)




    @spec     public_aggregate(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    () |     String.t    ()) ::
          Ash.Resource.Aggregate.t    () | nil


Get an aggregate by name





# public\_aggregates\(resource\)




    @spec     public_aggregates(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Aggregate.t    ()
    ]


Returns all public aggregates of a resource





# public\_attribute\(resource, name\)




    @spec     public_attribute(    Spark.Dsl.t    () |     Ash.Resource.t    (),     String.t    () |     atom    ()) ::
          Ash.Resource.Attribute.t    () | nil


Get a public attribute name from the resource





# public\_attributes\(resource\)




    @spec     public_attributes(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Attribute.t    ()
    ]


Returns all public attributes of a resource





# public\_calculation\(resource, name\)




    @spec     public_calculation(    Spark.Dsl.t    () |     Ash.Resource.t    (),     atom    () |     String.t    ()) ::
          Ash.Resource.Calculation.t    () | nil


Get a public calculation by name





# public\_calculations\(resource\)




    @spec     public_calculations(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Calculation.t    ()
    ]


Returns all public calculations of a resource





# public\_field\(resource, name\)




    @spec     public_field(    Spark.Dsl.t    () |     Ash.Resource.t    (),     String.t    () |     atom    ()) ::
          Ash.Resource.Attribute.t    ()
      |     Ash.Resource.Aggregate.t    ()
      |     Ash.Resource.Calculation.t    ()
      |     Ash.Resource.Relationships.relationship    ()
      | nil


Get a public field from a resource by name





# public\_fields\(resource\)




    @spec     public_fields(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Attribute.t    ()
      |     Ash.Resource.Aggregate.t    ()
      |     Ash.Resource.Calculation.t    ()
      |     Ash.Resource.Relationships.relationship    ()
    ]


Returns all public attributes, aggregates, calculations and relationships of a resource





# public\_relationship\(resource, relationship\_name\)



Get a public relationship by name or path





# public\_relationships\(resource\)




    @spec     public_relationships(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Relationships.relationship    ()
    ]


Returns all public relationships of a resource





# related\(resource, relationship\)




    @spec     related(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
          atom    () |     String.t    () | [    atom    () |     String.t    ()]
    ) ::
          Ash.Resource.t    () | nil





# relationship\(resource, relationship\_name\)




    @spec     relationship(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
          atom    () |     String.t    () | [    atom    () |     String.t    ()]
    ) ::
          Ash.Resource.Relationships.relationship    () | nil


Get a relationship by name or path





# relationships\(resource\)




    @spec     relationships(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
          Ash.Resource.Relationships.relationship    ()
    ]


Returns all relationships of a resource





# required\_belongs\_to\_relationships\(resource\)



The required belongs\_to relationships





# resource?\(module\)




    @spec     resource?(    module    ()) ::     boolean    ()


Whether or not a given module is a resource module





# reverse\_relationship\(resource, path, acc \\\\ \[\]\)



Retrieves a relationship path from the resource related by path, to the provided resource.





# selected\_by\_default\_attribute\_names\(resource\)




    @spec     selected_by_default_attribute_names(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::
          MapSet.t    ()





# short\_name\(resource\)




    @spec     short_name(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     atom    () | nil


The short\_name of the resource





# show\_inspect\_fields\(resource\)




    @spec     show_inspect_fields(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    atom    ()] | nil


An allow-list of fields to show in the inspect output.





# simple\_notifiers\(resource\)




    @spec     simple_notifiers(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    module    ()]


A list of simple notifiers \(require no DSL, used to avoid compile time dependencies\)





# sortable?\(resource, name, opts \\\\ \[\]\)




    @spec     sortable?(    Spark.Dsl.t    () |     Ash.Resource.t    (),     String.t    () |     atom    (),
      pagination_type:     Ash.Page.type    (),
      include_private?:     boolean    ()
    ) ::     boolean    ()


Determine if a field is sortable by name





# static\_default\_attributes\(resource, atom\)




    @spec     static_default_attributes(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
      type :: :create | :update
    ) :: [    Ash.Resource.Attribute.t    ()]


Returns all attributes of a resource with static defaults





# trace\_name\(resource\)




    @spec     trace_name(    Spark.Dsl.t    () |     Ash.Resource.t    ()) ::     String.t    () | nil


The trace\_name of the resource





# unique\_keys\(resource\)




    @spec     unique_keys(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [
      %{type:     atom    (), keys: [    atom    ()], nils_distinct?:     boolean    ()}
    ]


A list of unique keys and information for a resource





# validations\(resource\)




    @spec     validations(    Spark.Dsl.t    () |     Ash.Resource.t    ()) :: [    Ash.Resource.Validation.t    ()]


A list of all validations for the resource





# validations\(resource, type\)




    @spec     validations(
          Spark.Dsl.t    () |     Ash.Resource.t    (),
      :create | :update | :destroy | :read
    ) :: [
          Ash.Resource.Validation.t    ()
    ]


A list of all validations for the resource for a given action type





# Ash.Domain.Info.Diagram 

Generate Mermaid diagrams from a specified domain.

## Limitations

We can't easily model Ash relationships with Mermaid diagrams because they are unidirectional and could be asymmetric. Mermaid assumes symmetrical, bidirectional relationships. If we try to model all unidirectional relationships as separate lines in the diagram it gets very hard to read very quickly.





# Summary


## **Functions** 


mermaid\_class\_diagram\(domain, opts \\\\ \[indent: " ", show\_private?: false\]\) 


Generates a Mermaid Class Diagram for a given domain.




mermaid\_er\_diagram\(domains, opts \\\\ \[indent: " ", show\_private?: false\]\) 


Generates a Mermaid Entity Relationship Diagram for a given domain or list of domains.




# Functions




# mermaid\_class\_diagram\(domain, opts \\\\ \[indent: " ", show\_private?: false\]\)



Generates a Mermaid Class Diagram for a given domain.

Shows only public attributes, calculations, aggregates and actions. Shows a connecting line for relationships with the type of relationship indicated in the attribute list.





# mermaid\_er\_diagram\(domains, opts \\\\ \[indent: " ", show\_private?: false\]\)



Generates a Mermaid Entity Relationship Diagram for a given domain or list of domains.

Shows only public attributes, calculations, aggregates and actions. Shows a one-to-one line for relationships as enumerating all unidirectional relationships is far too noisy.





# Ash.Domain.Info.Livebook 

Generate a Livebook from a specified domain.





# Summary


## **Functions** 


action\_header\(\) 



action\_input\_section\(resource, action\) 



action\_section\(resource, action\) 



attr\_header\(\) 



attr\_section\(attr\) 



domain\_section\(domain\) 



overview\(domains\) 



resource\_section\(resource\) 



# Functions




# action\_header\(\)





# action\_input\_section\(resource, action\)





# action\_section\(resource, action\)





# attr\_header\(\)





# attr\_section\(attr\)





# domain\_section\(domain\)





# overview\(domains\)





# resource\_section\(resource\)





# Ash.Policy.Chart.Mermaid 

Generates policy mermaid charts





# Summary


## **Functions** 


chart\(resource\) 



# Functions




# chart\(resource\)





# Ash.Generator 

Tools for generating input to Ash resource actions and for generating seed data.

## Using Ash.Generator

To define generators for your tests, `use Ash.Generator`, and define functions that use `changeset_generator/3` and/or `seed_generator/2`.

    defmodule         YourApp.Generator         do    
          use         Ash.Generator    

          # using `seed_generator`, bypasses the action and saves directly to the data layer    
          def         blog_post    (    opts         \\         [    ]    )         do    
            seed_generator    (    
              %    MyApp.Blog.Post    {    
                name    :         sequence    (    :title    ,         &    "My Blog Post     #{    &1    }    "    )    
                text    :         StreamData    .    repeatedly    (    fn         ->         Faker.Lorem    .    paragraph    (    )         end    )    
              }    ,    
              overrides    :         opts    
            )    
          end    

          # using `changeset_generator`, calls the action when passed to `generate`    
          def         blog_post_comment    (    opts         \\         [    ]    )         do    
            blog_post_id         =         opts    [    :blog_post_id    ]         ||         once    (    :default_blog_post_id    ,         fn         ->         generate    (    blog_post    (    )    )    .    id         end    )    

            changeset_generator    (    
              MyApp.Blog.Comment    ,    
              :create    ,    
              defaults    :         [    
                blog_post_id    :         blog_post_id    
              ]    ,    
              overrides    :         opts    
            )    
          end        end

Then, in your tests, you can `import YourApp.Generator`, and use `generate/1` and `generate_many/1` to generate data. For example:

    import         YourApp.Generator    
        test         "`comment_count` on blog_post shows the count of comments"         do    
          blog_post         =         generate    (    blog_post    (    )    )    
          assert         Ash    .    load!    (    blog_post    ,         :comment_count    )    .    comment_count         ==         0    

          generate_many    (    blog_post_comment    (    blog_post_id    :         blog_post    .    id    )    ,         10    )    

          assert         Ash    .    load!    (    blog_post    ,         :comment_count    )    .    comment_count         ==         10        end

## About Generators

These generators are backed by `StreamData`, and are ready for use with property testing via `ExUnitProperties`

Many functions in this module support "overrides", which allow passing down either constant values or your own `StreamData` generators.

For example:

    # All generated posts will have text as `"text"`. Equivalent to providing `StreamData.constant("text")`.        Ash.Generator    .    seed_input    (    Post    ,         %{    text    :         "text"    }    )





# Summary


## **Types** 


overrides\(\) 


A map or keyword of data generators or constant values to use in place of defaults.




stream\_data\(\) 


An instance of `StreamData`, gotten from one of the functions in that module.





## **Functions** 


action\_input\(resource\_or\_record, action\_name, generators \\\\ %\{\}\) 


Generate input meant to be passed into a resource action.




changeset\(resource\_or\_record, action, generators \\\\ %\{\}, changeset\_options \\\\ \[\]\) 


Creates the input for the provided action with `action_input/3`, and creates a changeset for that action with that input.




changeset\_generator\(resource, action, opts \\\\ \[\]\) 


A generator of changesets which call their specific actions when passed to `generate/1` or `generate_many/2`.




generate\(changeset\) 


Takes one value from a changeset or seed generator and calls `Ash.create!` or `Ash.update!` on it.




generate\_many\(changeset\_generator, count\) 


Takes `count` values from a changeset or seed generator and passes their inputs into `Ash.bulk_create!` or `Ash.Seed.seed!` respectively.




initialize\_once\(identifier\) 


Starts and links an agent for a `once/2`, or returns the existing agent pid if it already exists.




initialize\_sequence\(identifier\) 


Starts and links an agent for a sequence, or returns the existing agent pid if it already exists.




many\_changesets\(resource\_or\_record, action, count, generators \\\\ %\{\}, changeset\_options \\\\ \[\]\) 


Generate `count` changesets and return them as a list.




many\_queries\(resource, action, count, generators \\\\ %\{\}, changeset\_options \\\\ \[\]\) 


Generate `count` queries and return them as a list.




mixed\_map\(map, keys\) 


Creates a generator of maps where all keys are required except the list provided




next\_in\_sequence\(identifier, fun, sequencer \\\\ fn i -> \(i || -1\) \+ 1 end\) 


Gets the next value for a given sequence identifier.




once\(identifier, generator\) 


Run the provided function or enumerable \(i.e generator\) only once.




query\(resource, action, generators \\\\ %\{\}, query\_options \\\\ \[\]\) 


Creates the input for the provided action with `action_input/3`, and returns a query for that action with that input.




seed\!\(resource, generators \\\\ %\{\}\) 


Gets input using `seed_input/2` and passes it to `Ash.Seed.seed!/2`, returning the result




seed\_generator\(record, opts \\\\ \[\]\) 


A generator of seedable records, to be passed to `generate/1` or `generate_many/1`




seed\_input\(resource, generators \\\\ %\{\}\) 


Generate input meant to be passed into `Ash.Seed.seed!/2`.




seed\_many\!\(resource, n, generators \\\\ %\{\}\) 


Generates an input `n` times, and passes them all to seed, returning the list of seeded items.




sequence\(identifier, generator, sequencer \\\\ fn i -> \(i || -1\) \+ 1 end\) 


Generate globally unique values.




stop\_once\(identifier\) 


Stops the agent for a `once/2`.




stop\_sequence\(identifier\) 


Stops the agent for a sequence.




# Types




# overrides\(\)




    @type     overrides() ::
      %{required(    term    ()) =>     stream_data    () |     term    ()}
      |     Keyword.t    (    stream_data    () |     term    ())


A map or keyword of data generators or constant values to use in place of defaults.

Many functions in `Ash.Generator` support `overrides`, allowing to customize the default generated values.





# stream\_data\(\)




    @type     stream_data() ::     Enumerable.t    ()


An instance of `StreamData`, gotten from one of the functions in that module.





# Functions




# action\_input\(resource\_or\_record, action\_name, generators \\\\ %\{\}\)




    @spec     action_input(
          Ash.Resource.t    () |     Ash.Resource.record    (),
      action_name ::     atom    (),
      generators ::     overrides    ()
    ) ::     map    ()


Generate input meant to be passed into a resource action.

Arguments that are passed to a `manage_relationship` are not generated by default, and you will have to generate them yourself by passing your own generators/values down. See the module documentation for more.





# changeset\(resource\_or\_record, action, generators \\\\ %\{\}, changeset\_options \\\\ \[\]\)




    @spec     changeset(
          Ash.Resource.t    (),
      action ::     atom    (),
          overrides    (),
      changeset_options ::     Keyword.t    ()
    ) ::     Ash.Changeset.t    ()


Creates the input for the provided action with `action_input/3`, and creates a changeset for that action with that input.

See `action_input/3` and the module documentation for more.





# changeset\_generator\(resource, action, opts \\\\ \[\]\)



A generator of changesets which call their specific actions when passed to `generate/1` or `generate_many/2`.

See `seed_generator/2` for the equivalent construct for cases when you want to seed directly to the data layer as opposed to calling resource actions.

## ******Examples**

    iex>     changeset_generator    (    MyApp.Blog.Post    ,         :create    ,         defaults    :         [    title    :         sequence    (    :blog_post_title    ,         &    "My Blog Post     #{    &1    }    "    )    ]    )         |>         generate    (    )        %    Ash.Changeset    {    ...    }

## ******Usage in tests**

This can be used to define generators in tests. A useful pattern is defining a function like so:

    def         blog_post    (    opts         \         [    ]    )         do    
          changeset_generator    (    
            MyApp.Blog.Post    ,    
            :create    ,    
            defaults    :         [    
              name    :         sequence    (    :blog_post_title    ,         &    "My Blog Post     #{    &1    }    "    )    
              text    :         StreamData    .    repeatedly    (    fn         ->         Faker.Lorem    .    paragraph    (    )         end    )    
            ]    ,    
            overrides    :         opts    
          )        end

When you only allow child resource to be created through a managed relationship, e.g. an update action on a parent resource, this pattern could be expanded, yielding a resource with a new child resource:

    def         post_for    (    author    ,         opts         \         [    ]    )         do    
          changeset_generator    (    
            author    ,    
            :new_post    ,    
            uses    :         [    
              post_input    :    
                action_input    (    
                  MyApp.Blog.Post    ,    
                  :create    ,    
                  title    :         sequence    (    :title    ,         &    "Post     #{    &1    }    "    )    
                )    
            ]    ,    
            defaults    :         fn         inputs         ->    
              [    posts    :         [    inputs    .    post_input    ]    ]    
            end    ,    
            overrides    :         opts    
          )        end

See the `Ash.Generator` moduledocs for more information.

## ******Options**

+ `:defaults` - A keyword list of values or generators, used as inputs. Can also be a function when using the `:uses` option.
+ `:overrides` - A keyword list or map of `t:overrides()`
+ `:actor` - Passed through to the changeset
+ `:tenant` - Passed through to the changeset
+ `:uses` - A map of generators that are passed into your `defaults`. `defaults` must be a function. This is useful when multiple things in your `defaults` need to use the same generated value.
+ `:authorize?` - Passed through to the changeset
+ `:context` - Passed through to the changeset
+ `:after_action` - A one argument function that takes the result and returns a new result to run after the record is created.
+ `:private_arguments` - A map of private arguments, whos values can also be generators. Can also be a function when using the `:uses` option.

## ******The `uses` option**

    def         blog_post    (    opts         \         [    ]    )         do    
          changeset_generator    (    
            MyApp.Blog.Post    ,    
            :create    ,    
            uses    :         [    
              author    :         author    (    )         # A function using `changeset_generator` just like this one.    
            ]    ,    
            defaults    :         fn         %{    author    :         author    }         ->    
              author         =         generate    (    author    )    

              [    
                name    :         sequence    (    :blog_post_title    ,         &    "My Blog Post     #{    &1    }    "    )    
                author_name    :         author    .    name    ,    
                text    :         StreamData    .    repeatedly    (    fn         ->         Faker.Lorem    .    paragraph    (    )         end    )    
              ]    
            end    
            overrides    :         opts    
          )        end





# generate\(changeset\)




    @spec     generate(    stream_data    () |     Ash.Changeset.t    () |     Ash.Resource.record    ()) ::
          Ash.Resource.record    ()


Takes one value from a changeset or seed generator and calls `Ash.create!` or `Ash.update!` on it.

Passes through resource structs without doing anything. Creates a changeset if given





# generate\_many\(changeset\_generator, count\)



Takes `count` values from a changeset or seed generator and passes their inputs into `Ash.bulk_create!` or `Ash.Seed.seed!` respectively.





# initialize\_once\(identifier\)




    @spec     initialize_once(    term    ()) ::     pid    ()


Starts and links an agent for a `once/2`, or returns the existing agent pid if it already exists.

See `once/2` for more.





# initialize\_sequence\(identifier\)




    @spec     initialize_sequence(    atom    ()) ::     pid    ()


Starts and links an agent for a sequence, or returns the existing agent pid if it already exists.

See `sequence/3` for more.





# many\_changesets\(resource\_or\_record, action, count, generators \\\\ %\{\}, changeset\_options \\\\ \[\]\)




    @spec     many_changesets(
          Ash.Resource.t    (),
      action ::     atom    (),
      count ::     pos_integer    (),
          overrides    (),
      changeset_options ::     Keyword.t    ()
    ) :: [    Ash.Changeset.t    ()]


Generate `count` changesets and return them as a list.





# many\_queries\(resource, action, count, generators \\\\ %\{\}, changeset\_options \\\\ \[\]\)




    @spec     many_queries(
          Ash.Resource.t    (),
      action ::     atom    (),
      count ::     pos_integer    (),
          overrides    (),
      changeset_options ::     Keyword.t    ()
    ) :: [    Ash.Query.t    ()]


Generate `count` queries and return them as a list.





# mixed\_map\(map, keys\)




    @spec     mixed_map(    map    (), [    term    ()]) ::     stream_data    ()


Creates a generator of maps where all keys are required except the list provided

## ******Example**

    iex>     mixed_map    (    %{    a    :         StreamData    .    constant    (    1    )    ,         b    :         StreamData    .    constant    (    2    )    }    ,         [    :b    ]    )         |>         Enum    .    take    (    2    )        [    %{    a    :         1    }    ,         %{    a    :         1    ,         b    :         2    }    ]





# next\_in\_sequence\(identifier, fun, sequencer \\\\ fn i -> \(i || -1\) \+ 1 end\)



Gets the next value for a given sequence identifier.

See `sequence/3` for more.

This is equivalent to `identifier |> Ash.Generator.sequence(fun, sequencer) |> Enum.at(0)`





# once\(identifier, generator\)




    @spec     once(    pid    () |     term    (), (-> value) |     Enumerable.t    (value)) ::     StreamData.t    (value)
    when value:     term    ()


Run the provided function or enumerable \(i.e generator\) only once.

This is useful for ensuring that some piece of data is generated a single time during a test.

The lifecycle of this generator is tied to the process that initially starts it. In general, that will be the test. In the rare case where you are running async processes that need to share a sequence that is not created in the test process, you can initialize a sequence in the test using `initialize_once/1`.

Example:

    iex>     Ash.Generator    .    once    (    :user    ,         fn         ->    
               register_user    (    ...    )    
             end    )         |>         Enum    .    at    (    0    )        %    User    {    id    :         1    }         # created the user    
        iex>     Ash.Generator    .    once    (    :user    ,         fn         ->    
               register_user    (    ...    )    
             end    )         |>         Enum    .    at    (    0    )        %    User    {    id    :         1    }         # reused the last user





# query\(resource, action, generators \\\\ %\{\}, query\_options \\\\ \[\]\)




    @spec     query(
          Ash.Resource.t    (),
      action ::     atom    (),
          overrides    (),
      query_options ::     Keyword.t    ()
    ) ::     Ash.Query.t    ()


Creates the input for the provided action with `action_input/3`, and returns a query for that action with that input.

See `action_input/3` and the module documentation for more.





# seed\!\(resource, generators \\\\ %\{\}\)



Gets input using `seed_input/2` and passes it to `Ash.Seed.seed!/2`, returning the result





# seed\_generator\(record, opts \\\\ \[\]\)




    @spec     seed_generator(
          Ash.Resource.record    ()
      | {    Ash.Resource.t    (),     map    ()}
      | (    map    () ->     Ash.Resource.record    () | {    Ash.Resource.t    (), %{}}),
      opts ::     Keyword.t    ()
    ) ::     stream_data    ()


A generator of seedable records, to be passed to `generate/1` or `generate_many/1`

See `changeset_generator/3` for the equivalent construct for cases when you want to call resource actions as opposed to seed directly to the data layer.

When a struct is given, only exactly the given values/generators will be used. If you pass a tuple, i.e `{Resource, %{field: :value}}`, all values not provided will be generated automatically.

## ******Examples**

    iex>     seed_generator    (    %    MyApp.Blog.Post    {    name    :         sequence    (    :blog_post_title    ,         &    "My Blog Post     #{    &1    }    "    )    }    )         |>         generate    (    )        %    Tunez.Music.Artist    {    name    :         "Artist 1"    }    
        iex>     seed_generator    (    {    MyApp.Blog.Post    ,         %{    }    }    )         |>         generate    (    )        %    Tunez.Music.Artist    {    name    :         "A random name"    }

## ******Usage in tests**

This can be used to define seed generators in tests. A useful pattern is defining a function like so:

    def         blog_post    (    opts         \         [    ]    )         do    
          seed_generator    (    
            %    MyApp.Blog.Post    {    
              name    :         sequence    (    :blog_post_title    ,         &    "My Blog Post     #{    &1    }    "    )    
              text    :         StreamData    .    repeatedly    (    fn         ->         Faker.Lorem    .    paragraph    (    )         end    )    
            }    ,    
            overrides    :         opts    
          )        end

See the `Ash.Generator` moduledocs for more information.

## ******Options**

+ `:overrides` - A keyword list or map of `t:overrides()`
+ `:actor` - Passed through to the changeset
+ `:tenant` - Passed through to the changeset
+ `:uses` - A map of generators that are passed into the first argument, if it is a function.
+ `:authorize?` - Passed through to the changeset
+ `:context` - Passed through to the changeset
+ `:after_action` - A one argument function that takes the result and returns a new result to run after the record is created.





# seed\_input\(resource, generators \\\\ %\{\}\)




    @spec     seed_input(    Ash.Resource.t    (),     map    ()) ::     StreamData.t    (    map    ())


Generate input meant to be passed into `Ash.Seed.seed!/2`.

A map of custom `StreamData` generators can be provided to add to or overwrite the generated input, for example: `Ash.Generator.seed_input(Post, %{text: StreamData.constant("Post")})`





# seed\_many\!\(resource, n, generators \\\\ %\{\}\)



Generates an input `n` times, and passes them all to seed, returning the list of seeded items.





# sequence\(identifier, generator, sequencer \\\\ fn i -> \(i || -1\) \+ 1 end\)




    @spec     sequence(    pid    () |     atom    (), (iterator | nil -> value), (iterator | nil -> iterator)) ::
          StreamData.t    (value)
    when iterator:     term    (), value:     term    ()


Generate globally unique values.

This is useful for generating values that are unique within a given test or processes that it spawns, such as email addresses, or for generating values that are unique across a single resource, such as identifiers. The values will be unique for anything using the same sequence name, **within the same test**.

### Not Globally Unique

The lifecycle of this generator is tied to the process that initially starts it. In general, that will be the test. In the rare case where you are running async processes that need to share a sequence that is not created in the test process, you can initialize a sequence in the test using `initialize_sequence/1`.

If you need a globally unique value, use a value like `System.unique_integer([:positive])` in your values instead.

For example:

    StreamData    .    repeatedly    (    fn         ->         "email    #{    System    .    unique_integer    (    [    :positive    ]    )    }    @example.com"         end    )

Example:

    Ash.Generator    .    sequence    (    :unique_email    ,         fn         i         ->         "user    #{    i    }    @example.com"         end    )         |>         Enum    .    take    (    3    )        iex>     [    "user0@example.com"    ,         "user1@example.com"    ,         "user2@example.com"    ]

## ******Using a different sequencer**

By default we use an incrementing integer starting at 0. However, if you want to use something else, you can provide your own sequencer. The initial value will be `nil`, which you can use to detect that you are the start of the sequence.

Example:

    Ash.Generator    .    sequence    (    :unique_email    ,         fn         i         ->         "user    #{    i    }    @example.com"         end    ,         fn         num         ->         (    num         ||         1    )         -         1         end    )         |>         Enum    .    take    (    3    )        iex>     [    "user0@example.com"    ,         "user-1@example.com"    ,         "user-2@example.com"    ]





# stop\_once\(identifier\)



Stops the agent for a `once/2`.

See `once/2` for more.





# stop\_sequence\(identifier\)



Stops the agent for a sequence.

See `sequence/3` for more.





# Ash.Seed 

Helpers for seeding data, useful for quickly creating lots of data either for database seeding or testing.

Important: this bypasses resource actions, and goes straight to the data layer. No action changes or validations are run. The only thing that it does at the moment is ensure that default values for attributes are set, it does not validate that required attributes are set \(although the data layer may do that for you, e.g with ash\_postgres\).





# Summary


## **Functions** 


keep\_nil\(\) 


Returns `:__keep_nil__`, allowing to ensure a default value is not used when you want the value to be `nil`.




seed\!\(input\) 


Seed using a record \(instance of a resource\) as input.




seed\!\(resource, input, opts \\\\ \[\]\) 


Performs a direct call to the data layer of a resource with the provided input.




skip\(\) 


Returns `:__skip__`, allowing to ensure no value is generated for a given field when used with generators.




update\!\(record, input, opts \\\\ \[\]\) 


Usage is the same as `seed!/2`, but it will update an existing record.




upsert\!\(input, opts \\\\ \[\]\) 


Performs an upsert operation on the data layer of a resource with the provided input and identities. The usage is the same as `seed!/1`, but it will update the record if it already exists.




upsert\!\(resource, input, opts\) 


Usage is the same as `seed!/2`, but it will update the record if it already exists based on the identities.




# Functions




# keep\_nil\(\)



Returns `:__keep_nil__`, allowing to ensure a default value is not used when you want the value to be `nil`.





# seed\!\(input\)



Seed using a record \(instance of a resource\) as input.

If the passed in struct was retrieved from the data layer already \(i.e already seeded\), then it is returned and nothing is done. Otherwise, the attributes and relationships are used as input to `seed/2`, after having any `%Ash.NotLoaded{}` values stripped out.

Any `nil` values will be overwritten with their default values. To avoid this, either use `seed/2` in which providing the key will have it not set the default values. If you want to force `nil` to be accepted and prevent the default value from being set, use the `keep_nil/0` function provided here, which returns `:__keep_nil__`. Alternatively, use `seed!(Post, %{text: nil})`.

See `seed!/2` for more information.





# seed\!\(resource, input, opts \\\\ \[\]\)



Performs a direct call to the data layer of a resource with the provided input.

If a list is provided as input, then you will get back that many results.

To set a tenant, use the tenant option.





# skip\(\)



Returns `:__skip__`, allowing to ensure no value is generated for a given field when used with generators.





# update\!\(record, input, opts \\\\ \[\]\)



Usage is the same as `seed!/2`, but it will update an existing record.

For multitenant resources, tenant will be extracted from the record if not provided in opts.





# upsert\!\(input, opts \\\\ \[\]\)



Performs an upsert operation on the data layer of a resource with the provided input and identities. The usage is the same as `seed!/1`, but it will update the record if it already exists.

    Ash.Seed    .    upsert!    (    %    User    {    email    :         'test@gmail.com'    ,         name    :         'Test'    }    ,         identity    :         :email    )





# upsert\!\(resource, input, opts\)



Usage is the same as `seed!/2`, but it will update the record if it already exists based on the identities.





# Ash.Test 

Testing helpers for Ash.





# Summary


## **Functions** 


assert\_has\_error\(changeset\_query\_or\_input, error\_class \\\\ nil, callback, opts \\\\ \[\]\) 


Assert that the given changeset, query, or action input has a matching error.




assert\_stripped\(expression\) 


A macro for comparing Ash resources while ignoring metadata differences.




refute\_has\_error\(changeset\_query\_or\_input, error\_class \\\\ nil, callback, opts \\\\ \[\]\) 


Refute that the given changeset, query, or action input has a matching error.




strip\_metadata\(structs\) 


Clears the `__metadata__` field and the underlying ecto `__meta__` field




# Functions




# assert\_has\_error\(changeset\_query\_or\_input, error\_class \\\\ nil, callback, opts \\\\ \[\]\)



Assert that the given changeset, query, or action input has a matching error.

Use the optional second argument to assert that the errors \(all together\) are of a specific class.





# assert\_stripped\(expression\)
\(macro\)   


A macro for comparing Ash resources while ignoring metadata differences.

## ******Overview**

Ash resources contain metadata fields \(`__metadata__` and `__meta__`\) that track internal state like loaded relationships and action history. These fields can cause equality comparisons to fail even when the actual data is identical. This macro uses `strip_metadata/1` to remove these fields before comparison.

## ******Usage**

Use when comparing resources that have gone through different processing paths, such as comparing seeded data with data that has been processed through resource actions.

## ******Supported Operators**

+ `==` and `===` - Equality comparison
+ `!=` and `!==` - Inequality comparison
+ `in` and `not in` - Membership testing

## ******Examples**

    # Compare resources        assert_stripped         user1         ==         user2        assert_stripped         [    user1    ,         user2    ]         ===         [    user3    ,         user4    ]        assert_stripped         user1         in         [    user2    ,         user3    ,         user4    ]        assert_stripped         user1         not         in         [    user2    ,         user3    ,         user4    ]





# refute\_has\_error\(changeset\_query\_or\_input, error\_class \\\\ nil, callback, opts \\\\ \[\]\)



Refute that the given changeset, query, or action input has a matching error.

The `error_class` argument has been deprecated and should not be used.





# strip\_metadata\(structs\)



Clears the `__metadata__` field and the underlying ecto `__meta__` field

This allows for easier comparison of changeset/query results





# Ash.Policy.Check.AccessingFrom 

This check is true when the current action is being run "through" a relationship.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Action 

This check is true when the action name matches the provided action name.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ActionType 

This check is true when the action type matches the provided type





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ActorAbsent 

This check is true when the actor is `nil`, and false when the actor is specified.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ActorAttributeEquals 

This check is true when the value of the specified attribute of the actor equals the specified value.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ActorPresent 

This check is true when there is an actor specified, and false when the actor is `nil`.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ChangingAttributes 

This check is true when attribute changes correspond to the provided options.





# Summary


## **Functions** 


auto\_filter\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.auto_filter/3`.




auto\_filter\_not\(actor, authorizer, opts\) 



check\(actor, data, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.check/4`.




eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




expand\_description\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.expand_description/3`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




reject\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.FilterCheck.reject/3`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




strict\_check\_context\(opts\) 



type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# auto\_filter\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.auto_filter/3`.





# auto\_filter\_not\(actor, authorizer, opts\)





# check\(actor, data, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.check/4`.





# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# expand\_description\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.expand_description/3`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# reject\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.FilterCheck.reject/3`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# strict\_check\_context\(opts\)





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ChangingRelationships 

This check is true when the specified relationship is changing





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.ContextEquals 

This check is true when the value of the specified key or path in the changeset or query context equals the specified value.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Expression 

The check module used for `expr`s in policies





# Summary


## **Functions** 


auto\_filter\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.auto_filter/3`.




auto\_filter\_not\(actor, authorizer, opts\) 



check\(actor, data, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.check/4`.




eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




expand\_description\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.expand_description/3`.




reject\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.FilterCheck.reject/3`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




strict\_check\_context\(opts\) 



type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# auto\_filter\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.auto_filter/3`.





# auto\_filter\_not\(actor, authorizer, opts\)





# check\(actor, data, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.check/4`.





# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# expand\_description\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.expand_description/3`.





# reject\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.FilterCheck.reject/3`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# strict\_check\_context\(opts\)





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.FilteringOn 

This check is true when the field provided is being referenced anywhere in a filter statement.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Loading 

This check is true when the field or relationship, or path to field, is being loaded and false when it is not.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Matches 

This check is true when the specified function returns true





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.RelatesToActorVia 

This check passes if the data relates to the actor via the specified relationship or path of relationships.





# Summary


## **Functions** 


auto\_filter\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.auto_filter/3`.




auto\_filter\_not\(actor, authorizer, opts\) 



check\(actor, data, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.check/4`.




eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




expand\_description\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.expand_description/3`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




strict\_check\_context\(opts\) 



type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# auto\_filter\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.auto_filter/3`.





# auto\_filter\_not\(actor, authorizer, opts\)





# check\(actor, data, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.check/4`.





# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# expand\_description\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.expand_description/3`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# strict\_check\_context\(opts\)





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.RelatingToActor 

This check is true when the specified relationship is being changed to the current actor.





# Summary


## **Functions** 


auto\_filter\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.auto_filter/3`.




auto\_filter\_not\(actor, authorizer, opts\) 



check\(actor, data, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.check/4`.




eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




expand\_description\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.expand_description/3`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




reject\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.FilterCheck.reject/3`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, authorizer, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




strict\_check\_context\(opts\) 



type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# auto\_filter\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.auto_filter/3`.





# auto\_filter\_not\(actor, authorizer, opts\)





# check\(actor, data, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.check/4`.





# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# expand\_description\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.expand_description/3`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# reject\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.FilterCheck.reject/3`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, authorizer, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# strict\_check\_context\(opts\)





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Resource 

This check is true when the resource matches the provided resource name or names.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Selecting 

This check is true when the field is being selected and false when it is not.





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Policy.Check.Static 

This check is always the result provided





# Summary


## **Functions** 


eager\_evaluate?\(\) 


Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.




prefer\_expanded\_description?\(\) 


Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.




requires\_original\_data?\(\_, \_\) 


Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.




strict\_check\(actor, context, opts\) 


Callback implementation for `Ash.Policy.Check.strict_check/3`.




type\(\) 


Callback implementation for `Ash.Policy.Check.type/0`.




# Functions




# eager\_evaluate?\(\)



Callback implementation for `Ash.Policy.Check.eager_evaluate?/0`.





# prefer\_expanded\_description?\(\)



Callback implementation for `Ash.Policy.Check.prefer_expanded_description?/0`.





# requires\_original\_data?\(\_, \_\)



Callback implementation for `Ash.Policy.Check.requires_original_data?/2`.





# strict\_check\(actor, context, opts\)



Callback implementation for `Ash.Policy.Check.strict_check/3`.





# type\(\)



Callback implementation for `Ash.Policy.Check.type/0`.





# Ash.Resource.Change.CascadeDestroy 

Cascade a resource's destroy action to a related resource's destroy action.

## Timing Control

The `after_action?` option controls when the cascade destroy occurs:

+ `after_action?: true` \(default\) - Runs as an after-action hook, making it safe for atomic actions
+ `after_action?: false` - Runs as a before-action hook

When `after_action?: true`, the change adds an after-action hook that explicitly calls destroy on any records related via the named relationship. It will optimise for bulk destroys where possible. This makes it safe to use in atomic actions, but might not be possible depending on the data layer setup \(see warning below\).

When `after_action?: false`, the change simply runs as a before\_action. Requires keyset pagination on the primary read action of the targeted relation.

#### Beware database constraints

Think carefully before using this change with data layers which enforce referential integrity \(ie PostgreSQL and SQLite\) and you may need to defer constraints for the relationship in question.

See also:

1. `postgres.references.reference.deferrable` DSL
2. `sqlite.references.reference.deferrable` DSL
3. PostgreSQL's `SET CONSTRAINTS` documentation
4. SQLite's `PRAGMA defer_foreign_keys` documentation

#### Cascading notifications

By default notifications are disabled for the related destroy. This is to avoid potentially sending a **lot** of notifications for high-cardinality relationships.

## Options

+ 
`:relationship` \(`atom/0`\) - Required. The name of the relationship to work on

+ 
`:action` \(`atom/0`\) - The name of the destroy action to call on the related resource. Uses the primary destroy by default.

+ 
`:read_action` \(`atom/0`\) - The name of the read action to call on the related resource to find results to be destroyed

+ 
`:return_notifications?` \(`boolean/0`\) - Return notifications for all destroyed records? The default value is `false`.

+ 
`:after_action?` \(`boolean/0`\) - If true, cascade destroys are done in after\_action hooks. If false, they run as before\_action hooks. Defaults to true for atomic action compatibility The default value is `true`.


## Example

    change         {    Ash.Resource.Change.CascadeDestroy    ,         relationship    :         :comments    ,         action    :         :destroy    }

or, equivalently using `Ash.Resource.Change.Builtins.cascade_destroy/2`:

    change         cascade_destroy    (    :comments    ,         action    :         :destroy    )





# Ash.Resource.Change.CascadeUpdate 

Cascade a resource's update action to a related resource's update action.

Adds an after-action hook that explicitly calls update on any records related via the named relationship. It will optimise for bulk updates where possible.

Allows you to copy fields from the arguments or changes to the destination, this way you can cascade a bunch of changes downstream.

#### Beware database constraints

Think carefully before using this change with data layers which enforce referential integrity \(ie PostgreSQL and SQLite\) and you may need to defer constraints for the relationship in question.

See also:

1. `postgres.references.reference.deferrable` DSL
2. `sqlite.references.reference.deferrable` DSL
3. PostgreSQL's `SET CONSTRAINTS` documentation
4. SQLite's `PRAGMA defer_foreign_keys` documentation

#### Cascading notifications

By default notifications are disabled for the related updates. This is to avoid potentially sending a **lot** of notifications for high-cardinality relationships.

## Options

+ 
`:relationship` \(`atom/0`\) - Required. The name of the relationship to work on

+ 
`:action` \(`atom/0`\) - The name of the update action to call on the related resource. Uses the primary update by default.

+ 
`:copy_inputs` \(list of `atom/0`\) - A list of fields to copy & pass on to the downstream update. The source action cannot be atomic. The default value is `[]`.

+ 
`:read_action` \(`atom/0`\) - The name of the read action to call on the related resource to find results to be updated

+ 
`:return_notifications?` \(`boolean/0`\) - Return notifications for all updated records? The default value is `false`.


## Example

    change         {    Ash.Resource.Change.CascadeUpdate    ,         relationship    :         :comments    ,         action    :         :update_all    ,         copy_inputs    :         [    :name    ]    }    
        or    ,         equivalently         using         `    Ash.Resource.Change.Builtins    .    cascade_update    /    2    `    :    
        change         cascade_update    (    :comments    ,         action    :         :update_all    ,         copy_inputs    :         [    :name    ]    )





# Ash.Resource.Change.Context 

The context for a change.

This is passed into various callbacks for `Ash.Resource.Change`.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Change.Context{
      actor:     Ash.Resource.record    () | nil,
      authorize?:     boolean    () | nil,
      bulk?:     boolean    (),
      source_context:     map    (),
      tenant:     term    (),
      tracer:     Ash.Tracer.t    () | [    Ash.Tracer.t    ()] | nil
    }





# Ash.Resource.Change.GetAndLock 

Refetches the record being updated or destroyed, and locks it with the given type.





# Ash.Resource.Change.GetAndLockForUpdate 

Refetches the record being updated or destroyed, and locks it for update.





# Ash.Resource.Change.Increment 

Increments an attribute's value by the amount specified, which defaults to 1.





# Ash.Resource.Change.OptimisticLock 

Apply an "optimistic lock" on a record being updated or destroyed.

## What is Optimistic Locking?

Optimistic Locking is the process of only allowing an update to occur if the version of a record that you have in memory is the same as the version in the database. Otherwise, an error is returned. On success, it increments the version while performing the action.

Optimistic locking may used for two primary purposes:

### User Experience

For example, if a user is editing a form that contains `State` and `County` fields, and they change the `County`, while another user has used the form to change the `State`, you could end up with a mismatch between `State` and `County`.

With optimistic locking, the user will instead get an error message that the record has been changed since they last looked.

### Concurrency Safety

Optimistic locking can make actions safe to run concurrently even if they can't be performed in a single query \(atomically\), by returning an error if the resource in the data layer does not have the same version as the one being edited.

This tells the user that they need to reload and try again.





# Ash.Resource.Validation.ActionIs 

Validates that the action is the specified action.





# Ash.Resource.Validation.Context 

Context for a validation.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Validation.Context{
      actor:     Ash.Resource.record    () | nil,
      authorize?:     boolean    () | nil,
      bulk?:     boolean    (),
      message:     String.t    () | nil,
      source_context:     map    (),
      tenant:     term    (),
      tracer:     Ash.Tracer.t    () | [    Ash.Tracer.t    ()] | nil
    }





# Ash.Tracer **behaviour** 

A behaviour for implementing tracing for an Ash application.





# Summary


## **Types** 


metadata\(\) 



span\_type\(\) 



t\(\) 




## **Callbacks** 


get\_span\_context\(\) 



set\_error\(t\) 



set\_error\(t, t\) 



set\_handled\_error\(t, t\) 



set\_metadata\(span\_type, metadata\) 


Set metadata for the current span.




set\_span\_context\(term\) 



start\_span\(span\_type, name\) 



stop\_span\(\) 



trace\_type?\(atom\) 




## **Functions** 


get\_span\_context\(tracer\) 



set\_error\(tracers, error\) 



set\_error\(tracers, error, opts\) 



set\_handled\_error\(tracers, error, opts\) 



set\_metadata\(tracers, type, metadata\) 



set\_span\_context\(tracer, context\) 



span\(type, name, tracer, block\_opts \\\\ \[\]\) 



start\_span\(tracers, type, name\) 



stop\_span\(tracers\) 



telemetry\_span\(name, metadata, opts \\\\ \[\], block\_opts\) 



trace\_type?\(tracer, type\) 



# Types




# metadata\(\)




    @type     metadata() :: %{
      domain: nil |     module    (),
      resource: nil |     module    (),
      actor:     term    (),
      tenant:     term    (),
      action:     atom    (),
      authorize?:     boolean    ()
    }





# span\_type\(\)




    @type     span_type() ::
      :action
      | :changeset
      | :query
      | :calculate
      | :request_step
      | :change
      | :validation
      | :preparation
      | :custom
      | :notifier
      | :before_transaction
      | :before_action
      | :after_transaction
      | :after_action
      | {:custom,     atom    ()}





# t\(\)




    @type     t() ::     module    ()





# Callbacks




# get\_span\_context\(\)




    @callback     get_span_context() ::     term    ()





# set\_error\(t\)
\(optional\)   



    @callback     set_error(    Exception.t    ()) :: :ok





# set\_error\(t, t\)
\(optional\)   



    @callback     set_error(    Exception.t    (),     Keyword.t    ()) :: :ok





# set\_handled\_error\(t, t\)
\(optional\)   



    @callback     set_handled_error(    Exception.t    (),     Keyword.t    ()) :: :ok





# set\_metadata\(span\_type, metadata\)




    @callback     set_metadata(    span_type    (),     metadata    ()) :: :ok


Set metadata for the current span.

This may be called multiple times per span, and should ideally merge with previous metadata.





# set\_span\_context\(term\)




    @callback     set_span_context(    term    ()) :: :ok





# start\_span\(span\_type, name\)




    @callback     start_span(    span_type    (), name ::     String.t    ()) :: :ok





# stop\_span\(\)




    @callback     stop_span() :: :ok





# trace\_type?\(atom\)
\(optional\)   



    @callback     trace_type?(    atom    ()) ::     boolean    ()





# Functions




# get\_span\_context\(tracer\)





# set\_error\(tracers, error\)





# set\_error\(tracers, error, opts\)





# set\_handled\_error\(tracers, error, opts\)





# set\_metadata\(tracers, type, metadata\)





# set\_span\_context\(tracer, context\)





# span\(type, name, tracer, block\_opts \\\\ \[\]\)
\(macro\)   





# start\_span\(tracers, type, name\)





# stop\_span\(tracers\)





# telemetry\_span\(name, metadata, opts \\\\ \[\], block\_opts\)
\(macro\)   





# trace\_type?\(tracer, type\)





# Ash.Tracer.Simple 

A simple tracer that can send traces to the current process or call a module with the trace.





# Summary


## **Functions** 


gather\_spans\(\) 



# Functions




# gather\_spans\(\)





# Ash.Tracer.Simple.Span 

A span produced by `Ash.Tracer.Simple`





# Ash.BulkResult 

The return value for bulk actions.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.BulkResult{
      error_count:     non_neg_integer    (),
      errors: [    Ash.Error.t    () |     Ash.Changeset.t    ()] | nil,
      notifications: [    Ash.Notifier.Notification.t    ()] | nil,
      records: [    Ash.Resource.record    ()] | nil,
      status: :success | :partial_success | :error
    }





# Ash.Changeset.ManagedRelationshipHelpers 

Tools for introspecting managed relationships.

Extensions can use this to look at an argument that will be passed to a `manage_relationship` change and determine what their behavior should be. For example, AshAdmin uses these to find out what kind of nested form it should offer for each argument that manages a relationship.





# Summary


## **Functions** 


could\_create?\(opts\) 



could\_handle\_missing?\(opts\) 



could\_lookup?\(opts\) 



could\_update?\(opts\) 



must\_load?\(opts, must\_load\_opts \\\\ \[\]\) 



on\_lookup\_read\_action\(opts, relationship\) 



on\_lookup\_update\_action\(opts, relationship\) 



on\_match\_destination\_actions\(opts, relationship\) 



on\_missing\_destination\_actions\(opts, relationship\) 



on\_no\_match\_destination\_actions\(opts, relationship\) 



sanitize\_opts\(relationship, opts\) 



# Functions




# could\_create?\(opts\)





# could\_handle\_missing?\(opts\)





# could\_lookup?\(opts\)





# could\_update?\(opts\)





# must\_load?\(opts, must\_load\_opts \\\\ \[\]\)





# on\_lookup\_read\_action\(opts, relationship\)





# on\_lookup\_update\_action\(opts, relationship\)





# on\_match\_destination\_actions\(opts, relationship\)





# on\_missing\_destination\_actions\(opts, relationship\)





# on\_no\_match\_destination\_actions\(opts, relationship\)





# sanitize\_opts\(relationship, opts\)





# Ash.CiString 

Represents a case insensitive string

While some data layers are aware of case insensitive string types, in order for values of this type to be used in other parts of Ash Framework, it has to be embedded in a module this allows us to implement the `Comparable` protocol for it.

For the type implementation, see `Ash.Type.CiString`





# Summary


## **Types** 


casing\(\) 



string\_type\(\) 



t\(\) 




## **Functions** 


compare\(left, right\) 


Compares an Elixir String or Ash.CiString. It will return `:eq` if equal, `:lt`, if the string is ordered alphabetically before the second string, and `:gt` if after.




new\(value, casing \\\\ nil\) 


Returns a Ash.CiString from a String, or `nil` if the value is `nil`.




sigil\_i\(value, mods\) 


Creates a case insensitive string




to\_comparable\_string\(value\) 


Returns the downcased value, only downcasing if it hasn't already been done




value\(ci\_string\) 


Converts a `Ash.CiString` into a normal Elixir String.




# Types




# casing\(\)




    @type     casing() :: nil | :lower | :upper





# string\_type\(\)




    @type     string_type() ::     t    () |     String.t    ()





# t\(\)




    @type     t() :: %Ash.CiString{case:     casing    (), casted?:     boolean    (), string:     String.t    ()}





# Functions




# compare\(left, right\)




    @spec     compare(    string_type    (),     string_type    ()) :: :gt | :lt | :eq


Compares an Elixir String or Ash.CiString. It will return `:eq` if equal, `:lt`, if the string is ordered alphabetically before the second string, and `:gt` if after.





# new\(value, casing \\\\ nil\)




    @spec     new(    string_type    () | nil,     casing    ()) ::     t    () | nil


Returns a Ash.CiString from a String, or `nil` if the value is `nil`.





# sigil\_i\(value, mods\)




    @spec     sigil_i(
          string_type    () | nil,
          charlist    ()
    ) ::     t    ()


Creates a case insensitive string





# to\_comparable\_string\(value\)




    @spec     to_comparable_string(    string_type    () | nil) ::     String.t    () | nil


Returns the downcased value, only downcasing if it hasn't already been done





# value\(ci\_string\)




    @spec     value(    t    ()) ::     String.t    ()


Converts a `Ash.CiString` into a normal Elixir String.





# Ash.Expr 

Tools to build Ash expressions





# Summary


## **Types** 


t\(\) 




## **Functions** 


actor\(value\) 


A template helper for using actor values in filter templates




arg\(name\) 


A template helper for using action arguments in filter templates




atomic\_ref\(expr\) 


A template helper for referring to the most recent atomic expression applied to an update field




calc\(expression, opts \\\\ \[\]\) 


Creates an expression calculation for use in sort and distinct statements.




can\_return\_nil?\(pred\) 



combinations\(name\) 


A template helper for creating a reference




context\(name\) 


A template helper for using query context in filter templates




determine\_type\(value\) 



determine\_types\(mod, args, returns \\\\ nil, nested? \\\\ false\) 



eval\(expression, opts \\\\ \[\]\) 


Evaluate an expression. This function only works if you have no references, or if you provide the `record` option.




eval\!\(expression, opts \\\\ \[\]\) 


Evaluate an expression. See `eval/2` for more.




expr\(body\) 


Creates an expression. See the Expressions guide for more.




expr?\(value\) 


Returns true if the value is or contains an expression




or\_where\(left, right\) 



parent\(expr\) 


A template helper for creating a parent reference




ref\(name\) 


A template helper for creating a reference




ref\(path, name\) 


A template helper for creating a reference to a related path




template\_references?\(list, pred\) 


Whether or not a given template contains an actor reference




template\_references\_argument?\(template\) 



template\_references\_context?\(template\) 



tenant\(\) 


A template helper for using the tenant in filter templates




where\(left, right\) 



# Types




# t\(\)




    @type     t() ::     any    ()





# Functions




# actor\(value\)



A template helper for using actor values in filter templates





# arg\(name\)



A template helper for using action arguments in filter templates





# atomic\_ref\(expr\)



A template helper for referring to the most recent atomic expression applied to an update field





# calc\(expression, opts \\\\ \[\]\)
\(macro\)   



    @spec     calc(    Macro.t    (), opts ::     Keyword.t    ()) ::     t    ()


Creates an expression calculation for use in sort and distinct statements.

## ******Examples**

    Ash.Query    .    sort    (    query    ,         [    
          {    calc    (    string_upcase    (    name    )    ,         :asc    }    ,    
          {    calc    (    count_nils    (    [    field1    ,         field2    ]    )    ,         type    :         :integer    )    ,         :desc    }    )        ]    )





# can\_return\_nil?\(pred\)





# combinations\(name\)



A template helper for creating a reference





# context\(name\)



A template helper for using query context in filter templates

An atom will get the value for a key, and a list will be accessed via `get_in`.





# determine\_type\(value\)





# determine\_types\(mod, args, returns \\\\ nil, nested? \\\\ false\)





# eval\(expression, opts \\\\ \[\]\)



Evaluate an expression. This function only works if you have no references, or if you provide the `record` option.





# eval\!\(expression, opts \\\\ \[\]\)



Evaluate an expression. See `eval/2` for more.





# expr\(body\)
\(macro\)   



    @spec     expr(    Macro.t    ()) ::     t    ()


Creates an expression. See the Expressions guide for more.





# expr?\(value\)




    @spec     expr?(    term    ()) ::     boolean    ()


Returns true if the value is or contains an expression





# or\_where\(left, right\)
\(macro\)   



    @spec     or_where(    Macro.t    (),     Macro.t    ()) ::     t    ()





# parent\(expr\)



A template helper for creating a parent reference





# ref\(name\)



A template helper for creating a reference





# ref\(path, name\)



A template helper for creating a reference to a related path





# template\_references?\(list, pred\)



Whether or not a given template contains an actor reference





# template\_references\_argument?\(template\)





# template\_references\_context?\(template\)





# tenant\(\)



A template helper for using the tenant in filter templates





# where\(left, right\)
\(macro\)   



    @spec     where(    Macro.t    (),     Macro.t    ()) ::     t    ()





# Ash.Filter 

The representation of a filter in Ash.

## Security Concerns

Do not pass user input directly to `Ash.Query.filter/2`, it will not be sanitised. Instead use `Ash.Filter.parse_input/2` or `Ash.Query.filter_input/2`.

Refer to those functions for more information on how to safely work with user input.

## Writing a filter

### Built In Predicates

+ `is_nil`
+ `==`
+ `!=`
+ `in`
+ `<`
+ `>`
+ `<=`
+ `>=`
+ `&&`
+ `||`
+ `<>`
+ `/`
+ `-`
+ `*`
+ `+`
+ `equals` \(alias for `==`\)
+ `not_equals` \(alias for `!=`\)
+ `gt` \(alias for `>`\)
+ `lt` \(alias for `<`\)
+ `gte` \(alias for `>=`\)
+ `lte` \(alias for `<=`\)
+ `eq` \(alias for `==`\)
+ `not_eq` \(alias for `!=`\)
+ `less_than` \(alias for `<`\)
+ `greater_than` \(alias for `>`\)
+ `less_than_or_equal` \(alias for `<=`\)
+ `greater_than_or_equal` \(alias for `>=`\)
+ `and` \(alias for `&&`\)
+ `or` \(alias for `||`\)
+ `concat` \(alias for `<>`\)
+ `div` \(alias for `/`\)
+ `minus` \(alias for `-`\)
+ `times` \(alias for `*`\)
+ `plus` \(alias for `+`\)

### BooleanExpression syntax

The expression syntax ultimately just builds the keyword list style filter, but with lots of conveniences that would be very annoying to do manually.

Examples

    Ash.Query    .    filter    (    resource    ,         name         ==         "Zardoz"    )        Ash.Query    .    filter    (    resource    ,         first_name         ==         "Zar"         and         last_name         ==         "Doz"    )        Ash.Query    .    filter    (    resource    ,         first_name         ==         "Zar"         and         last_name         in         [    "Doz"    ,         "Daz"    ]         and         high_score         >         10    )        Ash.Query    .    filter    (    resource    ,         first_name         ==         "Zar"         or         last_name         ==         "Doz"         or         (    high_score         >         10         and         high_score         <         -    10    )    )

### Expressions

More complex filters can be built using Ash Expressions.

Examples

    # Filter based on the contents of a string attribute        Ash.Query    .    filter    (    Helpdesk.Support.Ticket    ,         contains    (    subject    ,         "2"    )    )        # Filter based on the attribute of a joined relationship:        Ash.Query    .    filter    (    Helpdesk.Support.Ticket    ,         representative    .    name         ==         ^    name    )

See the Expressions guide guide for more information.

### Keyword list syntax

A filter is a nested keyword list \(with some exceptions, like `true` for everything and `false` for nothing\).

The key is the "predicate" \(or "condition"\) and the value is the parameter. You can use `and` and `or` to create nested filters. Data layers can expose custom predicates. Eventually, you will be able to define your own custom predicates, which will be a mechanism for you to attach complex filters supported by the data layer to your queries.

**Important ** In a given keyword list, all predicates are considered to be "ands". So `[or: [first_name: "Tom", last_name: "Bombadil"]]` doesn't mean 'First name == "tom" or last\_name == "bombadil"'. To say that, you want to provide a list of filters, like so: `[or: [[first_name: "Tom"], [last_name: "Bombadil"]]]`

Some example filters:

    Ash.Query    .    filter    (    resource    ,         [    name    :         "Zardoz"    ]    )        Ash.Query    .    filter    (    resource    ,         [    first_name    :         "Zar"    ,         last_name    :         "Doz"    ]    )        Ash.Query    .    filter    (    resource    ,         [    first_name    :         "Zar"    ,         last_name    :         [    in    :         [    "Doz"    ,         "Daz"    ]    ]    ,         high_score    :         [    greater_than    :         10    ]    ]    )        Ash.Query    .    filter    (    resource    ,         [    or    :         [    
          [    first_name    :         "Zar"    ]    ,    
          [    last_name    :         "Doz"    ]    ,    
          [    or    :         [    
            [    high_score    :         [    greater_than    :         10    ]    ]    ]    ,    
            [    high_score    :         [    less_than    :         -    10    ]    ]    
          ]        ]    ]    )

### Other formats

Maps are also accepted, as are maps with string keys. Technically, a list of `[{"string_key", value}]` would also work.





# Summary


## **Types** 


t\(\) 




## **Functions** 


add\_to\_filter\(base, addition, op \\\\ :and, aggregates \\\\ %\{\}, calculations \\\\ %\{\}, context \\\\ %\{\}\) 



add\_to\_filter\!\(base, addition, op \\\\ :and, aggregates \\\\ %\{\}, calculations \\\\ %\{\}, context \\\\ %\{\}\) 



builtin\_functions\(\) 



builtin\_operators\(\) 



builtin\_predicate\_operators\(\) 



builtins\(\) 



custom\_expression\(name, args\) 



do\_hydrate\_refs\(filter, context\) 



fetch\_simple\_equality\_predicate\(expression, attribute\) 


Can be used to find a simple equality predicate on an attribute




find\(expr, pred, ors? \\\\ true, ands? \\\\ true, structures? \\\\ false\) 


Find an expression inside of a filter that matches the provided predicate




find\_simple\_equality\_predicate\(expression, attribute\) 


Can be used to find a simple equality predicate on an attribute




find\_value\(expr, pred\) 



flat\_map\(expression, func\) 



get\_filter\(resource, id\) 


Returns a filter statement that would find a single record based on the input.




get\_function\(key, resource, public?\) 



get\_operator\(key\) 



get\_predicate\_function\(key, resource, public?\) 



hydrate\_refs\(value, context\) 



list\_predicates\(expression\) 



list\_refs\(expression, no\_longer\_simple? \\\\ false, in\_an\_eq? \\\\ false, expand\_calculations? \\\\ false, expand\_get\_path? \\\\ false\) 



map\(filter, func\) 



move\_exprs\_to\_relationship\_path\(refs, path\) 



move\_to\_relationship\_path\(expression, relationship\_path\) 



parse\(resource, statement, context \\\\ %\{\}\) 


Parses a filter statement




parse\!\(resource, statement, context \\\\ %\{\}\) 


Parses a filter statement




parse\_input\(resource, statement\) 


Parses a filter statement, accepting *only public attributes/relationships* and honoring field policies & related resource policies, raising on errors.




parse\_input\!\(resource, statement\) 


Parses a filter statement, accepting *only public attributes/relationships* and honoring field policies & related resource policies, raising on errors.




prefix\_refs\(expr, path\) 



put\_at\_path\(value, list\) 



relationship\_paths\(filter\_or\_expression, include\_exists? \\\\ false, with\_refs? \\\\ false, expand\_aggregates? \\\\ false\) 



run\_other\_data\_layer\_filters\(domain, resource, filter, tenant\) 



strict\_subset\_of\(filter, candidate\) 


Returns true if the second argument is a strict subset \(always returns the same or less data\) of the first




strict\_subset\_of?\(filter, candidate\) 



to\_simple\_filter\(map, opts \\\\ \[\]\) 


Transform an expression based filter to a simple filter, which is just a list of predicates




used\_aggregates\(filter, relationship\_path \\\\ \[\], return\_refs? \\\\ false\) 



used\_calculations\(filter, resource, relationship\_path \\\\ \[\], calculations \\\\ %\{\}, aggregates \\\\ %\{\}, return\_refs? \\\\ false\) 



# Types




# t\(\)




    @type     t() :: %Ash.Filter{expression:     term    (), resource:     term    ()}





# Functions




# add\_to\_filter\(base, addition, op \\\\ :and, aggregates \\\\ %\{\}, calculations \\\\ %\{\}, context \\\\ %\{\}\)





# add\_to\_filter\!\(base, addition, op \\\\ :and, aggregates \\\\ %\{\}, calculations \\\\ %\{\}, context \\\\ %\{\}\)





# builtin\_functions\(\)





# builtin\_operators\(\)





# builtin\_predicate\_operators\(\)





# builtins\(\)





# custom\_expression\(name, args\)





# do\_hydrate\_refs\(filter, context\)





# fetch\_simple\_equality\_predicate\(expression, attribute\)




    @spec     fetch_simple_equality_predicate(    Ash.Expr.t    (),     atom    ()) :: {:ok,     term    ()} | :error


Can be used to find a simple equality predicate on an attribute

Use this when your attribute is configured with `filterable? :simple_equality`, and you want to to find the value that it is being filtered on with \(if any\).





# find\(expr, pred, ors? \\\\ true, ands? \\\\ true, structures? \\\\ false\)



Find an expression inside of a filter that matches the provided predicate





# find\_simple\_equality\_predicate\(expression, attribute\)



Can be used to find a simple equality predicate on an attribute

Prefer `fetch_simple_equality_predicate/2`.





# find\_value\(expr, pred\)





# flat\_map\(expression, func\)





# get\_filter\(resource, id\)



Returns a filter statement that would find a single record based on the input.

For example:

    iex>     get_filter    (    MyApp.Post    ,         1    )        {    :ok    ,         %{    id    :         1    }    }         #using primary key        iex>     get_filter    (    MyApp.Post    ,         id    :         1    )        {    :ok    ,         %{    id    :         1    }    }         #using primary key        iex>     get_filter    (    MyApp.Post    ,         author_id    :         1    ,         publication_id    :         2    ,         first_name    :         "fred"    )        {    :ok    ,         %{    author_id    :         1    ,         publication_id    :         1    }    }         # using a unique identity        iex>     get_filter    (    MyApp.Post    ,         first_name    :         "fred"    )        :error         # not enough information





# get\_function\(key, resource, public?\)





# get\_operator\(key\)





# get\_predicate\_function\(key, resource, public?\)





# hydrate\_refs\(value, context\)





# list\_predicates\(expression\)





# list\_refs\(expression, no\_longer\_simple? \\\\ false, in\_an\_eq? \\\\ false, expand\_calculations? \\\\ false, expand\_get\_path? \\\\ false\)





# map\(filter, func\)





# move\_exprs\_to\_relationship\_path\(refs, path\)





# move\_to\_relationship\_path\(expression, relationship\_path\)





# parse\(resource, statement, context \\\\ %\{\}\)



Parses a filter statement

See the module documentation for more information on the supported formats for filter statements.

### ******Important**

If you are trying to validate a filter supplied from an external/untrusted source, be sure to use `parse_input/2` instead\!





# parse\!\(resource, statement, context \\\\ %\{\}\)



Parses a filter statement

See `parse/2` for more





# parse\_input\(resource, statement\)



Parses a filter statement, accepting *only public attributes/relationships* and honoring field policies & related resource policies, raising on errors.

See `parse/2` for more on filter parsing, and the policies guide for more on input references.





# parse\_input\!\(resource, statement\)



Parses a filter statement, accepting *only public attributes/relationships* and honoring field policies & related resource policies, raising on errors.

See `parse_input/2` for more





# prefix\_refs\(expr, path\)





# put\_at\_path\(value, list\)





# relationship\_paths\(filter\_or\_expression, include\_exists? \\\\ false, with\_refs? \\\\ false, expand\_aggregates? \\\\ false\)





# run\_other\_data\_layer\_filters\(domain, resource, filter, tenant\)





# strict\_subset\_of\(filter, candidate\)



Returns true if the second argument is a strict subset \(always returns the same or less data\) of the first





# strict\_subset\_of?\(filter, candidate\)





# to\_simple\_filter\(map, opts \\\\ \[\]\)



Transform an expression based filter to a simple filter, which is just a list of predicates

Options:

+ `:skip_invalid?` \(`boolean/0`\) - If an invalid filter expression is reached that can't be used with a simple filter \(like an `or` statement, or a non-predicate expression\), it will be ignored instead of raising an error. The default value is `false`.





# used\_aggregates\(filter, relationship\_path \\\\ \[\], return\_refs? \\\\ false\)





# used\_calculations\(filter, resource, relationship\_path \\\\ \[\], calculations \\\\ %\{\}, aggregates \\\\ %\{\}, return\_refs? \\\\ false\)





# Ash.Filter.Runtime 

Tools to checks a record to see if it matches a filter statement, or to evalute expressions against records.





# Summary


## **Functions** 


filter\_matches\(domain, records, filter, opts \\\\ \[\]\) 


Removes any records that don't match the filter. Automatically loads if necessary. If there are any ambiguous terms in the filter \(e.g things that could only be determined by data layer\), it is assumed that they are not matches.




old\_get\_related\(records, list, unknown\_on\_unknown\_refs?, join\_filters, parent\_stack, domain\) 



# Functions




# filter\_matches\(domain, records, filter, opts \\\\ \[\]\)



Removes any records that don't match the filter. Automatically loads if necessary. If there are any ambiguous terms in the filter \(e.g things that could only be determined by data layer\), it is assumed that they are not matches.





# old\_get\_related\(records, list, unknown\_on\_unknown\_refs?, join\_filters, parent\_stack, domain\)





# Ash.Filter.Simple 

Represents a simplified filter, with a simple list of predicates





# Ash.Filter.Simple.Not 

A negated predicate





# Ash.ForbiddenField 

Represents a field that was hidden due to authorization rules.





# Summary


## **Types** 


field\_type\(\) 



t\(\) 



# Types




# field\_type\(\)




    @type     field_type() :: :aggregate | :attribute | :calculation | :relationship





# t\(\)




    @type     t() :: %Ash.ForbiddenField{
      field:     atom    (),
      original_value:     term    (),
      type:     field_type    ()
    }





# Ash.Mix.Tasks.Helpers 

Helpers for Ash Mix tasks.





# Summary


## **Functions** 


domains\!\(argv\) 


Get all domains for the current project and ensure they are compiled.




extensions\!\(argv, opts \\\\ \[\]\) 


Gets all extensions in use by the current project's domains and resources




# Functions




# domains\!\(argv\)



Get all domains for the current project and ensure they are compiled.





# extensions\!\(argv, opts \\\\ \[\]\)



Gets all extensions in use by the current project's domains and resources





# Ash.NotLoaded 

Used when a field hasn't been loaded or selected.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.NotLoaded{
      field:     atom    (),
      type: :relationship | :calculation | :aggregate | :attribute
    }





# Ash.OptionsHelpers 

Helpers for working with nimble options





# Summary


## **Functions** 


ash\_resource\(\) 


Used to configure Spark to know that the type referenced is an Ash.Resource also using Spark.




ash\_type\(\) 


Specifies Ash types that can be allowed when declaring a type for an attribute, calculation, aggregate, etc.




calculation\_type\(\) 


Defines the calculation type used in DSL schema definitions, allowing either a calculation module/function or an `expr(...)` expression.




hide\_all\_except\(options, keys\) 


Used for marking an option as hidden so it doesn't show up as an option with Spark.




# Functions




# ash\_resource\(\)




    @spec     ash_resource() :: {:spark, Ash.Resource}


Used to configure Spark to know that the type referenced is an Ash.Resource also using Spark.





# ash\_type\(\)




    @spec     ash_type() ::
      {:spark_type, Ash.Type, :builtins, [{    String.t    (),     String.t    (),     String.t    ()}]}


Specifies Ash types that can be allowed when declaring a type for an attribute, calculation, aggregate, etc.





# calculation\_type\(\)




    @spec     calculation_type() ::     Spark.Options.type    ()


Defines the calculation type used in DSL schema definitions, allowing either a calculation module/function or an `expr(...)` expression.





# hide\_all\_except\(options, keys\)




    @spec     hide_all_except(    Keyword.t    (), [    atom    ()]) ::     Keyword.t    ()


Used for marking an option as hidden so it doesn't show up as an option with Spark.





# Ash.Page 

Types for Ash pages





# Summary


## **Types** 


page\(\) 



type\(\) 



# Types




# page\(\)




    @type     page() ::     Ash.Page.Keyset.t    () |     Ash.Page.Offset.t    ()





# type\(\)




    @type     type() :: :offset | :keyset





# Ash.Page.Keyset 

A page of results from `keyset` based pagination.

The results are generated with a `keyset` metadata, which can be used to fetch the next/previous pages.





# Summary


## **Types** 


page\_opts\(\) 



page\_opts\_opts\(\) 



page\_opts\_type\(\) 



t\(\) 




## **Functions** 


data\_with\_keyset\(results, resource, sort\) 


Appends keyset info to results.




filter\(query, values, sort, after\_or\_before\) 


Creates filters on the query using the query for the Keyset.




new\(results, count, sort, original\_query, more?, opts\) 


Creates a new `Ash.Page.Keyset.t`.




non\_executable\_binary\_to\_term\(binary, opts\) 


A restricted version of `:erlang.binary_to_term/2` that forbids *executable* terms, such as anonymous functions. The `opts` are given to the underlying `:erlang.binary_to_term/2` call, with an empty list as a default. By default this function does not restrict atoms, as an atom interned in one node may not yet have been interned on another \(except for releases, which preload all code\). If you want to avoid atoms from being created, then you can pass `[:safe]` as options, as that will also enable the safety mechanisms from `:erlang.binary_to_term/2` itself. Ripped from https://github.com/elixir-plug/plug\_crypto/blob/v1.2.0/lib/plug/crypto.ex




# Types




# page\_opts\(\)




    @type     page_opts() :: [
      before:     page_opts_opts    (),
      after:     page_opts_opts    (),
      limit:     page_opts_opts    (),
      filter:     page_opts_opts    (),
      count:     page_opts_opts    ()
    ]





# page\_opts\_opts\(\)




    @type     page_opts_opts() :: [type:     page_opts_type    (), doc:     String.t    ()]





# page\_opts\_type\(\)




    @type     page_opts_type() :: :non_neg_integer | :pos_integer | :any | :boolean





# t\(\)




    @type     t() :: %Ash.Page.Keyset{
      after:     binary    () | nil,
      before:     binary    () | nil,
      count:     non_neg_integer    (),
      limit:     pos_integer    (),
      more?:     boolean    (),
      rerun: {    Ash.Query.t    (),     Keyword.t    ()},
      results: [    Ash.Resource.record    ()]
    }





# Functions




# data\_with\_keyset\(results, resource, sort\)




    @spec     data_with_keyset([    Ash.Resource.record    ()],     term    (),     term    ()) :: [
          Ash.Resource.record    ()
    ]


Appends keyset info to results.





# filter\(query, values, sort, after\_or\_before\)




    @spec     filter(    Ash.Query.t    (), [    term    ()],     term    (), :after | :before) ::
      {:ok,     Keyword.t    ()} | {:error,     term    ()}


Creates filters on the query using the query for the Keyset.





# new\(results, count, sort, original\_query, more?, opts\)




    @spec     new(
      [    Ash.Resource.record    ()],
          non_neg_integer    (),
          term    (),
          Ash.Query.t    (),
          boolean    (),
          Keyword.t    ()
    ) ::     t    ()


Creates a new `Ash.Page.Keyset.t`.





# non\_executable\_binary\_to\_term\(binary, opts\)



A restricted version of `:erlang.binary_to_term/2` that forbids *executable* terms, such as anonymous functions. The `opts` are given to the underlying `:erlang.binary_to_term/2` call, with an empty list as a default. By default this function does not restrict atoms, as an atom interned in one node may not yet have been interned on another \(except for releases, which preload all code\). If you want to avoid atoms from being created, then you can pass `[:safe]` as options, as that will also enable the safety mechanisms from `:erlang.binary_to_term/2` itself. Ripped from https://github.com/elixir-plug/plug\_crypto/blob/v1.2.0/lib/plug/crypto.ex





# Ash.Page.Offset 

A page of results from `offset` based pagination.

If a resource supports `keyset` pagination as well, it will also have the `keyset` metadata.





# Summary


## **Types** 


page\_opts\(\) 



page\_opts\_opts\(\) 



page\_opts\_type\(\) 



t\(\) 




## **Functions** 


new\(results, count, original\_query, more?, opts\) 


Creates a new `Ash.Page.Offset.t()`.




# Types




# page\_opts\(\)




    @type     page_opts() :: [
      offset:     page_opts_opts    (),
      limit:     page_opts_opts    (),
      filter:     page_opts_opts    (),
      count:     page_opts_opts    ()
    ]





# page\_opts\_opts\(\)




    @type     page_opts_opts() :: [type:     page_opts_type    (), doc:     String.t    ()]





# page\_opts\_type\(\)




    @type     page_opts_type() :: :non_neg_integer | :pos_integer | :any | :boolean





# t\(\)




    @type     t() :: %Ash.Page.Offset{
      count:     integer    (),
      limit:     integer    (),
      more?:     boolean    (),
      offset:     integer    (),
      rerun: {    Ash.Query.t    (),     Keyword.t    ()},
      results: [    Ash.Resource.record    ()]
    }





# Functions




# new\(results, count, original\_query, more?, opts\)




    @spec     new(
      [    Ash.Resource.record    ()],
          non_neg_integer    (),
          Ash.Query.t    (),
          boolean    (),
          Keyword.t    ()
    ) ::     t    ()


Creates a new `Ash.Page.Offset.t()`.





# Ash.PlugHelpers 

Helpers for working with the Plug connection.





# Summary


## **Functions** 


get\_actor\(arg1\) 


Retrieves the actor from the Plug connection.




get\_context\(arg1\) 


Retrieves the context from the Plug connection.




get\_tenant\(arg1\) 


Retrieves the tenant from the Plug connection.




set\_actor\(conn, actor\) 


Sets the actor inside the Plug connection.




set\_context\(conn, context\) 


Sets the context inside the Plug connection.




set\_tenant\(conn, tenant\) 


Sets the tenant inside the Plug connection.




update\_actor\(conn, callback\) 


Updates the actor inside the Plug connection.




update\_context\(conn, callback\) 


Updates the context inside the Plug connection.




# Functions




# get\_actor\(arg1\)




    @spec     get_actor(    Plug.Conn.t    ()) :: nil |     Ash.Resource.record    ()


Retrieves the actor from the Plug connection.

The actor is stored inside the connection's private fields.

## ******Deprecation warning**

This function checks to see if the actor is already set in the `@actor` assign, and if so will emit a deprecation warning.

This is to allow apps using the previous method a chance to update.

Rather than setting the actor in the assigns, please use the `set_actor/2` method.

## ******Example**

    iex>     actor         =         build_actor    (    %{    email    :         "marty@1985.retro"    }    )        ...>     conn         =         build_conn    (    )         |>         put_private    (    :ash    ,         %{    actor    :         actor    }    )        ...>     actor         =         get_actor    (    conn    )        %{    email    :         "marty@1985.retro"    }         =         actor    
        iex>     actor         =         build_actor    (    %{    email    :         "marty@1985.retro"    }    )        ...>     conn         =         build_conn    (    )         |>         assign    (    :actor    ,         actor    )        ...>     actor         =         get_actor    (    conn    )        %{    email    :         "marty@1985.retro"    }         =         actor





# get\_context\(arg1\)




    @spec     get_context(    Plug.Conn.t    ()) :: nil |     map    ()


Retrieves the context from the Plug connection.

The context is stored inside the connection's private fields.

## ******Example**

    iex>     context         =         %{    fraud_score    :         0.427    }        ...>     conn         =         build_conn    (    )         |>         put_private    (    :ash    ,         %{    context    :         context    }    )        ...>     context         =         get_context    (    conn    )        %{    fraud_score    :         0.427    }





# get\_tenant\(arg1\)




    @spec     get_tenant(    Plug.Conn.t    ()) ::     term    ()


Retrieves the tenant from the Plug connection.

The tenant is stored inside the connection's private fields.

## ******Deprecation warning**

This function checks to see if the tenant is already set in the `@tenant` assign, and if so will emit a deprecation warning.

This is to allow apps using the previous method a chance to update.

Rather than setting the tenant in the assigns, please use the `set_tenant/2` method.

## ******Example**

    iex>     conn         =         build_conn    (    )         |>         put_private    (    :ash    ,         %{    tenant    :         "my-tenant"    }    )        ...>     tenant         =         get_tenant    (    conn    )        "my-tenant"         =         tenant    
        iex>     conn         =         build_conn    (    )         |>         assign    (    :tenant    ,         "my-tenant"    )        ...>     tenant         =         get_tenant    (    conn    )        "my-tenant"         =         tenant





# set\_actor\(conn, actor\)




    @spec     set_actor(    Plug.Conn.t    (),     Ash.Resource.record    ()) ::     Plug.Conn.t    ()


Sets the actor inside the Plug connection.

The actor is stored inside the connection's private fields.

## ******Example**

    iex>     actor         =         build_actor    (    %{    email    :         "marty@1985.retro"    }    )        ...>     conn         =         build_conn    (    )         |>         set_actor    (    actor    )        %    Plug.Conn    {    private    :         %{    ash    :         %{    actor    :         %{    email    :         "marty@1985.retro"    }    }    }    }         =         conn





# set\_context\(conn, context\)




    @spec     set_context(    Plug.Conn.t    (),     map    ()) ::     Plug.Conn.t    ()


Sets the context inside the Plug connection.

Context can be used to store arbitrary data about the user, connection, or anything else you like that doesn't belong as part of the actor or tenant.

The context is stored inside the connection's private fields.

## ******Example**

    iex>     context         =         %{    fraud_score    :         0.427    }        ...>     conn         =         build_conn    (    )         |>         set_context    (    context    )        %    Plug.Conn    {    private    :         %{    ash    :         %{    context    :         %{    fraud_score    :         0.427    }    }    }    }         =         conn





# set\_tenant\(conn, tenant\)




    @spec     set_tenant(    Plug.Conn.t    (),     Ash.ToTenant.t    ()) ::     Plug.Conn.t    ()


Sets the tenant inside the Plug connection.

The tenant is stored inside the connection's private fields.

## ******Example**

    iex>     conn         =         build_conn    (    )         |>         set_tenant    (    "my-tenant"    )        %    Plug.Conn    {    private    :         %{    ash    :         %{    tenant    :         "my-tenant"    }    }    }         =         conn





# update\_actor\(conn, callback\)




    @spec     update_actor(    Plug.Conn.t    (), (nil |     Ash.Resource.record    () ->
                                   nil |     Ash.Resource.record    ())) ::
          Plug.Conn.t    ()


Updates the actor inside the Plug connection.

The actor is stored inside the connection's private fields.

## ******Example**

    iex>     actor         =         build_actor    (    %{    email    :         "marty@1985.retro"    }    )        ...>     conn         =         build_conn    (    )         |>         put_private    (    :ash    ,         %{    actor    :         actor    }    )        ...>     actor         =         get_actor    (    conn    )        %{    email    :         "marty@1985.retro"    }         =         actor        ...>     conn         =         update_actor    (    conn    ,         fn         actor         ->         Map    .    put    (    actor    ,         :name    ,         "Marty Retro"    )         end    )        ...>     actor         =         get_actor    (    conn    )        %{    email    :         "marty@1985.retro"    ,         name    :         "Marty Retro"    }         =         actor        ...>     conn         =         update_actor    (    conn    ,         fn         actor         ->         Map    .    delete    (    actor    ,         :email    )         end    )        ...>     actor         =         get_actor    (    conn    )        %{    name    :         "Marty Retro"    }         =         actor





# update\_context\(conn, callback\)




    @spec     update_context(    Plug.Conn.t    (), (nil |     map    () -> nil |     map    ())) ::     Plug.Conn.t    ()


Updates the context inside the Plug connection.

The context is stored inside the connection's private fields.

## ******Example**

    iex>     context         =         %{    species    :         "Fythetropozoat"    }        ...>     conn         =         build_conn    (    )         |>         put_private    (    :ash    ,         %{    context    :         context    }    )        ...>     context         =         get_context    (    conn    )        %{    fraud_score    :         0.427    }         =         context        ...>     conn         =         update_context    (    conn    ,         fn         context         ->         Map    .    put    (    context    ,         :location    ,         "Barnard's Loop"    )         end    )        ...>     context         =         get_context    (    conn    )        %{    species    :         "Fythetropozoat"    ,         location    :         "Barnard's Loop"    }         =         context        ...>     conn         =         update_context    (    conn    ,         fn         context         ->         Map    .    delete    (    context    ,         :fraud_score    )         end    )        ...>     context         =         get_context    (    conn    )        %{    location    :         "Barnard's Loop"    }         =         context





# Ash.ProcessHelpers 

Helpers for working with processes and Ash actions.





# Summary


## **Functions** 


async\(func, opts\) 


Creates a task that will properly transfer the ash context to the new process




get\_context\_for\_transfer\(opts \\\\ \[\]\) 


Gets all of the ash context so it can be set into a new process.




task\_with\_timeout\(fun, resource, timeout, name, tracer\) 


Creates a task that will properly transfer the ash context to the new process, and timeout if it takes longer than the given timeout




transfer\_context\(tracer\_context, opts \\\\ \[\]\) 



# Functions




# async\(func, opts\)



Creates a task that will properly transfer the ash context to the new process





# get\_context\_for\_transfer\(opts \\\\ \[\]\)




    @spec     get_context_for_transfer(opts ::     Keyword.t    ()) ::     term    ()


Gets all of the ash context so it can be set into a new process.

Use `transfer_context/1` in the new process to set the context.





# task\_with\_timeout\(fun, resource, timeout, name, tracer\)



Creates a task that will properly transfer the ash context to the new process, and timeout if it takes longer than the given timeout





# transfer\_context\(tracer\_context, opts \\\\ \[\]\)




    @spec     transfer_context(    term    (), opts ::     Keyword.t    ()) :: :ok





# Ash.Resource.Builder 

Tools for transforming resources in DSL Transformers.





# Summary


## **Functions** 


add\_action\(dsl\_state, type, name, opts \\\\ \[\]\) 


Builds and adds an action




add\_aggregate\(dsl\_state, name, kind, relationship\_path, opts \\\\ \[\]\) 


Builds and adds an aggregate to a resource




add\_attribute\(dsl\_state, name, type, opts \\\\ \[\]\) 


Builds and adds an attribute to a resource




add\_calculation\(dsl\_state, name, type, calculation, opts \\\\ \[\]\) 


Builds and adds a calculation to a resource




add\_calculation\_interface\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds an calculation interface to a resource




add\_change\(dsl\_state, ref, opts \\\\ \[\]\) 


Builds and adds a change




add\_create\_timestamp\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds a create\_timestamp to a resource




add\_identity\(dsl\_state, name, fields, opts \\\\ \[\]\) 


Builds and adds an identity




add\_interface\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds an interface to a resource




add\_new\_action\(dsl\_state, type, name, opts \\\\ \[\]\) 


Builds and adds a new action unless an action with that name already exists




add\_new\_aggregate\(dsl\_state, name, kind, relationship\_path, opts \\\\ \[\]\) 


Builds and adds an aggregate unless an aggregate with that name already exists




add\_new\_attribute\(dsl\_state, name, type, opts \\\\ \[\]\) 


Builds and adds an attribute unless an attribute with that name already exists




add\_new\_calculation\(dsl\_state, name, type, calculation, opts \\\\ \[\]\) 


Builds and adds a calculation unless a calculation with that name already exists




add\_new\_calculation\_interface\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds an calculation interface unless an calculation interface with that name already exists




add\_new\_create\_timestamp\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds a create\_timestamp unless a create\_timestamp with that name already exists




add\_new\_identity\(dsl\_state, name, fields, opts \\\\ \[\]\) 


Builds and adds a new identity unless an identity with that name already exists




add\_new\_interface\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds an interface unless an interface with that name already exists




add\_new\_relationship\(dsl\_state, type, name, destination, opts \\\\ \[\]\) 


Builds and adds a new relationship unless a relationship with that name already exists




add\_new\_update\_timestamp\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds an update\_timestamp unless an update\_timestamp with that name already exists




add\_preparation\(dsl\_state, ref, opts \\\\ \[\]\) 


Builds and adds a preparation




add\_relationship\(dsl\_state, type, name, destination, opts \\\\ \[\]\) 


Builds and adds an action




add\_update\_timestamp\(dsl\_state, name, opts \\\\ \[\]\) 


Builds and adds an update\_timestamp




build\_action\(type, name, opts \\\\ \[\]\) 


Builds an action




build\_action\_argument\(name, type, opts \\\\ \[\]\) 


Builds an action argument




build\_action\_change\(change, opts \\\\ \[\]\) 


Builds an action change




build\_action\_metadata\(name, type, opts \\\\ \[\]\) 


Builds an action metadata




build\_action\_validation\(validation, opts \\\\ \[\]\) 


Builds an action validation




build\_aggregate\(name, kind, relationship\_path, opts \\\\ \[\]\) 


Builds a calculation with the given name, type, and options




build\_attribute\(name, type, opts \\\\ \[\]\) 


Builds an attribute with the given name, type, and options




build\_calculation\(name, type, calculation, opts \\\\ \[\]\) 


Builds a calculation with the given name, type, and options




build\_calculation\_argument\(name, type, opts \\\\ \[\]\) 


Builds a calculation argument




build\_calculation\_interface\(name, opts \\\\ \[\]\) 


Builds an calculation interface with the given name, type, and options




build\_change\(ref, opts \\\\ \[\]\) 


Builds a change




build\_create\_timestamp\(name, opts \\\\ \[\]\) 


Builds an create\_timestamp with the given name, type, and options




build\_identity\(name, fields, opts \\\\ \[\]\) 


Builds an action




build\_interface\(name, opts \\\\ \[\]\) 


Builds an interface with the given name, type, and options




build\_pagination\(opts \\\\ \[\]\) 


Builds a pagination object




build\_preparation\(ref, opts \\\\ \[\]\) 


Builds a preparation




build\_relationship\(type, name, destination, opts \\\\ \[\]\) 


Builds a relationship




build\_update\_timestamp\(name, opts \\\\ \[\]\) 


Builds an update\_timestamp with the given name, type, and options




prepend\_action\(dsl\_state, type, name, opts \\\\ \[\]\) 


Builds and adds an action to the front of the actions list




# Functions




# add\_action\(dsl\_state, type, name, opts \\\\ \[\]\)




    @spec     add_action(
          Spark.Dsl.Builder.input    (),
      type ::     Ash.Resource.Actions.action_type    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an action





# add\_aggregate\(dsl\_state, name, kind, relationship\_path, opts \\\\ \[\]\)




    @spec     add_aggregate(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      kind ::     Ash.Query.Aggregate.kind    (),
      relationship_path ::     atom    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an aggregate to a resource





# add\_attribute\(dsl\_state, name, type, opts \\\\ \[\]\)




    @spec     add_attribute(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      type ::     Ash.Type.t    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an attribute to a resource





# add\_calculation\(dsl\_state, name, type, calculation, opts \\\\ \[\]\)




    @spec     add_calculation(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      type ::     Ash.Type.t    (),
      calculation ::     module    () | {    module    (),     Keyword.t    ()},
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a calculation to a resource





# add\_calculation\_interface\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_calculation_interface(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an calculation interface to a resource





# add\_change\(dsl\_state, ref, opts \\\\ \[\]\)




    @spec     add_change(
          Spark.Dsl.Builder.input    (),
      ref ::     module    () | {    module    (),     Keyword.t    ()},
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a change





# add\_create\_timestamp\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_create_timestamp(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a create\_timestamp to a resource





# add\_identity\(dsl\_state, name, fields, opts \\\\ \[\]\)




    @spec     add_identity(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      fields ::     atom    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an identity





# add\_interface\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_interface(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an interface to a resource





# add\_new\_action\(dsl\_state, type, name, opts \\\\ \[\]\)




    @spec     add_new_action(
          Spark.Dsl.Builder.input    (),
      type ::     Ash.Resource.Actions.action_type    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a new action unless an action with that name already exists





# add\_new\_aggregate\(dsl\_state, name, kind, relationship\_path, opts \\\\ \[\]\)




    @spec     add_new_aggregate(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      kind ::     Ash.Query.Aggregate.kind    (),
      relationship_path ::     atom    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an aggregate unless an aggregate with that name already exists





# add\_new\_attribute\(dsl\_state, name, type, opts \\\\ \[\]\)




    @spec     add_new_attribute(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      type ::     Ash.Type.t    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an attribute unless an attribute with that name already exists





# add\_new\_calculation\(dsl\_state, name, type, calculation, opts \\\\ \[\]\)




    @spec     add_new_calculation(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      type ::     Ash.Type.t    (),
      calculation ::     module    () | {    module    (),     Keyword.t    ()} |     Ash.Expr.t    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a calculation unless a calculation with that name already exists





# add\_new\_calculation\_interface\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_new_calculation_interface(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an calculation interface unless an calculation interface with that name already exists





# add\_new\_create\_timestamp\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_new_create_timestamp(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::
          Spark.Dsl.Builder.result    ()


Builds and adds a create\_timestamp unless a create\_timestamp with that name already exists





# add\_new\_identity\(dsl\_state, name, fields, opts \\\\ \[\]\)




    @spec     add_new_identity(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      fields ::     atom    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a new identity unless an identity with that name already exists





# add\_new\_interface\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_new_interface(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an interface unless an interface with that name already exists





# add\_new\_relationship\(dsl\_state, type, name, destination, opts \\\\ \[\]\)




    @spec     add_new_relationship(
          Spark.Dsl.Builder.input    (),
      type ::     Ash.Resource.Relationships.type    (),
      name ::     atom    (),
      destination ::     module    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a new relationship unless a relationship with that name already exists





# add\_new\_update\_timestamp\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_new_update_timestamp(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::
          Spark.Dsl.Builder.result    ()


Builds and adds an update\_timestamp unless an update\_timestamp with that name already exists





# add\_preparation\(dsl\_state, ref, opts \\\\ \[\]\)




    @spec     add_preparation(
          Spark.Dsl.Builder.input    (),
      ref ::     module    () | {    module    (),     Keyword.t    ()},
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds a preparation





# add\_relationship\(dsl\_state, type, name, destination, opts \\\\ \[\]\)




    @spec     add_relationship(
          Spark.Dsl.Builder.input    (),
      type ::     Ash.Resource.Relationships.type    (),
      name ::     atom    (),
      destination ::     module    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an action





# add\_update\_timestamp\(dsl\_state, name, opts \\\\ \[\]\)




    @spec     add_update_timestamp(
          Spark.Dsl.Builder.input    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::
          Spark.Dsl.Builder.result    ()


Builds and adds an update\_timestamp





# build\_action\(type, name, opts \\\\ \[\]\)




    @spec     build_action(
      type ::     Ash.Resource.Actions.action_type    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Actions.action    ()} | {:error,     term    ()}


Builds an action





# build\_action\_argument\(name, type, opts \\\\ \[\]\)




    @spec     build_action_argument(name ::     atom    (), type ::     Ash.Type.t    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Actions.Argument.t    ()} | {:error,     term    ()}


Builds an action argument





# build\_action\_change\(change, opts \\\\ \[\]\)




    @spec     build_action_change(change ::     Ash.Resource.Change.ref    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Change.t    ()} | {:error,     term    ()}


Builds an action change





# build\_action\_metadata\(name, type, opts \\\\ \[\]\)




    @spec     build_action_metadata(name ::     atom    (), type ::     Ash.Type.t    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Actions.Metadata.t    ()} | {:error,     term    ()}


Builds an action metadata





# build\_action\_validation\(validation, opts \\\\ \[\]\)




    @spec     build_action_validation(
      change ::     Ash.Resource.Validation.ref    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.Validation.t    ()} | {:error,     term    ()}


Builds an action validation





# build\_aggregate\(name, kind, relationship\_path, opts \\\\ \[\]\)




    @spec     build_aggregate(
      name ::     atom    (),
      kind ::     Ash.Query.Aggregate.kind    (),
      relationship_path ::     atom    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Aggregate.t    ()} | {:error,     term    ()}


Builds a calculation with the given name, type, and options





# build\_attribute\(name, type, opts \\\\ \[\]\)




    @spec     build_attribute(name ::     atom    (), type ::     Ash.Type.t    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Attribute.t    ()} | {:error,     term    ()}


Builds an attribute with the given name, type, and options





# build\_calculation\(name, type, calculation, opts \\\\ \[\]\)




    @spec     build_calculation(
      name ::     atom    (),
      type ::     Ash.Type.t    (),
      calculation ::     module    () | {    module    (),     Keyword.t    ()},
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Calculation.t    ()} | {:error,     term    ()}


Builds a calculation with the given name, type, and options





# build\_calculation\_argument\(name, type, opts \\\\ \[\]\)




    @spec     build_calculation_argument(
      name ::     atom    (),
      type ::     Ash.Type.t    (),
      opts ::     Keyword.t    ()
    ) ::
      {:ok,     Ash.Resource.Calculation.Argument.t    ()} | {:error,     term    ()}


Builds a calculation argument





# build\_calculation\_interface\(name, opts \\\\ \[\]\)




    @spec     build_calculation_interface(name ::     atom    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.CalculationInterface.t    ()} | {:error,     term    ()}


Builds an calculation interface with the given name, type, and options





# build\_change\(ref, opts \\\\ \[\]\)




    @spec     build_change(
      ref ::     module    () | {    module    (),     Keyword.t    ()},
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Change.t    ()} | {:error,     term    ()}


Builds a change





# build\_create\_timestamp\(name, opts \\\\ \[\]\)




    @spec     build_create_timestamp(name ::     atom    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Attribute.t    ()} | {:error,     term    ()}


Builds an create\_timestamp with the given name, type, and options





# build\_identity\(name, fields, opts \\\\ \[\]\)




    @spec     build_identity(
      name ::     atom    (),
      fields ::     atom    () | [    atom    ()],
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Identity.t    ()} | {:error,     term    ()}


Builds an action





# build\_interface\(name, opts \\\\ \[\]\)




    @spec     build_interface(name ::     atom    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Interface.t    ()} | {:error,     term    ()}


Builds an interface with the given name, type, and options





# build\_pagination\(opts \\\\ \[\]\)




    @spec     build_pagination(pts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Actions.Read.Pagination.t    ()} | {:error,     term    ()}


Builds a pagination object





# build\_preparation\(ref, opts \\\\ \[\]\)




    @spec     build_preparation(
      ref ::     module    () | {    module    (),     Keyword.t    ()},
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Preparation.t    ()} | {:error,     term    ()}


Builds a preparation





# build\_relationship\(type, name, destination, opts \\\\ \[\]\)




    @spec     build_relationship(
      type ::     Ash.Resource.Relationships.type    (),
      name ::     atom    (),
      destination ::     module    (),
      opts ::     Keyword.t    ()
    ) :: {:ok,     Ash.Resource.Relationships.relationship    ()} | {:error,     term    ()}


Builds a relationship





# build\_update\_timestamp\(name, opts \\\\ \[\]\)




    @spec     build_update_timestamp(name ::     atom    (), opts ::     Keyword.t    ()) ::
      {:ok,     Ash.Resource.Attribute.t    ()} | {:error,     term    ()}


Builds an update\_timestamp with the given name, type, and options





# prepend\_action\(dsl\_state, type, name, opts \\\\ \[\]\)




    @spec     prepend_action(
          Spark.Dsl.Builder.input    (),
      type ::     Ash.Resource.Actions.action_type    (),
      name ::     atom    (),
      opts ::     Keyword.t    ()
    ) ::     Spark.Dsl.Builder.result    ()


Builds and adds an action to the front of the actions list





# Ash.SatSolver 

Tools for working with the satsolver that drives filter subset checking \(for authorization\)

This is public as a very low level toolkit for writing authorizers, but you almost certainly do not need to look at this module.

If you are looking for information about how authorization works, see the policy guide





# Summary


## **Functions** 


b\(statement\) 


Creates tuples of a boolean statement.




left\_excludes\_right\(left, right\) 


Returns `b(not (left and right))`




left\_implies\_right\(left, right\) 


Returns `b(not (left and not right))`




mutually\_exclusive\(predicates, acc \\\\ \[\]\) 


Returns a statement expressing that the predicates are mutually exclusive.




mutually\_exclusive\_and\_collectively\_exhaustive\(predicates\) 


Returns a statement expressing that the predicates are mutually exclusive and collectively exhaustive.




mutually\_inclusive\(predicates, acc \\\\ \[\]\) 


Returns a statement expressing that the predicates are mutually inclusive




right\_excludes\_left\(left, right\) 


Returns `b(not (right and left))`




right\_implies\_left\(left, right\) 


Returns `b(not (right and not left))`




strict\_filter\_subset\(filter, candidate\) 


Returns true if the candidate filter returns the same or less data than the filter




synonymous\_relationship\_paths?\(left\_resource, candidate, search, right\_resource \\\\ nil\) 


Returns `true` if the relationship paths are synonymous from a data perspective




to\_cnf\(expression\) 


Transforms a statement to Conjunctive Normal Form\(CNF\), as lists of lists of integers.




transform\(resource, expression\) 


Prepares a filter for comparison




transform\_and\_solve\(resource, expression\) 


Calls `transform/2` and solves the expression




# Functions




# b\(statement\)
\(macro\)   


Creates tuples of a boolean statement.

i.e `b(1 and 2) #=> {:and, 1, 2}`





# left\_excludes\_right\(left, right\)




    @spec     left_excludes_right(    Ash.Expr.t    (),     Ash.Expr.t    ()) :: boolean_expr()


Returns `b(not (left and right))`





# left\_implies\_right\(left, right\)



Returns `b(not (left and not right))`





# mutually\_exclusive\(predicates, acc \\\\ \[\]\)



Returns a statement expressing that the predicates are mutually exclusive.





# mutually\_exclusive\_and\_collectively\_exhaustive\(predicates\)




    @spec     mutually_exclusive_and_collectively_exhaustive([    Ash.Expr.t    ()]) :: boolean_expr()


Returns a statement expressing that the predicates are mutually exclusive and collectively exhaustive.





# mutually\_inclusive\(predicates, acc \\\\ \[\]\)



Returns a statement expressing that the predicates are mutually inclusive





# right\_excludes\_left\(left, right\)




    @spec     right_excludes_left(    Ash.Expr.t    (),     Ash.Expr.t    ()) :: boolean_expr()


Returns `b(not (right and left))`





# right\_implies\_left\(left, right\)




    @spec     right_implies_left(    Ash.Expr.t    (),     Ash.Expr.t    ()) :: boolean_expr()


Returns `b(not (right and not left))`





# strict\_filter\_subset\(filter, candidate\)




    @spec     strict_filter_subset(    Ash.Filter.t    (),     Ash.Filter.t    ()) ::     boolean    () | :maybe


Returns true if the candidate filter returns the same or less data than the filter





# synonymous\_relationship\_paths?\(left\_resource, candidate, search, right\_resource \\\\ nil\)




    @spec     synonymous_relationship_paths?(
          Ash.Resource.t    (),
      [    atom    ()],
      [    atom    ()],
          Ash.Resource.t    ()
    ) ::
          boolean    ()


Returns `true` if the relationship paths are synonymous from a data perspective





# to\_cnf\(expression\)



Transforms a statement to Conjunctive Normal Form\(CNF\), as lists of lists of integers.





# transform\(resource, expression\)




    @spec     transform(    Ash.Resource.t    (),     Ash.Expr.t    ()) :: boolean_expr()


Prepares a filter for comparison





# transform\_and\_solve\(resource, expression\)




    @spec     transform_and_solve(    Ash.Resource.t    (),     Ash.Expr.t    ()) ::
      {:ok, [    integer    ()]} | {:error, :unsatisfiable}


Calls `transform/2` and solves the expression





# Ash.Sort 

Utilities and types for sorting.





# Summary


## **Types** 


sort\_item\(\) 



sort\_order\(\) 



t\(\) 




## **Functions** 


expr\_sort\(expression, type \\\\ nil\) 


Builds an expression to be used in a sort statement. Prefer to use `Ash.Expr.calc/2` instead.




parse\_input\(resource, sort, handler \\\\ nil\) 


A utility for parsing sorts provided from external input. Only allows sorting on public fields.




parse\_input\!\(resource, sort, handler \\\\ nil\) 


Same as `parse_input/2` except raises any errors




parse\_sort\(resource, sort, handler \\\\ nil, public\_only? \\\\ true\) 



reverse\(sort\) 


Reverses an Ash sort statement.




runtime\_sort\(results, sort, opts \\\\ \[\]\) 


A utility for sorting a list of records at runtime.




# Types




# sort\_item\(\)




    @type     sort_item() ::
          String.t    ()
      |     atom    ()
      | {    atom    (),     sort_order    ()}
      | %Ash.Query.Calculation{
          async?:     term    (),
          calc_name:     term    (),
          constraints:     term    (),
          context:     term    (),
          filterable?:     term    (),
          load:     term    (),
          module:     term    (),
          name:     term    (),
          opts:     term    (),
          required_loads:     term    (),
          select:     term    (),
          sensitive?:     term    (),
          sortable?:     term    (),
          type:     term    ()
        }
      | {%Ash.Query.Calculation{
           async?:     term    (),
           calc_name:     term    (),
           constraints:     term    (),
           context:     term    (),
           filterable?:     term    (),
           load:     term    (),
           module:     term    (),
           name:     term    (),
           opts:     term    (),
           required_loads:     term    (),
           select:     term    (),
           sensitive?:     term    (),
           sortable?:     term    (),
           type:     term    ()
         },     sort_order    ()}
      | {    atom    (), {    Keyword.t    () |     map    (),     sort_order    ()}}





# sort\_order\(\)




    @type     sort_order() ::
      :asc
      | :desc
      | :asc_nils_first
      | :asc_nils_last
      | :desc_nils_first
      | :desc_nils_last





# t\(\)




    @type     t() :: [    sort_item    ()] |     sort_item    ()





# Functions




# expr\_sort\(expression, type \\\\ nil\)
\(macro\)   



    @spec     expr_sort(    Ash.Expr.t    (),     Ash.Type.t    () | nil) ::     Ash.Expr.t    ()


Builds an expression to be used in a sort statement. Prefer to use `Ash.Expr.calc/2` instead.

For example:

    Ash.Query    .    sort    (    query    ,         Ash.Sort    .    expr_sort    (    author    .    full_name    ,         :string    )    )    
        Ash.Query    .    sort    (    query    ,         [    {    Ash.Sort    .    expr_sort    (    author    .    full_name    ,         :string    )    ,         :desc_nils_first    }    ]    )





# parse\_input\(resource, sort, handler \\\\ nil\)




    @spec     parse_input(
          Ash.Resource.t    (),
          String.t    ()
      | [    atom    () |     String.t    () | {    atom    (),     sort_order    ()} | [    String.t    ()]]
      | nil,
      nil | (    String.t    () -> nil |     atom    () | {    atom    (),     map    ()})
    ) :: {:ok,     t    ()} | {:error,     term    ()}


A utility for parsing sorts provided from external input. Only allows sorting on public fields.

See `Ash.Query.sort/3` for supported formats.

## ******Handling specific values**

A handler function may be provided that takes a string, and returns the relevant sort It won't be given any prefixes, only the field. This allows for things like parsing the calculation values out of the sort, or setting calculation values if they are not included in the sort string.

To return calculation parameters, return `{:field, %{param: :value}}`. This will end up as something like `{:field, {%{param: :value}, :desc}}`, with the corresponding sort order.

This handler function will only be called if you pass in a string or list of strings for the sort. Atoms will be assumed to have already been handled. The handler should return `nil` if it is not handling the given field.





# parse\_input\!\(resource, sort, handler \\\\ nil\)



Same as `parse_input/2` except raises any errors

See `parse_input/2` for more.





# parse\_sort\(resource, sort, handler \\\\ nil, public\_only? \\\\ true\)





# reverse\(sort\)



Reverses an Ash sort statement.





# runtime\_sort\(results, sort, opts \\\\ \[\]\)



A utility for sorting a list of records at runtime.

For example:

    Ash.Sort    .    runtime_sort    (    [    record1    ,         record2    ,         record3    ]    ,         name    :         :asc    ,         type    :         :desc_nils_last    )

Keep in mind that it is unrealistic to expect this runtime sort to always be exactly the same as a sort that may have been applied by your data layer. This is especially true for strings. For example, `Postgres` strings have a collation that affects their sorting, making it unpredictable from the perspective of a tool using the database: https://www.postgresql.org/docs/current/collation.html





# Ash.UUID 

Helpers for working with UUIDs





# Summary


## **Types** 


raw\(\) 


A raw binary representation of a UUID.




t\(\) 


A hex-encoded UUID string.





## **Functions** 


generate\(\) 


Generates a new uuid




# Types




# raw\(\)




    @type     raw() ::     Ecto.UUID.raw    ()


A raw binary representation of a UUID.





# t\(\)




    @type     t() ::     Ecto.UUID.t    ()


A hex-encoded UUID string.





# Functions




# generate\(\)




    @spec     generate() ::     Ecto.UUID.t    ()


Generates a new uuid





# Ash.UUIDv7 

Helpers for working with UUIDs version 7.

RFC 9562

Used for generating UUIDs version 7 with increased clock precision for better monotonicity, as described by method 3 of the \[Section 6.2\]\(https://www.rfc-editor.org/rfc/rfc9562\#name-monotonicity-and-counters

Inspired by the work of Ryan Winchester on uuidv7

## Examples

    iex>     UUIDv7    .    generate    (    )        "018e90d8-06e8-7f9f-bfd7-6730ba98a51b"    
        iex>     UUIDv7    .    bingenerate    (    )        <<    1    ,         142    ,         144    ,         216    ,         6    ,         232    ,         127    ,         159    ,         191    ,         215    ,         103    ,         48    ,         186    ,         152    ,         165    ,         27    >>





# Summary


## **Types** 


raw\(\) 


A raw binary representation of a UUID.




t\(\) 


A hex-encoded UUID string.





## **Functions** 


bingenerate\(\) 


Generates a version 7 UUID in the binary format.




decode\(raw\_uuid\) 


Decode a string representation of a UUID to the raw binary version.




encode\(hex\_uuid\) 


Encode a raw UUID to the string representation.




extract\_timestamp\(uuid\) 


Extract the millisecond timestamp from the UUID.




generate\(\) 


Generates a version 7 UUID using submilliseconds for increased clock precision.




# Types




# raw\(\)




    @type     raw() :: <<_::128>>


A raw binary representation of a UUID.





# t\(\)




    @type     t() :: <<_::288>>


A hex-encoded UUID string.





# Functions




# bingenerate\(\)




    @spec     bingenerate() ::     raw    ()


Generates a version 7 UUID in the binary format.

## ******Example**

    iex>     UUIDv7    .    bingenerate    (    )        <<    1    ,         142    ,         144    ,         216    ,         6    ,         232    ,         127    ,         159    ,         191    ,         215    ,         103    ,         48    ,         186    ,         152    ,         165    ,         27    >>





# decode\(raw\_uuid\)




    @spec     decode(    t    () |     raw    ()) ::     raw    () | :error


Decode a string representation of a UUID to the raw binary version.

## ******Example**

    iex>     UUIDv7    .    decode    (    "018e90d8-06e8-7f9f-bfd7-6730ba98a51b"    )        <<    1    ,         142    ,         144    ,         216    ,         6    ,         232    ,         127    ,         159    ,         191    ,         215    ,         103    ,         48    ,         186    ,         152    ,         165    ,         27    >>





# encode\(hex\_uuid\)




    @spec     encode(    t    () |     raw    ()) ::     t    () | :error


Encode a raw UUID to the string representation.

## ******Example**

    iex>     UUIDv7    .    encode    (    <<    1    ,         142    ,         144    ,         216    ,         6    ,         232    ,         127    ,         159    ,         191    ,         215    ,         103    ,         48    ,         186    ,         152    ,         165    ,         27    >>    )        "018e90d8-06e8-7f9f-bfd7-6730ba98a51b"





# extract\_timestamp\(uuid\)




    @spec     extract_timestamp(    t    () |     raw    ()) ::     integer    ()


Extract the millisecond timestamp from the UUID.

## ******Example**

    iex>     UUIDv7    .    extract_timestamp    (    "018ecb40-c457-73e6-a400-000398daddd9"    )        1712807003223





# generate\(\)




    @spec     generate() ::     t    ()


Generates a version 7 UUID using submilliseconds for increased clock precision.

## ******Example**

    iex>     UUIDv7    .    generate    (    )        "018e90d8-06e8-7f9f-bfd7-6730ba98a51b"





# Ash.Union 

A wrapper for values that are sourced from `Ash.Type.Union`.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Union{type:     term    (), value:     term    ()}





# Ash.Vector 

A vector struct for Ash.

Implementation based off of https://github.com/pgvector/pgvector-elixir/blob/v0.2.0/lib/pgvector.ex





# Summary


## **Types** 


t\(\) 




## **Functions** 


from\_binary\(binary\) 


Creates a new vector from its binary representation




new\(vector\) 


Creates a new vector from a list or tensor




to\_binary\(vector\) 


Converts the vector to its binary representation




to\_list\(vector\) 


Converts the vector to a list




# Types




# t\(\)




    @type     t() :: %Ash.Vector{data:     binary    (), dimensions:     pos_integer    ()}





# Functions




# from\_binary\(binary\)




    @spec     from_binary(    binary    ()) ::     t    ()


Creates a new vector from its binary representation





# new\(vector\)




    @spec     new(    t    () |     binary    () | [    integer    ()]) :: {:ok,     t    ()} | {:error, :invalid_vector}


Creates a new vector from a list or tensor





# to\_binary\(vector\)




    @spec     to_binary(    t    ()) ::     binary    ()


Converts the vector to its binary representation





# to\_list\(vector\)




    @spec     to_list(    t    ()) ::     list    ()


Converts the vector to a list





# Ash.Type **behaviour** 

The `Ash.Type` behaviour is used to define a value type in Ash.

## Built in types

+ `:map` - `Ash.Type.Map`
+ `:keyword` - `Ash.Type.Keyword`
+ `:term` - `Ash.Type.Term`
+ `:atom` - `Ash.Type.Atom`
+ `:tuple` - `Ash.Type.Tuple`
+ `:string` - `Ash.Type.String`
+ `:integer` - `Ash.Type.Integer`
+ `:file` - `Ash.Type.File`
+ `:float` - `Ash.Type.Float`
+ `:duration_name` - `Ash.Type.DurationName`
+ `:function` - `Ash.Type.Function`
+ `:boolean` - `Ash.Type.Boolean`
+ `:struct` - `Ash.Type.Struct`
+ `:uuid` - `Ash.Type.UUID`
+ `:uuid_v7` - `Ash.Type.UUIDv7`
+ `:binary` - `Ash.Type.Binary`
+ `:date` - `Ash.Type.Date`
+ `:time` - `Ash.Type.Time`
+ `:time_usec` - `Ash.Type.TimeUsec`
+ `:decimal` - `Ash.Type.Decimal`
+ `:ci_string` - `Ash.Type.CiString`
+ `:naive_datetime` - `Ash.Type.NaiveDatetime`
+ `:utc_datetime` - `Ash.Type.UtcDatetime`
+ `:utc_datetime_usec` - `Ash.Type.UtcDatetimeUsec`
+ `:datetime` - `Ash.Type.DateTime`
+ `:duration` - `Ash.Type.Duration`
+ `:url_encoded_binary` - `Ash.Type.UrlEncodedBinary`
+ `:union` - `Ash.Type.Union`
+ `:module` - `Ash.Type.Module`
+ `:vector` - `Ash.Type.Vector`

## Lists/Arrays

To specify a list of values, use `{:array, Type}`. Arrays are special, and have special constraints:

+ 
`:items` \(`term/0`\) - Constraints for the elements of the list. See the contained type's docs for more.

+ 
`:min_length` \(`non_neg_integer/0`\) - A minimum length for the items.

+ 
`:max_length` \(`non_neg_integer/0`\) - A maximum length for the items.

+ 
`:nil_items?` \(`boolean/0`\) - Whether or not the list can contain nil items. The default value is `false`.

+ 
`:remove_nil_items?` \(`boolean/0`\) - Whether or not to remove the nil items from the list instead of adding errors. The default value is `false`.

+ 
`:empty_values` \(list of `term/0`\) - A set of values that, if encountered, will be considered an empty list. The default value is `[""]`.


## Defining Custom Types

Generally you add `use Ash.Type` to your module \(it is possible to add `@behaviour Ash.Type` and define everything yourself, but this is more work and error-prone\).

Another option is to use `Ash.Type.NewType`, which supports defining a new type that is the combination of an existing type and custom constraints. This can be helpful when defining a custom attribute \(e.g. struct\) for a resource.

Simple example of a float custom type

    defmodule         GenTracker.AshFloat         do    
          use         Ash.Type    

          @impl         Ash.Type    
          def         storage_type    (    _    )    ,         do    :         :float    

          @impl         Ash.Type    
          def         cast_input    (    nil    ,         _    )    ,         do    :         {    :ok    ,         nil    }    
          def         cast_input    (    value    ,         _    )         do    
            Ecto.Type    .    cast    (    :float    ,         value    )    
          end    

          @impl         Ash.Type    
          def         cast_stored    (    nil    ,         _    )    ,         do    :         {    :ok    ,         nil    }    
          def         cast_stored    (    value    ,         _    )         do    
            Ecto.Type    .    load    (    :float    ,         value    )    
          end    

          @impl         Ash.Type    
          def         dump_to_native    (    nil    ,         _    )    ,         do    :         {    :ok    ,         nil    }    
          def         dump_to_native    (    value    ,         _    )         do    
            Ecto.Type    .    dump    (    :float    ,         value    )    
          end        end

### Overriding the **`{:array, type}`** behaviour

By defining the `*_array` versions of `cast_input`, `cast_stored`, `dump_to_native` and `apply_constraints`, you can override how your type behaves as a collection. This is how the features of embedded resources are implemented. No need to implement them unless you wish to override the default behaviour. Your type is responsible for handling nil values in each callback as well.

All the Ash built-in types are implemented with `use Ash.Type` so they are good examples to look at to create your own `Ash.Type`.

### Short names

You can define short `:atom_names` for your custom types by adding them to your Ash configuration:

    config         :ash    ,         :custom_types    ,         [    ash_float    :         GenTracker.AshFloat    ]

Doing this will require a recompilation of the `:ash` dependency which can be triggered by calling:

    $     mix deps.compile ash --force

## Composite Types

Composite types are composite *in the data layer*. Many data layers do not support this, but some \(like AshPostgres\), do. To define a composite type, the following things should be true:

1. A casted value should be a map or struct, for example for a point: `%{x: 1, y: 2}`
2. The data layer must support composite types, and the data layer representation will be a tuple, i.e `{1, 2}`
3. Define `def composite?(_), do: true` in your composite type
4. Define the type & constraints of each item in the tuple, and its name in the map representation: `def composite_types(_), do: [{:x, :integer, []}, {:y, :integer, []}]`. You can also define a storage key for each item in the tuple, if the underlying type implementation has a different reference for an item, i.e `def composite_types(_), do: [{:x, :x_coord, :integer, []}, {:y, :y_coord, :integer, []}]`

With the above implemented, your composite type can be used in expressions, for example:

    Ash.Query    .    filter    (    expr    (    coordinates    [    :x    ]         ==         1    )    )

And you can also *construct* composite types in expressions, for example:

    calculate         :coordinates    ,         :composite_point    ,         expr    (    
          composite_type    (    %{    x    :         some_value    ,         y    :         some_other_value    }    ,         Point    )        )

## Constraints

Constraints are a way of validating an input type. This validation can be used in both attributes and arguments. The kinds of constraints you can apply depends on the type of data. You can find all types in `Ash.Type` . Each type has its own page on which the available constraints are listed. For example in `Ash.Type.String` you can find 5 constraints:

+ `:max_length`
+ `:min_length`
+ `:match`
+ `:trim?`
+ `:allow_empty?`

You can also discover these constraints from iex:

    $     iex -S mix    iex(1)> Ash.Type.String.constraints    [      max_length: [        type: :non_neg_integer,        doc: "Enforces a maximum length on the value"      ],      min_length: [        type: :non_neg_integer,        doc: "Enforces a minimum length on the value"      ],      match: [        type: :regex_as_mfa,        doc: "Enforces that the string matches a passed in regex"      ],      trim?: [type: :boolean, doc: "Trims the value.", default: true],      allow_empty?: [        type: :boolean,        doc: "If false, the value is set to `nil` if it's empty.",        default: false      ]    ]

### Attribute example

To show how constraints can be used in a attribute, here is an example attribute describing a username:

    defmodule         MyProject.MyDomain.Account         do    
          # ...    

          code_interface         do    
            define         :create    ,         action    :         :create    
          end    

          actions         do    
            default         [    :create    ,         :read    ,         :update    ,         :destroy    ]    
          end    

          attributes         do    
            uuid_primary_key         :id    

            attribute         :username    ,         :string         do    
              constraints         [    
                max_length    :         20    ,    
                min_length    :         3    ,    
                match    :         "^[a-z_-]*$"    ,    
                trim?    :         true    ,    
                allow_empty?    :         false    
              ]    
            end    
          end    

          # ...        end

If, when creating or updating this attribute, one of the constraints are not met, an error will be given telling you which constraint was broken. See below:

    iex(1)>     MyProject.MyDomain.Account    .    create!    (    %{    username    :         "hi"    }    )    
        ** (Ash.Error.Invalid) Invalid Error    
        *         Invalid         value         provided         for         username    :         length         must         be         greater         than         or         equal         to         3    .    
        "hi"    
        iex(2)>     MyProject.MyDomain.Account    .    create!    (    %{    username    :         "Hello there this is a long string"    }    )    
        ** (Ash.Error.Invalid) Invalid Error    
        *         Invalid         value         provided         for         username    :         length         must         be         less         than         or         equal         to         20    .    
        "Hello there this is a long string"    
        iex(3)>     MyProject.MyDomain.Account    .    create!    (    %{    username    :         "hello there"    }    )        ** (Ash.Error.Invalid) Invalid Error    
        *         Invalid         value         provided         for         username    :         must         match         the         pattern         ~r/^[a-z_-]*$/    .    
        "hello there"    
        iex(4)>     MyProject.MyDomain.Account    .    create!    (    %{    username    :         ""    }    )        ** (Ash.Error.Invalid) Invalid Error    
        *         attribute         title         is         required

It will give you the resource as usual on successful requests:

    iex(5)>     MyProject.MyDomain.Account    .    create!    (    %{    username    :         "hello"    }    )        #    MyProject.MyDomain.Account    <    
          __meta__    :         #    Ecto.Schema.Metadata    <    :loaded    ,         "account"    >    ,    
          id    :         "7ba467dd-277c-4916-88ae-f62c93fee7a3"    ,    
          username    :         "hello"    ,    
          ...        >





# Summary


## **Types** 


constraints\(\) 


A keyword list of constraints for a type




error\(\) 


An error value that can be returned from various callbacks




load\_context\(\) 


The context that is provided to the `load/4` callback.




merge\_load\_context\(\) 


The context that is provided to the `merge_load/4` callback.




t\(\) 


A valid Ash.Type





## **Callbacks** 


apply\_atomic\_constraints\(new\_value, constraints\) 


Applies type constraints within an expression.




apply\_atomic\_constraints\_array\(new\_value, constraints\) 


Applies type constraints to a list of values within an expression. See `apply_atomic_constraints/2` for more.




apply\_constraints\(term, constraints\) 


Called after casting, to apply additional constraints to the value.




apply\_constraints\_array\(list, constraints\) 


Called after casting a list of values, to apply additional constraints to the value.




array\_constraints\(\) 


Returns a `Spark.Options` spec for the additional constraints supported when used in a list.




can\_load?\(constraints\) 


Whether or not `load/4` can be used. Defined automatically




cast\_atomic\(new\_value, constraints\) 


Casts a value within an expression.




cast\_atomic\_array\(new\_value, constraints\) 


Casts a list of values within an expression. See `cast_atomic/2` for more.




cast\_in\_query?\(constraints\) 


Whether or not data layers that build queries should attempt to type cast values of this type while doing so.




cast\_input\(term, constraints\) 


Attempt to cast unknown, potentially user-provided input, into a valid instance of the type.




cast\_input\_array\(list, constraints\) 


Attempt to cast a list of unknown, potentially user-provided inputs, into a list of valid instances of type.




cast\_stored\(term, constraints\) 


Attempt to load a stored value from the data layer into a valid instance of the type.




cast\_stored\_array\(list, constraints\) 


Attempt to load a list of stored values from the data layer into a list of valid instances of the type.




coerce\(term, constraints\) 


Attempt to coerce unknown, potentially user-provided input, into a valid instance of the type.




composite?\(constraints\) 


Return true if the type is a composite type, meaning it is made up of one or more values. How this works is up to the data layer.




composite\_types\(constraints\) 


Information about each member of the composite type, if it is a composite type




constraints\(\) 


Returns a `Spark.Options` spec for the constraints supported by the type.




custom\_apply\_constraints\_array?\(\) 


Whether or not an `apply_constraints_array/2` callback has been defined. This is defined automatically.




describe\(constraints\) 


Describes a type given its constraints. Can be used to generate docs, for example.




dump\_to\_embedded\(term, constraints\) 


Transform a valid instance of the type into a format that can be JSON encoded.




dump\_to\_embedded\_array\(list, constraints\) 


Transform a list of valid instances of the type into a format that can be JSON encoded.




dump\_to\_native\(term, constraints\) 


Transform a valid instance of the type into a format that the data layer can store.




dump\_to\_native\_array\(list, constraints\) 


Transform a list of valid instance of the type into a format that the data layer can store.




ecto\_type\(\) 


The underlying Ecto.Type.




embedded?\(\) 


Whether or not the type is an embedded resource. This is defined by embedded resources, you should not define this.




equal?\(term, term\) 


Determine if two valid instances of the type are equal.




evaluate\_operator\(term\) 


The implementation for any overloaded implementations.




generator\(constraints\) 


An Enumerable that produces valid instances of the type.




get\_rewrites\(merged\_load, calculation, path, constraints\) 


Gets any "rewrites" necessary to apply a given load statement.




handle\_change\(old\_term, new\_term, constraints\) 


React to a changing value. This could be used, for example, to have a type like `:strictly_increasing_integer`.




handle\_change\_array\(old\_term, new\_term, constraints\) 


React to a changing list of values. This could be used, for example, to have a type like `:unique_integer`, which when used in a list all items must be unique.




handle\_change\_array?\(\) 


Whether or not a custom `handle_change_array/3` has been defined by the type. Defined automatically.




include\_source\(constraints, t\) 


Add the source changeset to the constraints, in cases where it is needed for type casting logic




init\(constraints\) 


Useful for typed data layers \(like ash\_postgres\) to instruct them not to attempt to cast input values.




load\(values, load, constraints, context\) 


Applies a load statement through a list of values.




loaded?\(value, path\_to\_load, constraints, opts\) 


Checks if the given path has been loaded on the type.




matches\_type?\(term, constraints\) 


Whether or not the value a valid instance of the type.




may\_support\_atomic\_update?\(constraints\) 


Whether or not a value with given constraints may support being cast atomic




merge\_load\(left, right, constraints, context\) 


Merges a load statement with an existing load statement for the type.




operator\_overloads\(\) 


A map of operators with overloaded implementations.




prepare\_change\(old\_term, new\_uncasted\_term, constraints\) 


Prepare a change, given the old value and the new uncasted value.




prepare\_change\_array\(old\_term, new\_uncasted\_term, constraints\) 


Prepare a changing list of values, given the old value and the new uncasted value.




prepare\_change\_array?\(\) 


Whether or not a custom `prepare_change_array/3` has been defined by the type. Defined automatically.




rewrite\(value, list, constraints\) 


Apply any "rewrites" necessary to provide the results of a load statement to calculations that depended on a given load.




simple\_equality?\(\) 


Whether or not `==` can be used to compare instances of the type.




storage\_type\(\) 


The storage type, which should be known by a data layer supporting this type.




storage\_type\(constraints\) 


The storage type, which should be known by a data layer supporting this type.





## **Functions** 


apply\_atomic\_constraints\(type, term, constraints\) 


Applies a types constraints to an expression.




apply\_constraints\(type, term, constraints\) 


Confirms if a casted value matches the provided constraints.




array\_constraints\(type\) 


Gets the array constraints for a type




ash\_type?\(module\) 


Returns true if the value is a builtin type or adopts the `Ash.Type` behaviour




builtin?\(type\) 


Returns true if the type is an ash builtin type




can\_load?\(type, constraints \\\\ \[\]\) 


Returns true if the type supports nested loads




cast\_atomic\(type, term, constraints\) 


Modifies an expression to apply a type's casting logic to the value it produces.




cast\_in\_query?\(type, constraints \\\\ \[\]\) 


Returns `true` if the type should be cast in underlying queries




cast\_input\(type, term, constraints \\\\ nil\) 


Casts input \(e.g. unknown\) data to an instance of the type, or errors




cast\_stored\(type, term, constraints \\\\ \[\]\) 


Casts a value from the data store to an instance of the type, or errors




coerce\(type, term, constraints \\\\ nil\) 


Coerces input \(e.g. unknown\) data to an instance of the type, or errors.




composite?\(type, constraints\) 


Returns true if the type is a composite type




composite\_types\(type, constraints\) 


Returns the wrapped composite types




constraints\(type\) 


Returns the constraint schema for a type




describe\(type, constraints\) 


Calls the type's `describe` function with the given constraints




determine\_types\(types, values\) 


Determine types for a given function or operator.




dump\_to\_embedded\(type, term, constraints \\\\ \[\]\) 


Casts a value from the Elixir type to a value that can be embedded in another data structure.




dump\_to\_native\(type, term, constraints \\\\ \[\]\) 


Casts a value from the Elixir type to a value that the data store can persist




ecto\_type\(type\) 


Returns the ecto compatible type for an Ash.Type.




embedded\_type?\(type\) 


Returns true if the type is an embedded resource




equal?\(type, left, right\) 


Determines if two values of a given type are equal.




generator\(type, constraints\) 


Returns the StreamData generator for a given type




get\_rewrites\(type, merged\_load, calculation, path, constraints\) 


Gets the load rewrites for a given type, load, calculation and path.




get\_type\(value\) 


Gets the type module for a given short name or module




get\_type\!\(value\) 


Gets the type module for a given short name or module, ensures that it is a valid `type`




handle\_change\(type, old\_value, new\_value, constraints\) 


Process the old casted values alongside the new casted values.




handle\_change\_array?\(type\) 


Handles the change of a given array of values for an attribute change. Runs after casting.




include\_source\(type, changeset\_or\_query, constraints\) 


Provides the changeset, action\_input or query to the type, to potentially store in its constraints.




init\(type, constraints\) 


Initializes the constraints according to the underlying type




load\(type, value, loads, constraints, context\) 


Apply a load statement to a value.




loaded?\(type, values, load, constraints, opts \\\\ \[\]\) 


Checks if a given path has been loaded on a type.




matches\_type?\(type, value, constraints \\\\ \[\]\) 


Detects as a best effort if an arbitrary value matches the given type




merge\_load\(type, left, right, constraints, context\) 


Merges two load statements for a given type.




prepare\_change\(type, old\_value, new\_value, constraints\) 


Process the old casted values alongside the new *un*casted values.




prepare\_change\_array?\(type\) 


Prepares a given array of values for an attribute change. Runs before casting.




rewrite\(type, value, rewrites, constraints\) 


Applies rewrites to a given value.




short\_names\(\) 


Returns the list of available type short names




simple\_equality?\(type\) 


Determines if a type can be compared using the `==` operator.




storage\_type\(type, constraints \\\\ \[\]\) 


Returns the *underlying* storage type \(the underlying type of the *ecto type* of the *ash type*\)




# Types




# constraints\(\)




    @type     constraints() ::     Keyword.t    ()


A keyword list of constraints for a type





# error\(\)




    @type     error() ::
      :error
      | {:error,
             String.t    ()
         | [field:     atom    (), fields: [    atom    ()], message:     String.t    (), value:     any    ()]
         |     Ash.Error.t    ()}


An error value that can be returned from various callbacks





# load\_context\(\)




    @type     load_context() :: %{
      domain:     Ash.Domain.t    (),
      actor:     term    () | nil,
      tenant:     term    (),
      tracer: [    Ash.Tracer.t    ()] |     Ash.Tracer.t    () | nil,
      authorize?:     boolean    () | nil
    }


The context that is provided to the `load/4` callback.





# merge\_load\_context\(\)




    @type     merge_load_context() :: %{
      domain:     Ash.Domain.t    (),
      calc_name:     term    (),
      calc_load:     term    (),
      calc_path: [    atom    ()],
      reuse_values?:     boolean    (),
      strict_loads?:     boolean    (),
      initial_data:     term    (),
      relationship_path: [    atom    ()],
      authorize?:     boolean    ()
    }


The context that is provided to the `merge_load/4` callback.





# t\(\)




    @type     t() ::     module    () | {:array,     atom    ()}


A valid Ash.Type





# Callbacks




# apply\_atomic\_constraints\(new\_value, constraints\)




    @callback     apply_atomic_constraints(new_value ::     Ash.Expr.t    (),     constraints    ()) ::
      :ok | {:ok,     Ash.Expr.t    ()} | {:error,     Ash.Error.t    ()}


Applies type constraints within an expression.





# apply\_atomic\_constraints\_array\(new\_value, constraints\)




    @callback     apply_atomic_constraints_array(new_value ::     Ash.Expr.t    (),     constraints    ()) ::
      :ok | {:ok,     Ash.Expr.t    ()} | {:error,     Ash.Error.t    ()}


Applies type constraints to a list of values within an expression. See `apply_atomic_constraints/2` for more.





# apply\_constraints\(term, constraints\)




    @callback     apply_constraints(    term    (),     constraints    ()) ::
      {:ok, new_value ::     term    ()} | :ok |     error    ()


Called after casting, to apply additional constraints to the value.





# apply\_constraints\_array\(list, constraints\)
\(optional\)   



    @callback     apply_constraints_array([    term    ()],     constraints    ()) ::
      {:ok, new_values :: [    term    ()]} | :ok |     error    ()


Called after casting a list of values, to apply additional constraints to the value.

If not defined, `apply_constraints/2` is called for each item.





# array\_constraints\(\)
\(optional\)   



    @callback     array_constraints() ::     constraints    ()


Returns a `Spark.Options` spec for the additional constraints supported when used in a list.





# can\_load?\(constraints\)




    @callback     can_load?(    constraints    ()) ::     boolean    ()


Whether or not `load/4` can be used. Defined automatically





# cast\_atomic\(new\_value, constraints\)




    @callback     cast_atomic(new_value ::     Ash.Expr.t    (),     constraints    ()) ::
      {:atomic,     Ash.Expr.t    ()} | {:error,     Ash.Error.t    ()} | {:not_atomic,     String.t    ()}


Casts a value within an expression.

For instance, if you had a type like `:non_neg_integer`, you might do:

    def         cast_atomic    (    value    ,         _constraints    )          do    
          expr    (    
            if         ^    value         <         0         do    
              error    (    Ash.Error.Changes.InvalidChanges    ,         %{    message    :         "must be positive"    ,         value    :         ^    value    }    )    
            else    
              value    
            end    
          )        end





# cast\_atomic\_array\(new\_value, constraints\)




    @callback     cast_atomic_array(new_value ::     Ash.Expr.t    (),     constraints    ()) ::
      {:atomic,     Ash.Expr.t    ()} | {:error,     Ash.Error.t    ()} | {:not_atomic,     String.t    ()}


Casts a list of values within an expression. See `cast_atomic/2` for more.





# cast\_in\_query?\(constraints\)




    @callback     cast_in_query?(    constraints    ()) ::     boolean    ()


Whether or not data layers that build queries should attempt to type cast values of this type while doing so.





# cast\_input\(term, constraints\)




    @callback     cast_input(    term    (),     constraints    ()) :: {:ok,     term    ()} |     Ash.Error.t    ()


Attempt to cast unknown, potentially user-provided input, into a valid instance of the type.





# cast\_input\_array\(list, constraints\)
\(optional\)   



    @callback     cast_input_array([    term    ()],     constraints    ()) :: {:ok, [    term    ()]} |     error    ()


Attempt to cast a list of unknown, potentially user-provided inputs, into a list of valid instances of type.

This callback allows to define types that are "collection-aware", i.e an integer that is unique whenever it appears in a list.

If not defined, `cast_input/2` is called for each item.





# cast\_stored\(term, constraints\)




    @callback     cast_stored(    term    (),     constraints    ()) :: {:ok,     term    ()} |     error    ()


Attempt to load a stored value from the data layer into a valid instance of the type.





# cast\_stored\_array\(list, constraints\)
\(optional\)   



    @callback     cast_stored_array([    term    ()],     constraints    ()) :: {:ok, [    term    ()]} |     error    ()


Attempt to load a list of stored values from the data layer into a list of valid instances of the type.

If not defined, `cast_stored/2` is called for each item.





# coerce\(term, constraints\)




    @callback     coerce(    term    (),     constraints    ()) :: {:ok,     term    ()} |     Ash.Error.t    ()


Attempt to coerce unknown, potentially user-provided input, into a valid instance of the type.

## ******Coercion vs Casting**

Coercion can be summed up as a more "insistent" form of casting. It means "we really want to use this value as this type, so please try to convert it to that type". This is used in expressions as opposed to `cast_input`. For example, the value `10`, if passed into `Ash.Type.cast_input(:string, 10)` would fail to cast. However, if used in the following expression: `expr(type(10, :string) <> " minutes")` the `10` would be "coerced" \(using `to_string/1`\) into `"10"`.

By default, coercion uses `cast_input/2` unless





# composite?\(constraints\)




    @callback     composite?(    constraints    ()) ::     boolean    ()


Return true if the type is a composite type, meaning it is made up of one or more values. How this works is up to the data layer.

For example, `AshMoney` provides a type that is composite with a "currency" and an "amount".





# composite\_types\(constraints\)




    @callback     composite_types(    constraints    ()) :: [
      {name, type,     constraints    ()} | {name, storage_key, type,     constraints    ()}
    ]
    when name:     atom    (), type:     t    (), storage_key:     atom    ()


Information about each member of the composite type, if it is a composite type

An example given the `AshMoney` example listed above:

`[{:currency, :string, []}, {:amount, :decimal, []}]`





# constraints\(\)




    @callback     constraints() ::     constraints    ()


Returns a `Spark.Options` spec for the constraints supported by the type.





# custom\_apply\_constraints\_array?\(\)




    @callback     custom_apply_constraints_array?() ::     boolean    ()


Whether or not an `apply_constraints_array/2` callback has been defined. This is defined automatically.





# describe\(constraints\)




    @callback     describe(    constraints    ()) ::     String.t    () | nil


Describes a type given its constraints. Can be used to generate docs, for example.





# dump\_to\_embedded\(term, constraints\)
\(optional\)   



    @callback     dump_to_embedded(    term    (),     constraints    ()) :: {:ok,     term    ()} | :error


Transform a valid instance of the type into a format that can be JSON encoded.





# dump\_to\_embedded\_array\(list, constraints\)
\(optional\)   



    @callback     dump_to_embedded_array([    term    ()],     constraints    ()) :: {:ok,     term    ()} |     error    ()


Transform a list of valid instances of the type into a format that can be JSON encoded.

If not defined, `dump_to_embedded/2` is called for each item.





# dump\_to\_native\(term, constraints\)




    @callback     dump_to_native(    term    (),     constraints    ()) :: {:ok,     term    ()} |     error    ()


Transform a valid instance of the type into a format that the data layer can store.





# dump\_to\_native\_array\(list, constraints\)
\(optional\)   



    @callback     dump_to_native_array([    term    ()],     constraints    ()) :: {:ok,     term    ()} |     error    ()


Transform a list of valid instance of the type into a format that the data layer can store.

If not defined, `dump_to_native/2` is called for each item.





# ecto\_type\(\)




    @callback     ecto_type() ::     Ecto.Type.t    ()


The underlying Ecto.Type.





# embedded?\(\)




    @callback     embedded?() ::     boolean    ()


Whether or not the type is an embedded resource. This is defined by embedded resources, you should not define this.





# equal?\(term, term\)




    @callback     equal?(    term    (),     term    ()) ::     boolean    ()


Determine if two valid instances of the type are equal.

*Do not define this* if `==` is sufficient for your type. See `simple_equality?/0` for more.





# evaluate\_operator\(term\)
\(optional\)   



    @callback     evaluate_operator(    term    ()) :: {:known,     term    ()} | :unknown | {:error,     term    ()}


The implementation for any overloaded implementations.





# generator\(constraints\)
\(optional\)   



    @callback     generator(    constraints    ()) ::     Enumerable.t    ()


An Enumerable that produces valid instances of the type.

This can be used for property testing, or generating valid inputs for seeding. Typically you would use `StreamData` for this.





# get\_rewrites\(merged\_load, calculation, path, constraints\)
\(optional\)   



    @callback     get_rewrites(
      merged_load ::     term    (),
      calculation ::     Ash.Query.Calculation.t    (),
      path :: [    atom    ()],
      constraints ::     Keyword.t    ()
    ) :: [rewrite()]


Gets any "rewrites" necessary to apply a given load statement.

This is a low level tool used when types can contain instances of resources. You generally should not need to know how this works. See `Ash.Type.Union` and `Ash.Type.Struct` for examples if you are trying to write a similar type.





# handle\_change\(old\_term, new\_term, constraints\)




    @callback     handle_change(old_term ::     term    (), new_term ::     term    (),     constraints    ()) ::
      {:ok,     term    ()} |     error    ()


React to a changing value. This could be used, for example, to have a type like `:strictly_increasing_integer`.





# handle\_change\_array\(old\_term, new\_term, constraints\)
\(optional\)   



    @callback     handle_change_array(old_term :: [    term    ()], new_term :: [    term    ()],     constraints    ()) ::
      {:ok,     term    ()} |     error    ()


React to a changing list of values. This could be used, for example, to have a type like `:unique_integer`, which when used in a list all items must be unique.

If not defined, `handle_change/3` is called for each item with a `nil` old value.





# handle\_change\_array?\(\)




    @callback     handle_change_array?() ::     boolean    ()


Whether or not a custom `handle_change_array/3` has been defined by the type. Defined automatically.





# include\_source\(constraints, t\)
\(optional\)   



    @callback     include_source(    constraints    (),     Ash.Changeset.t    ()) ::     constraints    ()


Add the source changeset to the constraints, in cases where it is needed for type casting logic





# init\(constraints\)
\(optional\)   



    @callback     init(    constraints    ()) :: {:ok,     constraints    ()} | {:error,     Ash.Error.t    ()}


Useful for typed data layers \(like ash\_postgres\) to instruct them not to attempt to cast input values.

You generally won't need this, but it can be an escape hatch for certain cases.





# load\(values, load, constraints, context\)
\(optional\)   



    @callback     load(
      values :: [    term    ()],
      load ::     Keyword.t    (),
      constraints ::     Keyword.t    (),
      context ::     load_context    ()
    ) :: {:ok, [    term    ()]} | {:error,     Ash.Error.t    ()}


Applies a load statement through a list of values.

This allows types to support load statements, like `Ash.Type.Union`, embedded resources, or the `Ash.Type.Struct` when it is an `instance_of` a resource.





# loaded?\(value, path\_to\_load, constraints, opts\)




    @callback     loaded?(
      value ::     term    (),
      path_to_load :: [    atom    ()],
      constraints ::     Keyword.t    (),
      opts ::     Keyword.t    ()
    ) ::     boolean    ()


Checks if the given path has been loaded on the type.





# matches\_type?\(term, constraints\)




    @callback     matches_type?(    term    (),     constraints    ()) ::     boolean    ()


Whether or not the value a valid instance of the type.





# may\_support\_atomic\_update?\(constraints\)




    @callback     may_support_atomic_update?(    constraints    ()) ::     boolean    ()


Whether or not a value with given constraints may support being cast atomic

Defaults to checking if `cast_atomic/2` is defined on the type.





# merge\_load\(left, right, constraints, context\)
\(optional\)   



    @callback     merge_load(
      left ::     term    (),
      right ::     term    (),
      constraints ::     Keyword.t    (),
      context ::     merge_load_context    () | nil
    ) :: {:ok,     term    ()} | {:error,     error    ()} | :error


Merges a load statement with an existing load statement for the type.





# operator\_overloads\(\)
\(optional\)   



    @callback     operator_overloads() :: %{optional(    atom    ()) => %{optional(    term    ()) =>     module    ()}}


A map of operators with overloaded implementations.

These will only be honored if the type is placed in `config :ash, :known_types, [...Type]`

A corresponding `evaluate_operator/1` clause should match.





# prepare\_change\(old\_term, new\_uncasted\_term, constraints\)




    @callback     prepare_change(old_term ::     term    (), new_uncasted_term ::     term    (),     constraints    ()) ::
      {:ok,     term    ()} |     error    ()


Prepare a change, given the old value and the new uncasted value.





# prepare\_change\_array\(old\_term, new\_uncasted\_term, constraints\)
\(optional\)   



    @callback     prepare_change_array(
      old_term :: [    term    ()],
      new_uncasted_term :: [    term    ()],
          constraints    ()
    ) :: {:ok,     term    ()} |     error    ()


Prepare a changing list of values, given the old value and the new uncasted value.

If not defined, `prepare_change/3` is called for each item with a `nil` old value.





# prepare\_change\_array?\(\)




    @callback     prepare_change_array?() ::     boolean    ()


Whether or not a custom `prepare_change_array/3` has been defined by the type. Defined automatically.





# rewrite\(value, list, constraints\)
\(optional\)   



    @callback     rewrite(value ::     term    (), [rewrite()], constraints ::     Keyword.t    ()) ::
      value ::     term    ()


Apply any "rewrites" necessary to provide the results of a load statement to calculations that depended on a given load.

This is a low level tool used when types can contain instances of resources. You generally should not need to know how this works. See `Ash.Type.Union` and `Ash.Type.Struct` for examples if you are trying to write a similar type.





# simple\_equality?\(\)




    @callback     simple_equality?() ::     boolean    ()


Whether or not `==` can be used to compare instances of the type.

This is defined automatically to return `false` if `equal?/2` is defined.

Types that cannot be compared using `==` incur significant runtime costs when used in certain ways. For example, if a resource's primary key cannot be compared with `==`, we cannot do things like key a list of records by their primary key. Implementing `equal?/2` will cause various code paths to be considerably slower, so only do it when necessary.





# storage\_type\(\)
\(optional\)   



    @callback     storage_type() ::     Ecto.Type.t    ()


The storage type, which should be known by a data layer supporting this type.

Use `storage_type/1`, as this will be deprecated in the future.





# storage\_type\(constraints\)




    @callback     storage_type(    constraints    ()) ::     Ecto.Type.t    ()


The storage type, which should be known by a data layer supporting this type.





# Functions




# apply\_atomic\_constraints\(type, term, constraints\)




    @spec     apply_atomic_constraints(    t    (),     term    (),     constraints    ()) ::
      {:ok,     Ash.Expr.t    ()} | {:error,     Ash.Error.t    ()}


Applies a types constraints to an expression.

This delegates to the underlying types implementation of `apply_atomic_constraints/2`.





# apply\_constraints\(type, term, constraints\)




    @spec     apply_constraints(    t    (),     term    (),     constraints    ()) ::
      {:ok,     term    ()} | {:error,     term    ()}


Confirms if a casted value matches the provided constraints.





# array\_constraints\(type\)



Gets the array constraints for a type





# ash\_type?\(module\)




    @spec     ash_type?(    term    ()) ::     boolean    ()


Returns true if the value is a builtin type or adopts the `Ash.Type` behaviour





# builtin?\(type\)



Returns true if the type is an ash builtin type





# can\_load?\(type, constraints \\\\ \[\]\)




    @spec     can_load?(    t    (),     Keyword.t    ()) ::     boolean    ()


Returns true if the type supports nested loads





# cast\_atomic\(type, term, constraints\)




    @spec     cast_atomic(    t    (),     term    (),     constraints    ()) ::
      {:atomic,     Ash.Expr.t    ()}
      | {:ok,     term    ()}
      | {:error,     Ash.Error.t    ()}
      | {:not_atomic,     String.t    ()}


Modifies an expression to apply a type's casting logic to the value it produces.

This delegates to the underlying types implementation of `cast_atomic/2`.





# cast\_in\_query?\(type, constraints \\\\ \[\]\)



Returns `true` if the type should be cast in underlying queries





# cast\_input\(type, term, constraints \\\\ nil\)




    @spec     cast_input(    t    (),     term    (),     constraints    () | nil) ::
      {:ok,     term    ()} | {:error,     Ash.Error.error_input    ()} | :error


Casts input \(e.g. unknown\) data to an instance of the type, or errors

Maps to `Ecto.Type.cast/2`





# cast\_stored\(type, term, constraints \\\\ \[\]\)




    @spec     cast_stored(    t    (),     term    (),     constraints    () | nil) ::
      {:ok,     term    ()} | {:error,     keyword    ()} | :error


Casts a value from the data store to an instance of the type, or errors

Maps to `Ecto.Type.load/2`





# coerce\(type, term, constraints \\\\ nil\)




    @spec     coerce(    t    (),     term    (),     constraints    () | nil) ::
      {:ok,     term    ()} | {:error,     Keyword.t    ()} | :error


Coerces input \(e.g. unknown\) data to an instance of the type, or errors.

See `Ash.Type.coerce/2`





# composite?\(type, constraints\)




    @spec     composite?(
          t    (),
          constraints    ()
    ) ::     Enumerable.t    ()


Returns true if the type is a composite type





# composite\_types\(type, constraints\)




    @spec     composite_types(
          t    (),
          constraints    ()
    ) ::     Enumerable.t    ()


Returns the wrapped composite types





# constraints\(type\)




    @spec     constraints(    t    ()) ::     constraints    ()


Returns the constraint schema for a type





# describe\(type, constraints\)



Calls the type's `describe` function with the given constraints





# determine\_types\(types, values\)



Determine types for a given function or operator.





# dump\_to\_embedded\(type, term, constraints \\\\ \[\]\)




    @spec     dump_to_embedded(    t    (),     term    (),     constraints    () | nil) ::
      {:ok,     term    ()} | {:error,     keyword    ()} | :error


Casts a value from the Elixir type to a value that can be embedded in another data structure.

Embedded resources expect to be stored in JSON, so this allows things like UUIDs to be stored as strings in embedded resources instead of binary.





# dump\_to\_native\(type, term, constraints \\\\ \[\]\)




    @spec     dump_to_native(    t    (),     term    (),     constraints    () | nil) ::
      {:ok,     term    ()} | {:error,     keyword    ()} | :error


Casts a value from the Elixir type to a value that the data store can persist

Maps to `Ecto.Type.dump/2`





# ecto\_type\(type\)




    @spec     ecto_type(    t    ()) ::     Ecto.Type.t    ()


Returns the ecto compatible type for an Ash.Type.

If you `use Ash.Type`, this is created for you. For builtin types this may return a corresponding ecto builtin type \(atom\)





# embedded\_type?\(type\)



Returns true if the type is an embedded resource





# equal?\(type, left, right\)




    @spec     equal?(    t    (),     term    (),     term    ()) ::     boolean    ()


Determines if two values of a given type are equal.

Maps to `Ecto.Type.equal?/3`





# generator\(type, constraints\)




    @spec     generator(
          module    () | {:array,     module    ()},
          constraints    ()
    ) ::     Enumerable.t    ()


Returns the StreamData generator for a given type





# get\_rewrites\(type, merged\_load, calculation, path, constraints\)



Gets the load rewrites for a given type, load, calculation and path.

This is used for defining types that support a nested load statement. See the embedded type and union type implementations for examples of how to use this.





# get\_type\(value\)




    @spec     get_type(    atom    () |     module    () | {:array,     atom    () |     module    ()}) ::
          atom    () |     module    () | {:array,     atom    () |     module    ()}


Gets the type module for a given short name or module





# get\_type\!\(value\)




    @spec     get_type!(    atom    () |     module    () | {:array,     atom    () |     module    ()}) ::
          atom    () |     module    () | {:array,     atom    () |     module    ()}


Gets the type module for a given short name or module, ensures that it is a valid `type`

## ******Raises**

+ `RuntimeError`: If the provided type module is not found or invalid.





# handle\_change\(type, old\_value, new\_value, constraints\)



Process the old casted values alongside the new casted values.

This is leveraged by embedded types to know if something is being updated or destroyed. This is not called on creates.





# handle\_change\_array?\(type\)




    @spec     handle_change_array?(    t    ()) ::     boolean    ()


Handles the change of a given array of values for an attribute change. Runs after casting.





# include\_source\(type, changeset\_or\_query, constraints\)




    @spec     include_source(
          t    (),
          Ash.Changeset.t    () |     Ash.Query.t    () |     Ash.ActionInput.t    (),
          constraints    ()
    ) ::     constraints    ()


Provides the changeset, action\_input or query to the type, to potentially store in its constraints.

This is used for embedded types to allow accessing the parent changeset in certain cases.





# init\(type, constraints\)




    @spec     init(    t    (),     constraints    ()) :: {:ok,     constraints    ()} | {:error,     Ash.Error.t    ()}


Initializes the constraints according to the underlying type





# load\(type, value, loads, constraints, context\)




    @spec     load(
      type ::     t    (),
      values :: [    term    ()],
      load ::     Keyword.t    (),
      constraints ::     Keyword.t    (),
      context ::     load_context    ()
    ) :: {:ok, [    term    ()]} | {:error,     Ash.Error.t    ()}


Apply a load statement to a value.

This is used for types that can be "loaded through". For example, maps, unions and structs. If they have keys that are embedded types, for example, we want to be able to apply a load statements to their contents.





# loaded?\(type, values, load, constraints, opts \\\\ \[\]\)




    @spec     loaded?(
      type ::     t    (),
      value_or_values ::     term    (),
      path_to_load :: [    atom    ()],
      constraints ::     Keyword.t    (),
      opts ::     Keyword.t    ()
    ) ::     boolean    ()


Checks if a given path has been loaded on a type.

This is used to "load through" types. For more see `load/5`.





# matches\_type?\(type, value, constraints \\\\ \[\]\)



Detects as a best effort if an arbitrary value matches the given type





# merge\_load\(type, left, right, constraints, context\)




    @spec     merge_load(
      type ::     t    (),
      left ::     term    (),
      right ::     term    (),
      constraints ::     Keyword.t    (),
      context ::     merge_load_context    () | nil
    ) :: {:ok, [    term    ()]} | :error | {:error,     Ash.Error.t    ()}


Merges two load statements for a given type.

This is used to "load through" types. For more see `load/5`.





# prepare\_change\(type, old\_value, new\_value, constraints\)



Process the old casted values alongside the new *un*casted values.

This is leveraged by embedded types to know if something is being updated or destroyed. This is not called on creates.





# prepare\_change\_array?\(type\)




    @spec     prepare_change_array?(    t    ()) ::     boolean    ()


Prepares a given array of values for an attribute change. Runs before casting.





# rewrite\(type, value, rewrites, constraints\)



Applies rewrites to a given value.

This is used for defining types that support a nested load statement. See the embedded type and union type implementations for examples of how to use this.





# short\_names\(\)



Returns the list of available type short names





# simple\_equality?\(type\)




    @spec     simple_equality?(    t    ()) ::     boolean    ()


Determines if a type can be compared using the `==` operator.





# storage\_type\(type, constraints \\\\ \[\]\)



Returns the *underlying* storage type \(the underlying type of the *ecto type* of the *ash type*\)





# Ash.Type.Atom 

Stores an atom as a string in the database

A builtin type that can be referenced via `:atom`

### Constraints

+ 
`:one_of` \(`term/0`\) - Allows constraining the value of an atom to a pre-defined list

+ 
`:unsafe_to_atom?` \(`boolean/0`\) - Allows casting to atoms that don't yet exist in the system. See https://security.erlef.org/secure\_coding\_and\_deployment\_hardening/atom\_exhaustion.html for more. The default value is `false`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Binary 

Represents a binary.

A builtin type that can be referenced via `:binary`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Boolean 

Represents a boolean.

A builtin type that can be referenced via `:boolean`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.CiString 

Stores a case insensitive string in the database

See `Ash.CiString` for more information.

A builtin type that can be referenced via `:ci_string`

### Constraints

+ 
`:max_length` \(`non_neg_integer/0`\) - Enforces a maximum length on the value

+ 
`:min_length` \(`non_neg_integer/0`\) - Enforces a minimum length on the value

+ 
`:match` \(`Regex.t/0`\) - Enforces that the string matches a passed in regex

+ 
`:trim?` \(`boolean/0`\) - Trims the value. The default value is `true`.

+ 
`:allow_empty?` \(`boolean/0`\) - Sets the value to `nil` if it's empty. The default value is `false`.

+ 
`:casing` - Lowercases or uppercases the value, fully discarding case information.  
For example, if you don't set this, a value of `FrEd` could be saved to the data layer. `FrEd` and `fReD` would still compare as equal, but the original casing information is retained. In many cases, this is what you want. In some cases, however, you want to remove all case information. For example, in an email, you may want to support a user inputting an upper case letter, but discard it when saved. Valid values are :upper, :lower, nil The default value is `nil`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Comparable 

Helpers for working with `Comparable`





# Summary


## **Functions** 


defcomparable\(arg1, arg2, list\) 



# Functions




# defcomparable\(arg1, arg2, list\)
\(macro\)   





# Ash.Type.Date 

Represents a date in the database

A builtin type that can be referenced via `:date`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.DateTime 

Represents a datetime, with configurable precision and timezone.

A builtin type that can be referenced via `:datetime`

### Constraints

+ 
`:precision` - Valid values are :microsecond, :second The default value is `:second`.

+ 
`:cast_dates_as` - Valid values are :start\_of\_day, :error The default value is `:start_of_day`.

+ 
`:timezone` - Valid values are :utc The default value is `:utc`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Decimal 

Represents a decimal.

A builtin type that can be referenced via `:decimal`

### Constraints

+ 
`:precision` - Enforces a maximum number of significant digits. Set to :arbitrary for no limit. The default value is `:arbitrary`.

+ 
`:scale` - Enforces a maximum number of decimal places. Set to :arbitrary for no limit. The default value is `:arbitrary`.

+ 
`:max` - Enforces a maximum on the value

+ 
`:min` - Enforces a minimum on the value

+ 
`:greater_than` - Enforces a minimum on the value \(exclusive\)

+ 
`:less_than` - Enforces a maximum on the value \(exclusive\)





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Duration 

Represents a Duration

A builtin type that can be referenced via `:duration`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.DurationName 

An interval of time, primarily meant to be used in expression functions

Valid intervals are \(as strings or atoms\): \[:year, :month, :week, :day, :hour, :minute, :second, :millisecond, :microsecond\]





# Summary


## **Types** 


t\(\) 




## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Types




# t\(\)




    @type     t() ::
      :microsecond
      | :millisecond
      | :second
      | :minute
      | :hour
      | :day
      | :week
      | :month
      | :year





# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Enum **behaviour** 

A type for abstracting enums into a single type.

For example, your existing attribute might look like:

    attribute         :status    ,         :atom    ,         constraints    :         [    one_of    :         [    :open    ,         :closed    ]    ]

But as that starts to spread around your system, you may find that you want to centralize that logic. To do that, use this module to define an Ash type easily:

    defmodule         MyApp.TicketStatus         do    
          use         Ash.Type.Enum    ,         values    :         [    :open    ,         :closed    ]        end

Then, you can rewrite your original attribute as follows:

    attribute         :status    ,         MyApp.TicketStatus

Valid values are:

+ The atom itself, e.g `:open`
+ A string that matches the atom, e.g `"open"`
+ A string that matches the atom after being downcased, e.g `"OPEN"` or `"oPeN"`
+ A string that matches the stringified, downcased atom, after itself being downcased. This allows for enum values like `:Open`, `:SomeState` and `:Some_State`

## Custom input values

If you need to accept inputs beyond those described above while still mapping them to one of the enum values, you can override the `match/1` callback.

For example, if you want to map both the `:half_empty` and `:half_full` states to the same enum value, you could implement it as follows:

    defmodule         MyApp.GlassState         do    
          use         Ash.Type.Enum    ,         values    :         [    :empty    ,         :half_full    ,         :full    ]    

          def         match    (    :half_empty    )    ,         do    :         {    :ok    ,         :half_full    }    
          def         match    (    "half_empty"    )    ,         do    :         {    :ok    ,         :half_full    }    
          def         match    (    value    )    ,         do    :         super    (    value    )        end

In the provided example, if no additional value is matched, `super(value)` is called, invoking the default implementation of `match/1`. This approach is typically suitable if you only aim to extend default matching rather than completely reimplementing it.

### Caveats

Additional input values are not exposed in derived interfaces. For example, `HALF_EMPTY` will not be present as a possible enum value when using `ash_graphql`.

Moreover, only explicitly matched values are mapped to the enum value. For instance, `"HaLf_emPty"` would not be accepted by the code provided earlier. If case normalization is needed for additional values, it must be explicitly implemented.

## Value labels and descriptions

It's possible to associate a label and/or description for each value.

    defmodule         MyApp.TicketStatus         do    
          use         Ash.Type.Enum    ,    
            values    :         [    
              open    :         "An open ticket"    ,         # <- description only,    
              escalated    :         [    description    :         "An escalated ticket"    ]    ,    
              follow_up    :         [    label    :         "Follow up"    ]    ,    
              closed    :         [    description    :         "A closed ticket"    ,         label    :         "Closed"    ]    
            ]        end

Adding labels and descriptions can be helpful when displaying the Enum values to users.

This can be used by extensions to provide detailed descriptions of enum values.

The description of a value can be retrieved with `description/1`:

    MyApp.TicketStatus    .    description    (    :open    )        iex>     "An open ticket"

The label of a value can be retrieved with `label/1`:

    MyApp.TicketStatus    .    label    (    :closed    )        iex>     "Closed"

Both the description and label can be retrieved with `details/1`

    MyApp.TicketStatus    .    details    (    :closed    )        iex>     %{    description    :         "A closed ticket"    ,         label    :         "Closed"    }





# Summary


## **Callbacks** 


description\(arg1\) 


The description of the value, if existing




details\(arg1\) 


The value detail map, if existing




label\(arg1\) 


The label of the value, if existing




match\(term\) 


finds the valid value that matches a given input term




match?\(term\) 


true if a given term matches a value




values\(\) 


The list of valid values \(not all input types that match them\)




# Callbacks




# description\(arg1\)




    @callback     description(    atom    () |     String.t    ()) ::     String.t    () | nil


The description of the value, if existing





# details\(arg1\)




    @callback     details(    atom    () |     String.t    ()) :: %{
      description:     String.t    () | nil,
      label:     String.t    () | nil
    }


The value detail map, if existing





# label\(arg1\)




    @callback     label(    atom    () |     String.t    ()) ::     String.t    () | nil


The label of the value, if existing





# match\(term\)




    @callback     match(    term    ()) :: {:ok,     atom    ()} | :error


finds the valid value that matches a given input term





# match?\(term\)




    @callback     match?(    term    ()) ::     boolean    ()


true if a given term matches a value





# values\(\)




    @callback     values() :: [    atom    () |     String.t    ()]


The list of valid values \(not all input types that match them\)





# Ash.Type.File 

A type that represents a file on the filesystem.

#### Persistence

This type does not support persisting via `Ash.DataLayer`.

It is mainly intended to be used in arguments.

## Valid values to cast

This type can cast multiple types of values:

+ itself
+ `Plug.Upload`
+ Any value that implements the `Ash.Type.File.Source` protocol.





# Summary


## **Types** 


t\(\) 




## **Functions** 


from\_io\(device\) 


Create a file from an `IO.device()`




from\_path\(path\) 


Create a file from a path.




handle\_change?\(\) 



open\(file, modes \\\\ \[\]\) 


Open the file with the given `modes`.




path\(file\) 


Returns the path to the file.




prepare\_change?\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Type.File{
      implementation:     Ash.Type.File.Implementation.t    (),
      source:     Ash.Type.File.Implementation.source    ()
    }





# Functions




# from\_io\(device\)




    @spec     from_io(device ::     IO.device    ()) ::     t    ()


Create a file from an `IO.device()`

## ******Example**

    iex>     path         =         "README.md"        ...>     {    :ok    ,         device    }         =         File    .    open    (    path    )        ...>     Ash.Type.File    .    from_io    (    device    )        %    Ash.Type.File    {    source    :         device    ,         implementation    :         Ash.Type.File.IO    }





# from\_path\(path\)




    @spec     from_path(path ::     Path.t    ()) ::     t    ()


Create a file from a path.

## ******Example**

    iex>     path         =         "README.md"        ...>     Ash.Type.File    .    from_path    (    path    )        %    Ash.Type.File    {    source    :         "README.md"    ,         implementation    :         Ash.Type.File.Path    }





# handle\_change?\(\)





# open\(file, modes \\\\ \[\]\)




    @spec     open(file ::     t    (), modes :: [    File.mode    ()]) ::
      {:ok,     IO.device    ()} | {:error,     Ash.Type.File.Implementation.error    ()}


Open the file with the given `modes`.

This function will delegate to the `open/2` function on the `implementation`.

For details on the `modes` argument, see the `File.open/2` documentation.

## ******Example**

    iex>     path         =         "README.md"        ...>     file         =         Ash.Type.File    .    from_path    (    path    )        ...>     Ash.Type.File    .    open    (    file    ,         [    :read    ]    )        ...>     # => {:ok, #PID<0.109.0>}





# path\(file\)




    @spec     path(file ::     t    ()) ::
      {:ok,     Path.t    ()}
      | {:error, :not_supported |     Ash.Type.File.Implementation.error    ()}


Returns the path to the file.

Not every implementation will support this operation. If the implementation does not support this operation, then `{:error, :not_supported}` will be returned. In this case, use the `open/2` function to access the file.

## ******Example**

    iex>     path         =         "README.md"        ...>     file         =         Ash.Type.File    .    from_path    (    path    )        ...>     Ash.Type.File    .    path    (    file    )        {    :ok    ,         "README.md"    }





# prepare\_change?\(\)





# Ash.Type.File.Implementation **behaviour** 

Behaviour for file implementations that are compatible with `Ash.Type.File`.





# Summary


## **Types** 


error\(\) 


Errors returned by the implementation.




source\(\) 


The source of the file the implementation operates on.




t\(\) 


Any `module()` implementing the `Ash.Type.File.Implementation` behaviour.





## **Callbacks** 


open\(file, modes\) 


Open `IO.device()` for the file.




path\(file\) 


Return path of the file on disk.




# Types




# error\(\)




    @type     error() ::     term    ()


Errors returned by the implementation.





# source\(\)




    @type     source() ::     term    ()


The source of the file the implementation operates on.





# t\(\)




    @type     t() ::     module    ()


Any `module()` implementing the `Ash.Type.File.Implementation` behaviour.





# Callbacks




# open\(file, modes\)




    @callback     open(file ::     source    (), modes :: [    File.mode    ()]) ::
      {:ok,     IO.device    ()} | {:error,     error    ()}


Open `IO.device()` for the file.

See `Ash.Type.File.open/2`

The return pid must point to a process following the Erlang I/O Protocol like `StringIO` or `File`.





# path\(file\)
\(optional\)   



    @callback     path(file ::     source    ()) :: {:ok,     Path.t    ()} | {:error,     error    ()}


Return path of the file on disk.

See: `Ash.Type.File.path/1`

This callback is optional. If the file is not stored on disk, this callback can be omitted.





# Ash.Type.File.Source **protocol** 

Protocol for allowing the casting of something into an `Ash.Type.File`.

## Usage

    defmodule         MyStruct         do    
          defstruct         [    :path    ]    

          @behavior         Ash.Type.File.Implementation    

          @impl         Ash.Type.File.Implementation    
          def         path    (    %    __MODULE__    {    path    :         path    }    )    ,         do    :         {    :ok    ,         path    }    

          @impl         Ash.Type.File.Implementation    
          def         open    (    %    __MODULE__    {    path    :         path    }    ,         modes    )    ,         do    :         File    .    open    (    path    ,         modes    )    

          defimpl         Ash.Type.File.Source         do    
            def         implementation    (    %    MyStruct    {    }         =         struct    )    ,         do    :         {    :ok    ,         MyStruct    }    
          end        end





# Summary


## **Types** 


t\(\) 


All the types that implement this protocol.





## **Functions** 


implementation\(file\) 


Detect Implementation of the file.




# Types




# t\(\)




    @type     t() ::     term    ()


All the types that implement this protocol.





# Functions




# implementation\(file\)




    @spec     implementation(    t    ()) :: {:ok,     Ash.Type.File.Implementation.t    ()} | :error


Detect Implementation of the file.

Returns an `:ok` tuple with the implementation module if the file is supported and `:error` otherwise.





# Ash.Type.Float 

Represents a float \(floating point number\)

A builtin type that be referenced via `:float`

### Constraints

+ 
`:max` - Enforces a maximum on the value

+ 
`:min` - Enforces a minimum on the value

+ 
`:greater_than` - Enforces a minimum on the value \(exclusive\)

+ 
`:less_than` - Enforces a maximum on the value \(exclusive\)





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Function 

Represents a function.

If the type would be dumped to a native format, `:erlang.term_to_binary(term, [:safe])` is used.

Please keep in mind, this is *NOT SAFE* to use with external input.

More information available here: https://erlang.org/doc/man/erlang.html\#binary\_to\_term-2

### Constraints

+ `:arity` \(`pos_integer/0`\) - Enforces a specific arity on the provided function





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Integer 

Represents a simple integer

A builtin type that can be referenced via `:integer`

### Constraints

+ 
`:max` - Enforces a maximum on the value

+ 
`:min` - Enforces a minimum on the value





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Keyword 

Represents a keyword list, stored as a `:map` in the database.

A builtin type that can be referenced via `:keyword_list`

+ `:fields` \(`keyword/0`\) - Required. The types of the fields in the keyword, and their constraints.  
If constraints are specified, only those fields will be in the casted keyword.  
For example: 
    fields    :          [    
          amount    :         [    
            type    :         :integer    ,    
            description    :         "The amount of the transaction"    ,    
            constraints    :         [    
              max    :         10    
            ]    
          ]    ,    
          currency    :         [    
            type    :         :string    ,    
            allow_nil?    :         false    ,    
            description    :         "The currency code of the transaction"    ,    
            constraints    :         [    
              max_length    :         3    
            ]    
          ]        ]      
allow\_nil? is true by default
	+ 
`:type` \(an `Ash.Type`\) - Required.

	+ 
`:description` \(`String.t/0`\)

	+ 
`:allow_nil?` \(`boolean/0`\) - The default value is `true`.

	+ 
`:constraints` \(`keyword/0`\) - The default value is `[]`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Map 

Represents a map stored in the database.

In postgres, for example, this represents binary encoded json

A builtin type that can be referenced via `:map`

### Constraints

+ `:fields` \(`keyword/0`\) - The types of the fields in the map, and their constraints.  
If constraints are specified, only those fields will be in the casted map.  
For example: 
    fields    :          [    
          amount    :         [    
            type    :         :integer    ,    
            description    :         "The amount of the transaction"    ,    
            constraints    :         [    
              max    :         10    
            ]    
          ]    ,    
          currency    :         [    
            type    :         :string    ,    
            allow_nil?    :         false    ,    
            description    :         "The currency code of the transaction"    ,    
            constraints    :         [    
              max_length    :         3    
            ]    
          ]        ]      
allow\_nil? is true by default
	+ 
`:type` \(an `Ash.Type`\) - Required.

	+ 
`:allow_nil?` \(`boolean/0`\) - The default value is `true`.

	+ 
`:description` \(`String.t/0`\)

	+ 
`:constraints` \(`keyword/0`\) - The default value is `[]`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Module 

Stores a module as a string in the database.

A builtin type that can be referenced via `:module`.

### Constraints

+ 
`:behaviour` \(`atom/0`\) - Allows constraining the module a one which implements a behaviour

+ 
`:protocol` \(`atom/0`\) - Allows constraining the module a one which implements a protocol





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.NaiveDatetime 

Represents a Naive datetime

A builtin type that can be referenced via `:naive_datetime`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.NewType **behaviour** 

Allows defining a new type that is the combination of an existing type and custom constraints

A subtle difference between this type and its supertype \(one that will almost certainly not matter in any case\) is that we use the `apply_constraints` logic of the underlying type in the same step as `cast_input`. We do this because new types like these are, generally speaking, considering the constraint application as part of the core type. Other types, if you simply do `Ash.Type.cast_input/3` you will not be also applying their constraints.

## Options

+ `:subtype_of` - The type that this new type is a subtype of.
+ `:constraints` - The constraints that this new type uses for the underlying type.
+ `:lazy_init?` - If true, the `init/1` function will be called at runtime instead of compile time. Allows for recursive types.

For Example:

    defmodule         MyApp.Types.SSN         do    
          use         Ash.Type.NewType    ,         subtype_of    :         :string    ,         constraints    :         [    match    :         ~r/regex for ssn/    ]        end    
        defmodule         MyApp.Types.Metadata         do    
          use         Ash.Type.NewType    ,         subtype_of    :         :union    ,         constraints    :         [    types    :         [    
            foo    :         [    ...    ]    ,    
            bar    :         [    ...    ]    
          ]    ]        end





# Summary


## **Types** 


t\(\) 




## **Callbacks** 


lazy\_init?\(\) 


Whether or not the type is lazy initialized \(so needs to be initialized when fetching constraints\)




subtype\_constraints\(\) 


Returns the underlying subtype constraints




subtype\_of\(\) 


Returns the type that the NewType is a subtype of.




type\_constraints\(constraints, subtype\_constraints\) 


Returns the modified NewType constraints





## **Functions** 


constraints\(type, constraints\) 


Returns the constraints schema.




new\_type?\(type\) 


Returns true if the corresponding type is an Ash.Type.NewType




subtype\_of\(type\) 


Returns the type that the given newtype is a subtype of




# Types




# t\(\)




    @type     t() ::     module    () |     atom    () | {:array,     module    () |     atom    ()}





# Callbacks




# lazy\_init?\(\)




    @callback     lazy_init?() ::     boolean    ()


Whether or not the type is lazy initialized \(so needs to be initialized when fetching constraints\)





# subtype\_constraints\(\)




    @callback     subtype_constraints() ::     Keyword.t    ()


Returns the underlying subtype constraints





# subtype\_of\(\)




    @callback     subtype_of() ::     module    () |     atom    ()


Returns the type that the NewType is a subtype of.





# type\_constraints\(constraints, subtype\_constraints\)




    @callback     type_constraints(constraints ::     Keyword.t    (), subtype_constraints ::     Keyword.t    ()) ::
          Keyword.t    ()


Returns the modified NewType constraints





# Functions




# constraints\(type, constraints\)




    @spec     constraints(    Ash.Type.t    (),     Keyword.t    ()) ::     Keyword.t    ()


Returns the constraints schema.





# new\_type?\(type\)




    @spec     new_type?(    Ash.Type.t    ()) ::     boolean    ()


Returns true if the corresponding type is an Ash.Type.NewType





# subtype\_of\(type\)




    @spec     subtype_of(    t    ()) ::     Ash.Type.t    ()


Returns the type that the given newtype is a subtype of





# Ash.Type.String 

Stores a string in the database.

A built-in type that can be referenced via `:string`.

By default, values are trimmed and empty values are set to `nil`. You can use the `allow_empty?` and `trim?` constraints to change these behaviors.

### Constraints

+ 
`:max_length` \(`non_neg_integer/0`\) - Enforces a maximum length on the value

+ 
`:min_length` \(`non_neg_integer/0`\) - Enforces a minimum length on the value

+ 
`:match` \(`Regex.t/0`\) - Enforces that the string matches a passed in regex

+ 
`:trim?` \(`boolean/0`\) - Trims the value. The default value is `true`.

+ 
`:allow_empty?` \(`boolean/0`\) - If false, the value is set to `nil` if it's empty. The default value is `false`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Struct 

Represents a struct.

Use the `instance_of` constraint to specify that it must be an instance of a specific struct.

This cannot be loaded from a database unless the `instance_of` constraint is provided. If not, it can only be used to cast input, i.e for arguments.

## Alternative: Ash.TypedStruct

For simpler use cases where you want to define a struct with typed fields inline, consider using `Ash.TypedStruct`. It provides a DSL for defining structs with:

+ Field type specifications and constraints
+ Default values
+ Required fields \(via `allow_nil?: false`\)
+ Automatic `new/1` and `new!/1` functions

Example:

    defmodule         MyStruct         do    
          use         Ash.TypedStruct     
          typed_struct         do    
            field         :name    ,         :string    ,         allow_nil?    :         false    
            field         :age    ,         :integer    ,         constraints    :         [    min    :         0    ]    
            field         :email    ,         :string    ,         default    :         nil    
          end        end

`Ash.TypedStruct` automatically creates an `Ash.Type.Struct` with the appropriate constraints under the hood.

## Constraints

+ 
`:instance_of` \(`atom/0`\) - The module the struct should be an instance of

+ 
`:preserve_nil_values?` \(`boolean/0`\) - If set to true, when storing, nil values will be kept. Otherwise, nil values will be omitted. The default value is `false`.

+ 
`:fields` \(`keyword/0`\) - The types of the fields in the struct, and their constraints.  
For example: 

    fields    :          [    
          amount    :         [    
            type    :         :integer    ,    
            description    :         "The amount of the transaction"    ,    
            constraints    :         [    
              max    :         10    
            ]    
          ]    ,    
          currency    :         [    
            type    :         :string    ,    
            allow_nil?    :         false    ,    
            description    :         "The currency code of the transaction"    ,    
            constraints    :         [    
              max_length    :         3    
            ]    
          ]        ]      

allow\_nil? is true by default

	+ 
`:type` \(an `Ash.Type`\) - Required.

	+ 
`:allow_nil?` \(`boolean/0`\) - The default value is `true`.

	+ 
`:description` \(`String.t/0`\)

	+ 
`:constraints` \(`keyword/0`\) - The default value is `[]`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Term 

Represents a raw elixir term in the database

A builtin type that can be referenced via `:binary`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Time 

Represents a time in the database, with a 'second' precision

A builtin type that can be referenced via `:time`

### Constraints

+ `:precision` - Valid values are :microsecond, :second The default value is `:second`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.TimeUsec 

Represents a time with `microsecond` precision.

A builtin type that can be referenced via `:time_usec`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Tuple 

Represents a tuple stored in the data layer as a map.

A builtin type that can be referenced via `:tuple`

+ `:fields` \(`keyword/0`\) - Required. The types of the fields in the tuple, and their constraints.  
This type is stored as a map under the hood, keyed by the field name, and is represented in memory as a tuple.  
Example constraints: 
    constraints    :         fields    :          [    
                      amount    :         [    
                        type    :         :integer    ,    
                        description    :         "The amount of the transaction"    ,    
                        constraints    :         [    
                          max    :         10    
                        ]    
                      ]    ,    
                      currency    :         [    
                        type    :         :string    ,    
                        allow_nil?    :         false    ,    
                        description    :         "The currency code of the transaction"    ,    
                        constraints    :         [    
                          max_length    :         3    
                        ]    
                      ]    
                    ]      
`allow_nil?` is `true` by default.
	+ 
`:type` \(an `Ash.Type`\) - Required.

	+ 
`:allow_nil?` \(`boolean/0`\) - The default value is `true`.

	+ 
`:description` \(`String.t/0`\)

	+ 
`:constraints` \(`keyword/0`\) - The default value is `[]`.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.UUID 

Represents a UUID.

A builtin type that can be referenced via `:uuid`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.UUIDv7 

Represents a UUID.

A builtin type that can be referenced via `:uuid_v7`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Union 

A union between multiple types, distinguished with a tag or by attempting to validate.

Union types allow you to define attributes that can hold values of different types. There are two main strategies for distinguishing between types:

1. **Tagged unions** - Uses a specific field \(tag\) and value \(tag\_value\) to identify the type
2. **Untagged unions** - Attempts to cast the value against each type in order until one succeeds

## Basic Usage

Define a union type in an attribute:

    attribute         :content    ,         :union    ,    
          constraints    :         [    
            types    :         [    
              text    :         [    type    :         :string    ]    ,    
              number    :         [    type    :         :integer    ]    ,    
              flag    :         [    type    :         :boolean    ]    
            ]    
          ]

Values are wrapped in an `%Ash.Union{}` struct with `:type` and `:value` fields:

    # Reading union values        %    Ash.Union    {    type    :         :text    ,         value    :         "Hello"    }        %    Ash.Union    {    type    :         :number    ,         value    :         42    }

## Tagged Unions

Tagged unions use a discriminator field to identify the type. This is more reliable but requires the data to include the tag field:

    attribute         :data    ,         :union    ,    
          constraints    :         [    
            types    :         [    
              user    :         [    
                type    :         :map    ,    
                tag    :         :type    ,    
                tag_value    :         "user"    
              ]    ,    
              admin    :         [    
                type    :         :map    ,    
                tag    :         :type    ,    
                tag_value    :         "admin"    
              ]    
            ]    
          ]

Input data must include the tag field:

    # Valid inputs        %{    type    :         "user"    ,         name    :         "John"    ,         email    :         "john@example.com"    }        %{    type    :         "admin"    ,         name    :         "Jane"    ,         permissions    :         [    "read"    ,         "write"    ]    }

### Tag Options

+ `tag` - The field name to check \(e.g., `:type`, `:kind`, `:__type__`\)
+ `tag_value` - The expected value for this type \(string, atom, or nil\)
+ `cast_tag?` - Whether to include the tag in the final value \(default: `true`\)

When `cast_tag?: false`, the tag field is removed from the final value.

## Untagged Unions

Without tags, union types attempt to cast values against each type in order:

    attribute         :flexible    ,         :union    ,    
          constraints    :         [    
            types    :         [    
              integer    :         [    type    :         :integer    ]    ,    
              string    :         [    type    :         :string    ]    
            ]    
          ]

**Order matters\!** The first successful cast wins:

    # "42" would be cast as :integer (42), not :string ("42")        # if integer comes first in the types list

## Mixed Tagged and Untagged Types

You can mix tagged and untagged types within a single union. Tagged types are checked first by their tag values, and if no tagged type matches, untagged types are tried in order:

    attribute         :flexible_data    ,         :union    ,    
          constraints    :         [    
            types    :         [    
              # Tagged types - checked first by tag    
              user    :         [    
                type    :         :map    ,    
                tag    :         :type    ,    
                tag_value    :         "user"    
              ]    ,    
              admin    :         [    
                type    :         :map    ,    
                tag    :         :type    ,    
                tag_value    :         "admin"    
              ]    ,    
              # Untagged types - tried in order if no tag matches    
              number    :         [    type    :         :integer    ]    ,    
              text    :         [    type    :         :string    ]    
            ]    
          ]

This allows for both explicit type identification \(via tags\) and fallback casting:

    # Tagged - uses :type field to determine it's a user        %{    type    :         "user"    ,         name    :         "John"    }    
        # Untagged - tries :integer first, then :string        42                # -> %Ash.Union{type: :number, value: 42}        "hello"           # -> %Ash.Union{type: :text, value: "hello"}

## Storage Modes

Union values can be stored in different formats:

### **`:type_and_value`** \(default\)

Stores as a map with explicit type and value fields:

    # Stored as: %{"type" => "text", "value" => "Hello"}

### **`:map_with_tag`**

Stores the value directly \(requires all types to have tags\):

    # Stored as: %{"type" => "user", "name" => "John", "email" => "john@example.com"}    
        constraints    :         [    
          storage    :         :map_with_tag    ,    
          types    :         [    
            user    :         [    type    :         :map    ,         tag    :         :type    ,         tag_value    :         "user"    ]    ,    
            admin    :         [    type    :         :map    ,         tag    :         :type    ,         tag_value    :         "admin"    ]    
          ]        ]

## Embedded Resources

Union types work seamlessly with embedded resources:

    attribute         :contact_info    ,         :union    ,    
          constraints    :         [    
            types    :         [    
              email    :         [    
                type    :         EmailContact    ,    
                tag    :         :type    ,    
                tag_value    :         "email"    
              ]    ,    
              phone    :         [    
                type    :         PhoneContact    ,    
                tag    :         :type    ,    
                tag_value    :         "phone"    
              ]    
            ]    
          ]

## Arrays of Unions

Union types support arrays using the standard `{:array, :union}` syntax:

    attribute         :mixed_data    ,         {    :array    ,         :union    }    ,    
          constraints    :         [    
            items    :         [    
              types    :         [    
                text    :         [    type    :         :string    ]    ,    
                number    :         [    type    :         :integer    ]    
              ]    
            ]    
          ]

## Advanced Input Formats

Union types support multiple input formats for flexibility:

### Direct Union Struct

    %    Ash.Union    {    type    :         :text    ,         value    :         "Hello"    }

### Tagged Map \(when tags are configured\)

    %{    type    :         "text"    ,         content    :         "Hello"    }

### Explicit Union Format

    %{    
          "_union_type"         =>         "text"    ,    
          "_union_value"         =>         "Hello"        }    
        # Or with the value merged in        %{    
          "_union_type"         =>         "text"    ,    
          "content"         =>         "Hello"        }

## Nested Unions

Unions can contain other union types. All type names must be unique across the entire nested structure:

    types    :         [    
          simple    :         [    type    :         :string    ]    ,    
          complex    :         [    
            type    :         :union    ,    
            constraints    :         [    
              types    :         [    
                # Names must be unique - can't reuse 'simple'    
                nested_text    :         [    type    :         :string    ]    ,    
                nested_num    :         [    type    :         :integer    ]    
              ]    
            ]    
          ]        ]

## Loading and Calculations

Union types support loading related data when member types are loadable \(like embedded resources\):

    # Load through all union types        query         |>         Ash.Query    .    load    (    union_field    :         :*    )    
        # Load through specific type        query         |>         Ash.Query    .    load    (    union_field    :         [    user    :         [    :profile    ,         :preferences    ]    ]    )

## Error Handling

Union casting provides detailed error information:

+ **Tagged unions**: Clear errors when tags don't match expected values
+ **Untagged unions**: Aggregated errors from all attempted type casts
+ **Array unions**: Errors include index and path information for debugging

## NewType Integration

Create reusable union types with `Ash.Type.NewType`:

    defmodule         MyApp.Types.ContactMethod         do    
          use         Ash.Type.NewType    ,    
            subtype_of    :         :union    ,    
            constraints    :         [    
              types    :         [    
                email    :         [    type    :         :string    ,         constraints    :         [    match    :         ~r/@/    ]    ]    ,    
                phone    :         [    type    :         :string    ,         constraints    :         [    match    :         ~r/^+$/    ]    ]    
              ]    
            ]        end

## Performance Considerations

+ **Tagged unions** are more efficient as they avoid trial-and-error casting
+ **Type order matters** in untagged unions - put more specific types first
+ **Use constraints** on member types to fail fast on invalid data

## Constraints

+ 
`:storage` - How the value will be stored when persisted.  
`:type_and_value` will store the type and value in a map like so `{type: :type_name, value: the_value}` `:map_with_tag` will store the value directly. This only works if all types have a `tag` and `tag_value` configured. Valid values are :type\_and\_value, :map\_with\_tag The default value is `:type_and_value`.

+ 
`:include_source?` \(`boolean/0`\) - Whether to include the source changeset in the context. Defaults to the value of `config :ash, :include_embedded_source_by_default`, or `true`. In 4.x, the default will be `false`. The default value is `true`.

+ 
`:types` - The types to be unioned, a map of an identifier for the enum value to its configuration.  
When using `tag` and `tag_value` we are referring to a map key that must equal a certain value in order for the value to be considered an instance of that type.  
For example: 

    types    :          [    
          int    :         [    
            type    :         :integer    ,    
            constraints    :         [    
              max    :         10    
            ]    
          ]    ,    
          object    :         [    
            type    :         MyObjectType    ,    
            # The default value is `true`    
            # this passes the tag key/value to the nested type    
            # when casting input    
            cast_tag?    :         true    ,    
            tag    :         :type    ,    
            tag_value    :         "my_object"    
          ]    ,    
          other_object    :         [    
            type    :         MyOtherObjectType    ,    
            cast_tag?    :         true    ,    
            tag    :         :type    ,    
            tag_value    :         "my_other_object"    
          ]    ,    
          other_object_without_type    :         [    
            type    :         MyOtherObjectTypeWithoutType    ,    
            cast_tag?    :         false    ,    
            tag    :         :type    ,    
            tag_value    :         nil    
          ]        ]      

IMPORTANT:  
This is stored as a map under the hood. Filters over the data will need to take this into account.  
Additionally, if you are not using a tag, a value will be considered to be of the given type if it successfully casts. This means that, for example, if you try to cast `"10"` as a union of a string and an integer, it will end up as `"10"` because it is a string. If you put the integer type ahead of the string type, it will cast first and `10` will be the value.





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.UrlEncodedBinary 

Represents a binary that attempts to decode input strings as a url encoded base64 string.

A builtin type that can be referenced via `:url_encoded_binary`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.UtcDatetime 

Represents a utc datetime, with 'second' precision. A wrapper around `:datetime` for backwards compatibility.

A builtin type that can be referenced via `:utc_datetime`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.UtcDatetimeUsec 

Represents a utc datetime with `microsecond` precision. A wrapper around `:datetime` for backwards compatibility.

A builtin type that can be referenced via `:utc_datetime_usec`





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Type.Vector 

Represents a vector.

A builtin type that can be referenced via `:vector`.

### Constraints

+ `:dimensions` \(`integer/0`\) - The dimensions of the vector





# Summary


## **Functions** 


handle\_change?\(\) 



prepare\_change?\(\) 



# Functions




# handle\_change?\(\)





# prepare\_change?\(\)





# Ash.Error 

Tools and utilities used by Ash to manage and conform errors





# Summary


## **Types** 


ash\_error\(\) 



ash\_error\_subject\(\) 



class\(\) 



class\_module\(\) 



error\_class\(\) 



error\_input\(\) 



error\_keyword\(\) 



error\_keyword\_option\(\) 



path\(\) 



path\_input\(\) 



t\(\) 




## **Functions** 


ash\_error?\(value\) 


Returns whether or not a term is an Ash.Error type.




error\_descriptions\(errors\) 


Converts errors into a single `String.t`.




set\_path\(errors, path\) 


This function prepends the provided path to any existing path on the errors.




splode\_error?\(arg1, splode\) 



to\_ash\_error\(value, stacktrace \\\\ nil, opts \\\\ \[\]\) 


Converts a value to an Ash exception.




to\_error\_class\(value, opts \\\\ \[\]\) 


Converts a value to an Ash.Error type.




unwrap\!\(result, opts \\\\ nil\) 


Raises an error if the result is an error, otherwise returns the result




# Types




# ash\_error\(\)




    @type     ash_error() ::     Exception.t    ()





# ash\_error\_subject\(\)




    @type     ash_error_subject() ::     Ash.Changeset.t    () |     Ash.Query.t    () |     Ash.ActionInput.t    ()





# class\(\)




    @type     class() :: %{
      :__struct__ =>     class_module    (),
      :__exception__ => true,
      :errors => [    t    ()],
      :class =>     error_class    (),
      :bread_crumbs => [    String.t    ()],
      :vars =>     Keyword.t    (),
      :stacktrace =>     Splode.Stacktrace.t    () | nil,
      :context =>     map    (),
      optional(    atom    ()) =>     any    ()
    }





# class\_module\(\)




    @type     class_module() ::
      Ash.Error.Unknown
      | Ash.Error.Framework
      | Ash.Error.Invalid
      | Ash.Error.Forbidden





# error\_class\(\)




    @type     error_class() :: :unknown | :framework | :invalid | :forbidden





# error\_input\(\)




    @type     error_input() ::
          ash_error    ()
      |     error_keyword    ()
      |     String.t    ()
      |     ash_error_subject    ()
      |     Exception.t    ()
      |     any    ()





# error\_keyword\(\)




    @type     error_keyword() :: [    error_keyword_option    ()]





# error\_keyword\_option\(\)




    @type     error_keyword_option() ::
      {:field,     atom    ()}
      | {:fields, [    atom    ()]}
      | {:value,     term    ()}
      | {:message,     String.t    ()}
      | {:path, [    atom    () |     String.t    ()]}





# path\(\)




    @type     path() :: [    String.t    () |     atom    () |     integer    ()]





# path\_input\(\)




    @type     path_input() ::
      [    String.t    () |     atom    () |     integer    ()] |     String.t    () |     atom    () |     integer    ()





# t\(\)




    @type     t() :: %{
      :__struct__ =>     module    (),
      :__exception__ => true,
      :class =>     error_class    (),
      :bread_crumbs => [    String.t    ()],
      :vars =>     Keyword.t    (),
      :stacktrace =>     Splode.Stacktrace.t    () | nil,
      :context =>     map    (),
      optional(    atom    ()) =>     any    ()
    }





# Functions




# ash\_error?\(value\)




    @spec     ash_error?(    term    ()) ::     boolean    ()


Returns whether or not a term is an Ash.Error type.





# error\_descriptions\(errors\)




    @spec     error_descriptions(    term    () | [    term    ()]) ::     String.t    ()


Converts errors into a single `String.t`.





# set\_path\(errors, path\)




    @spec     set_path(    ash_error    () | [    ash_error    ()],     path_input    ()) ::
          ash_error    () | [    ash_error    ()]

    @spec     set_path(    ash_error_subject    (),     path_input    ()) ::     ash_error_subject    ()


This function prepends the provided path to any existing path on the errors.





# splode\_error?\(arg1, splode\)





# to\_ash\_error\(value, stacktrace \\\\ nil, opts \\\\ \[\]\)




    @spec     to_ash_error(
          error_input    () | [    error_input    ()],
          Exception.stacktrace    () | nil,
          Keyword.t    ()
    ) ::     ash_error    () | [    ash_error    ()]


Converts a value to an Ash exception.

The supported inputs to this function can be provided to various places, like `Ash.Query.add_error/2`, `Ash.Changeset.add_error/2` and `Ash.ActionInput.add_error/2`.

Additionally, any place that you can *return* an error you can return instead a valid error input.

See the error handling guide for more.





# to\_error\_class\(value, opts \\\\ \[\]\)




    @spec     to_error_class(
          ash_error_subject    () |     term    () | [    ash_error_subject    ()] | [    term    ()],
          Keyword.t    ()
    ) ::     t    ()


Converts a value to an Ash.Error type.





# unwrap\!\(result, opts \\\\ nil\)



Raises an error if the result is an error, otherwise returns the result

Alternatively, you can use the `defsplode` macro, which does this automatically.

### ******Options**

+ `:error_opts` - Options to pass to `to_error/2` when converting the returned error
+ `:unknown_error_opts` - Options to pass to the unknown error if the function returns only `:error`. not necessary if your function always returns `{:error, error}`.

### ******Examples**

def function\(arg\) do

    case         do_something    (    arg    )         do    
          :success         ->         :ok    
          {    :success    ,         result    }         ->         {    :ok    ,         result    }    
          {    :error    ,         error    }         ->         {    :error    ,         error    }        end

end

def function\!\(arg\) do

    YourErrors    .    unwrap!    (    function    (    arg    )    )

end





# Ash.Error.Action.InvalidArgument **exception** 

Used when an invalid value is provided for an action argument





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Action.InvalidArgument` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Action.InvalidArgument{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Action.InvalidArgument` without raising it.

## ******Keys**

+ :field
+ :message
+ :value





# Ash.Error.Changes.ActionRequiresActor **exception** 

Used when an actor is referenced in a filter template, but no actor exists





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Changes.ActionRequiresActor` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.ActionRequiresActor{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.ActionRequiresActor` without raising it.

## ******Keys**





# Ash.Error.Changes.InvalidArgument **exception** 

Used when an invalid value is provided for an action argument





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Changes.InvalidArgument` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.InvalidArgument{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.InvalidArgument` without raising it.

## ******Keys**

+ :field
+ :message
+ :value





# Ash.Error.Changes.InvalidAttribute **exception** 

Used when an invalid value is provided for an attribute change





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Changes.InvalidAttribute` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.InvalidAttribute{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      has_value?:     term    (),
      message:     term    (),
      path:     term    (),
      private_vars:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.InvalidAttribute` without raising it.

## ******Keys**

+ :field
+ :message
+ :private\_vars
+ :value
+ :has\_value?





# Ash.Error.Changes.InvalidChanges **exception** 

Used when a change is provided that covers multiple attributes/relationships





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Changes.InvalidChanges` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.InvalidChanges{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      fields:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      validation:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.InvalidChanges` without raising it.

## ******Keys**

+ :fields
+ :message
+ :validation
+ :value





# Ash.Error.Changes.InvalidRelationship **exception** 

Used when an invalid value is provided for a relationship change





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Changes.InvalidRelationship` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.InvalidRelationship{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      message:     term    (),
      path:     term    (),
      relationship:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.InvalidRelationship` without raising it.

## ******Keys**

+ :relationship
+ :message





# Ash.Error.Changes.NoSuchAttribute **exception** 

Used when a change is provided for an attribute that does not exist





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Changes.NoSuchAttribute` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.NoSuchAttribute{
      __exception__: true,
      attribute:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.NoSuchAttribute` without raising it.

## ******Keys**

+ :resource
+ :attribute





# Ash.Error.Changes.NoSuchRelationship **exception** 

Used when a change is provided for an relationship that does not exist





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Changes.NoSuchRelationship` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.NoSuchRelationship{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      relationship:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.NoSuchRelationship` without raising it.

## ******Keys**

+ :resource
+ :relationship





# Ash.Error.Changes.Required **exception** 

Used when an attribute or relationship is required





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Changes.Required` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.Required{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.Required` without raising it.

## ******Keys**

+ :field
+ :type
+ :resource





# Ash.Error.Changes.StaleRecord **exception** 

Used when a stale record is attempted to be updated or deleted





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Changes.StaleRecord` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Changes.StaleRecord{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      filter:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Changes.StaleRecord` without raising it.

## ******Keys**

+ :resource
+ :filter
+ :field





# Ash.Error.Exception 

Tooling for creating an Ash exception





# Summary


## **Functions** 


def\_ash\_error\(fields, opts \\\\ \[\]\) 



# Functions




# def\_ash\_error\(fields, opts \\\\ \[\]\)
\(macro\)   





# Ash.Error.Forbidden **exception** 

Used when authorization for an action fails





# Summary


## **Types** 


t\(\) 




## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden` without raising it.




message\(map\) 


Callback implementation for `Exception.message/1`.




# Types




# t\(\)




    @type     t() :: %Ash.Error.Forbidden{
      __exception__: true,
      action_input:     Ash.ActionInput.t    () | nil,
      bread_crumbs:     term    (),
      changeset:     Ash.Changeset.t    () | nil,
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     Ash.Query.t    () | nil,
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }





# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden{
      __exception__: true,
      action_input:     term    (),
      bread_crumbs:     term    (),
      changeset:     term    (),
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden` without raising it.

## ******Keys**

+ :changeset
+ :query
+ :action\_input
+ :errors





# message\(map\)



Callback implementation for `Exception.message/1`.





# Ash.Error.Forbidden.CannotFilterCreates **exception** 

Used when a create action would be filtered





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.CannotFilterCreates` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.CannotFilterCreates{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      filter:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.CannotFilterCreates` without raising it.

## ******Keys**

+ :filter





# Ash.Error.Forbidden.DomainRequiresActor **exception** 

Used when a domain that has `require_actor? true` is provided no actor





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.DomainRequiresActor` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.DomainRequiresActor{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      domain:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.DomainRequiresActor` without raising it.

## ******Keys**

+ :domain





# Ash.Error.Forbidden.DomainRequiresAuthorization **exception** 

Used when a domain that has `authorize :always` is provided authorize?: false





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.DomainRequiresAuthorization` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) ::
      %Ash.Error.Forbidden.DomainRequiresAuthorization{
        __exception__: true,
        bread_crumbs:     term    (),
        class:     term    (),
        domain:     term    (),
        path:     term    (),
        splode:     term    (),
        stacktrace:     term    (),
        vars:     term    ()
      }


Create an `Elixir.Ash.Error.Forbidden.DomainRequiresAuthorization` without raising it.

## ******Keys**

+ :domain





# Ash.Error.Forbidden.ForbiddenField **exception** 

Raised in cases where access to a specific field was prevented





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.ForbiddenField` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.ForbiddenField{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.ForbiddenField` without raising it.

## ******Keys**

+ :resource
+ :field





# Ash.Error.Forbidden.InitialDataRequired **exception** 

Used when initial data was not supplied when it was required





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.InitialDataRequired` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.InitialDataRequired{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      source:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.InitialDataRequired` without raising it.

## ******Keys**

+ :source





# Ash.Error.Forbidden.MustPassStrictCheck **exception** 

Used when unreachable code/conditions are reached in the framework





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.MustPassStrictCheck` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.MustPassStrictCheck{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.MustPassStrictCheck` without raising it.

## ******Keys**





# Ash.Error.Forbidden.Placeholder **exception** 

A placeholder exception that the user should never see





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.Placeholder` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.Placeholder{
      __exception__: true,
      authorizer:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.Placeholder` without raising it.

## ******Keys**

+ :authorizer





# Ash.Error.Forbidden.Policy **exception** 

Raised when policy authorization for an action fails





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Forbidden.Policy` without raising it.




get\_breakdown\(facts, filter, policies, opts \\\\ \[\]\) 


Print a report of an authorization failure from authorization information.




report\(forbidden\) 


Print a report of an authorization failure from a forbidden error




report\(error, opts \\\\ \[\]\) 



# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Forbidden.Policy{
      __exception__: true,
      action:     term    (),
      actor:     term    (),
      bread_crumbs:     term    (),
      changeset_doesnt_match_filter:     term    (),
      class:     term    (),
      context_description:     term    (),
      domain:     term    (),
      facts:     term    (),
      filter:     term    (),
      for_fields:     term    (),
      must_pass_strict_check?:     term    (),
      path:     term    (),
      policies:     term    (),
      policy_breakdown?:     term    (),
      resource:     term    (),
      scenarios:     term    (),
      solver_statement:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      subject:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Forbidden.Policy` without raising it.

## ******Keys**

+ :scenarios
+ :facts
+ :filter
+ :actor
+ :policy\_breakdown?
+ :must\_pass\_strict\_check?
+ :for\_fields
+ :subject
+ :context\_description
+ :policies
+ :resource
+ :solver\_statement
+ :domain
+ :action
+ :changeset\_doesnt\_match\_filter





# get\_breakdown\(facts, filter, policies, opts \\\\ \[\]\)



Print a report of an authorization failure from authorization information.

Options:

+ `:help_text?`: Defaults to true. Displays help text at the top of the policy breakdown.
+ `:success?`: Defaults to false. Changes the messaging/graphics around to indicate successful policy authorization.
+ `:must_pass_strict_check?`: Defaults to false. Adds a message about this authorization requiring passing strict check.





# report\(forbidden\)



Print a report of an authorization failure from a forbidden error

Options:

+ `:help_text?`: Defaults to true. Displays help text at the top of the policy breakdown.





# report\(error, opts \\\\ \[\]\)





# Ash.Error.Framework **exception** 

Used when an unknown/generic framework error occurs





# Summary


## **Types** 


t\(\) 




## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework` without raising it.




message\(map\) 


Callback implementation for `Exception.message/1`.




# Types




# t\(\)




    @type     t() :: %Ash.Error.Framework{
      __exception__: true,
      action_input:     Ash.ActionInput.t    () | nil,
      bread_crumbs:     term    (),
      changeset:     Ash.Changeset.t    () | nil,
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     Ash.Query.t    () | nil,
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }





# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework{
      __exception__: true,
      action_input:     term    (),
      bread_crumbs:     term    (),
      changeset:     term    (),
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework` without raising it.

## ******Keys**

+ :changeset
+ :query
+ :action\_input
+ :errors





# message\(map\)



Callback implementation for `Exception.message/1`.





# Ash.Error.Framework.AssumptionFailed **exception** 

Used when unreachable code/conditions are reached in the framework





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Framework.AssumptionFailed` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.AssumptionFailed{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.AssumptionFailed` without raising it.

## ******Keys**

+ :message





# Ash.Error.Framework.CanNotBeAtomic **exception** 

Used when a change that is only atomic cannot be done atomically





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework.CanNotBeAtomic` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.CanNotBeAtomic{
      __exception__: true,
      bread_crumbs:     term    (),
      change:     term    (),
      class:     term    (),
      path:     term    (),
      reason:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.CanNotBeAtomic` without raising it.

## ******Keys**

+ :resource
+ :change
+ :reason





# Ash.Error.Framework.FlagAssertionFailed **exception** 

Used when unreachable code/conditions are reached in the framework





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework.FlagAssertionFailed` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.FlagAssertionFailed{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      flag:     term    (),
      heading:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.FlagAssertionFailed` without raising it.

## ******Keys**

+ :flag
+ :heading





# Ash.Error.Framework.InvalidReturnType **exception** 

Used when a callback returns an invalid type





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Framework.InvalidReturnType` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.InvalidReturnType{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.InvalidReturnType` without raising it.

## ******Keys**

+ :message





# Ash.Error.Framework.MustBeAtomic **exception** 

Used when an action that must be atomic cannot be done atomically





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework.MustBeAtomic` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.MustBeAtomic{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      reason:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.MustBeAtomic` without raising it.

## ******Keys**

+ :resource
+ :action
+ :reason





# Ash.Error.Framework.PendingCodegen **exception** 

Used when an extension has pending code generation and the --check flag is provided





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework.PendingCodegen` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.PendingCodegen{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      diff:     term    (),
      explain:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.PendingCodegen` without raising it.

## ******Keys**

+ :diff
+ :explain





# Ash.Error.Framework.SynchronousEngineStuck **exception** 

Used when the sycnrhonous engine cannot proceed





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework.SynchronousEngineStuck` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.SynchronousEngineStuck{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.SynchronousEngineStuck` without raising it.

## ******Keys**





# Ash.Error.Framework.UnsupportedSubject **exception** 

Used when a subject is provided to a validation or preparation that it does not support





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Framework.UnsupportedSubject` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Framework.UnsupportedSubject{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      module:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      subject:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Framework.UnsupportedSubject` without raising it.

## ******Keys**

+ :subject
+ :module





# Ash.Error.Invalid **exception** 

The top level invalid error





# Summary


## **Types** 


t\(\) 




## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid` without raising it.




message\(map\) 


Callback implementation for `Exception.message/1`.




# Types




# t\(\)




    @type     t() :: %Ash.Error.Invalid{
      __exception__: true,
      action_input:     Ash.ActionInput.t    () | nil,
      bread_crumbs:     term    (),
      changeset:     Ash.Changeset.t    () | nil,
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     Ash.Query.t    () | nil,
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }





# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid{
      __exception__: true,
      action_input:     term    (),
      bread_crumbs:     term    (),
      changeset:     term    (),
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid` without raising it.

## ******Keys**

+ :changeset
+ :query
+ :action\_input
+ :errors





# message\(map\)



Callback implementation for `Exception.message/1`.





# Ash.Error.Invalid.ActionRequiresPagination **exception** 

Used when page option is passed but pagination is not enabled.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.ActionRequiresPagination` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.ActionRequiresPagination{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.ActionRequiresPagination` without raising it.

## ******Keys**

+ :resource
+ :action





# Ash.Error.Invalid.AtomicsNotSupported **exception** 

Used when atomics for the given action type are not not supported by the data layer, but one is used.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.AtomicsNotSupported` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.AtomicsNotSupported{
      __exception__: true,
      action_type:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.AtomicsNotSupported` without raising it.

## ******Keys**

+ :resource
+ :action\_type





# Ash.Error.Invalid.InvalidActionType **exception** 

Used when a callback returns an invalid type





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Invalid.InvalidActionType` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.InvalidActionType{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      expectation:     term    (),
      message:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.InvalidActionType` without raising it.

## ******Keys**

+ :message
+ :type
+ :expectation
+ :resource
+ :action





# Ash.Error.Invalid.InvalidCustomInput **exception** 

Used when an invalid value is provided for a code interface custom input





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Invalid.InvalidCustomInput` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.InvalidCustomInput{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.InvalidCustomInput` without raising it.

## ******Keys**

+ :field
+ :message
+ :value





# Ash.Error.Invalid.InvalidPrimaryKey **exception** 

Used when an invalid primary key is given to `Ash.get/2`





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.InvalidPrimaryKey` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.InvalidPrimaryKey{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.InvalidPrimaryKey` without raising it.

## ******Keys**

+ :resource
+ :value





# Ash.Error.Invalid.LimitRequired **exception** 

Used when no limit is provided, pagination is required, and no default page size is configured





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.LimitRequired` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.LimitRequired{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.LimitRequired` without raising it.

## ******Keys**





# Ash.Error.Invalid.MultipleResults **exception** 

Used when multiple results are returned in a case where only one result was expected





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.MultipleResults` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.MultipleResults{
      __exception__: true,
      at_least?:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      count:     term    (),
      path:     term    (),
      query:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.MultipleResults` without raising it.

## ******Keys**

+ :count
+ :at\_least?
+ :query





# Ash.Error.Invalid.NoIdentityFound **exception** 

Used when an identity name is used that does not reference identity on the resource





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NoIdentityFound` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NoIdentityFound{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      identity:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NoIdentityFound` without raising it.

## ******Keys**

+ :resource
+ :identity





# Ash.Error.Invalid.NoMatchingBulkStrategy **exception** 

Used when an identity name is used that does not reference identity on the resource





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NoMatchingBulkStrategy` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NoMatchingBulkStrategy{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      footer:     term    (),
      not_atomic_batches_reason:     term    (),
      not_atomic_reason:     term    (),
      not_stream_reason:     term    (),
      path:     term    (),
      requested_strategies:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NoMatchingBulkStrategy` without raising it.

## ******Keys**

+ :resource
+ :action
+ :requested\_strategies
+ :not\_stream\_reason
+ :not\_atomic\_batches\_reason
+ :not\_atomic\_reason
+ :footer





# Ash.Error.Invalid.NoPrimaryAction **exception** 

Used when an action name is provided that doesn't exist





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NoPrimaryAction` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NoPrimaryAction{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NoPrimaryAction` without raising it.

## ******Keys**

+ :resource
+ :type





# Ash.Error.Invalid.NoSuchAction **exception** 

Used when an action name is provided that doesn't exist





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NoSuchAction` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NoSuchAction{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NoSuchAction` without raising it.

## ******Keys**

+ :resource
+ :action
+ :type





# Ash.Error.Invalid.NoSuchInput **exception** 

Used when an input is provided to an action or calculation that is not accepted





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NoSuchInput` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NoSuchInput{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      calculation:     term    (),
      class:     term    (),
      did_you_mean:     term    (),
      input:     term    (),
      inputs:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NoSuchInput` without raising it.

## ******Keys**

+ :calculation
+ :resource
+ :action
+ :input
+ :inputs
+ :did\_you\_mean





# Ash.Error.Invalid.NoSuchResource **exception** 

Used when a resource or alias is provided that doesn't exist





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Invalid.NoSuchResource` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NoSuchResource{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      message:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NoSuchResource` without raising it.

## ******Keys**

+ :resource
+ :message





# Ash.Error.Invalid.NonCountableAction **exception** 

Used when page\[:count\] option is passed but the action's pagination is not countable.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NonCountableAction` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NonCountableAction{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NonCountableAction` without raising it.

## ******Keys**

+ :resource
+ :action





# Ash.Error.Invalid.NonStreamableAction **exception** 

Used when Ash.stream is used with an action that does not support keyset pagination





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.NonStreamableAction` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.NonStreamableAction{
      __exception__: true,
      action:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      for_bulk_destroy:     term    (),
      for_bulk_update:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      types:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.NonStreamableAction` without raising it.

## ******Keys**

+ :resource
+ :action
+ :for\_bulk\_update
+ :for\_bulk\_destroy
+ :types





# Ash.Error.Invalid.PaginationRequired **exception** 

Used when `page: false` is provided but pagination is required





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.PaginationRequired` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.PaginationRequired{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.PaginationRequired` without raising it.

## ******Keys**





# Ash.Error.Invalid.ResourceNotAllowed **exception** 

Used when a resource or alias is provided that cannot be used with the given domain





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.ResourceNotAllowed` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.ResourceNotAllowed{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      domain:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.ResourceNotAllowed` without raising it.

## ******Keys**

+ :resource
+ :domain





# Ash.Error.Invalid.TenantRequired **exception** 

Used when a tenant is not specified





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.TenantRequired` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.TenantRequired{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.TenantRequired` without raising it.

## ******Keys**

+ :resource





# Ash.Error.Invalid.Timeout **exception** 

Used when a request to a domain times out.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.Timeout` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.Timeout{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      name:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      timeout:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.Timeout` without raising it.

## ******Keys**

+ :name
+ :timeout





# Ash.Error.Invalid.TimeoutNotSupported **exception** 

Used when timeouts are not supported by the data layer, but one is set





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.TimeoutNotSupported` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.TimeoutNotSupported{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.TimeoutNotSupported` without raising it.

## ******Keys**

+ :resource





# Ash.Error.Invalid.Unavailable **exception** 

Used when a given resource is unavailable.

This might happen due to locking at the data layer, or something you implement yourself.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Invalid.Unavailable` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Invalid.Unavailable{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      reason:     term    (),
      resource:     term    (),
      source:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Invalid.Unavailable` without raising it.

## ******Keys**

+ :resource
+ :source
+ :reason





# Ash.Error.Load.InvalidQuery **exception** 

Used when an invalid query is provided in a load





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Load.InvalidQuery` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Load.InvalidQuery{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      load_path:     term    (),
      path:     term    (),
      query:     term    (),
      relationship:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Load.InvalidQuery` without raising it.

## ******Keys**

+ :resource
+ :relationship
+ :query
+ :load\_path





# Ash.Error.Load.NoSuchRelationship **exception** 

Used when attempting to load a relationship that does not exist





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Load.NoSuchRelationship` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Load.NoSuchRelationship{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      load_path:     term    (),
      path:     term    (),
      relationship:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Load.NoSuchRelationship` without raising it.

## ******Keys**

+ :resource
+ :relationship
+ :load\_path





# Ash.Error.Page.InvalidKeyset **exception** 

Used when a value is provided for a keyset that cannot be Base64 decoded.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Page.InvalidKeyset` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Page.InvalidKeyset{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      key:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Page.InvalidKeyset` without raising it.

## ******Keys**

+ :value
+ :key





# Ash.Error.Query.AggregatesNotSupported **exception** 

Used when the data\_layer does not support aggregates, or filtering/sorting them





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.AggregatesNotSupported` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.AggregatesNotSupported{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      feature:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.AggregatesNotSupported` without raising it.

## ******Keys**

+ :resource
+ :feature
+ :type





# Ash.Error.Query.CalculationRequiresPrimaryKey **exception** 

Used when a calculation requires a primary key but was not supplied with one





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.CalculationRequiresPrimaryKey` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) ::
      %Ash.Error.Query.CalculationRequiresPrimaryKey{
        __exception__: true,
        bread_crumbs:     term    (),
        calculation:     term    (),
        class:     term    (),
        path:     term    (),
        resource:     term    (),
        splode:     term    (),
        stacktrace:     term    (),
        vars:     term    ()
      }


Create an `Elixir.Ash.Error.Query.CalculationRequiresPrimaryKey` without raising it.

## ******Keys**

+ :resource
+ :calculation





# Ash.Error.Query.CalculationsNotSupported **exception** 

Used when the data\_layer does not support calculations, or filtering/sorting them





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.CalculationsNotSupported` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.CalculationsNotSupported{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      feature:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.CalculationsNotSupported` without raising it.

## ******Keys**

+ :resource
+ :feature





# Ash.Error.Query.InvalidArgument **exception** 

Used when an invalid value is provided for an action argument





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Query.InvalidArgument` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidArgument{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidArgument` without raising it.

## ******Keys**

+ :field
+ :message
+ :value





# Ash.Error.Query.InvalidCalculationArgument **exception** 

Used when an invalid value is provided for a calculation argument





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Query.InvalidCalculationArgument` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidCalculationArgument{
      __exception__: true,
      bread_crumbs:     term    (),
      calculation:     term    (),
      class:     term    (),
      field:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidCalculationArgument` without raising it.

## ******Keys**

+ :calculation
+ :field
+ :message
+ :value





# Ash.Error.Query.InvalidExpression **exception** 

Used when an invalid expression is used in a filter





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Query.InvalidExpression` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidExpression{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      expression:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidExpression` without raising it.

## ******Keys**

+ :expression
+ :message





# Ash.Error.Query.InvalidFilterReference **exception** 

Used when an invalid reference is used in a filter





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.InvalidFilterReference` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidFilterReference{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      path:     term    (),
      simple_equality?:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidFilterReference` without raising it.

## ******Keys**

+ :field
+ :simple\_equality?





# Ash.Error.Query.InvalidFilterValue **exception** 

Used when an invalid value is provided for a filter





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Query.InvalidFilterValue` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidFilterValue{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      context:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidFilterValue` without raising it.

## ******Keys**

+ :message
+ :value
+ :context





# Ash.Error.Query.InvalidLimit **exception** 

Used when an invalid limit is provided





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.InvalidLimit` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidLimit{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      limit:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidLimit` without raising it.

## ******Keys**

+ :limit





# Ash.Error.Query.InvalidLoad **exception** 

Used when an invalid load is provided





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.InvalidLoad` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidLoad{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      load:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidLoad` without raising it.

## ******Keys**

+ :load





# Ash.Error.Query.InvalidOffset **exception** 

Used when an invalid offset is provided





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.InvalidOffset` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidOffset{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      offset:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidOffset` without raising it.

## ******Keys**

+ :offset





# Ash.Error.Query.InvalidPage **exception** 

Used when an invalid page option is provided





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.InvalidPage` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidPage{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      page:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidPage` without raising it.

## ******Keys**

+ :page





# Ash.Error.Query.InvalidQuery **exception** 

A generic error that can be used to add an error to a query for a specific field





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Query.InvalidQuery` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidQuery{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      fields:     term    (),
      message:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidQuery` without raising it.

## ******Keys**

+ :field
+ :fields
+ :message
+ :value





# Ash.Error.Query.InvalidSortOrder **exception** 

Used when an invalid sort order is provided





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.InvalidSortOrder` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.InvalidSortOrder{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      order:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.InvalidSortOrder` without raising it.

## ******Keys**

+ :order





# Ash.Error.Query.LockNotSupported **exception** 

Used when the data\_layer does not support a given lock type





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.LockNotSupported` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.LockNotSupported{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      lock_type:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.LockNotSupported` without raising it.

## ******Keys**

+ :resource
+ :lock\_type





# Ash.Error.Query.NoComplexSortsWithKeysetPagination **exception** 

Due to the filter-based implementation of keyset pagination, it cannot be used with sorts on calculations.

We could solve this problem by making the keyset only be the primary key of the record, and then fetching that value loading the calculations/aggregates that we need. If we do this we should either: 1.\) make it a new pagination mode or 2.\) add an option like `mode: :strict | :fetch` to pagination options.

Let me know if you're reading this and want to help implement it.





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoComplexSortsWithKeysetPagination` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) ::
      %Ash.Error.Query.NoComplexSortsWithKeysetPagination{
        __exception__: true,
        bread_crumbs:     term    (),
        class:     term    (),
        path:     term    (),
        resource:     term    (),
        sort:     term    (),
        splode:     term    (),
        stacktrace:     term    (),
        vars:     term    ()
      }


Create an `Elixir.Ash.Error.Query.NoComplexSortsWithKeysetPagination` without raising it.

## ******Keys**

+ :resource
+ :sort





# Ash.Error.Query.NoReadAction **exception** 

Used when a resource would be read but has no read action





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoReadAction` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoReadAction{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    (),
      when:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoReadAction` without raising it.

## ******Keys**

+ :resource
+ :when





# Ash.Error.Query.NoSuchAttribute **exception** 

Used when an attribute that doesn't exist is used in a query





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoSuchAttribute` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoSuchAttribute{
      __exception__: true,
      attribute:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoSuchAttribute` without raising it.

## ******Keys**

+ :resource
+ :attribute





# Ash.Error.Query.NoSuchField **exception** 

Used when a field\(attribute, calculation, aggregate or relationship\) that doesn't exist is used in a query





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoSuchField` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoSuchField{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoSuchField` without raising it.

## ******Keys**

+ :resource
+ :field





# Ash.Error.Query.NoSuchFilterPredicate **exception** 

Used when a filter predicate that does not exist is referenced





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.Query.NoSuchFilterPredicate` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoSuchFilterPredicate{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      key:     term    (),
      message:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoSuchFilterPredicate` without raising it.

## ******Keys**

+ :message
+ :value
+ :key
+ :resource





# Ash.Error.Query.NoSuchFunction **exception** 

Used when an function that doesn't exist is used in a query





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoSuchFunction` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoSuchFunction{
      __exception__: true,
      arity:     term    (),
      bread_crumbs:     term    (),
      class:     term    (),
      could_be_calculation?:     term    (),
      function:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoSuchFunction` without raising it.

## ******Keys**

+ :function
+ :arity
+ :resource
+ :could\_be\_calculation?





# Ash.Error.Query.NoSuchOperator **exception** 

Used when an operator that doesn't exist is used in a query





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoSuchOperator` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoSuchOperator{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      operator:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoSuchOperator` without raising it.

## ******Keys**

+ :operator





# Ash.Error.Query.NoSuchRelationship **exception** 

Used when an relationship that doesn't exist is used in a query





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NoSuchRelationship` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NoSuchRelationship{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      relationship:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NoSuchRelationship` without raising it.

## ******Keys**

+ :resource
+ :relationship





# Ash.Error.Query.NotFound **exception** 

Used when an entity that not exist is referenced





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.NotFound` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.NotFound{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      primary_key:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.NotFound` without raising it.

## ******Keys**

+ :primary\_key
+ :resource





# Ash.Error.Query.ReadActionRequired **exception** 

Used when a relationship is filtered and the destination does not have a default read action





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.ReadActionRequired` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.ReadActionRequired{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.ReadActionRequired` without raising it.

## ******Keys**

+ :resource





# Ash.Error.Query.ReadActionRequiresActor **exception** 

Used when an actor is referenced in a filter template, but no actor exists





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.ReadActionRequiresActor` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.ReadActionRequiresActor{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.ReadActionRequiresActor` without raising it.

## ******Keys**





# Ash.Error.Query.Required **exception** 

Used when a filter or argument is required in a query





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.Required` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.Required{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.Required` without raising it.

## ******Keys**

+ :field
+ :type
+ :resource





# Ash.Error.Query.UnsortableField **exception** 

Used when attempting to sort on a field that cannot be used for sorting





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.UnsortableField` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.UnsortableField{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      field:     term    (),
      path:     term    (),
      reason:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.UnsortableField` without raising it.

## ******Keys**

+ :resource
+ :field
+ :reason





# Ash.Error.Query.UnsupportedPredicate **exception** 

Used when the data\_layer does not support a provided predicate





# Summary


## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Query.UnsupportedPredicate` without raising it.




# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Query.UnsupportedPredicate{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      path:     term    (),
      predicate:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      type:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Query.UnsupportedPredicate` without raising it.

## ******Keys**

+ :resource
+ :predicate
+ :type





# Ash.Error.SimpleDataLayer.NoDataProvided **exception** 

Used when no data was provided to the simple data layer





# Summary


## **Functions** 


exception\(msg\) 


Create an `Elixir.Ash.Error.SimpleDataLayer.NoDataProvided` without raising it.




# Functions




# exception\(msg\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.SimpleDataLayer.NoDataProvided{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      message:     term    (),
      path:     term    (),
      resource:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.SimpleDataLayer.NoDataProvided` without raising it.

## ******Keys**

+ :resource
+ :message





# Ash.Error.Stacktrace 

A placeholder for a stacktrace so that we can avoid printing it everywhere





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Error.Stacktrace{stacktrace:     list    ()}





# Ash.Error.Unknown **exception** 

The top level unknown error container





# Summary


## **Types** 


t\(\) 




## **Functions** 


exception\(args\) 


Construction an exception using the arguments passed in. You can see Elixir's doc on `Exception/1` for more information.




message\(map\) 


Callback implementation for `Exception.message/1`.




# Types




# t\(\)




    @type     t() :: %Ash.Error.Unknown{
      __exception__: true,
      action_input:     Ash.ActionInput.t    () | nil,
      bread_crumbs:     term    (),
      changeset:     Ash.Changeset.t    () | nil,
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     Ash.Query.t    () | nil,
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }





# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Unknown{
      __exception__: true,
      action_input:     term    (),
      bread_crumbs:     term    (),
      changeset:     term    (),
      class:     term    (),
      errors:     term    (),
      path:     term    (),
      query:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      vars:     term    ()
    }

    @spec     exception(    Keyword.t    ()) ::     t    ()


Construction an exception using the arguments passed in. You can see Elixir's doc on `Exception/1` for more information.





# message\(map\)



Callback implementation for `Exception.message/1`.





# Ash.Error.Unknown.UnknownError **exception** 

Used when an unknown error occurs





# Summary


## **Types** 


t\(\) 




## **Functions** 


exception\(args\) 


Create an `Elixir.Ash.Error.Unknown.UnknownError` without raising it.




# Types




# t\(\)




    @type     t() :: %Ash.Error.Unknown.UnknownError{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      error:     binary    () | nil,
      field:     term    () | nil,
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    () | nil,
      vars:     term    ()
    }





# Functions




# exception\(args\)




    @spec     exception(opts ::     Keyword.t    ()) :: %Ash.Error.Unknown.UnknownError{
      __exception__: true,
      bread_crumbs:     term    (),
      class:     term    (),
      error:     term    (),
      field:     term    (),
      path:     term    (),
      splode:     term    (),
      stacktrace:     term    (),
      value:     term    (),
      vars:     term    ()
    }


Create an `Elixir.Ash.Error.Unknown.UnknownError` without raising it.

## ******Keys**

+ :error
+ :field
+ :value





# Ash.DataLayer.Verifiers.RequirePreCheckWith 

Ensures that all identities have a `pre_check_with` configured, or raises.





# Ash.Notifier.PubSub.Verifiers.VerifyActionNames 

Verifies action names in configured publications





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Domain.Verifiers.EnsureNoEmbeds 

Ensures that all resources for a given domain are not embeds.





# Ash.Domain.Verifiers.ValidateArgumentsToCodeInterface 

Validate the arguments defined in the code interface and reject arguments that are not action attributes/arguments





# Ash.Domain.Verifiers.ValidateRelatedResourceInclusion 

Ensures that all related resources are included in a domain.





# Ash.Policy.Authorizer.Transformers.AddMissingFieldPolicies 

Adds field policies for any missing fields





# Summary


## **Functions** 


after?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Policy.Authorizer.Transformers.CacheFieldPolicies 

Cache field policies for each field





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.AttributesByName 

Persists attribute\_names and attributes\_by\_name.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.BelongsToAttribute 

Creates the attribute for belongs\_to relationships that have `define_attribute?: true`





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.CacheActionInputs 

Stores the set of valid input keys for each action





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.CacheCalculations 

Persists commonly used calculation information.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.CachePrimaryKey 

Validates and caches the primary key of a resource





# Summary


## **Functions** 


after?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.CacheRelationships 

Persists commonly used relationship information.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.CacheUniqueKeys 

Stores the set of unique keys for a resource





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.CreateJoinRelationship 

Creates an automatically named `has_many` relationship for each many\_to\_many.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.DefaultAccept 

Sets the default `accept` for each action





# Summary


## **Functions** 


after?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.GetByReadActions 

Transform any read actions which contain a `get_by` option.





# Summary


## **Functions** 


after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




# Functions




# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# Ash.Resource.Transformers.HasDestinationField 

Guesses the `destination_attribute` for has many and has one relationships unless provided





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.ManyToManyDestinationAttributeOnJoinResource 

Guesses the `destination_attribute_on_join_resource` for many to many relationships unless provided.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.ManyToManySourceAttributeOnJoinResource 

Guesses the `source_attribute_on_join_resource` for many to many relationships unless provided.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.RequireUniqueActionNames 

Ensures that all actions have unique names.





# Summary


## **Functions** 


after?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.RequireUniqueFieldNames 

Confirms that a resource does not have multiple fields\(attributes, calculations, aggregates, and relationships\) with the same name.





# Summary


## **Functions** 


after?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.SetPrimaryActions 

Validates the primary action configuration

If multiple primary actions exist this results in an error.





# Summary


## **Functions** 


after?\(arg1\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(arg1\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.SetRelationshipSource 

Sets the `source` key on relationships to be the resource they were defined on





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Transformers.ValidationsAndChangesForType 

Persists global changes/validations and what type they go on.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




before?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.before?/1`.




transform\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Transformer.transform/1`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# before?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.before?/1`.





# transform\(dsl\_state\)



Callback implementation for `Spark.Dsl.Transformer.transform/1`.





# Ash.Resource.Verifiers.EnsureAggregateFieldIsAttributeOrCalculation 

Ensures that the field at the end of the path is an attribute or calculation.





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.NoReservedFieldNames 

Confirms that a resource does not use reserved names for field names.

Reserved field names are: \[:**struct**, :**meta**, :**metadata**, :**order**, :**lateral\_join\_source**, :\*, :calculations, :aggregates, :relationships, :as\].





# Summary


## **Functions** 


verify\(dsl\_state\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\_state\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.ValidateAccept 

Validates that accept and reject lists only contain valid attributes





# Ash.Resource.Verifiers.ValidateActionTypesSupported 

Confirms that all action types declared on a resource are supported by its data layer





# Ash.Resource.Verifiers.ValidateAggregatesSupported 

Confirms that all aggregates are supported by the data layer





# Ash.Resource.Verifiers.ValidateArgumentsToCodeInterface 

Validate the arguments defined in the code interface and reject arguments that are not action attributes/arguments





# Summary


## **Functions** 


verify\_interface\!\(interface, action, attributes, module\) 



# Functions




# verify\_interface\!\(interface, action, attributes, module\)





# Ash.Resource.Verifiers.ValidateEagerIdentities 

Confirms that eager identities are not declared on a resource with no primary read.





# Ash.Resource.Verifiers.ValidateManagedRelationshipOpts 

Confirms that all action types declared on a resource are supported by its data layer





# Ash.Resource.Verifiers.ValidateMultitenancy 

Ensures that the multitenancy configuration is valid for the given resource





# Ash.Resource.Verifiers.ValidatePrimaryKey 

Validates and caches the primary key of a resource





# Ash.Resource.Verifiers.ValidateRelationshipAttributes 

Validates that all relationships point to valid fields





# Ash.Resource.Verifiers.ValidateRelationshipAttributesMatch 

Shows a warning on potentially incompatible relationship attributes.





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifyActionsAtomic 

Raises an error on update or destroy actions with `require_atomic?` set to true when it is known at compile time that they will not be atomic.





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifyGenericActionReactorInputs 

Returns an error if a generic action calls a Reactor module without specifying an argument for all expected inputs.





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifyIdentityFields 

Raises an error on potentially incompatible identity attributes.





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifyPrimaryKeyPresent 

Raises an error when a required primary key is missing





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifyPrimaryReadActionHasNoArguments 

Verifies that primary read actions do not have any arguments





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifyReservedCalculationArguments 

Verifies that standard context keys are not used as calculation arguments





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Resource.Verifiers.VerifySelectedByDefault 

Raises an error when a required primary key is missing





# Summary


## **Functions** 


verify\(dsl\) 


Callback implementation for `Spark.Dsl.Verifier.verify/1`.




# Functions




# verify\(dsl\)



Callback implementation for `Spark.Dsl.Verifier.verify/1`.





# Ash.Filter.Predicate **behaviour** 

Represents a predicate which can be simplified and/or compared with other predicates

Simplification and comparison will need more documentation, but ultimately it is the logic that allows us to have a flexible and powerful authorization system.





# Summary


## **Types** 


comparison\(\) 



predicate\(\) 




## **Callbacks** 


bulk\_compare\(list\) 


As long as at least one predicate of the type defined in your module, \(and this callback is implemented\), it will be called with all of the other predicates present in a filter. The return value is relatively complex, but it should be a list of boolean statements. E.g. `{op, left, right}` and `{:not, predicate}` \(nested as deep as necessary\).




compare\(predicate, predicate\) 


Compare two predicates. If possible, use `bulk_compare/1` instead




simplify\(predicate\) 


Simplify to a more primitive statement.





## **Functions** 


compare\(same, same\) 


Checks with each predicate module to see if it has a comparison with




# Types




# comparison\(\)




    @type     comparison() ::
      :unknown
      | :right_includes_left
      | :left_includes_right
      | :mutually_inclusive
      | :mutually_exclusive





# predicate\(\)




    @type     predicate() ::     struct    ()





# Callbacks




# bulk\_compare\(list\)
\(optional\)   



    @callback     bulk_compare([    predicate    ()]) ::     term    ()


As long as at least one predicate of the type defined in your module, \(and this callback is implemented\), it will be called with all of the other predicates present in a filter. The return value is relatively complex, but it should be a list of boolean statements. E.g. `{op, left, right}` and `{:not, predicate}` \(nested as deep as necessary\).

The best way to do it is to find lists of predicates that are mutually exclusive or mutually inclusive, and pass those lists into `Ash.SatSolver.mutually_exclusive/1` and `Ash.SatSolver.mutually_inclusive/1`





# compare\(predicate, predicate\)
\(optional\)   



    @callback     compare(    predicate    (),     predicate    ()) ::     comparison    ()


Compare two predicates. If possible, use `bulk_compare/1` instead





# simplify\(predicate\)
\(optional\)   



    @callback     simplify(    predicate    ()) ::     term    ()


Simplify to a more primitive statement.

For example, `x in [1, 2]` simplifies to `x == 1 or x == 2`. Simplifying to filter expressions that already have comparisons lets you avoid writing that logic for a given predicate.





# Functions




# compare\(same, same\)



Checks with each predicate module to see if it has a comparison with





# Ash.Query.BooleanExpression 

Represents a boolean expression





# Summary


## **Functions** 


new\(op, left, right\) 



optimized\_new\(op, left, right\) 



# Functions




# new\(op, left, right\)





# optimized\_new\(op, left, right\)





# Ash.Query.Call 

Represents a function call/AST node in an Ash query expression





# Ash.Query.Exists 

Determines if a given related entity exists.





# Summary


## **Functions** 


can\_return\_nil?\(\_\) 



new\(path, expr, at\_path \\\\ \[\]\) 



# Functions




# can\_return\_nil?\(\_\)





# new\(path, expr, at\_path \\\\ \[\]\)





# Ash.Query.Function **behaviour** 

A function is a predicate with an arguments list.

For more information on being a predicate, see `Ash.Filter.Predicate`. Most of the complexities are there. A function must meet both behaviours.





# Summary


## **Types** 


arg\(\) 




## **Callbacks** 


args\(\) 


The number and types of arguments supported.




can\_return\_nil?\(func\) 


Whether or not the function return nil.




eager\_evaluate?\(\) 


Whether or not the function can be evaluated eagerly. For example, `now()` cannot be.




evaluate\(func\) 


Evaluate a function when all arguments are known valid values




evaluate\_nil\_inputs?\(\) 


If `true`, will be allowed to evaluate `nil` inputs.




name\(\) 


The name of the function




new\(list\) 


Instantiate a new function with the provided arguments




partial\_evaluate\(func\) 


Evaluate a function when some or no arguments are known valid values




predicate?\(\) 


Whether or not the function is a predicate \(takes a reference as the first argument, a value as the second, and returns a boolean\)




private?\(\) 


Whether or not the function should be usable when parsing input.




returns\(\) 


The return type for each corresponding set of args.





## **Functions** 


evaluate\(func\) 


Evaluate the operator with provided inputs




new\(mod, args\) 



ordinal\(num\) 


Attaches the appropriate suffix to refer to an ordinal number, e.g 1 -> "1st"




try\_cast\_arguments\(configured\_args, args\) 



# Types




# arg\(\)




    @type     arg() ::     any    ()





# Callbacks




# args\(\)




    @callback     args() :: [    arg    ()] | :var_args


The number and types of arguments supported.





# can\_return\_nil?\(func\)




    @callback     can_return_nil?(func ::     map    ()) ::     boolean    ()


Whether or not the function return nil.





# eager\_evaluate?\(\)




    @callback     eager_evaluate?() ::     boolean    ()


Whether or not the function can be evaluated eagerly. For example, `now()` cannot be.





# evaluate\(func\)




    @callback     evaluate(func ::     map    ()) :: :unknown | {:known,     term    ()} | {:error,     term    ()}


Evaluate a function when all arguments are known valid values





# evaluate\_nil\_inputs?\(\)




    @callback     evaluate_nil_inputs?() ::     boolean    ()


If `true`, will be allowed to evaluate `nil` inputs.

If `false` \(the default\), any `nil` inputs will cause a `nil` return.





# name\(\)




    @callback     name() ::     atom    ()


The name of the function





# new\(list\)




    @callback     new([    term    ()]) :: {:ok,     term    ()} | {:error,     String.t    () |     Exception.t    ()}


Instantiate a new function with the provided arguments





# partial\_evaluate\(func\)
\(optional\)   



    @callback     partial_evaluate(func) :: {:ok, func} | {:error,     term    ()} when func:     map    ()


Evaluate a function when some or no arguments are known valid values





# predicate?\(\)




    @callback     predicate?() ::     boolean    ()


Whether or not the function is a predicate \(takes a reference as the first argument, a value as the second, and returns a boolean\)





# private?\(\)




    @callback     private?() ::     boolean    ()


Whether or not the function should be usable when parsing input.





# returns\(\)




    @callback     returns() ::
      [    Ash.Type.t    () | {    Ash.Type.t    (), constraints ::     Keyword.t    ()}]
      |     Ash.Type.t    ()
      | {    Ash.Type.t    (), constraints ::     Keyword.t    ()}
      | :unknown


The return type for each corresponding set of args.





# Functions




# evaluate\(func\)



Evaluate the operator with provided inputs





# new\(mod, args\)





# ordinal\(num\)



Attaches the appropriate suffix to refer to an ordinal number, e.g 1 -> "1st"





# try\_cast\_arguments\(configured\_args, args\)





# Ash.Query.Not 

Represents the negation of the contained expression





# Summary


## **Functions** 


new\(expression\) 



# Functions




# new\(expression\)





# Ash.Query.Operator **behaviour** 

An operator is a predicate with a `left` and a `right`

For more information on being a predicate, see `Ash.Filter.Predicate`. Most of the complexities are there. An operator must meet both behaviours.





# Summary


## **Callbacks** 


can\_return\_nil?\(func\) 


Whether or not the operator can evaluate to nil.




evaluate\(term\) 


Evaluates the operator in Elixir




evaluate\_nil\_inputs?\(\) 


If `true`, will be allowed to evaluate `nil` inputs.




new\(term, term\) 


Create a new predicate. There are various return types possible




predicate?\(\) 



returns\(\) 


The types that the expression can return. Should be one entry in the list for each entry in `types`.




to\_string\(struct, t\) 


The implementation of the inspect protocol.




types\(\) 


The types accepted by the operator. Defaults to `[:same, :any]`, which is any values of the same type.





## **Functions** 


evaluate\(op\) 


Evaluate the operator with provided inputs




new\(mod, left, right\) 


Create a new operator. Pass the module and the left and right values




operator\_overloads\(operator\) 


Get type overloads for the given operator




operator\_symbols\(\) 



operators\(\) 



# Callbacks




# can\_return\_nil?\(func\)




    @callback     can_return_nil?(func ::     map    ()) ::     boolean    ()


Whether or not the operator can evaluate to nil.





# evaluate\(term\)




    @callback     evaluate(    term    ()) ::     term    ()


Evaluates the operator in Elixir





# evaluate\_nil\_inputs?\(\)




    @callback     evaluate_nil_inputs?() ::     boolean    ()


If `true`, will be allowed to evaluate `nil` inputs.

If `false` \(the default\), any `nil` inputs will cause a `nil` return.





# new\(term, term\)




    @callback     new(    term    (),     term    ()) ::
      {:ok,     term    (),     term    ()} | {:ok,     term    ()} | {:known,     boolean    ()} | {:error,     term    ()}


Create a new predicate. There are various return types possible:

+ `{:ok, left, right}` - Return the left/right values of the operator
+ `{:ok, operator}` - Return the operator itself, this or the one above are acceptable
+ `{:known, boolean}` - If the value is already known, e.g `1 == 1`
+ `{:error, error}` - If there was an error creating the operator





# predicate?\(\)




    @callback     predicate?() ::     boolean    ()





# returns\(\)




    @callback     returns() :: [
      :any | :same |     Ash.Type.t    () | {    Ash.Type.t    (), constraints ::     Keyword.t    ()}
    ]


The types that the expression can return. Should be one entry in the list for each entry in `types`.





# to\_string\(struct, t\)




    @callback     to_string(
          struct    (),
          Inspect.Opts.t    ()
    ) ::     term    ()


The implementation of the inspect protocol.

If not defined, it will be inferred





# types\(\)




    @callback     types() :: [
      :any | :same | [    Ash.Type.t    () | {    Ash.Type.t    (), constraints ::     Keyword.t    ()}]
    ]


The types accepted by the operator. Defaults to `[:same, :any]`, which is any values of the same type.





# Functions




# evaluate\(op\)



Evaluate the operator with provided inputs





# new\(mod, left, right\)



Create a new operator. Pass the module and the left and right values





# operator\_overloads\(operator\)



Get type overloads for the given operator





# operator\_symbols\(\)





# operators\(\)





# Ash.Query.Parent 

Used to access values from the "source" of a given expression.

This is used in cases where expressions are given for some relationship path, for example:any\(\)

         has_many         :foo    ,         Foo         do    
           filter         expr    (    priority         ==         :foo         and         type         ==         parent    (    foo_type    )    )    
         end

This is supported on a case by case basis by a given data layer and in specific usages.





# Summary


## **Functions** 


new\(expr\) 



# Functions




# new\(expr\)





# Ash.Query.Ref 

Represents a relation/attribute reference





# Summary


## **Functions** 


name\(ref\) 


Returns the referenced field




# Functions




# name\(ref\)



Returns the referenced field





# Ash.Query.Function.Ago 

Subtracts the given interval or Duration from the current time in UTC.

For example: deleted\_at > ago\(7, :day\) deleted\_at > ago\(Duration.new\!\(day: 7\)\)

Documentation \+ available intervals inspired by the corresponding ecto interval implementation





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




datetime\_add\(datetime, duration\) 



# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# datetime\_add\(datetime, duration\)





# Ash.Query.Function.At 

Gets an element in the list by index





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.CompositeType 

Constructs a composite type in a way that is natively understood by the data layer

To do this, provide a tuple matching the format expected by the type in question. Check that type's documentation for this information.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Contains 

Returns true if the first string contains the second.

Case insensitive strings are accounted for on either side.

contains\("foo", "fo"\) true

contains\(%Ash.CiString\{:string "foo"\}, "FoO"\) true

contains\("foo", %Ash.CiString\{:string "FOO"\}\) true





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.CountNils 

Returns the count of nil.

    count_nil    (    [    nil    ,         1    ,         nil    ]    )         # 2





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.DateAdd 

Adds the given interval or Duration to the current time in UTC Adds the given interval or Duration to the current time in UTC

For example: activates\_at < date\_add\(today\(\), 7, :day\) activates\_at < date\_add\(today\(\), Duration.new\!\(day: 7\)\) activates\_at < date\_add\(today\(\), Duration.new\!\(day: 7\)\)

Documentation \+ available intervals inspired by the corresponding ecto interval implementation





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.DateTimeAdd 

Adds the given interval or Duration to the current time in UTC

For example: activates\_at < datetime\_add\(now\(\), 7, :day\) activates\_at < datetime\_add\(now\(\), Duration.new\!\(day:7\)\)

Documentation \+ available intervals inspired by the corresponding ecto interval implementation





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Error 

If the predicate is truthy, the provided exception is raised with the provided values.

This exception is not "raised" in the Elixir sense, but the entire expression fails to evaluate with the given error. Various data layers will handle this differently.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Fragment 

Adds the given interval from the current time in UTC.

For example: expires\_at < from\_now\(7, :day\)

Documentation \+ available intervals inspired by the corresponding ecto interval implementation





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




casted\_new\(list\) 



# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# casted\_new\(list\)





# Ash.Query.Function.FromNow 

Adds the given interval or Duration from the current time in UTC.

For example: expires\_at < from\_now\(7, :day\) expires\_at < from\_now\(Duration.new\!\(day: 7\)\)

Documentation \+ available intervals inspired by the corresponding ecto interval implementation





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.GetPath 

Gets the value at the provided path in the value, which must be a map or embed.

If you are using a datalayer that provides a `type` function \(like AshPostgres\), it is a good idea to wrap your call in that function, e.g `type(author[:bio][:title], :string)`, since data layers that depend on knowing types may not be able to infer the type from the path. Ash may eventually be able to figure out the type, in the case that the path consists of only embedded attributes.

If an atom key is provided, access is *indiscriminate* of atoms vs strings. The atom key is checked first. If a string key is provided, that is the only thing that is checked. If the value will or may be a struct, be sure to use atoms.

The data layer may handle this differently, for example, AshPostgres only checks strings at the data layer \(because thats all it can be in the database anyway\).

Available in query expressions using bracket syntax, e.g `foo[:bar][:baz]`.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.If 

If predicate is truthy, then the second argument is returned, otherwise the third.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




partial\_evaluate\(fun\) 


Callback implementation for `Ash.Query.Function.partial_evaluate/1`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# partial\_evaluate\(fun\)



Callback implementation for `Ash.Query.Function.partial_evaluate/1`.





# Ash.Query.Function.IsNil 

true if the provided field is nil





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Lazy 

Runs the provided MFA and returns the result as a known value.

Evaluated just before running the query.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Length 

Returns the length of a list attribute defined by the composite type `{:array, Type}`.

    length    (    roles    )

If the attribute allows nils:

    length    (    roles         ||         [    ]    )





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Minus 

Negates the value





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Now 

Returns the current datetime





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Rem 

Rounds a float, decimal or integer to the given number of points





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Round 

Rounds a float, decimal or integer to the given number of points





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StartOfDay 

Converts a date or datetime into the start of day

Accepts an optional time zone, in the same format that can be passed to `DateTime.new/3`.

For example: start\_of\_day\(now\(\)\) < a\_datetime\(\) start\_of\_day\(now\(\), "Europe/Copenhagen"\) < a\_datetime\(\)





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StringDowncase 

Downcase a string





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StringJoin 

Joins a list of values.

Ignores `nil` values and concatenates the remaining non-nil values. An optional joiner can be provided.

    string_join    (    [    first_name    ,         last_name    ]    ,         " "    )    
        string_join    (    [    item_a    ,         item_b    ]    )





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StringLength 

Trims whitespace from a string





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StringPosition 

Returns the zero-based position of a substring within a string, nil if the string does not contain the substring.

Case insensitive strings are accounted for on either side.

string\_position\("foo", "fo"\) 0

string\_position\(%Ash.CiString\{string: "foo"\}, "FoO"\) 0

string\_position\("foo", %Ash.CiString\{string: "FOO"\}\) 0





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StringSplit 

Split a string into a list of strings

Splits a string on the given delimiter. The delimiter defaults to a single space. Also supports options.

Keep in mind, this function does *not* support regexes the way that `String.split/3` does, only raw strings.

    string_split    (    employee_code    )        string_split    (    full_name    ,         "foo"    )        string_split    (    full_name    ,         "foo"    ,         trim?    :         true    )

## Options

+ `:trim?` \(`boolean/0`\) - Whether or not to trim empty strings from the beginning or end of the result. Equivalent to the `trim` option to `String.split/3` The default value is `false`.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.StringTrim 

Trims whitespace from a string





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Today 

Returns the current date.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Function.Type 

Casts the value to a given type. Can also be used to provide type hints to data layers, where appropriate.





# Summary


## **Functions** 


args\(\) 


Callback implementation for `Ash.Query.Function.args/0`.




# Functions




# args\(\)



Callback implementation for `Ash.Query.Function.args/0`.





# Ash.Query.Operator.Eq 

left == right

The simplest operator, matches if the left and right are equal.

For comparison, this compares as mutually exclusive with other equality and `is_nil` checks that have the same reference on the left side





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Query.Operator.GreaterThan 

left > right

In comparison, simplifies to `not(left < right + 1)`, so it will never need to be compared against.





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Query.Operator.GreaterThanOrEqual 

left >= right

In comparison, simplifies to `not(left < right)`, so it will never need to be compared against.





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Query.Operator.In 

left in \[1, 2, 3\]

this predicate matches if the left is in the list on the right

For comparison, this simplifies to a set of "or equals", e.g `{:or, {:or, {:or, left == 1}, left == 2}, left == 3}`





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Query.Operator.IsNil 

left is\_nil true/false

This predicate matches if the left is nil when the right is `true` or if the left is not nil when the right is `false`





# Summary


## **Functions** 


name\(\) 



operator\(\) 



# Functions




# name\(\)





# operator\(\)





# Ash.Query.Operator.LessThan 

left < right

Does not simplify, but is used as the simplification value for `Ash.Query.Operator.LessThanOrEqual`, `Ash.Query.Operator.GreaterThan` and `Ash.Query.Operator.GreaterThanOrEqual`.

When comparing predicates, it is mutually exclusive with `Ash.Query.Operator.IsNil`. Additionally, it compares as mutually inclusive with any `Ash.Query.Operator.Eq` and any `Ash.Query.Operator.LessThan` who's right sides are less than it, and mutually exclusive with any `Ash.Query.Operator.Eq` or `Ash.Query.Operator.GreaterThan` who's right side's are greater than or equal to it.





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Query.Operator.LessThanOrEqual 

left <= right

In comparison, simplifies to `left < right + 1`, so it will never need to be compared against.





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Query.Operator.NotEq 

left \!= right

In comparison, simplifies to `not(left == right)`





# Summary


## **Functions** 


evaluate\(map\) 


Callback implementation for `Ash.Query.Operator.evaluate/1`.




name\(\) 



operator\(\) 



# Functions




# evaluate\(map\)



Callback implementation for `Ash.Query.Operator.evaluate/1`.





# name\(\)





# operator\(\)





# Ash.Notifier.PubSub.Publication 

Represents a configured publication from the pubsub notifier on an Ash.Resource





# Summary


## **Functions** 


publish\_all\_schema\(\) 



schema\(\) 



# Functions




# publish\_all\_schema\(\)





# schema\(\)





# Ash.Policy.FieldPolicy 

Represents a field policy in an Ash.Resource





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Policy.FieldPolicy{
      __identifier__:     term    (),
      access_type:     term    (),
      bypass?:     term    (),
      condition:     term    (),
      description:     term    (),
      fields:     term    (),
      policies:     term    ()
    }





# Ash.Policy.Policy 

Represents a policy on an Ash.Resource





# Summary


## **Types** 


t\(\) 




## **Functions** 


at\_least\_one\_policy\_expression\(policies\) 



fetch\_fact\(facts, arg2\) 



fetch\_or\_strict\_check\_fact\(authorizer, arg2\) 



solve\(authorizer\) 



# Types




# t\(\)




    @type     t() :: %Ash.Policy.Policy{
      access_type:     term    (),
      bypass?:     term    (),
      condition:     term    (),
      description:     term    (),
      policies:     term    ()
    }





# Functions




# at\_least\_one\_policy\_expression\(policies\)





# fetch\_fact\(facts, arg2\)





# fetch\_or\_strict\_check\_fact\(authorizer, arg2\)





# solve\(authorizer\)





# Ash.Resource.Actions 

Types for Ash actions





# Summary


## **Types** 


action\(\) 



action\_type\(\) 



# Types




# action\(\)




    @type     action() ::
          Ash.Resource.Actions.Action.t    ()
      |     Ash.Resource.Actions.Create.t    ()
      |     Ash.Resource.Actions.Read.t    ()
      |     Ash.Resource.Actions.Update.t    ()
      |     Ash.Resource.Actions.Destroy.t    ()





# action\_type\(\)




    @type     action_type() :: :action | :read | :create | :update | :destroy





# Ash.Resource.Actions.Action 

Represents a custom action on a resource.





# Summary


## **Types** 


t\(\) 




## **Functions** 


transform\(action\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Action{
      allow_nil?:     boolean    (),
      arguments: [    Ash.Resource.Actions.Argument.t    ()],
      constraints:     Keyword.t    (),
      description:     String.t    () | nil,
      name:     atom    (),
      preparations: [    Ash.Resource.Preparation.t    ()],
      primary?:     boolean    (),
      returns:     Ash.Type.t    () | nil,
      run: {    module    (),     Keyword.t    ()},
      skip_global_validations?:     boolean    (),
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      touches_resources: [    Ash.Resource.t    ()],
      transaction?:     boolean    (),
      type: :action
    }





# Functions




# transform\(action\)





# Ash.Resource.Actions.Argument 

Represents an argument to an action





# Summary


## **Types** 


t\(\) 




## **Functions** 


schema\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Argument{
      allow_nil?:     term    (),
      constraints:     term    (),
      default:     term    (),
      description:     term    (),
      name:     term    (),
      public?:     term    (),
      sensitive?:     term    (),
      type:     term    ()
    }





# Functions




# schema\(\)





# Ash.Resource.Actions.Create 

Represents a create action on a resource.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Create{
      accept: nil | [    atom    ()],
      action_select: [    atom    ()] | nil,
      allow_nil_input: [    atom    ()],
      arguments: [    Ash.Resource.Actions.Argument.t    ()],
      changes:     term    (),
      delay_global_validations?:     boolean    (),
      description:     String.t    () | nil,
      error_handler:     term    (),
      manual:     module    () | nil,
      metadata:     term    (),
      name:     atom    (),
      notifiers: [    module    ()],
      primary?:     boolean    (),
      reject:     term    (),
      require_attributes: [    atom    ()],
      return_skipped_upsert?:     boolean    (),
      skip_global_validations?:     boolean    (),
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      touches_resources: [    atom    ()],
      transaction?:     term    (),
      type: :create,
      upsert?:     boolean    (),
      upsert_condition:     Ash.Expr.t    () | nil,
      upsert_fields:
        nil
        | [    atom    ()]
        | :replace_all
        | {:replace, [    atom    ()]}
        | {:replace_all_except, [    atom    ()]},
      upsert_identity:     atom    () | nil
    }





# Ash.Resource.Actions.Destroy 

Represents a destroy action on a resource.





# Summary


## **Types** 


t\(\) 




## **Functions** 


transform\(action\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Destroy{
      accept: nil | [    atom    ()],
      action_select: [    atom    ()] | nil,
      allow_nil_input: [    atom    ()],
      arguments: [    Ash.Resource.Actions.Argument.t    ()],
      atomic_upgrade?:     boolean    (),
      atomic_upgrade_with:     atom    () | nil,
      changes:     term    (),
      delay_global_validations?:     boolean    (),
      description:     String.t    () | nil,
      error_handler:     term    (),
      manual:     module    () | nil,
      metadata:     term    (),
      name:     atom    (),
      notifiers: [    module    ()],
      primary?:     boolean    (),
      reject:     term    (),
      require_atomic?:     boolean    (),
      require_attributes: [    atom    ()],
      skip_global_validations?:     boolean    (),
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      soft?:     term    (),
      touches_resources: [    atom    ()],
      transaction?:     term    (),
      type: :destroy
    }





# Functions




# transform\(action\)





# Ash.Resource.Actions.Implementation **behaviour** 

An implementation of a generic action.

### Example

    defmodule         YourModule         do    
          use         Ash.Resource.Actions.Implementation    

          def         run    (    input    ,         opts    ,         context    )         do    
            {    :ok    ,         "Hello"    }    
          end        end





# Summary


## **Callbacks** 


run\(t, opts, t\) 




## **Functions** 


run\(module, action\_input, opts, context\) 



# Callbacks




# run\(t, opts, t\)




    @callback     run(
          Ash.ActionInput.t    (),
      opts ::     Keyword.t    (),
          Ash.Resource.Actions.Implementation.Context.t    ()
    ) ::
      :ok
      | {:ok,     term    ()}
      | {:ok,     term    (), [    Ash.Notifier.Notification.t    ()]}
      | {:error,     term    ()}





# Functions




# run\(module, action\_input, opts, context\)





# Ash.Resource.Actions.Implementation.Context 

The context passed into generic action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Implementation.Context{
      actor:     term    (),
      authorize?:     boolean    (),
      domain:     module    (),
      source_context:     map    (),
      tenant:     term    (),
      tracer:     atom    () | [    atom    ()] | nil
    }





# Ash.Resource.Actions.Metadata 

Represents metadata from an action





# Summary


## **Types** 


t\(\) 




## **Functions** 


schema\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Metadata{
      allow_nil?:     term    (),
      constraints:     term    (),
      default:     term    (),
      description:     term    (),
      name:     term    (),
      type:     term    ()
    }





# Functions




# schema\(\)





# Ash.Resource.Actions.Read 

Represents a read action on a resource.





# Summary


## **Types** 


t\(\) 




## **Functions** 


pagination\_schema\(\) 



transform\(read\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Read{
      arguments: [    Ash.Resource.Actions.Argument.t    ()],
      description:     String.t    () | nil,
      filter:     any    (),
      filters: [    any    ()],
      get?: nil |     boolean    (),
      get_by: nil |     atom    () | [    atom    ()],
      manual:     atom    () | {    atom    (),     Keyword.t    ()} | nil,
      metadata: [    Ash.Resource.Actions.Metadata.t    ()],
      modify_query: nil |     mfa    (),
      multitenancy:     atom    (),
      name:     atom    (),
      pagination:     any    (),
      preparations: [    Ash.Resource.Preparation.ref    () |     Ash.Resource.Validation.ref    ()],
      primary?:     boolean    (),
      skip_global_validations?:     boolean    (),
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      timeout:     pos_integer    () | nil,
      touches_resources: [    atom    ()],
      transaction?:     boolean    (),
      type: :read
    }





# Functions




# pagination\_schema\(\)





# transform\(read\)





# Ash.Resource.Actions.Read.Pagination 

Represents the pagination configuration of a read action





# Summary


## **Types** 


t\(\) 




## **Functions** 


transform\(pagination\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Read.Pagination{
      countable:     term    (),
      default_limit:     term    (),
      keyset?:     term    (),
      max_page_size:     term    (),
      offset?:     term    (),
      required?:     term    (),
      stable_sort:     term    ()
    }





# Functions




# transform\(pagination\)





# Ash.Resource.Actions.Update 

Represents a update action on a resource.





# Summary


## **Types** 


t\(\) 




## **Functions** 


transform\(action\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Actions.Update{
      accept: nil | [    atom    ()],
      action_select: [    atom    ()] | nil,
      allow_nil_input: [    atom    ()],
      arguments: [    Ash.Resource.Actions.Argument.t    ()],
      atomic_upgrade?:     boolean    (),
      atomic_upgrade_with:     atom    () | nil,
      atomics:     term    (),
      changes:     term    (),
      delay_global_validations?:     boolean    (),
      description:     String.t    () | nil,
      error_handler:     term    (),
      manual:     module    () | nil,
      manual?:     term    (),
      metadata:     term    (),
      name:     atom    (),
      notifiers: [    module    ()],
      primary?:     boolean    (),
      reject:     term    (),
      require_atomic?:     boolean    (),
      require_attributes: [    atom    ()],
      skip_global_validations?:     boolean    (),
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      touches_resources: [    atom    ()],
      transaction?:     term    (),
      type: :update
    }





# Functions




# transform\(action\)





# Ash.Resource.Aggregate 

Represents a named aggregate on the resource that can be loaded





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Aggregate{
      authorize?:     boolean    (),
      constraints:     term    (),
      default:     term    (),
      description:     String.t    () | nil,
      field:     atom    (),
      filter:     Keyword.t    (),
      filterable?:     boolean    (),
      implementation:     term    (),
      include_nil?:     term    (),
      join_filters: %{required([    atom    ()]) =>     term    ()},
      kind:     Ash.Query.Aggregate.kind    (),
      name:     atom    (),
      public?:     boolean    (),
      read_action:     atom    () | nil,
      relationship_path: [    atom    ()],
      sensitive?:     boolean    (),
      sort:     term    (),
      sortable?:     boolean    (),
      type:     term    (),
      uniq?:     term    ()
    }





# Ash.Resource.Aggregate.CustomAggregate **behaviour** 

The root behavior for a custom aggregate.

See data layers for their implementation of custom aggregates.





# Summary


## **Types** 


t\(\) 




## **Callbacks** 


describe\(t\) 



# Types




# t\(\)




    @type     t() :: {    module    (),     Keyword.t    ()}





# Callbacks




# describe\(t\)




    @callback     describe(    t    ()) ::     String.t    ()





# Ash.Resource.Aggregate.JoinFilter 

Represents a join filter on a resource aggregate





# Ash.Resource.Attribute 

Represents an attribute on a resource





# Summary


## **Types** 


t\(\) 




## **Functions** 


create\_timestamp\_schema\(\) 



integer\_primary\_key\_schema\(\) 



transform\(attribute\) 



update\_timestamp\_schema\(\) 



uuid\_primary\_key\_schema\(\) 



uuid\_v7\_primary\_key\_schema\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Attribute{
      allow_nil?:     term    (),
      always_select?:     term    (),
      constraints:     Keyword.t    (),
      default: nil |     term    () | (->     term    ()),
      description:     term    (),
      filterable?:     term    (),
      generated?:     term    (),
      match_other_defaults?:     term    (),
      name:     atom    (),
      primary_key?:     boolean    (),
      public?:     boolean    (),
      select_by_default?:     boolean    (),
      sensitive?:     boolean    (),
      sortable?:     boolean    (),
      source:     term    (),
      type:     Ash.Type.t    (),
      update_default:
        nil |     term    () | (->     term    ()) | (    Ash.Resource.record    () ->     term    ()),
      writable?:     boolean    ()
    }





# Functions




# create\_timestamp\_schema\(\)





# integer\_primary\_key\_schema\(\)





# transform\(attribute\)





# update\_timestamp\_schema\(\)





# uuid\_primary\_key\_schema\(\)





# uuid\_v7\_primary\_key\_schema\(\)





# Ash.Resource.Calculation.Argument 

An argument to a calculation





# Summary


## **Types** 


t\(\) 




## **Functions** 


schema\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Calculation.Argument{
      allow_expr?:     boolean    (),
      allow_nil?:     boolean    (),
      constraints:     keyword    (),
      default:     any    (),
      name:     atom    (),
      type:     Ash.Type.t    ()
    }





# Functions




# schema\(\)





# Ash.Resource.Calculation.Context 

The context and arguments of a calculation





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Calculation.Context{
      actor:     term    () | nil,
      arguments:     map    (),
      authorize?:     boolean    (),
      constraints:     Keyword.t    (),
      domain:     module    (),
      resource:     module    (),
      source_context:     map    (),
      tenant:     term    (),
      tracer:     module    () | nil,
      type:     Ash.Type.t    ()
    }





# Ash.Resource.Calculation.LoadAttribute 

Loads an attribute as a calculation.

Can be used to load the same attribute with different load statements applied.





# Summary


## **Functions** 


calculate\(list, opts, context\) 


Callback implementation for `Ash.Resource.Calculation.calculate/3`.




describe\(opts\) 


Callback implementation for `Ash.Resource.Calculation.describe/1`.




has\_calculate?\(\) 



has\_expression?\(\) 


Callback implementation for `Ash.Resource.Calculation.has_expression?/0`.




init\(opts\) 


Callback implementation for `Ash.Resource.Calculation.init/1`.




load\(query, opts, arg3\) 


Callback implementation for `Ash.Resource.Calculation.load/3`.




strict\_loads?\(\) 


Callback implementation for `Ash.Resource.Calculation.strict_loads?/0`.




# Functions




# calculate\(list, opts, context\)



Callback implementation for `Ash.Resource.Calculation.calculate/3`.





# describe\(opts\)



Callback implementation for `Ash.Resource.Calculation.describe/1`.





# has\_calculate?\(\)





# has\_expression?\(\)



Callback implementation for `Ash.Resource.Calculation.has_expression?/0`.





# init\(opts\)



Callback implementation for `Ash.Resource.Calculation.init/1`.





# load\(query, opts, arg3\)



Callback implementation for `Ash.Resource.Calculation.load/3`.





# strict\_loads?\(\)



Callback implementation for `Ash.Resource.Calculation.strict_loads?/0`.





# Ash.Resource.Calculation.LoadRelationship 

Loads a relationship as a calculation.

Can be used to load the same relationship with a different query.





# Summary


## **Functions** 


calculate\(results, opts, context\) 


Callback implementation for `Ash.Resource.Calculation.calculate/3`.




describe\(opts\) 


Callback implementation for `Ash.Resource.Calculation.describe/1`.




has\_calculate?\(\) 



has\_expression?\(\) 


Callback implementation for `Ash.Resource.Calculation.has_expression?/0`.




init\(opts\) 


Callback implementation for `Ash.Resource.Calculation.init/1`.




load\(query, opts, arg3\) 


Callback implementation for `Ash.Resource.Calculation.load/3`.




strict\_loads?\(\) 


Callback implementation for `Ash.Resource.Calculation.strict_loads?/0`.




# Functions




# calculate\(results, opts, context\)



Callback implementation for `Ash.Resource.Calculation.calculate/3`.





# describe\(opts\)



Callback implementation for `Ash.Resource.Calculation.describe/1`.





# has\_calculate?\(\)





# has\_expression?\(\)



Callback implementation for `Ash.Resource.Calculation.has_expression?/0`.





# init\(opts\)



Callback implementation for `Ash.Resource.Calculation.init/1`.





# load\(query, opts, arg3\)



Callback implementation for `Ash.Resource.Calculation.load/3`.





# strict\_loads?\(\)



Callback implementation for `Ash.Resource.Calculation.strict_loads?/0`.





# Ash.Resource.CalculationInterface 

Represents a function that evaluates a calculation in a resource's code interface





# Summary


## **Types** 


t\(\) 




## **Functions** 


schema\(\) 



transform\(interface\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.CalculationInterface{
      args:     term    (),
      calculation:     term    (),
      custom_inputs:     term    (),
      exclude_inputs:     term    (),
      name:     term    ()
    }





# Functions




# schema\(\)





# transform\(interface\)





# Ash.Resource.Identity 

Represents a unique constraint on a resource

Data layers should \(and all built in ones do\), discount `nil` or `null` \(in the case of postgres\) values when determining if a unique constraint matches. This often means that you should prefer to use identities with non-nullable columns.

Eventually, features could be added to support including `nil` or `null` values, but they would need to include a corresponding feature for data layers.





# Summary


## **Types** 


t\(\) 




## **Functions** 


schema\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Identity{
      all_tenants?:     boolean    (),
      description:     String.t    () | nil,
      eager_check?:     term    (),
      eager_check_with:     term    (),
      field_names:     term    (),
      keys: [    atom    ()],
      message:     term    (),
      name:     atom    (),
      nils_distinct?:     boolean    (),
      pre_check?:     term    (),
      pre_check_with:     term    (),
      where: nil |     Ash.Expr.t    ()
    }





# Functions




# schema\(\)





# Ash.Resource.Interface 

Represents a function in a resource's code interface

See the functions defined in this module for specifications of the options that each type of code interface function supports in its options list.





# Summary


## **Types** 


t\(\) 




## **Functions** 


calculate\_opts\(\) 


Options supported by code interfaces for calculations




create\_opts\(\) 


Options supported by code interfaces for create actions




destroy\_opts\(\) 


Options supported by code interfaces for destroy actions




generic\_action\_opts\(\) 


Options supported by code interfaces for generic actions




get\_opts\(\) 


Options supported by code interfaces for read actions with `get?` or `get_by` set.




read\_opts\(\) 


Options supported by code interfaces for read actions




update\_opts\(\) 


Options supported by code interfaces for update actions




# Types




# t\(\)




    @type     t() :: %Ash.Resource.Interface{
      action:     term    (),
      args:     term    (),
      custom_inputs:     term    (),
      default_options:     term    (),
      exclude_inputs:     term    (),
      get?:     term    (),
      get_by:     term    (),
      get_by_identity:     term    (),
      name:     term    (),
      not_found_error?:     term    (),
      require_reference?:     term    ()
    }





# Functions




# calculate\_opts\(\)



Options supported by code interfaces for calculations

## ******Options**

+ 
`:actor` \(`term/0`\) - The actor for handling `^actor/1` templates, supplied to calculation context.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol. Will overwrite any actor, tenant or context provided. See `Ash.Context` for more.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - The tenant, supplied to calculation context.

+ 
`:context` \(`map/0`\) - Context to set on the calculation input.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not the request is being authorized, provided to calculation context. The default value is `true`.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer, provided to the calculation context.

+ 
`:data_layer?` \(`boolean/0`\) - Set to `true` to require that the value be computed within the data layer. Only works for calculations that define an expression.

+ 
`:reuse_values?` \(`boolean/0`\) - Set to `true` to reuse existing values on any provided record. Only necessary if providing a record as the basis for calculation. The default value is `false`.





# create\_opts\(\)



Options supported by code interfaces for create actions

## ******Options**

+ 
`:upsert?` \(`boolean/0`\) - If a conflict is found based on the primary key, the record is updated in the database \(requires upsert support\) The default value is `false`.

+ 
`:return_skipped_upsert?` \(`boolean/0`\) - If `true`, and a record was *not* upserted because its filter prevented the upsert, the original record \(which was *not* upserted\) will be returned. The default value is `false`.

+ 
`:upsert_identity` \(`atom/0`\) - The identity to use when detecting conflicts for `upsert?`, e.g. `upsert_identity: :full_name`. By default, the primary key is used. Has no effect if `upsert?: true` is not provided

+ 
`:upsert_fields` - The fields to upsert. If not set, the action's upsert\_fields is used, and if that is not set, then any fields not being set to defaults are written.

+ 
`:upsert_condition` \(`term/0`\) - An expression to check if the record should be updated when there's a conflict.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - A load statement to add onto the changeset

+ 
`:changeset` \(`term/0`\) - A changeset to seed the action with.

+ 
`:bulk_options` \(`keyword/0`\) - Options passed to `Ash.bulk_create`, if a list or stream of inputs is provided.

	+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

	+ 
`:after_action` \(function of arity 2\) - An after\_action hook to be added to each processed changeset

	+ 
`:read_action` \(`atom/0`\) - The action to use when building the read query.

	+ 
`:assume_casted?` \(`boolean/0`\) - Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting The default value is `false`.

	+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

	+ 
`:authorize_query_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Uses `authorize_with` if not set.

	+ 
`:authorize_changeset_with` - If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error. Uses `authorize_with` if not set.

	+ 
`:authorize_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. The default value is `:filter`.

	+ 
`:private_arguments` \(`map/0`\) - Private argument values to set on each changeset before validations and changes are run. The default value is `%{}`.

	+ 
`:sorted?` \(`boolean/0`\) - Whether or not to sort results by their input position, in cases where `return_records?: true` was provided. The default value is `false`.

	+ 
`:return_records?` \(`boolean/0`\) - Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts. The default value is `false`.

	+ 
`:return_errors?` \(`boolean/0`\) - Whether to return all errors that occur during the operation. Defaults to the value of `:bulk_actions_default_to_errors?` in your config, or `false` if not set. Returning all errors may be expensive for large inserts. The default value is `true`.

	+ 
`:batch_size` \(`pos_integer/0`\) - The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.

	+ 
`:return_stream?` \(`boolean/0`\) - If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.

Potential elements:

`{:notification, notification}` - if `return_notifications?` is set to `true` `{:ok, record}` - if `return_records?` is set to `true` `{:error, error}` - an error that occurred. May be changeset or an individual error.

The default value is `false`.

	+ 
`:return_nothing?` \(`boolean/0`\) - Mutes warnings about returning nothing.

Only relevant if `return_stream?` is set to `true` and all other `return_*?` options are set to `false`.

The default value is `false`.

	+ 
`:stop_on_error?` \(`boolean/0`\) - If true, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped. The default value is `true`.

	+ 
`:notify?` \(`boolean/0`\) - Whether or not to generate any notifications. If this is set to `true` then the data layer must return the results from each batch. This may be intensive for large bulk actions.

Notifications will be automatically sent unless `return_notifications?` is set to `true`.

The default value is `false`.

	+ 
`:transaction` - Whether or not to wrap the entire execution in a transaction, each batch, or not at all.

Keep in mind:

`before_transaction` and `after_transaction` hooks attached to changesets will have to be run *inside* the transaction if you choose `transaction: :all`.

The default value is `:batch`.

	+ 
`:max_concurrency` \(`non_neg_integer/0`\) - If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously The default value is `0`.


+ 
`:private_arguments` \(`map/0`\) - Private argument values to set before validations and changes. The default value is `%{}`.





# destroy\_opts\(\)



Options supported by code interfaces for destroy actions

## ******Options**

+ 
`:return_destroyed?` \(`boolean/0`\) - If true, the destroyed record is included in the return result, e.g `{:ok, destroyed}` or `{:ok, destroyed, notifications}` The default value is `false`.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - A load statement to add onto the changeset

+ 
`:bulk_options` \(`keyword/0`\) - Options passed to `Ash.bulk_destroy`, if a query, list, or stream of inputs is provided.

	+ 
`:stream_batch_size` \(`integer/0`\) - Batch size to use if provided a query and the query must be streamed

	+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records if the `:stream` strategy is chosen. See the `Ash.stream!/2` docs for more. The default value is `:keyset`.

	+ 
`:authorize_query?` \(`boolean/0`\) - If a query is given, determines whether or not authorization is run on that query. The default value is `true`.

	+ 
`:strategy` - The strategy or strategies to enable. :stream is used in all cases if the data layer does not support atomics. The default value is `:atomic`.

	+ 
`:filter` \(`term/0`\) - A filter to apply to records. This is also applied to a stream of inputs.

	+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. The default value is `:keyset`.

	+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more.

	+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

	+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

	+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.

The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer.

The default value is `false`.

	+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

	+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.

See `Ash.Query.load/2`.

The default value is `false`.

	+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. The default value is `:filter`.

	+ 
`:read_action` \(`atom/0`\) - The action to use when building the read query.

	+ 
`:assume_casted?` \(`boolean/0`\) - Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting The default value is `false`.

	+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

	+ 
`:authorize_query_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Uses `authorize_with` if not set.

	+ 
`:authorize_changeset_with` - If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error. Uses `authorize_with` if not set.

	+ 
`:authorize_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. The default value is `:filter`.

	+ 
`:private_arguments` \(`map/0`\) - Private argument values to set on each changeset before validations and changes are run. The default value is `%{}`.

	+ 
`:sorted?` \(`boolean/0`\) - Whether or not to sort results by their input position, in cases where `return_records?: true` was provided. The default value is `false`.

	+ 
`:return_records?` \(`boolean/0`\) - Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts. The default value is `false`.

	+ 
`:return_errors?` \(`boolean/0`\) - Whether to return all errors that occur during the operation. Defaults to the value of `:bulk_actions_default_to_errors?` in your config, or `false` if not set. Returning all errors may be expensive for large inserts. The default value is `true`.

	+ 
`:batch_size` \(`pos_integer/0`\) - The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.

	+ 
`:return_stream?` \(`boolean/0`\) - If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.

Potential elements:

`{:notification, notification}` - if `return_notifications?` is set to `true` `{:ok, record}` - if `return_records?` is set to `true` `{:error, error}` - an error that occurred. May be changeset or an individual error.

The default value is `false`.

	+ 
`:return_nothing?` \(`boolean/0`\) - Mutes warnings about returning nothing.

Only relevant if `return_stream?` is set to `true` and all other `return_*?` options are set to `false`.

The default value is `false`.

	+ 
`:stop_on_error?` \(`boolean/0`\) - If true, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped. The default value is `true`.

	+ 
`:notify?` \(`boolean/0`\) - Whether or not to generate any notifications. If this is set to `true` then the data layer must return the results from each batch. This may be intensive for large bulk actions.

Notifications will be automatically sent unless `return_notifications?` is set to `true`.

The default value is `false`.

	+ 
`:transaction` - Whether or not to wrap the entire execution in a transaction, each batch, or not at all.

Keep in mind:

`before_transaction` and `after_transaction` hooks attached to changesets will have to be run *inside* the transaction if you choose `transaction: :all`.

The default value is `:batch`.

	+ 
`:max_concurrency` \(`non_neg_integer/0`\) - If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously The default value is `0`.


+ 
`:private_arguments` \(`map/0`\) - Private argument values to set before validations and changes. The default value is `%{}`.





# generic\_action\_opts\(\)



Options supported by code interfaces for generic actions

## ******Options**

+ 
`:actor` \(`term/0`\) - The actor for handling `^actor/1` templates, supplied to calculation context.

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol. Will overwrite any actor, tenant or context provided. See `Ash.Context` for more.

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - The tenant, supplied to calculation context.

+ 
`:authorize?` \(`boolean/0`\) - Whether or not the request should be authorized.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer, provided to the calculation context.

+ 
`:context` \(`map/0`\) - Context to set on the action input

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:private_arguments` \(`map/0`\) - Private argument values to set before validations and changes. The default value is `%{}`.





# get\_opts\(\)



Options supported by code interfaces for read actions with `get?` or `get_by` set.

## ******Options**

+ 
`:page` - Pagination options, see `Ash.read/2` for more.

+ 
`:load` \(`term/0`\) - A load statement to add onto the query

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:query` - A query to seed the action with.

+ 
`:not_found_error?` \(`boolean/0`\) - Whether or not to return or raise a `NotFound` error or to return `nil` when a get? action/interface is called.

+ 
`:stream?` \(`boolean/0`\) - If true, a stream of the results will be returned The default value is `false`.

+ 
`:stream_options` \(`keyword/0`\) - Options passed to `Ash.stream!`, if `stream?: true` is given

	+ 
`:batch_size` \(`integer/0`\) - How many records to request in each query run. Defaults to the pagination limits on the resource, or 250.

	+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. The default value is `:keyset`.

	+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more.





# read\_opts\(\)



Options supported by code interfaces for read actions

## ******Options**

+ 
`:page` - Pagination options, see `Ash.read/2` for more.

+ 
`:load` \(`term/0`\) - A load statement to add onto the query

+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.  
The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer. The default value is `false`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.  
See `Ash.Query.load/2`. The default value is `false`.

+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. Valid values are :filter, :error The default value is `:filter`.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:query` - A query to seed the action with.

+ 
`:not_found_error?` \(`boolean/0`\) - Whether or not to return or raise a `NotFound` error or to return `nil` when a get? action/interface is called.

+ 
`:stream?` \(`boolean/0`\) - If true, a stream of the results will be returned The default value is `false`.

+ 
`:stream_options` \(`keyword/0`\) - Options passed to `Ash.stream!`, if `stream?: true` is given

	+ 
`:batch_size` \(`integer/0`\) - How many records to request in each query run. Defaults to the pagination limits on the resource, or 250.

	+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. The default value is `:keyset`.

	+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more.





# update\_opts\(\)



Options supported by code interfaces for update actions

## ******Options**

+ 
`:params` \(`map/0`\) - Parameters to supply, ignored if the input is a changeset, only used when an identifier is given.

+ 
`:atomic_upgrade?` \(`boolean/0`\) - If true the action will be done atomically if it can \(and is configured to do so\), ignoring the in memory transformations and validations. You should not generally need to disable this. The default value is `true`.

+ 
`:timeout` \(`timeout/0`\) - A positive integer, or `:infinity`. If none is provided, the timeout configured on the domain is used.

+ 
`:tracer` \(one or a list of module that adopts `Ash.Tracer`\) - A tracer that implements the `Ash.Tracer` behaviour. See that module for more.

+ 
`:action` \(`term/0`\) - The action to use, either an Action struct or the name of the action

+ 
`:authorize?` - If an actor option is provided \(even if it is `nil`\), authorization happens automatically. If not, this flag can be used to authorize with no user.

+ 
`:context` \(`map/0`\) - Context to set on the query, changeset, or input

+ 
`:tenant` \(value that implements the `Ash.ToTenant` protocol\) - A tenant to set on the query or changeset

+ 
`:actor` \(`term/0`\) - If an actor is provided, it will be used in conjunction with the authorizers of a resource to authorize access

+ 
`:scope` \(`term/0`\) - A value that implements the `Ash.Scope.ToOpts` protocol, for passing around actor/tenant/context in a single value. See `Ash.Scope.ToOpts` for more.

+ 
`:return_notifications?` \(`boolean/0`\) - Use this if you're running ash actions in your own transaction and you want to manually handle sending notifications.  
If a transaction is ongoing, and this is false, notifications will be discarded, otherwise the return value is `{:ok, result, notifications}` \(or `{:ok, notifications}`\)  
To send notifications later, use `Ash.Notifier.notify(notifications)`. It sends any notifications that can be sent, and returns the rest. The default value is `false`.

+ 
`:rollback_on_error?` \(`boolean/0`\) - Whether or not to rollback the transaction on error, if the resource is in a transaction.  
If the action has `transaction? false` this option has no effect. If an error is returned from the data layer and the resource is in a transaction, the transaction is always rolled back, regardless. The default value is `true`.

+ 
`:notification_metadata` \(`term/0`\) - Metadata to be merged into the metadata field for all notifications sent from this operation. The default value is `%{}`.

+ 
`:skip_unknown_inputs` - A list of inputs that, if provided, will be ignored if they are not recognized by the action. Use `:*` to indicate all unknown keys.

+ 
`:load` \(`term/0`\) - A load statement to add onto the changeset

+ 
`:bulk_options` \(`keyword/0`\) - Options passed to `Ash.bulk_update`, if a query, list, or stream of inputs is provided.

	+ 
`:atomic_update` \(`map/0`\) - A map of atomic updates to apply. See `Ash.Changeset.atomic_update/3` for more.

	+ 
`:stream_batch_size` \(`integer/0`\) - Batch size to use if provided a query and the query must be streamed

	+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records if the `:stream` strategy is chosen. See the `Ash.stream!/2` docs for more. The default value is `:keyset`.

	+ 
`:authorize_query?` \(`boolean/0`\) - If a query is given, determines whether or not authorization is run on that query. The default value is `true`.

	+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

	+ 
`:filter` \(`term/0`\) - A filter to apply to records. This is also applied to a stream of inputs.

	+ 
`:strategy` - The strategy or strategies to enable. :stream is used in all cases if the data layer does not support atomics. The default value is `[:atomic]`.

	+ 
`:allow_stream_with` - The 'worst' strategy allowed to be used to fetch records. See `Ash.stream!/2` docs for more. The default value is `:keyset`.

	+ 
`:stream_with` - The specific strategy to use to fetch records. See `Ash.stream!/2` docs for more.

	+ 
`:max_concurrency` \(`non_neg_integer/0`\) - The maximum number of processes allowed to be started for parallel loading of relationships and calculations. Defaults to `System.schedulers_online() * 2`

	+ 
`:lock` \(`term/0`\) - A lock statement to add onto the query

	+ 
`:return_query?` \(`boolean/0`\) - If `true`, the query that was ultimately used is returned as a third tuple element.

The query goes through many potential changes during a request, potentially adding authorization filters, or replacing relationships for other data layers with their corresponding ids. This option can be used to get the true query that was sent to the data layer.

The default value is `false`.

	+ 
`:reuse_values?` \(`boolean/0`\) - Whether calculations are allowed to reuse values that have already been loaded, or must refetch them from the data layer. The default value is `false`.

	+ 
`:strict?` \(`boolean/0`\) - If set to true, only specified attributes will be loaded when passing a list of fields to fetch on a relationship, which allows for more optimized data-fetching.

See `Ash.Query.load/2`.

The default value is `false`.

	+ 
`:authorize_with` - If set to `:error`, instead of applying authorization filters as a filter, any records not matching the authorization filter will cause an error to be returned. The default value is `:filter`.

	+ 
`:read_action` \(`atom/0`\) - The action to use when building the read query.

	+ 
`:assume_casted?` \(`boolean/0`\) - Whether or not to cast attributes and arguments as input. This is an optimization for cases where the input is already casted and/or not in need of casting The default value is `false`.

	+ 
`:select` \(list of `atom/0`\) - A select statement to apply to records. Ignored if `return_records?` is not true.

	+ 
`:authorize_query_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. Uses `authorize_with` if not set.

	+ 
`:authorize_changeset_with` - If set to `:error`, instead of filtering unauthorized changes, unauthorized changes will raise an appropriate forbidden error. Uses `authorize_with` if not set.

	+ 
`:authorize_with` - If set to `:error`, instead of filtering unauthorized query results, unauthorized query results will raise an appropriate forbidden error. The default value is `:filter`.

	+ 
`:private_arguments` \(`map/0`\) - Private argument values to set on each changeset before validations and changes are run. The default value is `%{}`.

	+ 
`:sorted?` \(`boolean/0`\) - Whether or not to sort results by their input position, in cases where `return_records?: true` was provided. The default value is `false`.

	+ 
`:return_records?` \(`boolean/0`\) - Whether or not to return all of the records that were inserted. Defaults to false to account for large inserts. The default value is `false`.

	+ 
`:return_errors?` \(`boolean/0`\) - Whether to return all errors that occur during the operation. Defaults to the value of `:bulk_actions_default_to_errors?` in your config, or `false` if not set. Returning all errors may be expensive for large inserts. The default value is `true`.

	+ 
`:batch_size` \(`pos_integer/0`\) - The number of records to include in each batch. Defaults to the `default_limit` or `max_page_size` of the action, or 100.

	+ 
`:return_stream?` \(`boolean/0`\) - If set to `true`, instead of an `Ash.BulkResult`, a mixed stream is returned.

Potential elements:

`{:notification, notification}` - if `return_notifications?` is set to `true` `{:ok, record}` - if `return_records?` is set to `true` `{:error, error}` - an error that occurred. May be changeset or an individual error.

The default value is `false`.

	+ 
`:return_nothing?` \(`boolean/0`\) - Mutes warnings about returning nothing.

Only relevant if `return_stream?` is set to `true` and all other `return_*?` options are set to `false`.

The default value is `false`.

	+ 
`:stop_on_error?` \(`boolean/0`\) - If true, the first encountered error will stop the action and be returned. Otherwise, errors will be skipped. The default value is `true`.

	+ 
`:notify?` \(`boolean/0`\) - Whether or not to generate any notifications. If this is set to `true` then the data layer must return the results from each batch. This may be intensive for large bulk actions.

Notifications will be automatically sent unless `return_notifications?` is set to `true`.

The default value is `false`.

	+ 
`:transaction` - Whether or not to wrap the entire execution in a transaction, each batch, or not at all.

Keep in mind:

`before_transaction` and `after_transaction` hooks attached to changesets will have to be run *inside* the transaction if you choose `transaction: :all`.

The default value is `:batch`.

	+ 
`:max_concurrency` \(`non_neg_integer/0`\) - If set to a value greater than 0, up to that many tasks will be started to run batches asynchronously The default value is `0`.


+ 
`:private_arguments` \(`map/0`\) - Private argument values to set before validations and changes. The default value is `%{}`.





# Ash.Resource.Interface.CustomInput 

Represents a custom input to a code interface





# Summary


## **Types** 


t\(\) 




## **Functions** 


schema\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Interface.CustomInput{
      allow_nil?:     term    (),
      constraints:     term    (),
      default:     term    (),
      description:     term    (),
      name:     term    (),
      sensitive?:     term    (),
      transform:     term    (),
      type:     term    ()
    }





# Functions




# schema\(\)





# Ash.Resource.Interface.CustomInput.Transform 

Represents a transformation applied to a custom input





# Ash.Resource.Relationships 

Types Ash relationships





# Summary


## **Types** 


cardinality\(\) 



relationship\(\) 



type\(\) 



# Types




# cardinality\(\)




    @type     cardinality() :: :many | :one





# relationship\(\)




    @type     relationship() ::
          Ash.Resource.Relationships.HasOne.t    ()
      |     Ash.Resource.Relationships.BelongsTo.t    ()
      |     Ash.Resource.Relationships.HasMany.t    ()
      |     Ash.Resource.Relationships.ManyToMany.t    ()





# type\(\)




    @type     type() :: :has_many | :has_one | :belongs_to | :many_to_many





# Ash.Resource.Relationships.BelongsTo 

Represents a belongs\_to relationship on a resource





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Relationships.BelongsTo{
      allow_forbidden_field?:     term    (),
      allow_nil?:     boolean    (),
      attribute_public?:     boolean    (),
      attribute_type:     term    (),
      attribute_writable?:     boolean    (),
      authorize_read_with:     term    (),
      cardinality: :one,
      context:     term    (),
      default_sort:     Keyword.t    () | nil,
      define_attribute?:     boolean    (),
      description:     String.t    (),
      destination:     Ash.Resource.t    (),
      destination_attribute:     atom    (),
      domain:     term    (),
      filter:     Ash.Filter.t    () | nil,
      filterable?:     boolean    (),
      filters: [    any    ()],
      name:     atom    (),
      not_found_message:     term    (),
      primary_key?:     boolean    (),
      public?:     boolean    (),
      read_action:     atom    (),
      sort:     Keyword.t    () | nil,
      sortable?:     boolean    (),
      source:     Ash.Resource.t    (),
      source_attribute:     atom    () | nil,
      type: :belongs_to,
      validate_destination_attribute?:     term    (),
      violation_message:     term    (),
      writable?:     boolean    ()
    }





# Ash.Resource.Relationships.HasMany 

Represents a has\_many relationship on a resource





# Summary


## **Types** 


t\(\) 




## **Functions** 


manual\(module\) 



transform\(relationship\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Relationships.HasMany{
      allow_forbidden_field?:     term    (),
      authorize_read_with:     term    (),
      autogenerated_join_relationship_of:     atom    () | nil,
      cardinality: :many,
      context:     term    (),
      could_be_related_at_creation?:     term    (),
      default_sort:     Keyword.t    () | nil,
      description:     String.t    (),
      destination:     Ash.Resource.t    (),
      destination_attribute:     atom    (),
      domain:     term    (),
      filter:     Ash.Filter.t    () | nil,
      filterable?:     boolean    (),
      filters: [    any    ()],
      limit:     integer    (),
      manual:     atom    () | {    atom    (),     Keyword.t    ()} | nil,
      name:     atom    (),
      no_attributes?:     boolean    (),
      not_found_message:     term    (),
      public?:     boolean    (),
      read_action:     atom    (),
      sort:     Keyword.t    () | nil,
      sortable?: true,
      source:     Ash.Resource.t    (),
      source_attribute:     atom    (),
      type: :has_many,
      validate_destination_attribute?:     term    (),
      violation_message:     term    (),
      writable?:     boolean    ()
    }





# Functions




# manual\(module\)





# transform\(relationship\)





# Ash.Resource.Relationships.HasOne 

Represents a has\_one relationship on a resource





# Summary


## **Types** 


t\(\) 




## **Functions** 


transform\(relationship\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Relationships.HasOne{
      allow_forbidden_field?:     term    (),
      allow_nil?:     term    (),
      allow_orphans?:     boolean    (),
      authorize_read_with:     term    (),
      cardinality: :one,
      context:     term    (),
      could_be_related_at_creation?:     term    (),
      default_sort:     Keyword.t    () | nil,
      description:     String.t    (),
      destination:     Ash.Resource.t    (),
      destination_attribute:     atom    (),
      domain:     term    (),
      filter:     Ash.Filter.t    () | nil,
      filterable?:     boolean    (),
      filters: [    any    ()],
      from_many?:     boolean    (),
      manual:     atom    () | {    atom    (),     Keyword.t    ()} | nil,
      name:     atom    (),
      no_attributes?:     boolean    (),
      not_found_message:     term    (),
      public?:     boolean    (),
      read_action:     atom    (),
      sort:     Keyword.t    () | nil,
      sortable?:     boolean    (),
      source:     Ash.Resource.t    (),
      source_attribute:     atom    (),
      type: :has_one,
      validate_destination_attribute?:     term    (),
      violation_message:     term    (),
      writable?:     boolean    ()
    }





# Functions




# transform\(relationship\)





# Ash.Resource.Relationships.ManyToMany 

Represents a many\_to\_many relationship on a resource





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Relationships.ManyToMany{
      allow_forbidden_field?:     term    (),
      authorize_read_with:     term    (),
      cardinality: :many,
      context:     term    (),
      could_be_related_at_creation?:     term    (),
      default_sort:     Keyword.t    () | nil,
      description:     String.t    (),
      destination:     Ash.Resource.t    (),
      destination_attribute:     atom    (),
      destination_attribute_on_join_resource:     atom    (),
      domain:     term    (),
      filter:     Ash.Filter.t    () | nil,
      filterable?:     boolean    (),
      filters: [    any    ()],
      has_many:     boolean    (),
      join_relationship:     atom    (),
      name:     atom    (),
      not_found_message:     term    (),
      public?:     boolean    (),
      read_action:     atom    (),
      sort:     Keyword.t    () | nil,
      sortable?:     boolean    (),
      source:     Ash.Resource.t    (),
      source_attribute:     atom    (),
      source_attribute_on_join_resource:     atom    (),
      through:     Ash.Resource.t    (),
      type: :many_to_many,
      validate_destination_attribute?:     term    (),
      violation_message:     term    ()
    }





# Ash.Actions.BulkManualActionHelpers 

Helper functions used for handling manual actions when used in bulk operations.





# Summary


## **Functions** 


process\_bulk\_results\(results, manual\_action\_module, bulk\_action\_type, store\_notification, store\_error, ref, opts\) 


Processes the results of a manual action's bulk function.




process\_non\_bulk\_result\(result, changeset, bulk\_action\_type\) 


Used when a manual action does not export a bulk version of the action.




# Functions




# process\_bulk\_results\(results, manual\_action\_module, bulk\_action\_type, store\_notification, store\_error, ref, opts\)



Processes the results of a manual action's bulk function.





# process\_non\_bulk\_result\(result, changeset, bulk\_action\_type\)



Used when a manual action does not export a bulk version of the action.





# Ash.Actions.Read.AsyncLimiter 

A utility for limiting the number of concurrent async operations

Because this is an optimization, we opt to run something synchronously if there is no async task available in the slot. The idea here is that the *vast* majority of things we do async will be fast enough not to warrant always waiting for an async slot to be free. We may add in some smarter heuristics later \(i.e choosing to wait for a task instead of doing the work sync\), but for now this is a good start.





# Summary


## **Functions** 


async\_or\_inline\(query, opts, last?, func\) 



await\_all\(list\) 



await\_at\_least\_one\(list\) 



child\_spec\(arg\) 


Returns a specification to start this module under a supervisor.




start\_link\(limit\) 



# Functions




# async\_or\_inline\(query, opts, last?, func\)





# await\_all\(list\)





# await\_at\_least\_one\(list\)





# child\_spec\(arg\)



Returns a specification to start this module under a supervisor.

See `Supervisor`.





# start\_link\(limit\)





# Ash.Can 

Contains the Ash.can function logic.





# Summary


## **Types** 


subject\(\) 




## **Functions** 


can\(action\_or\_query\_or\_changeset, domain, actor\_or\_scope, opts \\\\ \[\]\) 


Returns a an ok tuple if the actor can perform the action, query, or changeset, an error tuple if an error happens, and a ok tuple with maybe if maybe is set to true or not set.




can?\(action\_or\_query\_or\_changeset, domain, actor, opts \\\\ \[\]\) 


Returns whether an actor can perform an action, query, or changeset.




# Types




# subject\(\)




    @type     subject() ::
          Ash.Query.t    ()
      |     Ash.Changeset.t    ()
      |     Ash.ActionInput.t    ()
      | {    Ash.Resource.t    (),     atom    () |     Ash.Resource.Actions.action    ()}
      | {    Ash.Resource.t    (),     atom    () |     Ash.Resource.Actions.action    (), input ::     map    ()}
      | {    Ash.Resource.record    (),     atom    () |     Ash.Resource.Actions.action    ()}
      | {    Ash.Resource.record    (),     atom    () |     Ash.Resource.Actions.action    (),
         input ::     map    ()}





# Functions




# can\(action\_or\_query\_or\_changeset, domain, actor\_or\_scope, opts \\\\ \[\]\)




    @spec     can(    subject    (),     Ash.Domain.t    (),     Ash.actor    () |     Ash.Scope.t    (),     Keyword.t    ()) ::
      {:ok,     boolean    () | :maybe}
      | {:ok,     boolean    (),     term    ()}
      | {:ok,     boolean    (),     Ash.Changeset.t    (),     Ash.Query.t    ()}
      | {:error,     Ash.Error.t    ()}


Returns a an ok tuple if the actor can perform the action, query, or changeset, an error tuple if an error happens, and a ok tuple with maybe if maybe is set to true or not set.

You should prefer to use `Ash.can/3` over this module, directly.

Note: `is_maybe` is set to `true`, if not set.





# can?\(action\_or\_query\_or\_changeset, domain, actor, opts \\\\ \[\]\)




    @spec     can?(    subject    (),     Ash.Domain.t    (),     Ash.Resource.record    (),     Keyword.t    ()) ::
          boolean    () |     no_return    ()


Returns whether an actor can perform an action, query, or changeset.

You should prefer to use `Ash.can?/3` over this module, directly.

Can raise an exception if return\_forbidden\_error is truthy in opts or there's an error.





# Ash.Changeset.OriginalDataNotAvailable 

A value placed in changeset.data to indicate that the original data is not available





# Summary


## **Types** 


t\(\) 


Placeholder struct used when original data is not available.




# Types




# t\(\)




    @type     t() :: %Ash.Changeset.OriginalDataNotAvailable{reason: :atomic_query_update}


Placeholder struct used when original data is not available.

Used in atomic operations where the original record data cannot be loaded.





# Ash.Context 

Functions for working with the context provided to various callbacks in Ash.





# Summary


## **Types** 


context\_keyword\_list\(\) 




## **Functions** 


to\_opts\(map, opts \\\\ \[\]\) deprecated 


Copies keys from the given context map into a keyword list. Does *not* copy the `:domain` key.




# Types




# context\_keyword\_list\(\)




    @type     context_keyword_list() :: [
      actor:     Ash.Resource.t    (),
      authorize?:     boolean    (),
      tracer:     Ash.Tracer.t    (),
      tenant:     Ash.Resource.t    ()
    ]





# Functions




# to\_opts\(map, opts \\\\ \[\]\)



This function is deprecated. Use \`Ash.Scope.to\_opts/2\` instead. 


    @spec     to_opts(    Ash.Scope.t    (),     Keyword.t    ()) ::     context_keyword_list    ()


Copies keys from the given context map into a keyword list. Does *not* copy the `:domain` key.

Keys copied:

+ `:actor`
+ `:authorize?`
+ `:tracer`
+ `:tenant`
+ `context[:shared]` -> `:context`





# Ash.CustomExpression **behaviour** 

A module for defining custom functions that can be called in Ash expressions.

For example:

    defmodule         MyApp.Expressions.LevenshteinDistance         do    
          use         Ash.CustomExpression    ,    
            name    :         :levenshtein    ,    
            arguments    :         [    
              [    :string    ,         :string    ]    
            ]    

          def         expression    (    AshPostgres.DataLayer    ,         [    left    ,         right    ]    )         do    
            {    :ok    ,         expr    (    fragment    (    "levenshtein(?, ?)"    ,         ^    left    ,         ^    right    )    )    }    
          end    

          # It is good practice to always define an expression for `Ash.DataLayer.Simple`,    
          # as that is what Ash will use to run your custom expression in Elixir.    
          # This allows us to completely avoid communicating with the database in some cases.    

          # Always use a fragment like this to evaluate code in simple data layers. The value you    
          # get here for arguments may be expressions at this point.    
          def         expression    (    data_layer    ,         [    left    ,         right    ]    )         when         data_layer         in         [    
            Ash.DataLayer.Ets    ,    
            Ash.DataLayer.Simple    
          ]         do    
            {    :ok    ,         expr    (    fragment    (    &    __MODULE__    .    levenshtein    /    2    ,         ^    left    ,         ^    right    )    )    }    
          end    

          # always define this fallback clause as well    
          def         expression    (    _data_layer    ,         _args    )    ,         do    :         :unknown    

          @doc         "Computes the levenshtein distance of two strings"    
          def         levenshtein    (    left    ,         right    )         do    
            # ......    
          end        end

### Options

+ `name` - The name of the custom expression. This is the name that will be used in Ash expressions.
+ `arguments` - A list of lists of types that the custom expression accepts. Each list represents a set of arguments that the custom expression can accept.
+ `predicate?` - Whether this expression can be exposed as a predicate in filter interfaces. Defaults to `false`.

### Registering Your Expression

Use compile-time configuration to register your custom expressions

    config         :ash    ,         :custom_expressions    ,         [    MyApp.Expressions.LevenshteinDistance    ]





# Summary


## **Callbacks** 


arguments\(\) 



expression\(data\_layer, arguments\) 



name\(\) 



# Callbacks




# arguments\(\)




    @callback     arguments() :: [[    Ash.Type.t    () | {    Ash.Type.t    (),     Keyword.t    ()}]]





# expression\(data\_layer, arguments\)




    @callback     expression(
      data_layer ::     Ash.DataLayer.t    (),
      arguments :: [    Ash.Expr.t    ()]
    ) :: {:ok,     Ash.Expr.t    ()} | :unknown





# name\(\)




    @callback     name() ::     atom    ()





# Ash.DataLayer **behaviour** 

The behaviour for backing resource actions with persistence layers.





# Summary


## **Types** 


bulk\_create\_options\(\) 



bulk\_update\_options\(\) 



combination\_type\(\) 



data\_layer\_query\(\) 



feature\(\) 



lateral\_join\_link\(\) 



lock\_type\(\) 



t\(\) 



transaction\_reason\(\) 




## **Callbacks** 


add\_aggregate\(data\_layer\_query, t, t\) 



add\_aggregates\(data\_layer\_query, list, t\) 



add\_calculation\(data\_layer\_query, t, expression, t\) 



add\_calculations\(data\_layer\_query, list, t\) 



bulk\_create\(t, t, options\) 



calculate\(t, list, context\) 



can?\(arg1, feature\) 



combination\_of\(combine, resource, domain\) 



create\(t, t\) 



destroy\(t, t\) 



destroy\_query\(data\_layer\_query, t, t, opts\) 



distinct\(data\_layer\_query, list, resource\) 



distinct\_sort\(data\_layer\_query, t, resource\) 



filter\(data\_layer\_query, t, resource\) 



functions\(t\) 



in\_transaction?\(t\) 



limit\(data\_layer\_query, limit, resource\) 



lock\(data\_layer\_query, lock\_type, resource\) 



offset\(data\_layer\_query, offset, resource\) 



prefer\_lateral\_join\_for\_many\_to\_many?\(\) 



prefer\_transaction?\(t\) 



prefer\_transaction\_for\_atomic\_updates?\(t\) 



resource\_to\_query\(t, t\) 



return\_query\(data\_layer\_query, t\) 



rollback\(t, term\) 



run\_aggregate\_query\(data\_layer\_query, list, t\) 



run\_aggregate\_query\_with\_lateral\_join\(data\_layer\_query, list, list, destination\_resource, list\) 



run\_query\(data\_layer\_query, t\) 



run\_query\_with\_lateral\_join\(data\_layer\_query, list, source\_resource, list\) 



select\(data\_layer\_query, select, resource\) 



set\_context\(t, data\_layer\_query, map\) 



set\_tenant\(t, data\_layer\_query, term\) 



sort\(data\_layer\_query, t, resource\) 



source\(t\) 



transaction\(t, function, arg3, reason\) 



transform\_query\(t\) 



update\(t, t\) 



update\_query\(data\_layer\_query, t, t, opts\) 



upsert\(t, t, list\) 



upsert\(t, t, list, arg4\) 




## **Functions** 


add\_aggregates\(query, aggregates, resource\) 



add\_calculations\(query, calculations, resource\) 



bulk\_create\(resource, changesets, options\) 



calculate\(resource, exprs, context\) 



can?\(feature, resource\) 



combination\_of\(combinations, resource, domain\) 



create\(resource, changeset\) 



data\_layer\(resource\) 


The data layer of the resource, or nil if it does not have one




data\_layer\_can?\(resource, feature\) 


Whether or not the data layer supports a specific feature




data\_layer\_functions\(resource\) 


Custom functions supported by the data layer of the resource




destroy\(resource, changeset\) 



destroy\_query\(query, changeset, opts\) 



distinct\(query, distinct, resource\) 



distinct\_sort\(query, sort, resource\) 



filter\(query, filter, resource\) 



functions\(resource\) 



in\_transaction?\(resource\) 



limit\(query, limit, resource\) 



lock\(query, lock\_type, resource\) 



offset\(query, offset, resource\) 



prefer\_lateral\_join\_for\_many\_to\_many?\(data\_layer\) 


Whether or not lateral joins should be used for many to many relationships by default




prefer\_transaction?\(resource\) 



prefer\_transaction\_for\_atomic\_updates?\(resource\) 



resource\_to\_query\(resource, domain\) 



return\_query\(query, resource\) 



rollback\(resource, term\) 


Rolls back the current transaction




run\_aggregate\_query\(query, aggregates, resource\) 



run\_aggregate\_query\_with\_lateral\_join\(query, aggregates, root\_data, destination\_resource, path\) 



run\_query\(query, central\_resource\) 



run\_query\_with\_lateral\_join\(query, root\_data, destination\_resource, path\) 



select\(query, select, resource\) 



set\_context\(resource, query, map\) 



set\_tenant\(resource, query, term\) 



sort\(query, sort, resource\) 



source\(resource\) 



transaction\(resource\_or\_resources, func, timeout \\\\ nil, reason \\\\ %\{type: :custom, metadata: %\{\}\}\) 


Wraps the execution of the function in a transaction with the resource's data\_layer




transform\_query\(query\) 



update\(resource, changeset\) 



update\_query\(query, changeset, opts\) 



upsert\(resource, changeset, keys, identity \\\\ nil\) 



# Types




# bulk\_create\_options\(\)




    @type     bulk_create_options() :: %{
      batch_size:     pos_integer    (),
      return_records?:     boolean    (),
      upsert?:     boolean    (),
      action_select: [    atom    ()],
      upsert_keys: nil | [    atom    ()],
      upsert_condition:     Ash.Expr.t    () | nil,
      identity:     Ash.Resource.Identity.t    () | nil,
      select: [    atom    ()],
      upsert_fields:
        nil
        | [    atom    ()]
        | :replace_all
        | {:replace, [    atom    ()]}
        | {:replace_all_except, [    atom    ()]},
      tenant:     term    ()
    }





# bulk\_update\_options\(\)




    @type     bulk_update_options() :: %{
      return_records?:     boolean    (),
      action_select: [    atom    ()],
      calculations: [{    Ash.Query.Calculation.t    (),     Ash.Expr.t    ()}],
      select: [    atom    ()],
      tenant:     term    ()
    }





# combination\_type\(\)




    @type     combination_type() :: :union | :union_all | :intersection





# data\_layer\_query\(\)




    @type     data_layer_query() ::     struct    ()





# feature\(\)




    @type     feature() ::
      :transact
      | :multitenancy
      | :combine
      | {:combine,     combination_type    ()}
      | {:atomic, :update}
      | {:atomic, :upsert}
      | {:lateral_join, [    Ash.Resource.t    ()]}
      | {:join,     Ash.Resource.t    ()}
      | {:aggregate,     Ash.Query.Aggregate.kind    ()}
      | {:aggregate_relationship,     Ash.Resource.Relationships.relationship    ()}
      | {:query_aggregate,     Ash.Query.Aggregate.kind    ()}
      | :select
      | :expr_error
      | :expression_calculation_sort
      | :aggregate_filter
      | :aggregate_sort
      | :boolean_filter
      | :async_engine
      | :bulk_create
      | :update_query
      | :destroy_query
      | :create
      | :read
      | :update
      | :destroy
      | :limit
      | :offset
      | :transact
      | :filter
      | :composite_type
      | {:lock,     lock_type    ()}
      | {:filter_expr,     struct    ()}
      | {:filter_relationship,     Ash.Resource.Relationships.relationship    ()}
      | :sort
      | {:sort,     Ash.Type.t    ()}
      | :upsert
      | :composite_primary_key





# lateral\_join\_link\(\)




    @type     lateral_join_link() ::
      {    Ash.Resource.t    (),     atom    (),     atom    (),     Ash.Resource.Relationships.relationship    ()}





# lock\_type\(\)




    @type     lock_type() :: :for_update |     term    ()





# t\(\)




    @type     t() ::     module    ()





# transaction\_reason\(\)




    @type     transaction_reason() ::
      %{
        :type => :create,
        :metadata => %{resource:     Ash.Resource.t    (), action:     atom    ()},
        optional(:data_layer_context) => %{}
      }
      | %{
          :type => :update,
          :metadata => %{
            resource:     Ash.Resource.t    (),
            action:     atom    (),
            record:     Ash.Resource.record    (),
            actor:     term    ()
          },
          optional(:data_layer_context) => %{}
        }
      | %{
          :type => :destroy,
          :metadata => %{
            resource:     Ash.Resource.t    (),
            action:     atom    (),
            record:     Ash.Resource.record    (),
            actor:     term    ()
          },
          optional(:data_layer_context) => %{}
        }
      | %{
          :type => :read,
          :metadata => %{
            resource:     Ash.Resource.t    (),
            query:     Ash.Query.t    (),
            actor:     term    ()
          },
          optional(:data_layer_context) => %{}
        }
      | %{
          :type => :flow_transaction,
          :metadata => %{
            resource:     Ash.Resource.t    (),
            input:     Ash.ActionInput.t    (),
            action:     atom    (),
            actor:     term    ()
          },
          optional(:data_layer_context) => %{}
        }
      | %{
          :type => :generic,
          :metadata => %{
            step_name:     atom    () | [    term    ()],
            flow:     module    (),
            actor:     term    ()
          },
          optional(:data_layer_context) => %{}
        }
      | %{type: :custom, metadata:     map    ()}
      | %{type:     atom    (), metadata:     map    ()}





# Callbacks




# add\_aggregate\(data\_layer\_query, t, t\)
\(optional\)   



    @callback     add_aggregate(
          data_layer_query    (),
          Ash.Query.Aggregate.t    (),
          Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# add\_aggregates\(data\_layer\_query, list, t\)
\(optional\)   



    @callback     add_aggregates(
          data_layer_query    (),
      [    Ash.Query.Aggregate.t    ()],
          Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# add\_calculation\(data\_layer\_query, t, expression, t\)
\(optional\)   



    @callback     add_calculation(
          data_layer_query    (),
          Ash.Query.Calculation.t    (),
      expression ::     any    (),
          Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# add\_calculations\(data\_layer\_query, list, t\)
\(optional\)   



    @callback     add_calculations(
          data_layer_query    (),
      [{    Ash.Query.Calculation.t    (), expression ::     any    ()}],
          Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# bulk\_create\(t, t, options\)
\(optional\)   



    @callback     bulk_create(
          Ash.Resource.t    (),
          Enumerable.t    (    Ash.Changeset.t    ()),
      options ::     bulk_create_options    ()
    ) ::
      :ok
      | {:ok,     Enumerable.t    (    Ash.Resource.record    ())}
      | {:error,     Ash.Error.t    ()}
      | {:error, :no_rollback,     Ash.Error.t    ()}





# calculate\(t, list, context\)
\(optional\)   



    @callback     calculate(    Ash.Resource.t    (), [    Ash.Expr.t    ()], context ::     map    ()) ::
      {:ok,     term    ()} | {:error,     term    ()}





# can?\(arg1, feature\)




    @callback     can?(    Ash.Resource.t    () |     Spark.Dsl.t    (),     feature    ()) ::     boolean    ()





# combination\_of\(combine, resource, domain\)
\(optional\)   



    @callback     combination_of(
      combine :: [{    combination_type    (),     data_layer_query    ()}],
      resource ::     Ash.Resource.t    (),
      domain ::     Ash.Domain.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# create\(t, t\)
\(optional\)   



    @callback     create(    Ash.Resource.t    (),     Ash.Changeset.t    ()) ::
      {:ok,     Ash.Resource.record    ()}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# destroy\(t, t\)
\(optional\)   



    @callback     destroy(    Ash.Resource.t    (),     Ash.Changeset.t    ()) :: :ok | {:error,     term    ()}





# destroy\_query\(data\_layer\_query, t, t, opts\)
\(optional\)   



    @callback     destroy_query(
          data_layer_query    (),
          Ash.Changeset.t    (),
          Ash.Resource.t    (),
      opts ::     bulk_update_options    ()
    ) ::
      :ok
      | {:ok,     Enumerable.t    (    Ash.Resource.record    ())}
      | {:error,     Ash.Error.t    ()}
      | {:error, :no_rollback,     Ash.Error.t    ()}





# distinct\(data\_layer\_query, list, resource\)
\(optional\)   



    @callback     distinct(    data_layer_query    (), [    atom    ()], resource ::     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# distinct\_sort\(data\_layer\_query, t, resource\)
\(optional\)   



    @callback     distinct_sort(    data_layer_query    (),     Ash.Sort.t    (), resource ::     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# filter\(data\_layer\_query, t, resource\)
\(optional\)   



    @callback     filter(    data_layer_query    (),     Ash.Filter.t    (), resource ::     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# functions\(t\)
\(optional\)   



    @callback     functions(    Ash.Resource.t    ()) :: [    module    ()]





# in\_transaction?\(t\)
\(optional\)   



    @callback     in_transaction?(    Ash.Resource.t    ()) ::     boolean    ()





# limit\(data\_layer\_query, limit, resource\)
\(optional\)   



    @callback     limit(
          data_layer_query    (),
      limit ::     non_neg_integer    (),
      resource ::     Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# lock\(data\_layer\_query, lock\_type, resource\)
\(optional\)   



    @callback     lock(    data_layer_query    (),     lock_type    (), resource ::     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# offset\(data\_layer\_query, offset, resource\)
\(optional\)   



    @callback     offset(
          data_layer_query    (),
      offset ::     non_neg_integer    (),
      resource ::     Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# prefer\_lateral\_join\_for\_many\_to\_many?\(\)
\(optional\)   



    @callback     prefer_lateral_join_for_many_to_many?() ::     boolean    ()





# prefer\_transaction?\(t\)
\(optional\)   



    @callback     prefer_transaction?(    Ash.Resource.t    ()) ::     boolean    ()





# prefer\_transaction\_for\_atomic\_updates?\(t\)
\(optional\)   



    @callback     prefer_transaction_for_atomic_updates?(    Ash.Resource.t    ()) ::     boolean    ()





# resource\_to\_query\(t, t\)




    @callback     resource_to_query(    Ash.Resource.t    (),     Ash.Domain.t    ()) ::     data_layer_query    ()





# return\_query\(data\_layer\_query, t\)
\(optional\)   



    @callback     return_query(    data_layer_query    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# rollback\(t, term\)
\(optional\)   



    @callback     rollback(    Ash.Resource.t    (),     term    ()) ::     no_return    ()





# run\_aggregate\_query\(data\_layer\_query, list, t\)
\(optional\)   



    @callback     run_aggregate_query(
          data_layer_query    (),
      [    Ash.Query.Aggregate.t    ()],
          Ash.Resource.t    ()
    ) :: {:ok,     map    ()} | {:error,     term    ()}





# run\_aggregate\_query\_with\_lateral\_join\(data\_layer\_query, list, list, destination\_resource, list\)
\(optional\)   



    @callback     run_aggregate_query_with_lateral_join(
          data_layer_query    (),
      [    Ash.Query.Aggregate.t    ()],
      [    Ash.Resource.record    ()],
      destination_resource ::     Ash.Resource.t    (),
      [    lateral_join_link    ()]
    ) :: {:ok, [    Ash.Resource.t    ()]} | {:error,     term    ()}





# run\_query\(data\_layer\_query, t\)
\(optional\)   



    @callback     run_query(    data_layer_query    (),     Ash.Resource.t    ()) ::
      {:ok, [    Ash.Resource.record    ()]}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# run\_query\_with\_lateral\_join\(data\_layer\_query, list, source\_resource, list\)
\(optional\)   



    @callback     run_query_with_lateral_join(
          data_layer_query    (),
      [    Ash.Resource.record    ()],
      source_resource ::     Ash.Resource.t    (),
      [    lateral_join_link    ()]
    ) :: {:ok, [    Ash.Resource.record    ()]} | {:error,     term    ()}





# select\(data\_layer\_query, select, resource\)
\(optional\)   



    @callback     select(
          data_layer_query    (),
      select :: [    atom    ()],
      resource ::     Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# set\_context\(t, data\_layer\_query, map\)
\(optional\)   



    @callback     set_context(    Ash.Resource.t    (),     data_layer_query    (),     map    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# set\_tenant\(t, data\_layer\_query, term\)
\(optional\)   



    @callback     set_tenant(    Ash.Resource.t    (),     data_layer_query    (),     term    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# sort\(data\_layer\_query, t, resource\)
\(optional\)   



    @callback     sort(    data_layer_query    (),     Ash.Sort.t    (), resource ::     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# source\(t\)
\(optional\)   



    @callback     source(    Ash.Resource.t    ()) ::     String.t    ()





# transaction\(t, function, arg3, reason\)
\(optional\)   



    @callback     transaction(
          Ash.Resource.t    (),
      (->     term    ()),
      nil |     pos_integer    (),
      reason ::     transaction_reason    ()
    ) :: {:ok,     term    ()} | {:error,     term    ()}





# transform\_query\(t\)
\(optional\)   



    @callback     transform_query(    Ash.Query.t    ()) ::     Ash.Query.t    ()





# update\(t, t\)
\(optional\)   



    @callback     update(    Ash.Resource.t    (),     Ash.Changeset.t    ()) ::
      {:ok,     Ash.Resource.record    ()}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# update\_query\(data\_layer\_query, t, t, opts\)
\(optional\)   



    @callback     update_query(
          data_layer_query    (),
          Ash.Changeset.t    (),
          Ash.Resource.t    (),
      opts ::     bulk_update_options    ()
    ) ::
      :ok
      | {:ok,     Enumerable.t    (    Ash.Resource.record    ())}
      | {:error,     Ash.Error.t    ()}
      | {:error, :no_rollback,     Ash.Error.t    ()}





# upsert\(t, t, list\)
\(optional\)   



    @callback     upsert(    Ash.Resource.t    (),     Ash.Changeset.t    (), [    atom    ()]) ::
      {:ok,     Ash.Resource.record    ()}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# upsert\(t, t, list, arg4\)
\(optional\)   



    @callback     upsert(
          Ash.Resource.t    (),
          Ash.Changeset.t    (),
      [    atom    ()],
          Ash.Resource.Identity.t    () | nil
    ) ::
      {:ok,
           Ash.Resource.record    ()
       | {:upsert_skipped,     Ash.Query.t    (),
          (-> {:ok,     Ash.Resource.record    ()}
              | {:error,     term    ()}
              | {:error, :no_rollback,     term    ()})}}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# Functions




# add\_aggregates\(query, aggregates, resource\)




    @spec     add_aggregates(    data_layer_query    (), [    Ash.Query.Aggregate.t    ()],     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# add\_calculations\(query, calculations, resource\)




    @spec     add_calculations(
          data_layer_query    (),
      [{    Ash.Query.Calculation.t    (), expression ::     term    ()}],
          Ash.Resource.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# bulk\_create\(resource, changesets, options\)




    @spec     bulk_create(
          Ash.Resource.t    (),
          Enumerable.t    (    Ash.Changeset.t    ()),
      options ::     bulk_create_options    ()
    ) ::
      :ok
      | {:ok,     Enumerable.t    (    Ash.Resource.record    ())}
      | {:error,     Ash.Error.t    ()}
      | {:error, :no_rollback,     Ash.Error.t    ()}





# calculate\(resource, exprs, context\)




    @spec     calculate(    Ash.Resource.t    (), [    Ash.Expr.t    ()], context ::     map    ()) ::
      {:ok, [    term    ()]} | {:error,     Ash.Error.t    ()}





# can?\(feature, resource\)




    @spec     can?(    feature    (),     Ash.Resource.t    () |     Spark.Dsl.t    ()) ::     boolean    ()





# combination\_of\(combinations, resource, domain\)




    @spec     combination_of(
      [{    combination_type    (),     data_layer_query    ()}],
      resource ::     Ash.Resource.t    (),
      domain ::     Ash.Domain.t    ()
    ) :: {:ok,     data_layer_query    ()} | {:error,     term    ()}





# create\(resource, changeset\)




    @spec     create(    Ash.Resource.t    (),     Ash.Changeset.t    ()) ::
      {:ok,     Ash.Resource.record    ()}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# data\_layer\(resource\)




    @spec     data_layer(    Ash.Resource.t    () |     Spark.Dsl.t    ()) ::     t    () | nil


The data layer of the resource, or nil if it does not have one





# data\_layer\_can?\(resource, feature\)




    @spec     data_layer_can?(    Ash.Resource.t    () |     Spark.Dsl.t    (),     feature    ()) ::     boolean    ()


Whether or not the data layer supports a specific feature





# data\_layer\_functions\(resource\)




    @spec     data_layer_functions(    Ash.Resource.t    ()) ::     map    ()


Custom functions supported by the data layer of the resource





# destroy\(resource, changeset\)




    @spec     destroy(    Ash.Resource.t    (),     Ash.Changeset.t    ()) ::
      :ok | {:error,     term    ()} | {:error, :no_rollback,     term    ()}





# destroy\_query\(query, changeset, opts\)




    @spec     destroy_query(
          data_layer_query    (),
          Ash.Changeset.t    (),
      opts ::     bulk_update_options    ()
    ) ::
      :ok
      | {:ok,     Enumerable.t    (    Ash.Resource.record    ())}
      | {:error,     Ash.Error.t    ()}
      | {:error, :no_rollback,     Ash.Error.t    ()}





# distinct\(query, distinct, resource\)




    @spec     distinct(    data_layer_query    (),     Ash.Sort.t    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# distinct\_sort\(query, sort, resource\)




    @spec     distinct_sort(    data_layer_query    (),     Ash.Sort.t    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# filter\(query, filter, resource\)




    @spec     filter(    data_layer_query    (),     Ash.Filter.t    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# functions\(resource\)





# in\_transaction?\(resource\)





# limit\(query, limit, resource\)




    @spec     limit(    data_layer_query    (), limit ::     non_neg_integer    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# lock\(query, lock\_type, resource\)




    @spec     lock(
          data_layer_query    (),
      lock_type ::     lock_type    () | nil,
      resource ::     Ash.Resource.t    ()
    ) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# offset\(query, offset, resource\)




    @spec     offset(    data_layer_query    (), offset ::     non_neg_integer    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# prefer\_lateral\_join\_for\_many\_to\_many?\(data\_layer\)




    @spec     prefer_lateral_join_for_many_to_many?(    t    ()) ::     boolean    ()


Whether or not lateral joins should be used for many to many relationships by default





# prefer\_transaction?\(resource\)




    @spec     prefer_transaction?(    Ash.Resource.t    ()) ::     boolean    ()





# prefer\_transaction\_for\_atomic\_updates?\(resource\)




    @spec     prefer_transaction_for_atomic_updates?(    Ash.Resource.t    ()) ::     boolean    ()





# resource\_to\_query\(resource, domain\)




    @spec     resource_to_query(    Ash.Resource.t    (),     Ash.Domain.t    ()) ::     data_layer_query    ()





# return\_query\(query, resource\)




    @spec     return_query(    data_layer_query    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# rollback\(resource, term\)




    @spec     rollback(    Ash.Resource.t    () | [    Ash.Resource.t    ()],     term    ()) ::     no_return    ()


Rolls back the current transaction





# run\_aggregate\_query\(query, aggregates, resource\)




    @spec     run_aggregate_query(
          data_layer_query    (),
      [    Ash.Query.Aggregate.t    ()],
          Ash.Resource.t    ()
    ) :: {:ok,     map    ()} | {:error,     term    ()}





# run\_aggregate\_query\_with\_lateral\_join\(query, aggregates, root\_data, destination\_resource, path\)





# run\_query\(query, central\_resource\)




    @spec     run_query(    data_layer_query    (), central_resource ::     Ash.Resource.t    ()) ::
      {:ok, [    Ash.Resource.record    ()]}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# run\_query\_with\_lateral\_join\(query, root\_data, destination\_resource, path\)





# select\(query, select, resource\)




    @spec     select(    data_layer_query    (), select :: [    atom    ()],     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# set\_context\(resource, query, map\)




    @spec     set_context(    Ash.Resource.t    (),     data_layer_query    (),     map    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# set\_tenant\(resource, query, term\)




    @spec     set_tenant(    Ash.Resource.t    (),     data_layer_query    (),     String.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# sort\(query, sort, resource\)




    @spec     sort(    data_layer_query    (),     Ash.Sort.t    (),     Ash.Resource.t    ()) ::
      {:ok,     data_layer_query    ()} | {:error,     term    ()}





# source\(resource\)




    @spec     source(    Ash.Resource.t    ()) ::     String.t    ()





# transaction\(resource\_or\_resources, func, timeout \\\\ nil, reason \\\\ %\{type: :custom, metadata: %\{\}\}\)




    @spec     transaction(
          Ash.Resource.t    () | [    Ash.Resource.t    ()],
      (->     term    ()),
      nil |     pos_integer    (),
      reason ::     transaction_reason    ()
    ) ::     term    ()


Wraps the execution of the function in a transaction with the resource's data\_layer





# transform\_query\(query\)





# update\(resource, changeset\)




    @spec     update(    Ash.Resource.t    (),     Ash.Changeset.t    ()) ::
      {:ok,     Ash.Resource.record    ()}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# update\_query\(query, changeset, opts\)




    @spec     update_query(
          data_layer_query    (),
          Ash.Changeset.t    (),
      opts ::     bulk_update_options    ()
    ) ::
      :ok
      | {:ok,     Enumerable.t    (    Ash.Resource.record    ())}
      | {:error,     Ash.Error.t    ()}
      | {:error, :no_rollback,     Ash.Error.t    ()}





# upsert\(resource, changeset, keys, identity \\\\ nil\)




    @spec     upsert(
          Ash.Resource.t    (),
          Ash.Changeset.t    (),
      [    atom    ()],
      identity ::     Ash.Resource.Identity.t    () | nil
    ) ::
      {:ok,
           Ash.Resource.record    ()
       | {:upsert_skipped,     Ash.Query.t    (),
          (-> {:ok,     Ash.Resource.record    ()}
              | {:error,     term    ()}
              | {:error, :no_rollback,     term    ()})}}
      | {:error,     term    ()}
      | {:error, :no_rollback,     term    ()}





# Ash.Domain.Dsl.ResourceReference 

A resource reference in a domain





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Domain.Dsl.ResourceReference{
      definitions: [
            Ash.Resource.Interface.t    () |     Ash.Resource.CalculationInterface.t    ()
      ],
      resource:     module    ()
    }





# Ash.Domain.Igniter 

Codemods for working with Ash.Domain modules





# Summary


## **Functions** 


add\_new\_code\_interface\(igniter, domain, resource, name, definition\) 


Adds a code interface if not present to the given resource on the given domain




add\_resource\_reference\(igniter, domain, resource\) 


Adds a resource reference to a domain's `resources` block




list\_domains\(igniter\) 


List all domain modules found in the project




remove\_resource\_reference\(igniter, domain, resource\) 


Removes a resource reference from a domain's `resources` block




# Functions




# add\_new\_code\_interface\(igniter, domain, resource, name, definition\)



Adds a code interface if not present to the given resource on the given domain





# add\_resource\_reference\(igniter, domain, resource\)



Adds a resource reference to a domain's `resources` block





# list\_domains\(igniter\)



List all domain modules found in the project





# remove\_resource\_reference\(igniter, domain, resource\)



Removes a resource reference from a domain's `resources` block





# Ash.Extension **behaviour** 

A behavior of additional callbacks that extensions can implement, specific to Ash.

It is not necessary to adopt this behavior, but it is recommended to do so if you want to define these functions on your extension. These functions are invoked when their relevant Mix task is run.





# Summary


## **Types** 


argv\(\) 



igniter\(\) 




## **Callbacks** 


codegen\(argv\) 



install\(igniter, module, type, location, argv\) 



migrate\(argv\) 



reset\(argv\) 



rollback\(argv\) 



setup argv 



tear\_down\(argv\) 



# Types




# argv\(\)




    @type     argv() :: [    String.t    ()]





# igniter\(\)




    @type     igniter() ::     Igniter.t    ()





# Callbacks




# codegen\(argv\)
\(optional\)   



    @callback     codegen(    argv    ()) ::     term    ()





# install\(igniter, module, type, location, argv\)
\(optional\)   



    @callback     install(
          igniter    (),
      module ::     module    (),
      type ::     Ash.Resource.t    () |     Ash.Domain.t    (),
      location ::     String.t    (),
          argv    ()
    ) ::     igniter    ()





# migrate\(argv\)
\(optional\)   



    @callback     migrate(    argv    ()) ::     term    ()





# reset\(argv\)
\(optional\)   



    @callback     reset(    argv    ()) ::     term    ()





# rollback\(argv\)
\(optional\)   



    @callback     rollback(    argv    ()) ::     term    ()





# setup argv
\(optional\)   



    @callback     setup(    argv    ()) ::     term    ()





# tear\_down\(argv\)
\(optional\)   



    @callback     tear_down(    argv    ()) ::     term    ()





# Ash.Igniter 

Codemods and utilities for working with Ash & Igniter





# Summary


## **Functions** 


codegen\(igniter, name\) 


Adds a codegen task, or updates the name to be `<old_name>_and_name`




# Functions




# codegen\(igniter, name\)



Adds a codegen task, or updates the name to be `<old_name>_and_name`





# Ash.Info 

General introspection helpers for Ash applications.

Use `Ash.Info.mermaid_overview(otp_app)` to generate a mermaid chart of the application's domains and resources. This offers a high level view, but will not include information from extensions. Use `resource_report/2` for a detailed report of a resource.

Use `Ash.Info.mermaid_overview(otp_app, type: :entity_relationship)` to get a simplified entity relationship diagram.

Use `Ash.Info.domains_and_resources(otp_app)` to get a map where the keys are the domains, and the value is the list of resources for that domain.





# Summary


## **Functions** 


domains\(otp\_app\) 



domains\_and\_resources\(otp\_app\) 


Returns a map where the keys are the domains, and the value is the list of resources for that domain.




mermaid\_overview\(otp\_app, type \\\\ :class\) 


Generate a mermaid chart of the application's domains and resources.




# Functions




# domains\(otp\_app\)




    @spec     domains(    atom    ()) :: [    Ash.Domain.t    ()]





# domains\_and\_resources\(otp\_app\)




    @spec     domains_and_resources(    atom    ()) :: %{
      required(    Ash.Domain.t    ()) => [    Ash.Resource.t    ()]
    }


Returns a map where the keys are the domains, and the value is the list of resources for that domain.





# mermaid\_overview\(otp\_app, type \\\\ :class\)



Generate a mermaid chart of the application's domains and resources.

This offers a high level view, but will not include information from extensions.





# Ash.Policy.PolicyGroup 

Represents a policy group on an Ash.Resource





# Ash.Query.Combination 

Represents one combination in a combination of queries.





# Summary


## **Types** 


t\(\) 




## **Functions** 


base\(opts\) 


The initial combination of a combined query.




except\(opts\) 


Removes all rows that are present in the previous combinations *and* this one.




intersect\(opts\) 


Intersects the query with the previous combinations, keeping only rows that are present in the previous combinations and this one.




union\(opts\) 


Unions the query with the previous combinations, discarding duplicates when all fields are equal.




union\_all\(opts\) 


Unions the query with the previous combinations, keeping all rows.




# Types




# t\(\)




    @type     t() :: %Ash.Query.Combination{
      calculations: %{required(    atom    ()) =>     Ash.Query.Calculation.t    ()},
      filter:     Ash.Expr.t    (),
      limit:     pos_integer    () | nil,
      offset:     pos_integer    () | nil,
      select: [    atom    ()],
      sort:     Ash.Sort.t    (),
      type: :base | :union | :union_all | :except | :intersect
    }





# Functions




# base\(opts\)



The initial combination of a combined query.





# except\(opts\)



Removes all rows that are present in the previous combinations *and* this one.





# intersect\(opts\)



Intersects the query with the previous combinations, keeping only rows that are present in the previous combinations and this one.





# union\(opts\)



Unions the query with the previous combinations, discarding duplicates when all fields are equal.





# union\_all\(opts\)



Unions the query with the previous combinations, keeping all rows.





# Ash.Query.UpsertConflict 

Returns the conflicting new information.





# Summary


## **Functions** 


new\(attribute\) 



# Functions




# new\(attribute\)





# Ash.Reactor.ActionStep 

The Reactor step which is used to execute generic actions.





# Ash.Reactor.AshStep 

A reactor step which runs a step-module or an anonymous function, and enqueues any returned notifications before returning.

The following return values are supported: `{:ok, result}`, `{:ok, result, notifications}`, `{:ok, result, notifications, new_steps}`

Example:

    ash_step         :maybe_update_post         do    
          run         fn         %{    post    :         post    ,         new_amount_of_likes    :         new_amount_of_likes    }    ,         ctx         ->    
            opts         =         Ash.Context    .    to_opts    (    ctx    ,         return_notifications?    :         true    )    
            if         post    .    amount_of_likes         !=         new_amount_of_likes         do    
              Post    .    update    (    post    ,         %{    amount_of_likes    :         new_amount_of_likes    }    ,         opts    )    
            else    
              {    :ok    ,         post    }    
            end        end

## Options

+ `run` - a one or two arity function or MFA which will be called as the run function of the step.
+ `compensate` - a one to three arity function or MFA which will be called as the compensate function of the step. Optional.
+ `undo` - a one to three arity function or MFA which will be called as the undo function of this step. Optional.





# Ash.Reactor.BulkCreateStep 

The Reactor step which is used to execute create actions in bulk.





# Ash.Reactor.BulkUpdateStep 

The Reactor step which is used to execute update actions in bulk.





# Ash.Reactor.ChangeStep 

The Reactor step which is used to execute change steps.





# Ash.Reactor.CreateStep 

The Reactor step which is used to execute create actions.





# Ash.Reactor.DestroyStep 

The Reactor step which is used to execute update actions.





# Ash.Reactor.Dsl.Action 

The `action` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Action{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      name:     atom    (),
      resource:     module    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform:     term    (),
      type: :action,
      undo: :always | :never | :outside_transaction,
      undo_action:     atom    (),
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.ActionLoad 

Add a load statement to an action.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.ActionLoad{
      __identifier__:     any    (),
      source:     Reactor.Template.t    (),
      transform: nil | (    any    () ->     any    ()) | {    module    (),     keyword    ()} |     mfa    ()
    }





# Ash.Reactor.Dsl.ActionTransformer 

Responsible for transforming actions.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# Ash.Reactor.Dsl.Actor 

Specify the actor used to execute an action.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Actor{
      __identifier__:     any    (),
      source:     Reactor.Template.t    (),
      transform: nil | (    any    () ->     any    ()) | {    module    (),     keyword    ()} |     mfa    ()
    }





# Ash.Reactor.Dsl.AshStep 

The ash\_step DSL module.

See `d:Reactor.step`.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.AshStep{
      __identifier__:     any    (),
      arguments: [    Reactor.Dsl.Argument.t    ()],
      async?:     boolean    (),
      compensate:
        nil
        | (    any    (),     Reactor.inputs    (),     Reactor.context    () ->
             :ok | :retry | {:continue,     any    ()}),
      guards: [    Reactor.Guard.Build.t    ()],
      impl: nil |     module    () | {    module    (),     keyword    ()},
      max_retries:     non_neg_integer    () | :infinity,
      name:     atom    (),
      run:
        nil
        | (    Reactor.inputs    (),     Reactor.context    () ->
             {:ok,     any    ()}
             | {:ok,     any    (), [    Reactor.Step.t    ()]}
             | {:halt | :error,     any    ()}),
      transform: nil | (    any    () ->     any    ()),
      undo:
        nil
        | (    any    (),     Reactor.inputs    (),     Reactor.context    () ->
             :ok | :retry | {:error,     any    ()})
    }





# Ash.Reactor.Dsl.BulkCreate 

The `bulk_create` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.BulkCreate{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      assume_casted?:     boolean    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      authorize_changeset_with: :filter | :error,
      authorize_query_with: :filter | :error,
      batch_size: nil |     pos_integer    (),
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      initial:     Reactor.Template.t    (),
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      max_concurrency:     non_neg_integer    (),
      name:     atom    (),
      notification_metadata:     map    (),
      notify?:     boolean    (),
      read_action:     atom    (),
      resource:     module    (),
      return_errors?:     boolean    (),
      return_records?:     boolean    (),
      return_stream?:     boolean    (),
      rollback_on_error?:     boolean    (),
      select: [    atom    ()],
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      sorted?:     boolean    (),
      stop_on_error?:     boolean    (),
      success_state: :success | :partial_success,
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      timeout: nil |     timeout    (),
      transaction: :all | :batch | false,
      transform:     term    (),
      type: :bulk_create,
      undo: :never,
      undo_action: nil,
      upsert?:     term    (),
      upsert_fields: [],
      upsert_identity: nil,
      wait_for:     term    ()
    }





# Ash.Reactor.Dsl.BulkUpdate 

The `bulk_update` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.BulkUpdate{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      allow_stream_with: :keyset | :offset | :full_read,
      assume_casted?:     boolean    (),
      async?:     boolean    (),
      atomic_update: %{optional(    atom    ()) =>     Ash.Expr.t    ()},
      authorize?:     boolean    () | nil,
      authorize_changeset_with: :filter | :error,
      authorize_query?:     boolean    (),
      authorize_query_with: :filter | :error,
      batch_size: nil |     pos_integer    (),
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      filter:
        %{
          optional(    String.t    ()) => %{
            required(    String.t    ()) =>     String.t    () |     number    () |     boolean    ()
          }
        }
        |     Keyword.t    (    Keyword.t    (    String.t    () |     number    () |     boolean    ())),
      guards: [    Reactor.Guard.Build.t    ()],
      initial:     Reactor.Template.t    (),
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      lock: nil |     Ash.DataLayer.lock_type    (),
      max_concurrency:     non_neg_integer    (),
      name:     atom    (),
      notification_metadata:     map    () |     Reactor.Template.t    (),
      notify?:     boolean    (),
      page:     Keyword.t    (),
      read_action:     atom    (),
      resource:     module    (),
      return_errors?:     boolean    (),
      return_records?:     boolean    (),
      return_stream?:     boolean    (),
      reuse_values?:     boolean    (),
      rollback_on_error?:     boolean    (),
      select: [    atom    ()],
      skip_unknown_inputs: [    atom    () |     String.t    ()],
      sorted?:     boolean    (),
      stop_on_error?:     boolean    (),
      strategy: :atomic | :atomic_batches | :stream,
      stream_batch_size: nil |     pos_integer    (),
      stream_with: nil | :keyset | :offset | :full_read,
      success_state: :success | :partial_success,
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      timeout: nil |     timeout    (),
      transaction: :all | :batch | false,
      transform:     term    (),
      type: :bulk_create,
      undo: :never,
      undo_action: nil,
      wait_for:     term    ()
    }





# Ash.Reactor.Dsl.Change 

The `change` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Change{
      __identifier__:     any    (),
      action_step?: false,
      arguments: [    Reactor.Dsl.Argument.t    ()],
      async?:     boolean    (),
      change:     Ash.Resource.Change.t    () |     Ash.Resource.Change.ref    (),
      description: nil |     String.t    (),
      fail_if_invalid?:     boolean    (),
      initial: nil |     Reactor.Template.t    (),
      name:     atom    (),
      only_when_valid?:     term    (),
      type: :change,
      where: [    Ash.Resource.Validation.ref    ()]
    }





# Ash.Reactor.Dsl.Context 

Specify context to merge into an action's context.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Context{
      __identifier__:     any    (),
      context: nil |     t    () |     map    (),
      transform: nil | (    any    () ->     any    ()) | {    module    (),     keyword    ()} |     mfa    ()
    }





# Ash.Reactor.Dsl.Create 

The `create` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Create{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      initial: nil |     Ash.Resource.t    () |     Reactor.Template.t    (),
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      name:     atom    (),
      resource:     module    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform:     term    (),
      type: :create,
      undo: :always | :never | :outside_transaction,
      undo_action:     atom    (),
      upsert?:     boolean    (),
      upsert_identity: nil |     atom    (),
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.Destroy 

The `destroy` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Destroy{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      initial:     Reactor.Template.t    (),
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      name:     atom    (),
      resource:     module    (),
      return_destroyed?:     boolean    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform:     term    (),
      type: :destroy,
      undo: :always | :never | :outside_transaction,
      undo_action:     atom    (),
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.Inputs 

The `inputs` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Inputs{
      __identifier__:     any    (),
      template:
        %{optional(    atom    ()) =>     Reactor.Template.t    ()}
        |     Keyword.t    (    Reactor.Template.t    ()),
      transform: nil | (    any    () ->     any    ()) | {    module    (),     keyword    ()} |     mfa    ()
    }





# Ash.Reactor.Dsl.Load 

The `load` step entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Load{
      __identifier__:     any    (),
      action: nil |     atom    (),
      action_step?: false,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?: nil |     boolean    (),
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description: nil |     String.t    (),
      domain: nil |     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      lazy?: nil |     boolean    (),
      load:     Reactor.Template.t    (),
      name:     atom    (),
      records:     Reactor.Template.t    (),
      reuse_values?: nil |     boolean    (),
      strict?: nil |     boolean    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform: nil | (    any    () ->     any    ()) | {    module    (),     keyword    ()} |     mfa    (),
      type: :load,
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.MiddlewareTransformer 

Ensures that the required middlewares are added to the Reactor.





# Summary


## **Functions** 


after?\(\_\) 


Callback implementation for `Spark.Dsl.Transformer.after?/1`.




after\_compile?\(\) 


Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.




# Functions




# after?\(\_\)



Callback implementation for `Spark.Dsl.Transformer.after?/1`.





# after\_compile?\(\)



Callback implementation for `Spark.Dsl.Transformer.after_compile?/0`.





# Ash.Reactor.Dsl.Read 

The `read` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Read{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      name:     atom    (),
      resource:     module    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform:     term    (),
      type: :create,
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.ReadOne 

The `read_one` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.ReadOne{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      fail_on_not_found?:     boolean    (),
      guards: [    Reactor.Guard.Build.t    ()],
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      name:     atom    (),
      resource:     module    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform:     term    (),
      type: :create,
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.Tenant 

Specify the tenant used to execute an action.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Tenant{
      __identifier__:     any    (),
      source:     Reactor.Template.t    (),
      transform: nil | (    any    () ->     any    ()) | {    module    (),     keyword    ()} |     mfa    ()
    }





# Ash.Reactor.Dsl.Transaction 

The `transaction` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Transaction{
      __identifier__:     any    (),
      arguments: [],
      description: nil |     String.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      name:     atom    (),
      resources: [    Ash.Resource.t    ()],
      return:     atom    (),
      steps: [    Reactor.Step.t    ()],
      timeout:     timeout    (),
      type: :transaction,
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.Dsl.Update 

The `update` entity for the `Ash.Reactor` reactor extension.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Reactor.Dsl.Update{
      __identifier__:     any    (),
      action:     atom    (),
      action_step?: true,
      actor: nil |     Ash.Reactor.Dsl.Actor.t    (),
      async?:     boolean    (),
      authorize?:     boolean    () | nil,
      context: nil |     Ash.Reactor.Dsl.Context.t    (),
      description:     String.t    () | nil,
      domain:     Ash.Domain.t    (),
      guards: [    Reactor.Guard.Build.t    ()],
      initial:     Reactor.Template.t    (),
      inputs: [    Ash.Reactor.Dsl.Inputs.t    ()],
      load: nil |     Ash.Reactor.Dsl.ActionLoad.t    (),
      name:     atom    (),
      resource:     module    (),
      tenant: nil |     Ash.Reactor.Dsl.Tenant.t    (),
      transform:     term    (),
      type: :update,
      undo: :always | :never | :outside_transaction,
      undo_action:     atom    (),
      wait_for: [    Reactor.Dsl.WaitFor.t    ()]
    }





# Ash.Reactor.LoadStep 

The Reactor step which is used to execute load steps.





# Summary


## **Functions** 


run\(arguments, context, options\) 


Callback implementation for `Reactor.Step.run/3`.




# Functions




# run\(arguments, context, options\)



Callback implementation for `Reactor.Step.run/3`.





# Ash.Reactor.MergeInputsStep 

A custom step which merges any number of `inputs` results into a single map.





# Ash.Reactor.Notifications 

Reactor middleware used to collect and emit notifications upon successful completion of the Reactor.





# Summary


## **Functions** 


complete\(result, context\) 


When the reactor completes successfully, publish any queued notifications.




enqueue\_notifications\(context, notifications\) 


Add notifications to the queue to be published on reactor success.




error\(errors, context\) 


When the reactor fails, discard any queued notifications.




halt\(context\) 


When halting the reactor, store any queued notifications in the context for eventual resumption.




init\(context\) 


When starting a reactor, start an agent to act as a temporary store of notifications.




publish\(context, notifications\) 


Dispatch notifications.




# Functions




# complete\(result, context\)



When the reactor completes successfully, publish any queued notifications.





# enqueue\_notifications\(context, notifications\)




    @spec     enqueue_notifications(
          Reactor.context    (),
          Enumerable.t    (    Ash.Notifier.Notification.t    ())
    ) ::
      :ok | {:error,     any    ()}


Add notifications to the queue to be published on reactor success.





# error\(errors, context\)



When the reactor fails, discard any queued notifications.





# halt\(context\)



When halting the reactor, store any queued notifications in the context for eventual resumption.





# init\(context\)



When starting a reactor, start an agent to act as a temporary store of notifications.





# publish\(context, notifications\)




    @spec     publish(
          Reactor.context    (),
          Ash.Notifier.Notification.t    () | [    Ash.Notifier.Notification.t    ()]
    ) :: [    Ash.Notifier.Notification.t    ()]


Dispatch notifications.





# Ash.Reactor.ReadOneStep 

The Reactor step which is used to execute get actions.





# Summary


## **Functions** 


run\(arguments, context, options\) 


Callback implementation for `Reactor.Step.run/3`.




# Functions




# run\(arguments, context, options\)



Callback implementation for `Reactor.Step.run/3`.





# Ash.Reactor.ReadStep 

The Reactor step which is used to execute read actions.





# Summary


## **Functions** 


run\(arguments, context, options\) 


Callback implementation for `Reactor.Step.run/3`.




# Functions




# run\(arguments, context, options\)



Callback implementation for `Reactor.Step.run/3`.





# Ash.Reactor.Tracer 

Reactor middleware which threads Ash's tracing information through to new processes spawned by Reactor.





# Ash.Reactor.TransactionStep 

The Reactor step which is used to wrap other steps in an Ash data layer transaction.





# Summary


## **Functions** 


run\(arguments, context, options\) 


Callback implementation for `Reactor.Step.run/3`.




# Functions




# run\(arguments, context, options\)



Callback implementation for `Reactor.Step.run/3`.





# Ash.Reactor.UpdateStep 

The Reactor step which is used to execute update actions.





# Ash.Resource.Dsl.Filter 

Introspection target for a filter for read actions and relationships





# Ash.Resource.Igniter 

Codemods for working with Ash.Resource modules

## Important Details

This interrogates *the source code* of a resource, not its ultimate compiled state. What this means, is that things like `defines_attribute` will not return `true` if the attribute is added by an extension. Only if it appears literally in the source code of the resource or one of its `Spark.Dsl.Fragment`s.





# Summary


## **Functions** 


add\_action\(igniter, resource, action\) 


Adds the given code block to the resource's `actions` block




add\_attribute\(igniter, resource, attribute\) 


Adds the given code block to the resource's `attributes` block




add\_block\(igniter, resource, block, chunk\) 


Adds the given code block to the block of the resource specified




add\_bypass\(igniter, resource, condition, body\) 


Adds a bypass to the top of the resource's `policies` block




add\_calculation\(igniter, resource, calculation\) 


Adds the given code block to the resource's `calculations` block




add\_identity\(igniter, resource, identity\) 


Adds the given code block to the resource's `identities` block




add\_new\_action\(igniter, resource, name, action\) 


Adds an action if it doesn't already exist




add\_new\_attribute\(igniter, resource, name, attribute\) 


Adds the given code block to the resource's `attributes` block if there is no existing attribute with the given name




add\_new\_calculation\(igniter, resource, name, attribute\) 


Adds the given code block to the resource's `calculations` block if there is no existing calculation with the given name




add\_new\_identity\(igniter, resource, name, identity\) 


Adds the given code block to the resource's `identities` block if there is no existing identity with the given name




add\_new\_relationship\(igniter, resource, name, relationship\) 


Adds the given code block to the resource's `relationships` block




add\_policy\(igniter, resource, condition, body\) 


Adds a policy to the bottom of the resource's `policies` block




add\_relationship\(igniter, resource, relationship\) 


Adds the given code block to the resource's `relationships` block




add\_resource\_configuration\(igniter, resource, resource\_configuration\) 


Adds the given code block to the resource's `resource` block




defines\_action\(igniter, resource, name\) 


Returns true if the given resource defines an action with the provided name




defines\_attribute\(igniter, resource, name\) 


Returns true if the given resource defines an attribute with the provided name




defines\_calculation\(igniter, resource, name\) 


Returns true if the given resource defines a calculation with the provided name




defines\_identity\(igniter, resource, name\) 


Returns true if the given resource defines an identity with the provided name




defines\_relationship\(igniter, resource, name\) 


Returns true if the given resource defines a relationship with the provided name




domain\(igniter, resource\) 


Gets the domain from the given resource module




ensure\_primary\_action\(igniter, resource, type\) 



ensure\_timestamps\(igniter, resource\) 


Ensures that created\_at and updated\_at timestamps exist on the resource




has\_action\_with\_primary\(igniter, resource, type\) 



list\_resources\(igniter\) 


List all resource modules found in the project




resource\_mods\(igniter\) 



# Functions




# add\_action\(igniter, resource, action\)



Adds the given code block to the resource's `actions` block





# add\_attribute\(igniter, resource, attribute\)



Adds the given code block to the resource's `attributes` block





# add\_block\(igniter, resource, block, chunk\)



Adds the given code block to the block of the resource specified





# add\_bypass\(igniter, resource, condition, body\)



Adds a bypass to the top of the resource's `policies` block





# add\_calculation\(igniter, resource, calculation\)



Adds the given code block to the resource's `calculations` block





# add\_identity\(igniter, resource, identity\)



Adds the given code block to the resource's `identities` block





# add\_new\_action\(igniter, resource, name, action\)



Adds an action if it doesn't already exist





# add\_new\_attribute\(igniter, resource, name, attribute\)



Adds the given code block to the resource's `attributes` block if there is no existing attribute with the given name





# add\_new\_calculation\(igniter, resource, name, attribute\)



Adds the given code block to the resource's `calculations` block if there is no existing calculation with the given name





# add\_new\_identity\(igniter, resource, name, identity\)



Adds the given code block to the resource's `identities` block if there is no existing identity with the given name





# add\_new\_relationship\(igniter, resource, name, relationship\)



Adds the given code block to the resource's `relationships` block





# add\_policy\(igniter, resource, condition, body\)



Adds a policy to the bottom of the resource's `policies` block





# add\_relationship\(igniter, resource, relationship\)



Adds the given code block to the resource's `relationships` block





# add\_resource\_configuration\(igniter, resource, resource\_configuration\)



Adds the given code block to the resource's `resource` block





# defines\_action\(igniter, resource, name\)




    @spec     defines_action(    Igniter.t    (),     Ash.Resource.t    (),     atom    ()) ::
      {    Igniter.t    (), true | false}


Returns true if the given resource defines an action with the provided name





# defines\_attribute\(igniter, resource, name\)




    @spec     defines_attribute(    Igniter.t    (),     Ash.Resource.t    (),     atom    ()) ::
      {    Igniter.t    (), true | false}


Returns true if the given resource defines an attribute with the provided name





# defines\_calculation\(igniter, resource, name\)




    @spec     defines_calculation(    Igniter.t    (),     Ash.Resource.t    (),     atom    ()) ::
      {    Igniter.t    (), true | false}


Returns true if the given resource defines a calculation with the provided name





# defines\_identity\(igniter, resource, name\)




    @spec     defines_identity(    Igniter.t    (),     Ash.Resource.t    (),     atom    ()) ::
      {    Igniter.t    (), true | false}


Returns true if the given resource defines an identity with the provided name





# defines\_relationship\(igniter, resource, name\)




    @spec     defines_relationship(    Igniter.t    (),     Ash.Resource.t    (),     atom    ()) ::
      {    Igniter.t    (), true | false}


Returns true if the given resource defines a relationship with the provided name





# domain\(igniter, resource\)




    @spec     domain(    Igniter.t    (),     Ash.Resource.t    ()) ::
      {:ok,     Igniter.t    (),     Ash.Domain.t    ()} | {:error,     Igniter.t    ()}


Gets the domain from the given resource module





# ensure\_primary\_action\(igniter, resource, type\)




    @spec     ensure_primary_action(
          Igniter.t    (),
          Ash.Resource.t    (),
      :create | :read | :update | :destroy
    ) ::     Igniter.t    ()





# ensure\_timestamps\(igniter, resource\)



Ensures that created\_at and updated\_at timestamps exist on the resource





# has\_action\_with\_primary\(igniter, resource, type\)




    @spec     has_action_with_primary(    Igniter.t    (),     Ash.Resource.t    (),     atom    ()) ::
      {    Igniter.t    (), true | false}





# list\_resources\(igniter\)



List all resource modules found in the project





# resource\_mods\(igniter\)





# Ash.Resource.ManualCreate.BulkContext 

The context passed into manual bulk\_create action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualCreate.BulkContext{
      actor:     any    (),
      authorize?:     boolean    (),
      batch_size:     pos_integer    (),
      domain:     Ash.Domain.t    (),
      identity:     Ash.Resource.Identity.t    () | nil,
      return_errors?:     boolean    (),
      return_notifications?:     boolean    (),
      return_records?:     boolean    (),
      select: [    atom    ()],
      source_context:     map    (),
      tenant:     any    (),
      tracer: [    module    ()],
      upsert?:     boolean    (),
      upsert_fields: [    atom    ()],
      upsert_keys: [    atom    ()]
    }





# Ash.Resource.ManualCreate.Context 

The context passed into manual create action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualCreate.Context{
      actor:     any    (),
      authorize?:     boolean    (),
      domain:     Ash.Domain.t    (),
      identity:     Ash.Resource.Identity.t    () | nil,
      return_notifications?:     boolean    (),
      select: [    atom    ()],
      source_context:     map    (),
      tenant:     any    (),
      tracer: [    module    ()],
      upsert?:     boolean    (),
      upsert_fields: [    atom    ()],
      upsert_keys: [    atom    ()]
    }





# Ash.Resource.ManualDestroy.BulkContext 

The context passed into manual bulk\_update action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualDestroy.BulkContext{
      actor:     any    (),
      authorize?:     boolean    (),
      batch_size:     pos_integer    (),
      domain:     Ash.Domain.t    (),
      return_errors?:     boolean    (),
      return_notifications?:     boolean    (),
      return_records?:     boolean    (),
      select: [    atom    ()],
      source_context:     map    (),
      tenant:     any    (),
      tracer: [    module    ()]
    }





# Ash.Resource.ManualDestroy.Context 

The context passed into manual update action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualDestroy.Context{
      actor:     any    (),
      authorize?:     boolean    (),
      domain:     Ash.Domain.t    (),
      return_destroyed?:     boolean    (),
      return_notifications?:     boolean    (),
      select: [    atom    ()],
      source_context: %{},
      tenant:     any    (),
      tracer: [    module    ()]
    }





# Ash.Resource.ManualRelationship.Context 

The context passed into manual relationship functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualRelationship.Context{
      actor:     term    (),
      authorize?:     boolean    (),
      domain:     module    (),
      query:     Ash.Query.t    (),
      relationship:     Ash.Resource.Relationships.relationship    (),
      source_context:     map    (),
      tenant:     term    (),
      tracer:     atom    () | [    atom    ()] | nil
    }





# Ash.Resource.ManualUpdate.BulkContext 

The context passed into manual update action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualUpdate.BulkContext{
      actor:     any    (),
      authorize?:     boolean    (),
      batch_size:     pos_integer    (),
      domain:     Ash.Domain.t    (),
      return_errors?:     boolean    (),
      return_notifications?:     boolean    (),
      return_records?:     boolean    (),
      select: [    atom    ()],
      source_context:     map    (),
      tenant:     any    (),
      tracer: [    module    ()]
    }





# Ash.Resource.ManualUpdate.Context 

The context passed into manual update action functions





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.ManualUpdate.Context{
      actor:     any    (),
      authorize?:     boolean    (),
      domain:     Ash.Domain.t    (),
      return_notifications?:     boolean    (),
      select: [    atom    ()],
      source_context:     map    (),
      tenant:     any    (),
      tracer: [    module    ()]
    }





# Ash.Resource.Preparation.Context 

The context for a preparation.





# Summary


## **Types** 


t\(\) 



# Types




# t\(\)




    @type     t() :: %Ash.Resource.Preparation.Context{
      actor:     Ash.Resource.record    () | nil,
      authorize?:     boolean    () | nil,
      source_context:     map    (),
      tenant:     term    (),
      tracer:     Ash.Tracer.t    () | [    Ash.Tracer.t    ()] | nil
    }





# Ash.Scope 

Determines how the `actor`, `tenant` and `context` are extracted from a data structure.

This is inspired by the same feature in `Phoenix`, however the `actor`, `tenant` and `context` options will always remain available, as they are standardized representations of things that actions can use to do their work.

When you have a scope, you can group up actor/tenant/context into one struct and pass that around, for example:

    scope         =         %    MyApp.Scope    {    current_user    :         user    ,         current_tenant    :         tenant    ,         locale    :         "en"    }    
        # instead of        MyDomain    .    create_thing    (    actor    :         current_user    ,         tenant    :         tenant    )    
        # you can do        MyDomain    .    create_thing    (    scope    :         scope    )

### Scope is left at the front door

Your scope is "left at the front door". That is, when you pass a scope to an action, the options are extracted and the scope is removed from those options. Within hooks, you are meant to use the `context` provided to your functions as the new `scope`. This is very important, because you don't want a bunch of your code or extension code having to switch on `if opts[:scope]`, extracting the things that it needs, etc.

See the actions guide for more information.

## Setup

If you are using Phoenix, you will want to assign your `scope` module in a plug that runs after your plugs that determine actor/tenant/context. Then, you will want to add an `on_mount` hook for LiveViews that sets your `scope` assign. This is especially true for `AshAuthentication`, as it does not currently have a concept of scopes.

## Passing scope and options

For the `actor`, `tenant` and `authorize?`, extracted from scopes, the values from the scope are *discarded* if also present in `opts`.

i.e `scope: scope, actor: nil` will remove the set actor. `scope: scope, actor: some_other_actor` will set the actor to `some_other_actor`.

For `context`, the values are deep merged.

For `tracer`, the value\(s\) are concatenated into a single list.

## Example

You would implement `Ash.Scope.ToOpts` for a module like so:

    defmodule         MyApp.Scope         do    
          defstruct         [    :current_user    ,         :current_tenant    ,         :locale    ]    

          defimpl         Ash.Scope.ToOpts         do    
            def         get_actor    (    %{    current_user    :         current_user    }    )    ,         do    :         {    :ok    ,         current_user    }    
            def         get_tenant    (    %{    current_tenant    :         current_tenant    }    )    ,         do    :         {    :ok    ,         current_tenant    }    
            def         get_context    (    %{    locale    :         locale    }    )    ,         do    :         {    :ok    ,         %{    shared    :         %{    locale    :         locale    }    }    }    
            # You typically configure tracers in config giles    
            # so this will typically return :error    
            def         get_tracer    (    _    )    ,         do    :         :error    

            # This should likely always return :error    
            # unless you want a way to bypass authorization configured in your scope    
            def         get_authorize?    (    _    )    ,         do    :         :error    
          end        end

For more on context, and what the `shared` key is used for, see the actions guide

You could then use this in various places by passing the `scope` option.

For example:

    scope         =         %    MyApp.Scope    {    ...    }        # with code interfaces        MyApp.Blog    .    create_post!    (    "new post"    ,         scope    :         scope    )    
        # with changesets and queries        MyApp.Blog        |>         Ash.Changeset    .    for_create    (    :create    ,         %{    title    :         "new post"    }    ,         scope    :         scope    )        |>         Ash    .    create!    (    )    
        # with the context structs that we provide    
        def         change    (    changeset    ,         _    ,         context    )         do    
          Ash.Changeset    .    after_action    (    changeset    ,         fn         changeset    ,         result         ->    
            MyApp.Domain    .    do_something_else    (    ...    ,         scope    :         context    )    
            # if not using as a scope, the alternative is this    
            # in the future this will be deprecated    
            MyApp.Domain    .    do_somethign_else    (    ...    ,         Ash.Context    .    to_opts    (    context    )    )    
          end    )        end

Extensions should not use this option, only end users.





# Summary


## **Types** 


t\(\) 




## **Functions** 


to\_opts\(scope, overrides \\\\ \[\]\) 



# Types




# t\(\)




    @type     t() ::     Ash.Scope.ToOpts.t    ()





# Functions




# to\_opts\(scope, overrides \\\\ \[\]\)





# Ash.Scope.ToOpts **protocol** 

# Summary


## **Types** 


t\(\) 




## **Functions** 


get\_actor\(scope\) 


Extracts the actor from the scope




get\_authorize?\(scope\) 


Extracts the `authorize?` option from the scope




get\_context\(scope\) 


Extracts the context from the scope




get\_tenant\(scope\) 


Extracts the tenant from the scope




get\_tracer\(scope\) 


Extracts the tracer\(s\) from the scope




# Types




# t\(\)




    @type     t() ::     term    ()





# Functions




# get\_actor\(scope\)




    @spec     get_actor(    term    ()) :: {:ok,     term    ()} | :error


Extracts the actor from the scope





# get\_authorize?\(scope\)




    @spec     get_authorize?(    term    ()) :: {:ok,     boolean    ()} | :error


Extracts the `authorize?` option from the scope





# get\_context\(scope\)




    @spec     get_context(    term    ()) :: {:ok,     term    ()} | :error


Extracts the context from the scope





# get\_tenant\(scope\)




    @spec     get_tenant(    term    ()) :: {:ok,     term    ()} | :error


Extracts the tenant from the scope





# get\_tracer\(scope\)




    @spec     get_tracer(    term    ()) :: {:ok,     module    () | [    module    ()]} | :error


Extracts the tracer\(s\) from the scope





# Ash.Subject 

Provides a consistent API for common operations across `Ash.Changeset`, `Ash.Query`, and `Ash.ActionInput`. It allows you to write generic code that works with any of these types without needing to pattern match or special-case your logic.





# Summary


## **Types** 


after\_action\_fun\(\) 


Function type for after action hooks.




after\_transaction\_fun\(\) 


Function type for after transaction hooks.




around\_transaction\_fun\(\) 


Function type for around transaction hooks.




before\_action\_fun\(\) 


Function type for before action hooks.




before\_transaction\_fun\(\) 


Function type for before transaction hooks.




t\(\) 




## **Functions** 


add\_error\(subject, error\) 


Adds an error or list of errors to the subject.




after\_action\(subject, callback, opts \\\\ \[\]\) 


Adds a callback to be executed after the action.




after\_transaction\(subject, callback, opts \\\\ \[\]\) 


Adds an after\_transaction hook to the subject.




around\_transaction\(subject, callback, opts \\\\ \[\]\) 


Adds an around\_transaction hook to the subject.




before\_action\(subject, callback, opts \\\\ \[\]\) 


Adds a callback to be executed before the action.




before\_transaction\(subject, callback, opts \\\\ \[\]\) 


Adds a before\_transaction hook to the subject.




delete\_argument\(subject, argument\_or\_arguments\) 


Deletes one or more arguments from the subject.




fetch\_argument\(subject, argument\) 


Fetches an argument value from the subject.




get\_argument\(subject, argument\) 


Gets an argument value from the subject.




get\_argument\(subject, argument, default \\\\ nil\) 


Gets an argument value from the subject




get\_argument\_or\_attribute\(subject, argument\_or\_attribute, default \\\\ nil\) 


Gets an argument or attribute value from a subject




get\_attribute\(subject, attribute\) 



put\_context\(subject, key, value\) 


Puts a key-value pair into the subject's context.




set\_argument\(subject, argument, value\) 


Sets a single argument on the subject.




set\_arguments\(subject, map\) 


Sets multiple arguments on the subject.




set\_context\(subject, map\) 


Sets the context for the subject.




set\_private\_argument\(subject, argument, value\) 


Sets a private argument value on the action input.




set\_private\_arguments\(subject, map\) 


Sets multiple private arguments on the subject.




# Types




# after\_action\_fun\(\)




    @type     after_action_fun() :: (    t    (),     term    () ->
                             {:ok,     term    ()}
                             | {:ok,     term    (), [    Ash.Notifier.Notification.t    ()]}
                             | {:error,     any    ()})


Function type for after action hooks.

Receives the action input and the result of the action, and can return the result optionally with notifications, or an error.





# after\_transaction\_fun\(\)




    @type     after_transaction_fun() :: (    t    (), {:ok,     term    ()} | {:error,     any    ()} ->
                                  {:ok,     term    ()} | {:error,     any    ()})


Function type for after transaction hooks.

Receives the action input and the result of the transaction, and returns the result \(potentially modified\) or an error.





# around\_transaction\_fun\(\)




    @type     around_transaction_fun() :: (    t    (), (    t    () -> {:ok,     term    ()} | {:error,     any    ()}) ->
                                   {:ok,     term    ()} | {:error,     any    ()})


Function type for around transaction hooks.

Receives an action input and a callback function that executes the transaction, and returns the result of calling the callback or an error.





# before\_action\_fun\(\)




    @type     before_action_fun() :: (    t    () ->
                                  t    ()
                              | {    t    (),
                                 %{notifications: [    Ash.Notifier.Notification.t    ()]}})


Function type for before action hooks.

Receives an action input and returns a modified action input, optionally with notifications.





# before\_transaction\_fun\(\)




    @type     before_transaction_fun() :: (    t    () ->     t    () | {:error,     any    ()})


Function type for before transaction hooks.

Receives an action input and returns a modified action input or an error.





# t\(\)




    @type     t() ::     Ash.Changeset.t    () |     Ash.Query.t    () |     Ash.ActionInput.t    ()





# Functions




# add\_error\(subject, error\)




    @spec     add_error(
      subject ::     t    (),
      error_input ::     Ash.Error.error_input    () | [    Ash.Error.error_input    ()]
    ) ::     t    ()


Adds an error or list of errors to the subject.

Supports all subject types \(Changeset, Query, ActionInput\) and maintains type consistency.

## ******Parameters**

+ `subject` - The subject to add errors to
+ `errors` - Error or list of errors to add





# after\_action\(subject, callback, opts \\\\ \[\]\)




    @spec     after_action(
      subject ::     t    (),
      callback ::     after_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a callback to be executed after the action.

Note: Query only supports 2-arity callbacks and ignores opts.

## ******Parameters**

+ `subject` - The subject to add callback to
+ `callback` - Function that processes the result
+ `opts` - Options including `:prepend?` \(ignored for Query\)





# after\_transaction\(subject, callback, opts \\\\ \[\]\)




    @spec     after_transaction(
      subject ::     t    (),
      callback ::     after_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an after\_transaction hook to the subject.

After transaction hooks are executed after the database transaction completes, regardless of success or failure. They receive both the subject and the transaction result, allowing for cleanup operations, logging, or result modification.

## ******Parameters**

+ `subject` - The subject to add the hook to \(Changeset, Query, or ActionInput\)
+ `callback` - Function that takes the subject and result, returns modified result
+ `opts` - Options including `:prepend?` to add at beginning of hooks list

## ******Examples**

    # Add cleanup after transaction        iex>     changeset        ...>     |>         Ash.Subject    .    after_transaction    (    fn         changeset    ,         result         ->        ...>           cleanup_temp_resources    (    )        ...>           result        ...>     end    )    
        # Log transaction outcome        iex>     query        ...>     |>         Ash.Subject    .    after_transaction    (    fn         query    ,         result         ->        ...>           case         result         do        ...>             {    :ok    ,         _    }         ->         Logger    .    info    (    "Query succeeded"    )        ...>             {    :error    ,         reason    }         ->         Logger    .    error    (    "Query failed:     #{    inspect    (    reason    )    }    "    )        ...>           end        ...>           result        ...>     end    )    
        # Modify successful results        iex>     action_input        ...>     |>         Ash.Subject    .    after_transaction    (    fn         input    ,         result         ->        ...>           case         result         do        ...>             {    :ok    ,         data    }         ->         {    :ok    ,         Map    .    put    (    data    ,         :processed_at    ,         DateTime    .    utc_now    (    )    )    }        ...>             error         ->         error        ...>           end        ...>     end    )

## ******Important Notes**

+ These hooks run whether the transaction succeeds or fails
+ They run outside the transaction, so database operations here are not rolled back
+ The hook must return a result in the same format it received

## ******See also**

+ `before_transaction/3` for hooks that run before the transaction starts
+ `around_transaction/3` for hooks that wrap the entire transaction
+ `after_action/3` for hooks that run after the action \(inside transaction, success only\)





# around\_transaction\(subject, callback, opts \\\\ \[\]\)




    @spec     around_transaction(
      subject ::     t    (),
      callback ::     around_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds an around\_transaction hook to the subject.

Around transaction hooks wrap the entire transaction execution. They receive the subject and a callback function that executes the transaction. This allows adding logic both before and after the transaction while maintaining full control over its execution.

## ******Parameters**

+ `subject` - The subject to add the hook to \(Changeset, Query, or ActionInput\)
+ `callback` - Function that takes the subject and a callback, must call the callback
+ `opts` - Options including `:prepend?` to add at beginning of hooks list

## ******Examples**

    # Add timing measurements        iex>     changeset        ...>     |>         Ash.Subject    .    around_transaction    (    fn         changeset    ,         callback         ->        ...>           start_time         =         System    .    monotonic_time    (    :millisecond    )        ...>           result         =         callback    .    (    changeset    )        ...>           duration         =         System    .    monotonic_time    (    :millisecond    )         -         start_time        ...>           Logger    .    info    (    "Transaction took     #{    duration    }    ms"    )        ...>           result        ...>     end    )    
        # Add retry logic for transient failures        iex>     query        ...>     |>         Ash.Subject    .    around_transaction    (    fn         query    ,         callback         ->        ...>           case         callback    .    (    query    )         do        ...>             {    :error    ,         %{    retryable?    :         true    }    }         =         error         ->        ...>               Logger    .    warn    (    "Retrying after error:     #{    inspect    (    error    )    }    "    )        ...>               :timer    .    sleep    (    100    )        ...>               callback    .    (    query    )        ...>             result         ->        ...>               result        ...>           end        ...>     end    )    
        # Wrap with custom error handling        iex>     action_input        ...>     |>         Ash.Subject    .    around_transaction    (    fn         input    ,         callback         ->        ...>           try         do        ...>             callback    .    (    input    )        ...>           rescue        ...>             exception         ->        ...>               Logger    .    error    (    "Transaction failed:     #{    Exception    .    message    (    exception    )    }    "    )        ...>               {    :error    ,         Exception    .    message    (    exception    )    }        ...>           end        ...>     end    )

## ******Warning**

This is an advanced hook that controls transaction execution. You **must** call the callback function provided to your hook, and the return value must match the structure returned by the callback \(typically `{:ok, result}` or `{:error, reason}`\).

Failing to call the callback will prevent the transaction from executing at all.

## ******See also**

+ `before_transaction/3` and `after_transaction/3` for simpler hooks
+ `around_action/2` for wrapping just the action execution





# before\_action\(subject, callback, opts \\\\ \[\]\)




    @spec     before_action(
      subject ::     t    (),
      callback ::     before_action_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a callback to be executed before the action.

## ******Parameters**

+ `subject` - The subject to add callback to
+ `callback` - Function that takes and returns the subject
+ `opts` - Options including `:prepend?` to add at beginning





# before\_transaction\(subject, callback, opts \\\\ \[\]\)




    @spec     before_transaction(
      subject ::     t    (),
      callback ::     before_transaction_fun    (),
      opts ::     Keyword.t    ()
    ) ::     t    ()


Adds a before\_transaction hook to the subject.

Before transaction hooks are executed before the database transaction begins. They receive the subject and must return either a modified subject or an error tuple. These hooks are useful for validation, authorization checks, or preparatory logic that should run outside of the transaction.

## ******Parameters**

+ `subject` - The subject to add the hook to \(Changeset, Query, or ActionInput\)
+ `callback` - Function that takes the subject and returns the subject or `{:error, reason}`
+ `opts` - Options including `:prepend?` to add at beginning of hooks list

## ******Examples**

    # Add validation before transaction starts        iex>     changeset        ...>     |>         Ash.Subject    .    before_transaction    (    fn         changeset         ->        ...>           if         valid_state?    (    changeset    )         do        ...>             changeset        ...>           else        ...>             {    :error    ,         "Invalid state for this operation"    }        ...>           end        ...>     end    )    
        # Add logging for all subject types        iex>     subject        ...>     |>         Ash.Subject    .    before_transaction    (    fn         subject         ->        ...>           Logger    .    info    (    "Starting transaction for     #{    inspect    (    subject    .    resource    )    }    "    )        ...>           subject        ...>     end    )    
        # Prepend a hook to run first        iex>     query        ...>     |>         Ash.Subject    .    before_transaction    (    check_permissions    ,         prepend?    :         true    )

## ******See also**

+ `after_transaction/3` for hooks that run after the transaction completes
+ `around_transaction/3` for hooks that wrap the entire transaction
+ `before_action/3` for hooks that run before the action \(inside transaction\)





# delete\_argument\(subject, argument\_or\_arguments\)




    @spec     delete_argument(
      subject ::     t    (),
      argument_or_arguments ::     atom    () |     String.t    () | [    atom    () |     String.t    ()]
    ) ::     t    ()


Deletes one or more arguments from the subject.

## ******Parameters**

+ `subject` - The subject to delete arguments from
+ `arguments` - Single argument name or list of argument names to delete





# fetch\_argument\(subject, argument\)




    @spec     fetch_argument(subject ::     t    (), argument ::     atom    () |     String.t    ()) ::
      {:ok,     term    ()} | :error


Fetches an argument value from the subject.

Returns `{:ok, value}` if the argument exists, `:error` otherwise. Supports both atom and string argument names.

## ******Parameters**

+ `subject` - The subject to fetch argument from
+ `argument` - The argument name \(atom or string\)





# get\_argument\(subject, argument\)




    @spec     get_argument(subject ::     t    (), argument ::     atom    () |     String.t    ()) ::     term    ()


Gets an argument value from the subject.

Supports both atom and string argument names.

## ******Parameters**

+ `subject` - The subject to get argument from
+ `argument` - The argument name \(atom or string\)





# get\_argument\(subject, argument, default \\\\ nil\)




    @spec     get_argument(subject ::     t    (), argument ::     atom    () |     String.t    (), default ::     term    ()) ::
          term    ()


Gets an argument value from the subject

Supports both atom and string argument names.

## ******Parameters**

+ `subject` - The subject to get argument from
+ `argument` - The argument name \(atom or string\)
+ `default` - The default value to return if the argument is not found





# get\_argument\_or\_attribute\(subject, argument\_or\_attribute, default \\\\ nil\)




    @spec     get_argument_or_attribute(
      subject ::     t    (),
      argument_or_attribute ::     atom    () |     String.t    (),
      default ::     term    ()
    ) ::     term    () | nil


Gets an argument or attribute value from a subject

For Changesets, this will return the argument if it exists, otherwise the attribute. For Query and ActionInput, this only retrieves arguments.

## ******Parameters**

+ `subject` - The subject to get value from
+ `name` - The argument or attribute name \(atom or string\)
+ `default` - The default value to return if the argument or attribute is not found





# get\_attribute\(subject, attribute\)




    @spec     get_attribute(subject ::     t    (), attribute ::     atom    ()) ::     term    ()





# put\_context\(subject, key, value\)




    @spec     put_context(
      subject ::     t    (),
      key ::     atom    (),
      value ::     term    ()
    ) ::     t    ()


Puts a key-value pair into the subject's context.

## ******Parameters**

+ `subject` - The subject to update context on
+ `key` - The context key
+ `value` - The value to store





# set\_argument\(subject, argument, value\)




    @spec     set_argument(subject ::     t    (), argument ::     atom    () |     String.t    (), value ::     term    ()) ::
          t    ()


Sets a single argument on the subject.

## ******Parameters**

+ `subject` - The subject to set argument on
+ `argument` - The argument name \(atom or string\)
+ `value` - The value to set





# set\_arguments\(subject, map\)




    @spec     set_arguments(subject ::     t    (), arguments ::     map    ()) ::     t    ()


Sets multiple arguments on the subject.

Takes a map of argument names to values and sets them all.

## ******Parameters**

+ `subject` - The subject to set arguments on
+ `arguments` - Map of argument names to values





# set\_context\(subject, map\)




    @spec     set_context(subject ::     t    (), context ::     map    ()) ::     t    ()


Sets the context for the subject.

Merges the provided map into the subject's existing context. For Changeset and Query, delegates to their specific implementations.

## ******Parameters**

+ `subject` - The subject to set context on
+ `context` - Map of context data to merge





# set\_private\_argument\(subject, argument, value\)




    @spec     set_private_argument(
      subject ::     Ash.Changeset.t    () |     Ash.ActionInput.t    (),
      argument ::     atom    () |     String.t    (),
      value ::     term    ()
    ) ::     t    ()


Sets a private argument value on the action input.

*Only supports `Ash.Changeset` and `Ash.ActionInput` subjects.*

Private arguments are not exposed in the public API and can only be set internally. This function will only work for arguments marked as `public?: false` in the action definition.

## ******Examples**

    # Set a private argument (assuming :internal_flag is private)        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    }    )        ...>     |>         Ash.Subject    .    set_private_argument    (    :internal_flag    ,         true    )        ...>     |>         Ash.Subject    .    get_argument    (    :internal_flag    )        true    
        # Attempting to set a public argument as private will error        iex>     input         =         MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :example    ,         %{    }    )        ...>     |>         Ash.Subject    .    set_private_argument    (    :public_arg    ,         "value"    )        iex>     input    .    valid?        false    
        # Use in action implementations for internal state        iex>     MyApp.Post        ...>     |>         Ash.ActionInput    .    for_action    (    :complex_workflow    ,         %{    data    :         "user_data"    }    )        ...>     |>         Ash.Subject    .    set_private_argument    (    :workflow_step    ,         1    )

## ******See also**

+ `set_argument/3` for setting public arguments
+ `get_argument/2-3` for retrieving argument values
+ Action argument definitions with `public?: false`





# set\_private\_arguments\(subject, map\)




    @spec     set_private_arguments(
      subject ::     Ash.Changeset.t    () |     Ash.ActionInput.t    (),
      arguments ::     map    ()
    ) ::     t    ()


Sets multiple private arguments on the subject.

*Only supports `Ash.Changeset` and `Ash.ActionInput` subjects.*

Takes a map of argument names to values and sets them all as private arguments.

## ******Parameters**

+ `subject` - The subject to set private arguments on \(Changeset or ActionInput\)
+ `arguments` - Map of argument names to values





# Ash.ToTenant **protocol** 

Converts a value to a tenant. To add this to a resource, implement the protocol like so:application

What this should do is entirely dependent on how you've set up your tenants. This example assumes that you want the tenant to be `org_#{organization_id}`, but it could also be something like `organization.schema`.

    defmodule         MyApp.Organization         do    
          use         Ash.Resource    ,         ...    

          ...    

          defimpl         Ash.ToTenant         do    
            def         to_tenant    (    %{    id    :         id    }    ,         _resource    )    ,         do    :         "org_    #{    id    }    "    
          end        end





# Summary


## **Types** 


t\(\) 




## **Functions** 


to\_tenant\(value, resource\) 



# Types




# t\(\)




    @type     t() ::     term    ()





# Functions




# to\_tenant\(value, resource\)




    @spec     to_tenant(    t    (),     Ash.Resource.t    ()) ::     term    ()





# Ash.TypedStruct 

A DSL for defining typed structs with field validation and constraints.

`Ash.TypedStruct` provides a convenient way to define a struct type in Ash.

Under the hood, it creates an `Ash.Type.NewType` with `subtype_of: :struct` and the appropriate constraints.

## Example

    defmodule         MyApp.UserProfile         do    
          use         Ash.TypedStruct     

          typed_struct         do    
            field         :username    ,         :string    ,         allow_nil?    :         false    
            field         :email    ,         :string    ,         constraints    :         [    match    :         ~r/@/    ]    
            field         :age    ,         :integer    ,         constraints    :         [    min    :         0    ,         max    :         150    ]    
            field         :bio    ,         :string    ,         default    :         ""    
            field         :verified    ,         :boolean    ,         default    :         false    
          end        end    
        # Creating instances        {    :ok    ,         profile    }         =         MyApp.UserProfile    .    new    (    username    :         "john"    ,         email    :         "john@example.com"    )    
        # Using new! for raising on errors        profile         =         MyApp.UserProfile    .    new!    (    username    :         "jane"    ,         email    :         "jane@example.com"    ,         age    :         25    )    
        # Can be used as an Ash type        defmodule         MyApp.User         do    
          use         Ash.Resource    

          attributes         do    
            attribute         :profile    ,         MyApp.UserProfile    
          end        end

## Field Options

+ `:type` - The Ash type of the field \(required\)
+ `:default` - Default value for the field
+ `:allow_nil?` - Whether the field can be nil \(defaults to `true`\)
+ `:constraints` - Type-specific constraints \(e.g., `:min`, `:max`, `:match`\)
+ `:description` - Field documentation

## Constructor Functions

The generated module includes:

+ `new/1` - Returns `{:ok, struct}` or `{:error, error}`
+ `new!/1` - Returns the struct or raises an error

## Overriding new/1

You can override the `new/1` function to add custom logic:

    defmodule         MyApp.CustomStruct         do    
          use         Ash.TypedStruct    

          typed_struct         do    
            field         :name    ,         :string    ,         allow_nil?    :         false    
            field         :created_at    ,         :utc_datetime    
          end    

          def         new    (    params    )         do    
            params         =         Map    .    put_new    (    params    ,         :created_at    ,         DateTime    .    utc_now    (    )    )    
            super    (    params    )    
          end        end

### Options

+ 
`:extensions` \(list of module that adopts `Spark.Dsl.Extension`\) - A list of DSL extensions to add to the `Spark.Dsl`

+ 
`:otp_app` \(`atom/0`\) - The otp\_app to use for any application configurable options

+ 
`:fragments` \(list of `module/0`\) - Fragments to include in the `Spark.Dsl`. See the fragments guide for more.





# Comp 

Provides utilities to implement and work with `Comparable` types





# Summary


## **Types** 


left\(\) 



right\(\) 




## **Functions** 


compare\(left, right\) 


Compare left and right term




defcomparable\(arg1, arg2, list\) 


Helper to define ordering relation for pair of types, accepts two `term :: type` pairs and block of code where relation is described.




eq\(\) 



equal?\(left, right\) 


Is left term equal to right term?




greater\_or\_equal?\(left, right\) 


Is left term greater or equal to right term?




greater\_than?\(left, right\) 


Is left term greater than right term?




gt\(\) 



less\_or\_equal?\(left, right\) 


Is left term less or equal to right term?




less\_than?\(left, right\) 


Is left term less than right term?




lt\(\) 



max\(left, right\) 


Returns the biggest of the two given terms, if terms are equal - then the first one is returned




min\(left, right\) 


Returns the smallest of the two given terms, if terms are equal - then the first one is returned




not\_equal?\(left, right\) 


Is left term not equal to right term?




type\_of\(v\) 



# Types




# left\(\)




    @type     left() ::     term    ()





# right\(\)




    @type     right() ::     term    ()





# Functions




# compare\(left, right\)




    @spec     compare(    left    (),     right    ()) ::     Comparable.ord    ()


Compare left and right term

## ******Examples**

    iex>     Comp    .    compare    (    1    ,         2    )        :lt        iex>     Comp    .    compare    (    2    ,         1    )        :gt        iex>     Comp    .    compare    (    1    ,         1    )        :eq





# defcomparable\(arg1, arg2, list\)
\(macro\)   


Helper to define ordering relation for pair of types, accepts two `term :: type` pairs and block of code where relation is described.

## ******Examples**

    iex>     quote         do        ...>           use         Comp        ...>           defmodule         Foo         do        ...>             defstruct         [    :value    ,         :meta    ]        ...>           end        ...>           defmodule         Bar         do        ...>             defstruct         [    :value    ,         :meta    ]        ...>           end        ...>           defcomparable         %    Foo    {    value    :         left    }         ::         Foo    ,         %    Foo    {    value    :         right    }         ::         Foo         do        ...>             Comp    .    compare    (    left    ,         right    )        ...>           end        ...>           defcomparable         %    Foo    {    value    :         left    }         ::         Foo    ,         %    Bar    {    value    :         right    }         ::         Bar         do        ...>             Comp    .    compare    (    left    ,         right    )        ...>           end        ...>           defcomparable         %    Foo    {    value    :         left    }         ::         Foo    ,         right         ::         Integer         do        ...>             Comp    .    compare    (    left    ,         right    )        ...>           end        ...>     end        ...>     |>         Code    .    compile_quoted        iex>     quote         do        ...>           x         =         %    Foo    {    value    :         1    ,         meta    :         1    }        ...>           y         =         %    Foo    {    value    :         1    ,         meta    :         2    }        ...>           Comp    .    equal?    (    x    ,         y    )         &&         Comp    .    equal?    (    y    ,         x    )        ...>     end        ...>     |>         Code    .    eval_quoted        ...>     |>         elem    (    0    )        true        iex>     quote         do        ...>           x         =         %    Foo    {    value    :         1    ,         meta    :         1    }        ...>           y         =         %    Bar    {    value    :         1    ,         meta    :         2    }        ...>           Comp    .    equal?    (    x    ,         y    )         &&         Comp    .    equal?    (    y    ,         x    )        ...>     end        ...>     |>         Code    .    eval_quoted        ...>     |>         elem    (    0    )        true        iex>     quote         do        ...>           x         =         %    Foo    {    value    :         1    ,         meta    :         1    }        ...>           y         =         1        ...>           Comp    .    equal?    (    x    ,         y    )         &&         Comp    .    equal?    (    y    ,         x    )        ...>     end        ...>     |>         Code    .    eval_quoted        ...>     |>         elem    (    0    )        true





# eq\(\)
\(macro\)   





# equal?\(left, right\)




    @spec     equal?(    left    (),     right    ()) ::     boolean    ()


Is left term equal to right term?

## ******Examples**

    iex>     Comp    .    equal?    (    1    ,         1    )        true        iex>     Comp    .    equal?    (    1    ,         :hello    )        false





# greater\_or\_equal?\(left, right\)




    @spec     greater_or_equal?(    left    (),     right    ()) ::     boolean    ()


Is left term greater or equal to right term?

## ******Examples**

    iex>     Comp    .    greater_or_equal?    (    1    ,         1    )        true        iex>     Comp    .    greater_or_equal?    (    1    ,         2    )        false        iex>     Comp    .    greater_or_equal?    (    2    ,         1    )        true





# greater\_than?\(left, right\)




    @spec     greater_than?(    left    (),     right    ()) ::     boolean    ()


Is left term greater than right term?

## ******Examples**

    iex>     Comp    .    greater_than?    (    1    ,         1    )        false        iex>     Comp    .    greater_than?    (    1    ,         2    )        false        iex>     Comp    .    greater_than?    (    2    ,         1    )        true





# gt\(\)
\(macro\)   





# less\_or\_equal?\(left, right\)




    @spec     less_or_equal?(    left    (),     right    ()) ::     boolean    ()


Is left term less or equal to right term?

## ******Examples**

    iex>     Comp    .    less_or_equal?    (    1    ,         1    )        true        iex>     Comp    .    less_or_equal?    (    1    ,         2    )        true        iex>     Comp    .    less_or_equal?    (    2    ,         1    )        false





# less\_than?\(left, right\)




    @spec     less_than?(    left    (),     right    ()) ::     boolean    ()


Is left term less than right term?

## ******Examples**

    iex>     Comp    .    less_than?    (    1    ,         1    )        false        iex>     Comp    .    less_than?    (    1    ,         2    )        true        iex>     Comp    .    less_than?    (    2    ,         1    )        false





# lt\(\)
\(macro\)   





# max\(left, right\)




    @spec     max(    left    (),     right    ()) ::     left    () |     right    ()


Returns the biggest of the two given terms, if terms are equal - then the first one is returned

## ******Examples**

    iex>     Comp    .    max    (    1    ,         1    )        1        iex>     Comp    .    max    (    1    ,         2    )        2        iex>     Comp    .    max    (    2    ,         1    )        2





# min\(left, right\)




    @spec     min(    left    (),     right    ()) ::     left    () |     right    ()


Returns the smallest of the two given terms, if terms are equal - then the first one is returned

## ******Examples**

    iex>     Comp    .    min    (    1    ,         1    )        1        iex>     Comp    .    min    (    1    ,         2    )        1        iex>     Comp    .    min    (    2    ,         1    )        1





# not\_equal?\(left, right\)




    @spec     not_equal?(    left    (),     right    ()) ::     boolean    ()


Is left term not equal to right term?

## ******Examples**

    iex>     Comp    .    not_equal?    (    1    ,         1    )        false        iex>     Comp    .    not_equal?    (    1    ,         :hello    )        true





# type\_of\(v\)





# Comparable **protocol** 

Protocol which describes ordering relation for pair of types





# Summary


## **Types** 


ord\(\) 



t\(\) 




## **Functions** 


compare\(left\_and\_right\) 


Accepts struct with fields :left and :right and returns ord value




# Types




# ord\(\)




    @type     ord() :: :gt | :lt | :eq





# t\(\)




    @type     t() ::     t    ()





# Functions




# compare\(left\_and\_right\)




    @spec     compare(    t    ()) ::     ord    ()


Accepts struct with fields :left and :right and returns ord value





# Comparable.Type.Any.To.Any 



# Comparable.Type.Ash.CiString.To.Ash.CiString 



# Comparable.Type.Ash.CiString.To.BitString 



# Comparable.Type.Atom.To.BitString 



# Comparable.Type.BitString.To.Ash.CiString 



# Comparable.Type.BitString.To.Atom 



# Comparable.Type.BitString.To.Decimal 



# Comparable.Type.Date.To.Date 



# Comparable.Type.DateTime.To.DateTime 



# Comparable.Type.Decimal.To.BitString 



# Comparable.Type.Decimal.To.Decimal 



# Comparable.Type.Decimal.To.Float 



# Comparable.Type.Decimal.To.Integer 



# Comparable.Type.Float.To.Decimal 



# Comparable.Type.Integer.To.Decimal 



# Comparable.Type.List.To.List 



# Comparable.Type.Map.To.Map 



# Comparable.Type.NaiveDateTime.To.NaiveDateTime 



# Comparable.Type.Time.To.Time 



# Comparable.Type.Tuple.To.Tuple 



# mix ash 

Prints Ash tasks and their information.

    $     mix ash

To print the Ash version, pass `-v` or `--version`, for example:

    $     mix ash --version





# mix ash.codegen 

Runs all codegen tasks for any extension on any resource/domain in your application.

## Flags

+ `--dry-run` - no files are created, instead the new generated code is printed to the console
+ `--check` - no files are created, returns an exit\(1\) code if any code would need to be generated
+ `--dev` - runs codegen tasks in dev mode. See the section on dev mode below
+ Individual extensions may use additional flags.

## Dev Mode

Some extensions that do `codegen` require providing a `name`. Those extensions \(should\) support a `--dev` flag, which indicates that the codegen can have a temporary name chosen by the extension. Then, once you are ready to commit the changes, you can run the codegen tasks again without the `--dev` flag and with a name to generate the final code.

For example, using AshPostgres:

+ First we add `first_name` to `MyApp.Accounts.User`
+ `mix ash.codegen --dev`, which generates a migration for adding `first_name` to the `"users"` table, but the migration is suffixed with `_dev`
+ `mix ash.migrate` apply the migrations
+ Then we add `last_name` to `MyApp.Accounts.User`
+ `mix ash.codegen --dev` which generates a migration for adding `last_name` to the `"users"` table, but the migration is suffixed with `_dev`
+ We review our changes, and are ready to save them as a unit
+ `mix ash.codegen add_name_to_user`, which rolls back and deletes the dev migrations & snapshots, and creates new ones using the provided name





# Summary


## **Functions** 


run\(argv\) 


Runs all codegen tasks for any extension on any resource/domain in your application.




# Functions




# run\(argv\)



Runs all codegen tasks for any extension on any resource/domain in your application.





# mix ash.extend 

Adds an extension or extensions to the domain/resource

Extensions can either be a fully qualified module name, or one of the following list, based on the thing being extended

### Ash.Domain

+ `json_api` - `AshJsonApi.Domain`
+ `graphql` - `AshGraphql.Domain`

### Ash.Resource

+ `postgres` - `AshPostgres.DataLayer`
+ `sqlite` - `AshSqlite.DataLayer`
+ `mysql` - `AshMysql.DataLayer`
+ `ets` - `Ash.DataLayer.Ets`
+ `mnesia` - `Ash.DataLayer.Mnesia`
+ `embedded` - `data_layer: :embedded`
+ `json_api` - `AshJsonApi.Resource`
+ `graphql` - `AshGraphql.Resource`

## Example

    mix ash.extend My.Domain.Resource postgres,Ash.Policy.Authorizer





# mix ash.gen.base\_resource 

Generates a base resource

See the writing extensions guide for more.

## Example

    mix ash.gen.base_resource MyApp.Resource





# mix ash.gen.change 

Generates a custom change

See Custom Changes for more.

## Example

    mix ash.gen.change MyApp.Changes.Slugify





# mix ash.gen.custom\_expression 

Generates a custom expression

See Ash.CustomExpression for more.

## Example

    mix ash.gen.custom_expression MyApp.Expressions.LevenshteinDistance --args string,string

## Options

+ `--args` - A comma separated list of argument types. i.e `--args string`





# mix ash.gen.domain 

Generates an Ash.Domain

## Example

    mix ash.gen.domain MyApp.Accounts





# mix ash.gen.enum 

Generates an Ash.Type.Enum

## Example

    mix ash.gen.enum MyApp.Support.Ticket.Types.Status open,closed --short-name ticket_status

## Options

+ `--short-name`, `-s`: Register the type under the provided shortname, so it can be referenced like `:short_name` instead of the module name.
+ `--ignore-if-exists` - Does nothing if the resource already exists





# mix ash.gen.preparation 

Generates a custom preparation

See Custom Preparations for more.

## Example

    mix ash.gen.preparation MyApp.Preparations.Top5





# mix ash.gen.resource 

Generate and configure an Ash.Resource.

If the domain does not exist, we create it. If it does, we add the resource to it if it is not already present.

## Example

    mix ash.gen.resource Helpdesk.Support.Ticket \      --default-actions read \      --uuid-primary-key id \      --attribute subject:string:required:public \      --relationship belongs_to:representative:Helpdesk.Support.Representative \      --timestamps \      --extend postgres,graphql    

## Options

+ `--attribute` or `-a` - An attribute or comma separated list of attributes to add, as `name:type`. Modifiers: `primary_key`, `array`, `public`, `sensitive`, and `required`. i.e `-a name:string:required`
+ `--relationship` or `-r` - A relationship or comma separated list of relationships to add, as `type:name:dest`. Modifiers: `public`. `belongs_to` only modifiers: `primary_key`, `sensitive`, and `required`. i.e `-r belongs_to:author:MyApp.Accounts.Author:required`
+ `--default-actions` - A csv list of default action types to add. The `create` and `update` actions accept the public attributes being added.
+ `--uuid-primary-key` or `-u` - Adds a UUIDv4 primary key with that name. i.e `-u id`
+ `--uuid-v7-primary-key` - Adds a UUIDv7 primary key with that name.
+ `--integer-primary-key` or `-i` - Adds an integer primary key with that name. i.e `-i id`
+ `--domain` or `-d` - The domain module to add the resource to. i.e `-d MyApp.MyDomain`. This defaults to the resource's module name, minus the last segment.
+ `--extend` or `-e` - A comma separated list of modules or builtins to extend the resource with. i.e `-e postgres,Some.Extension`
+ `--base` or `-b` - The base module to use for the resource. i.e `-b Ash.Resource`. Requires that the module is in `config :your_app, :base_resources`
+ `--timestamps` or `-t` - If set adds `inserted_at` and `updated_at` timestamps to the resource.
+ `--ignore-if-exists` - Does nothing if the resource already exists
+ `--conflicts` - How to handle conflicts when the same attribute, relationship, or action already exists. Options: `ignore` \(default\), `replace` `ignore` will ignore your addition for that attribute, relationship, or action. `replace` will remove the existing one in favor of yours.





# mix ash.gen.validation 

Generates a custom validation

See Custom Validations for more.

## Example

    mix ash.gen.validation MyApp.Validations.IsPrime





# mix ash.generate\_livebook 

Generates a Livebook for each Ash domain.

## Command line options

+ `--filename` - Specify the name of the generated Livebook file. Default: `livebook.livemd`





# Summary


## **Functions** 


run\(argv\) 


Generates a Livebook for each Ash domain




# Functions




# run\(argv\)



Generates a Livebook for each Ash domain





# mix ash.generate\_policy\_charts 

Generates a Mermaid Flow Chart for a given resource's policies.

## Prerequisites

This mix task requires the Mermaid CLI to be installed on your system.

See https://github.com/mermaid-js/mermaid-cli

## Command line options

+ `--only` - only generates for the given file
+ `--format` - Can be set to one of either:
	+ `plain` - Prints just the mermaid output as text. This is the default.
	+ `md` - Prints the mermaid diagram in a markdown code block.
	+ `svg` - Generates an SVG
	+ `pdf` - Generates a PDF
	+ `png` - Generates a PNG





# Summary


## **Functions** 


run\(argv\) 


Generates a Mermaid Flow Chart for a given resource's policies.




# Functions




# run\(argv\)



Generates a Mermaid Flow Chart for a given resource's policies.





# mix ash.generate\_resource\_diagrams 

Generates a Mermaid Resource Diagram for each Ash domain.

## Prerequisites

This mix task requires the Mermaid CLI to be installed on your system.

See https://github.com/mermaid-js/mermaid-cli

## Command line options

+ `--type` - `er` or `class` \(defaults to `class`\)
+ `--only` - only generates for the given domain
+ `--format` - Can be set to one of either:
	+ `plain` - Prints just the mermaid output as text. This is the default.
	+ `md` - Prints the mermaid diagram in a markdown code block.
	+ `svg` - Generates an SVG
	+ `pdf` - Generates a PDF
	+ `png` - Generates a PNG





# Summary


## **Functions** 


run\(argv\) 


Generates Mermaid Resource Diagrams for each Ash domain




# Functions




# run\(argv\)



Generates Mermaid Resource Diagrams for each Ash domain





# mix ash.install 

Installs Ash into a project. Should be called with `mix igniter.install ash`

## Options

+ `--example` - Creates some example resources. When used, will pass through options to `mix ash.gen.resource`. See that task docs for more.





# mix ash.migrate 

Runs all migration tasks for any extension on any resource/domain in your application.





# Summary


## **Functions** 


run\(argv\) 


Runs all migration tasks for any extension on any resource/domain in your application.




# Functions




# run\(argv\)



Runs all migration tasks for any extension on any resource/domain in your application.





# mix ash.patch.extend 

Adds an extension or extensions to the domain/resource. Use `ash.extend` instead.





# mix ash.reset 

Runs all tear down tasks for any extension on any resource/domain in your application, followed by setup tasks.





# Summary


## **Functions** 


run\(argv\) 


Runs all tear down & setup tasks for any extension on any resource/domain in your application.




# Functions




# run\(argv\)



Runs all tear down & setup tasks for any extension on any resource/domain in your application.





# mix ash.rollback 

Runs all rollback tasks for any extension on any resource/domain in your application.





# Summary


## **Functions** 


run\(argv\) 


Runs all rollback tasks for any extension on any resource/domain in your application.




# Functions




# run\(argv\)



Runs all rollback tasks for any extension on any resource/domain in your application.





# mix ash.setup 

Runs all setup tasks for any extension on any resource/domain in your application.





# Summary


## **Functions** 


run\(argv\) 


Runs all setup tasks for any extension on any resource/domain in your application.




# Functions




# run\(argv\)



Runs all setup tasks for any extension on any resource/domain in your application.





# mix ash.tear\_down 

Runs all tear down tasks for any extension on any resource/domain in your application.





# Summary


## **Functions** 


run\(argv\) 


Runs all tear\_down tasks for any extension on any resource/domain in your application.




# Functions




# run\(argv\)



Runs all tear\_down tasks for any extension on any resource/domain in your application.



