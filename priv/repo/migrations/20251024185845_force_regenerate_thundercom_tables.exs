defmodule Thunderline.Repo.Migrations.ForceRegenerateThundercomTables do
  @moduledoc """
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  """

  use Ecto.Migration

  def up do
    execute "CREATE EXTENSION IF NOT EXISTS pg_trgm"

    create_if_not_exists table(:decision_traces, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid, null: false
      add :feature_window_id, :uuid, null: false
      add :router_version, :text, null: false
      add :gate_scores, :map, null: false, default: %{}
      add :selected_experts, :map, null: false, default: %{}
      add :actions, :map, null: false, default: %{}
      add :blended_action, :map
      add :pnl_snapshot, :map
      add :risk_flags, :map, null: false, default: %{}
      add :behavior_embedding, :binary
      add :hash, :binary, null: false

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderlane_rule_oracles, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :implementation, :text, null: false
      add :description, :text
      add :input_size, :bigint, default: 16
      add :hidden_size, :bigint, default: 32
      add :batch_size, :bigint, default: 32
      add :temperature, :float, default: 1.0
      add :total_inferences, :bigint, default: 0
      add :avg_latency_us, :float
      add :error_rate, :float, default: 0.0
      add :last_inference_at, :utc_datetime
      add :model_version, :text
      add :training_examples, :bigint, default: 0
      add :model_size_bytes, :bigint
      add :rule_parameters, :map, default: %{}
      add :performance_metrics, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :state, :text, null: false, default: "initializing"
    end

    create_if_not_exists table(:performance_traces, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :trace_id, :text, null: false
      add :span_name, :text, null: false
      add :duration_ms, :bigint, null: false
      add :status, :text
      add :domain, :text
      add :operation, :text
      add :metadata, :map, default: %{}
      add :parent_span_id, :text
      add :node_name, :text

      add :started_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :completed_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:performance_traces, [:trace_id, :span_name],
             name: "performance_traces_unique_span_index"
           )

    create_if_not_exists table(:voice_rooms, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :title, :text, null: false
      add :community_id, :uuid
      add :block_id, :uuid
      add :status, :text, null: false, default: "open"
      add :created_by_id, :uuid, null: false
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thundereye_system_actions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :action_name, :text, null: false
      add :domain, :text, null: false
      add :status, :text, null: false, default: "running"
      add :result_data, :map, null: false, default: %{}
      add :error_data, :map
      add :duration_ms, :bigint
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thundereye_system_actions, [:status, :inserted_at],
             name: "system_actions_status_time_idx"
           )

    create_if_not_exists index(:thundereye_system_actions, [:action_name, :inserted_at],
             name: "system_actions_name_time_idx"
           )

    create_if_not_exists index(:thundereye_system_actions, [:domain, :status],
             name: "system_actions_domain_status_idx"
           )

    create_if_not_exists table(:tokens, primary_key: false) do
      add :jti, :text, null: false, primary_key: true
      add :subject, :text, null: false
      add :expires_at, :utc_datetime, null: false
      add :purpose, :text, null: false
      add :extra_data, :map

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thundermag_task_executions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :execution_id, :uuid, null: false
      add :macro_command_id, :uuid, null: false
      add :status, :text, null: false, default: "pending"
      add :total_tasks, :bigint, null: false, default: 0
      add :completed_tasks, :bigint, default: 0
      add :failed_tasks, :bigint, default: 0
      add :execution_plan, :map, default: %{}
      add :results, {:array, :map}, default: []
      add :errors, {:array, :map}, default: []
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime
      add :session_id, :uuid
      add :zone_assignments, {:array, :text}, default: []

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:system_metrics, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :domain, :text, null: false
      add :metric_name, :text, null: false
      add :value, :decimal, null: false
      add :unit, :text
      add :tags, :map, default: %{}
      add :node_name, :text

      add :collected_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:system_metrics, [:domain, :metric_name, :collected_at, :node_name],
             name: "system_metrics_unique_metric_point_index"
           )

    create_if_not_exists table(:ml_consent_records, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :user_id, :uuid, null: false
      add :tenant_id, :text, null: false
      add :purpose, :text, null: false
      add :granted_at, :utc_datetime_usec
      add :revoked_at, :utc_datetime_usec
      add :expires_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:ml_consent_records, [:user_id, :tenant_id, :purpose],
             name: "ml_consent_records_unique_consent_index"
           )

    create_if_not_exists table(:ml_training_runs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :run_id, :text, null: false
      add :tenant_id, :text, null: false
      add :dataset_id, :uuid, null: false
      add :spec_id, :uuid, null: false
      add :artifact_id, :uuid
      add :params, :map, default: %{}
      add :status, :text, default: "queued"
      add :error, :text
      add :started_at, :utc_datetime_usec
      add :completed_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:messages, primary_key: false) do
      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :text, :text, null: false
      add :tool_calls, {:array, :map}
      add :tool_results, {:array, :map}
      add :source, :text, null: false, default: "user"
      add :complete, :boolean, null: false, default: true
      add :conversation_id, :uuid, null: false
      add :response_to_id, :uuid
    end

    create_if_not_exists table(:thunderblock_cache_entries, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :cache_key, :text, null: false
      add :cache_value, :map, null: false, default: %{}
      add :expires_at, :utc_datetime
      add :hit_count, :bigint, null: false, default: 0
      add :last_hit_at, :utc_datetime
      add :cache_tags, {:array, :text}, null: false, default: []

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thunderblock_cache_entries, [:cache_tags],
             name: "cache_entries_tags_idx",
             using: :gin
           )

    create_if_not_exists index(:thunderblock_cache_entries, [:expires_at], name: "cache_entries_expires_idx")

    create_if_not_exists index(:thunderblock_cache_entries, [:cache_key],
             name: "cache_entries_key_idx",
             unique: true
           )

    create_if_not_exists unique_index(:thunderblock_cache_entries, [:cache_key],
             name: "thunderblock_cache_entries_unique_cache_key_index"
           )

    create_if_not_exists table(:experiences, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :experience_type, :text, null: false
      add :situation_context, :text, null: false
      add :action_taken, :text, null: false
      add :outcome, :text, null: false
      add :lesson_learned, :text
      add :impact_score, :float, default: 0.5
      add :surprise_factor, :float, default: 0.0
      add :difficulty_level, :bigint, default: 5
      add :times_referenced, :bigint, default: 0
      add :learning_strength, :float, default: 1.0
      add :emotions_felt, {:array, :text}, default: []
      add :skills_used, {:array, :text}, default: []
      add :environmental_factors, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :agent_id, :uuid, null: false
      add :decision_id, :uuid
      add :action_id, :uuid
    end

    create_if_not_exists table(:thundercore_agents, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :agent_name, :text, null: false
      add :agent_type, :text, null: false
      add :status, :text, default: "starting"
      add :capabilities, :map, default: %{}
      add :current_task, :text
      add :last_heartbeat, :utc_datetime_usec, default: fragment("(now() AT TIME ZONE 'utc')")

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thundercore_agents, [:agent_name],
             name: "thundercore_agents_unique_agent_name_index"
           )

    create_if_not_exists table(:dag_edges, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :workflow_id, :uuid, null: false
      add :from_node_id, :uuid, null: false
      add :to_node_id, :uuid, null: false
      add :edge_type, :text, null: false, default: "causal"

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:probe_runs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :provider, :text, null: false
      add :model, :text
      add :prompt_path, :text, null: false
      add :laps, :bigint, null: false, default: 5
      add :samples, :bigint, null: false, default: 1
      add :embedding_dim, :bigint, null: false, default: 512
      add :embedding_ngram, :bigint, null: false, default: 3
      add :condition, :text
      add :attractor_m, :bigint
      add :attractor_tau, :bigint
      add :attractor_min_points, :bigint
      add :status, :text, null: false
      add :error_message, :text
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime
      add :intrinsic_reward, :decimal

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:probe_runs, [:model])

    create_if_not_exists index(:probe_runs, [:provider])

    create_if_not_exists index(:probe_runs, [:status])

    create_if_not_exists table(:upm_snapshots, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :version, :text, null: false
      add :tenant_id, :uuid
      add :mode, :text, null: false, default: "shadow"
      add :status, :text, null: false, default: "created"
      add :checksum, :text
      add :size_bytes, :bigint
      add :storage_path, :text
      add :activated_at, :utc_datetime_usec
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :trainer_id, :uuid, null: false
    end

    create_if_not_exists table(:thunderblock_messages, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :content, :text, null: false
      add :message_type, :text, null: false, default: "text"
      add :sender_id, :uuid, null: false
      add :sender_type, :text, null: false, default: "user"
      add :status, :text, null: false, default: "active"

      add :reply_to_id,
          references(:thunderblock_messages,
            column: :id,
            name: "thunderblock_messages_reply_to_id_fkey",
            type: :uuid,
            on_delete: :nilify_all,
            on_update: :update_all
          )

      add :thread_root_id,
          references(:thunderblock_messages,
            column: :id,
            name: "thunderblock_messages_thread_root_id_fkey",
            type: :uuid,
            on_delete: :nilify_all,
            on_update: :update_all
          )

      add :attachments, {:array, :map}, null: false, default: []
      add :reactions, :map, null: false, default: %{}
      add :mentions, {:array, :uuid}, null: false, default: []
      add :channel_mentions, {:array, :uuid}, null: false, default: []
      add :role_mentions, {:array, :uuid}, null: false, default: []
      add :message_flags, {:array, :text}, null: false, default: []
      add :edit_history, {:array, :map}, null: false, default: []
      add :ai_metadata, :map, null: false
      add :pac_metadata, :map, null: false
      add :federation_metadata, :map, null: false
      add :search_vector, :text
      add :thread_participant_count, :bigint, null: false, default: 0
      add :thread_message_count, :bigint, null: false, default: 0
      add :last_thread_activity, :utc_datetime
      add :moderation_data, :map, null: false
      add :message_metrics, :map, null: false
      add :ephemeral_until, :utc_datetime
      add :tags, {:array, :text}, null: false, default: []
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :channel_id, :uuid
      add :community_id, :uuid
    end

    create_if_not_exists index(:thunderblock_messages, [:reactions], using: :gin,
             name: "messages_reactions_idx"
           )

    create_if_not_exists index(:thunderblock_messages, [:tags], using: :gin, name: "messages_tags_idx")

    create_if_not_exists index(:thunderblock_messages, [:message_flags], using: :gin,
             name: "messages_flags_idx"
           )

    create_if_not_exists index(:thunderblock_messages, [:mentions], using: :gin, name: "messages_mentions_idx")

    execute """
    CREATE INDEX IF NOT EXISTS messages_search_idx
    ON thunderblock_messages USING gin (search_vector gin_trgm_ops)
    """

    create_if_not_exists index(:thunderblock_messages, [:ephemeral_until], name: "messages_ephemeral_idx")

    create_if_not_exists index(:thunderblock_messages, [:message_type, :sender_type], name: "messages_type_idx")

    create_if_not_exists index(:thunderblock_messages, [:status, :inserted_at],
             name: "messages_status_time_idx"
           )

    create_if_not_exists index(:thunderblock_messages, [:reply_to_id], name: "messages_reply_idx")

    create_if_not_exists index(:thunderblock_messages, [:thread_root_id, :inserted_at],
             name: "messages_thread_idx"
           )

    create_if_not_exists index(:thunderblock_messages, [:sender_id, :inserted_at],
             name: "messages_sender_time_idx"
           )

    create_if_not_exists index(:thunderblock_messages, [:channel_id, :inserted_at],
             name: "messages_channel_time_idx"
           )

    create_if_not_exists table(:thunderblock_pac_homes, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :home_name, :text, null: false
      add :home_slug, :text, null: false
      add :status, :text, null: false, default: "provisioning"
      add :owner_id, :uuid, null: false
      add :pac_config, :map, null: false
      add :resource_limits, :map, null: false
      add :current_usage, :map, null: false
      add :agent_registry, :map, null: false, default: %{}
      add :networking_config, :map, null: false
      add :storage_config, :map, null: false
      add :community_integration, :map, null: false
      add :agent_permissions, :map, null: false
      add :automation_config, :map, null: false
      add :health_metrics, :map, null: false
      add :last_activity, :utc_datetime
      add :last_health_check, :utc_datetime
      add :provisioned_at, :utc_datetime
      add :suspended_until, :utc_datetime
      add :suspension_reason, :text
      add :backup_schedule, :map, null: false
      add :tags, {:array, :text}, null: false, default: []
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :community_id, :uuid
      add :zone_container_id, :uuid
    end

    create_if_not_exists index(:thunderblock_pac_homes, [:tags], using: :gin, name: "pac_homes_tags_idx")

    create_if_not_exists index(:thunderblock_pac_homes, [:health_metrics], using: :gin,
             name: "pac_homes_health_metrics_idx"
           )

    create_if_not_exists index(:thunderblock_pac_homes, [:current_usage], using: :gin,
             name: "pac_homes_usage_idx"
           )

    create_if_not_exists index(:thunderblock_pac_homes, [:agent_registry], using: :gin,
             name: "pac_homes_agents_idx"
           )

    create_if_not_exists index(:thunderblock_pac_homes, [:last_health_check], name: "pac_homes_health_idx")

    create_if_not_exists index(:thunderblock_pac_homes, [:suspended_until], name: "pac_homes_suspension_idx")

    create_if_not_exists index(:thunderblock_pac_homes, [:status, :last_activity],
             name: "pac_homes_activity_idx"
           )

    create_if_not_exists index(:thunderblock_pac_homes, [:community_id, :status],
             name: "pac_homes_community_idx"
           )

    create_if_not_exists index(:thunderblock_pac_homes, [:owner_id, :status], name: "pac_homes_owner_idx")

    create_if_not_exists index(:thunderblock_pac_homes, [:home_slug, :community_id],
             name: "pac_homes_slug_community_idx",
             unique: true
           )

    create_if_not_exists table(:thundereye_audit_logs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :action_type, :text, null: false
      add :target_resource_type, :text, null: false
      add :target_resource_id, :uuid
      add :actor_id, :uuid
      add :actor_type, :text, null: false, default: "user"
      add :changes, :map, null: false, default: %{}
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thundereye_audit_logs, [:inserted_at], name: "audit_logs_time_idx")

    create_if_not_exists index(:thundereye_audit_logs, [:actor_id, :action_type], name: "audit_logs_actor_idx")

    create_if_not_exists index(:thundereye_audit_logs, [:target_resource_type, :target_resource_id],
             name: "audit_logs_target_idx"
           )

    create_if_not_exists table(:export_jobs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid, null: false
      add :slice_spec, :map, null: false, default: %{}
      add :status, :text, null: false, default: "pending"
      add :artifact_uri, :text
      add :error, :text
      add :completed_at, :utc_datetime

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderflow_consciousness_flows, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :agent_id, :uuid, null: false
      add :consciousness_type, :text, null: false
      add :mental_state, :map, null: false, default: %{}
      add :awareness_level, :decimal, null: false, default: "0.5"
      add :cognitive_load, :decimal, null: false, default: "0.0"
      add :active_goals, {:array, :text}, null: false, default: []
      add :memory_anchors, {:array, :uuid}, null: false, default: []
      add :emotional_markers, :map, null: false, default: %{}
      add :flow_metadata, :map, null: false, default: %{}
      add :stream_position, :bigint, null: false, default: 0

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thunderflow_consciousness_flows, [:memory_anchors], using: :gin,
             name: "consciousness_flow_memory_anchors_gin_idx"
           )

    create_if_not_exists index(:thunderflow_consciousness_flows, [:active_goals], using: :gin,
             name: "consciousness_flow_active_goals_gin_idx"
           )

    create_if_not_exists index(:thunderflow_consciousness_flows, [:inserted_at])

    create_if_not_exists index(:thunderflow_consciousness_flows, [:stream_position])

    create_if_not_exists index(:thunderflow_consciousness_flows, [:awareness_level])

    create_if_not_exists index(:thunderflow_consciousness_flows, [:consciousness_type])

    create_if_not_exists index(:thunderflow_consciousness_flows, [:agent_id])

    create_if_not_exists table(:ml_model_specs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :text, null: false
      add :base_model, :text, null: false
      add :task, :text, null: false
      add :adapter, :text, null: false
      add :framework, :text, null: false
      add :params, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:dag_snapshots, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :workflow_id, :uuid, null: false
      add :version, :bigint, null: false, default: 1
      add :node_order, {:array, :uuid}, null: false, default: []
      add :nodes_payload, :map, null: false, default: %{}
      add :edges, {:array, :map}, null: false, default: []
      add :embedding_vector, {:array, :float}
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:ml_model_artifacts, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :spec_id,
          references(:ml_model_specs,
            column: :id,
            name: "ml_model_artifacts_spec_id_fkey",
            type: :uuid
          ),
          null: false

      add :model_run_id, :uuid
      add :uri, :text, null: false
      add :checksum, :text, null: false
      add :bytes, :bigint, null: false
      add :status, :text, default: "created"
      add :promoted, :boolean, default: false
      add :semver, :text, default: "0.1.0"

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderlane_coordinators, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :lane_dimension, :text, null: false
      add :name, :text, null: false
      add :description, :text
      add :active_ruleset_id, :uuid
      add :active_ruleset_version, :bigint
      add :status, :text, null: false, default: "initializing"
      add :topology_shape, :map, null: false
      add :cells_managed, :bigint, default: 0
      add :updates_per_second, :float, default: 0.0
      add :last_sync_at, :utc_datetime_usec
      add :coordination_latency_ms, :float
      add :coordinator_pid, :text
      add :coordinator_node, :text
      add :last_heartbeat_at, :utc_datetime_usec
      add :coupling_enabled, :boolean, null: false, default: true
      add :coupling_buffers, :map, default: %{}
      add :coupling_backpressure, :map, default: %{}
      add :event_queue_size, :bigint, default: 0
      add :events_processed, :bigint, default: 0
      add :events_dropped, :bigint, default: 0
      add :target_ups, :float, null: false, default: 1.0e3
      add :max_coordination_latency_ms, :float, null: false, default: 5.0
      add :max_queue_size, :bigint, null: false, default: 10000
      add :error_count, :bigint, default: 0
      add :last_error, :text
      add :last_error_at, :utc_datetime_usec
      add :config, :map, default: %{}
      add :metadata, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:ml_feature_views, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :feature_view_id, :text, null: false
      add :dataset_id, :uuid, null: false
      add :name, :text, null: false
      add :schema_json, :map, null: false
      add :materialization, :text, null: false
      add :version, :bigint, default: 1

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:decision_frameworks, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :description, :text
      add :framework_type, :text, null: false
      add :configuration, :map, default: %{}
      add :active, :boolean, default: true
      add :version, :text, default: "1.0.0"

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:decision_frameworks, [:name],
             name: "decision_frameworks_unique_name_index"
           )

    create_if_not_exists table(:health_checks, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :component, :text, null: false
      add :domain, :text, null: false
      add :status, :text
      add :response_time_ms, :bigint
      add :message, :text
      add :details, :map, default: %{}
      add :node_name, :text
      add :endpoint_url, :text
      add :check_type, :text
      add :timeout_ms, :bigint, default: 30000
      add :expected_status_code, :bigint
      add :metadata, :map, default: %{}

      add :checked_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:health_checks, [:component, :domain, :checked_at],
             name: "health_checks_unique_check_index"
           )

    create_if_not_exists table(:upm_adapters, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :adapter_key, :text, null: false
      add :tenant_id, :uuid
      add :mode, :text, null: false, default: "shadow"
      add :status, :text, null: false, default: "pending"
      add :last_synced_at, :utc_datetime_usec
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :snapshot_id,
          references(:upm_snapshots,
            column: :id,
            name: "upm_adapters_snapshot_id_fkey",
            type: :uuid
          ),
          null: false
    end

    create_if_not_exists unique_index(:upm_adapters, [:adapter_key, :tenant_id],
             name: "upm_adapters_adapter_key_per_tenant_index"
           )

    create_if_not_exists table(:thunderblock_load_balancing_rules, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :rule_name, :text, null: false
      add :target_service, :text, null: false
      add :algorithm, :text, default: "round_robin"
      add :weights, :map, default: %{}
      add :health_check_path, :text
      add :is_active, :boolean, default: true

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderblock_load_balancing_rules, [:rule_name, :target_service],
             name: "thunderblock_load_balancing_rules_unique_rule_service_index"
           )

    create_if_not_exists table(:data_adapters, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :source_format, :text, null: false
      add :target_format, :text, null: false
      add :transformation_rules, :map, null: false
      add :validation_schema, :map
      add :field_mappings, :map, default: %{}
      add :default_values, :map, default: %{}
      add :preprocessing_steps, {:array, :text}, default: []
      add :postprocessing_steps, {:array, :text}, default: []
      add :status, :text
      add :test_input, :map
      add :expected_output, :map
      add :metadata, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:data_adapters, [:name], name: "data_adapters_unique_adapter_name_index")

    create_if_not_exists unique_index(:data_adapters, [:source_format, :target_format, :name],
             name: "data_adapters_unique_transformation_path_index"
           )

    create_if_not_exists table(:agents, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :agent_name, :text
      add :agent_type, :text
      add :status, :text
      add :capabilities, :map
      add :current_task, :text
      add :last_heartbeat, :utc_datetime_usec
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for experiences
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'experiences_agent_id_fkey'
          ) THEN
            ALTER TABLE experiences
            ADD CONSTRAINT experiences_agent_id_fkey
            FOREIGN KEY (agent_id)
            REFERENCES agents(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:task_orchestrators, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :workflow_name, :text, null: false
      add :workflow_version, :text, default: "1.0.0"
      add :tasks, {:array, :map}, null: false
      add :dependencies, :map, default: %{}
      add :status, :text
      add :execution_strategy, :text
      add :retry_policy, :map
      add :timeout_ms, :bigint, default: 300_000
      add :execution_log, {:array, :map}, default: []
      add :current_step, :bigint, default: 0
      add :total_steps, :bigint
      add :progress_percentage, :decimal, default: "0.0"
      add :assigned_containers, {:array, :text}, default: []
      add :metadata, :map, default: %{}
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:task_orchestrators, [:workflow_name, :workflow_version],
             name: "task_orchestrators_unique_workflow_index"
           )

    create_if_not_exists table(:thundercom_realm_identities, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :realm_id, :uuid, null: false
      add :public_key, :text, null: false
      add :key_algorithm, :text, null: false, default: "Ed25519"
      add :fingerprint, :text, null: false
      add :verification_status, :text, null: false, default: "unverified"
      add :verified_at, :utc_datetime

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thundercom_realm_identities, [:verification_status])

    create_if_not_exists index(:thundercom_realm_identities, [:fingerprint], unique: true)

    create_if_not_exists index(:thundercom_realm_identities, [:realm_id])

    create_if_not_exists table(:conversations, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :title, :text
    end

    # Foreign key constraints for messages
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'messages_conversation_id_fkey'
          ) THEN
            ALTER TABLE messages
            ADD CONSTRAINT messages_conversation_id_fkey
            FOREIGN KEY (conversation_id)
            REFERENCES conversations(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'messages_response_to_id_fkey'
          ) THEN
            ALTER TABLE messages
            ADD CONSTRAINT messages_response_to_id_fkey
            FOREIGN KEY (response_to_id)
            REFERENCES messages(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:thunderblock_retention_policies, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :resource, :text, null: false
      add :scope_type, :text, default: "global"
      add :scope_id, :uuid
      add :ttl_seconds, :bigint
      add :keep_versions, :bigint
      add :action, :text, default: "delete"
      add :grace_seconds, :bigint, default: 0
      add :metadata, :map, default: %{}
      add :notes, :text
      add :is_active, :boolean, default: true

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderblock_retention_policies, [:resource, :scope_type, :scope_id],
             name: "thunderblock_retention_policies_policy_scope_index"
           )

    create_if_not_exists table(:thundermag_macro_commands, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :command_type, :text
      add :macro_input, :text
      add :status, :text
      add :execution_metadata, :map
      add :session_id, :uuid
      add :priority, :text
      add :estimated_duration_ms, :bigint
      add :actual_duration_ms, :bigint
    end

    # Foreign key constraints for thundermag_task_executions
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thundermag_task_executions_macro_command_id_fkey'
          ) THEN
            ALTER TABLE thundermag_task_executions
            ADD CONSTRAINT thundermag_task_executions_macro_command_id_fkey
            FOREIGN KEY (macro_command_id)
            REFERENCES thundermag_macro_commands(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:thunderlane_rulesets, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :version, :bigint
      add :name, :text
      add :description, :text
      add :x_lane_rule, :text
      add :y_lane_rule, :text
      add :z_lane_rule, :text
      add :x_lane_params, :map
      add :y_lane_params, :map
      add :z_lane_params, :map
      add :alpha_xy, :float
      add :alpha_xz, :float
      add :alpha_yx, :float
      add :alpha_yz, :float
      add :alpha_zx, :float
      add :alpha_zy, :float
      add :schedule_type, :text
      add :schedule_params, :map
      add :boundaries, :map
      add :parameter_bounds, :map
      add :objective_function, :map
      add :status, :text
      add :deployed_at, :utc_datetime_usec
      add :performance_score, :float
      add :signature, :text
      add :signature_algorithm, :text
      add :signed_by, :text
      add :metadata, :map
      add :lane_configuration_id, :uuid
      add :created_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thunderlane_coordinators
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderlane_coordinators_active_ruleset_id_fkey'
          ) THEN
            ALTER TABLE thunderlane_coordinators
            ADD CONSTRAINT thunderlane_coordinators_active_ruleset_id_fkey
            FOREIGN KEY (active_ruleset_id)
            REFERENCES thunderlane_rulesets(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:external_services, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :base_url, :text, null: false
      add :protocol_type, :text
      add :auth_config, :map
      add :rate_limits, :map, default: %{}
      add :timeout_ms, :bigint, default: 30000
      add :retry_config, :map
      add :headers, :map, default: %{}
      add :status, :text
      add :health_check_url, :text
      add :last_health_check, :utc_datetime
      add :metadata, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:external_services, [:name],
             name: "external_services_unique_service_name_index"
           )

    create_if_not_exists unique_index(:external_services, [:base_url],
             name: "external_services_unique_service_url_index"
           )

    create_if_not_exists table(:thundermag_task_assignments, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :task_execution_id,
          references(:thundermag_task_executions,
            column: :id,
            name: "thundermag_task_assignments_task_execution_id_fkey",
            type: :uuid
          ),
          null: false

      add :task_id, :uuid, null: false
      add :thunderbit_id, :uuid
      add :zone_id, :text
      add :task_type, :text, null: false
      add :task_value, :text
      add :sequence, :bigint
      add :status, :text, null: false, default: "assigned"
      add :priority, :text, default: "normal"
      add :estimated_execution_time_ms, :bigint
      add :actual_execution_time_ms, :bigint
      add :retry_count, :bigint, default: 0
      add :max_retries, :bigint, default: 3
      add :result, :map
      add :error, :map
      add :assigned_at, :utc_datetime
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:alert_rules, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :description, :text
      add :domain, :text
      add :component, :text
      add :metric_name, :text
      add :condition, :text
      add :threshold_value, :decimal
      add :threshold_count, :bigint, default: 1
      add :time_window_minutes, :bigint, default: 5
      add :severity, :text
      add :notification_channels, {:array, :text}, default: []
      add :escalation_minutes, :bigint, default: 60
      add :suppression_minutes, :bigint, default: 15
      add :enabled, :boolean, default: true
      add :expression, :text
      add :tags, :map, default: %{}
      add :metadata, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:alert_rules, [:domain, :component, :metric_name, :condition],
             name: "alert_rules_unique_metric_rule_index"
           )

    create_if_not_exists unique_index(:alert_rules, [:name], name: "alert_rules_unique_rule_name_index")

    create_if_not_exists table(:thunderblock_communities, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :community_name, :string
      add :community_slug, :string
      add :community_type, :string
      add :governance_model, :string
      add :status, :string
      add :federation_config, :map
      add :community_config, :map
      add :resource_limits, :map
      add :member_count, :integer
      add :channel_count, :integer
      add :pac_home_count, :integer
      add :owner_id, :uuid
      add :moderator_ids, {:array, :uuid}
      add :member_ids, {:array, :uuid}
      add :invitation_config, :map
      add :community_policies, :map
      add :vault_mount_id, :uuid
      add :execution_zone_id, :uuid
      add :federation_socket_id, :uuid
      add :community_metrics, :map
      add :tags, {:array, :string}
      add :metadata, :map
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thunderblock_pac_homes
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_pac_homes_community_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_pac_homes
            ADD CONSTRAINT thunderblock_pac_homes_community_id_fkey
            FOREIGN KEY (community_id)
            REFERENCES thunderblock_communities(id);
          END IF;
        END $$;
        """


    create_if_not_exists index(:thunderblock_communities, [:community_metrics], using: :gin,
             name: "communities_metrics_idx"
           )

    create_if_not_exists index(:thunderblock_communities, [:federation_config], using: :gin,
             name: "communities_federation_idx"
           )

    create_if_not_exists index(:thunderblock_communities, [:tags], using: :gin, name: "communities_tags_idx")

    create_if_not_exists index(:thunderblock_communities, [:moderator_ids], using: :gin,
             name: "communities_moderators_idx"
           )

    create_if_not_exists index(:thunderblock_communities, [:member_ids], using: :gin,
             name: "communities_members_idx"
           )

    create_if_not_exists index(:thunderblock_communities, [:community_type, :governance_model],
             name: "communities_type_idx"
           )

    create_if_not_exists index(:thunderblock_communities, [:status, :member_count],
             name: "communities_activity_idx"
           )

    create_if_not_exists index(:thunderblock_communities, [:owner_id, :status], name: "communities_owner_idx")

    create_if_not_exists index(:thunderblock_communities, [:community_slug],
             name: "communities_slug_idx",
             unique: true
           )

    create_if_not_exists table(:thunderblock_query_optimizations, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :query_hash, :text, null: false
      add :query_sql, :text, null: false
      add :execution_time_ms, :decimal, null: false
      add :rows_examined, :bigint
      add :rows_returned, :bigint
      add :index_usage, :map, null: false, default: %{}
      add :execution_plan, :map, null: false, default: %{}
      add :optimization_suggestions, {:array, :text}, null: false, default: []
      add :frequency, :bigint, null: false, default: 1
      add :avg_execution_time, :decimal, null: false

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thunderblock_query_optimizations, [:optimization_suggestions], using: :gin,
             name: "query_optimizations_suggestions_idx"
           )

    create_if_not_exists index(:thunderblock_query_optimizations, [:frequency],
             name: "query_optimizations_frequency_idx"
           )

    create_if_not_exists index(:thunderblock_query_optimizations, [:avg_execution_time],
             name: "query_optimizations_avg_time_idx"
           )

    create_if_not_exists index(:thunderblock_query_optimizations, [:query_hash],
             name: "query_optimizations_hash_idx",
             unique: true
           )

    create_if_not_exists unique_index(:thunderblock_query_optimizations, [:query_hash],
             name: "thunderblock_query_optimizations_unique_query_hash_index"
           )

    create_if_not_exists table(:error_logs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :domain, :text, null: false
      add :error_type, :text, null: false
      add :message, :text, null: false
      add :severity, :text
      add :stack_trace, :text
      add :context, :map, default: %{}
      add :node_name, :text
      add :process_id, :text
      add :user_id, :uuid
      add :request_id, :text
      add :metadata, :map, default: %{}
      add :resolved, :boolean, default: false
      add :resolution_notes, :text

      add :occurred_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:error_logs, [:domain, :error_type, :message, :occurred_at],
             name: "error_logs_unique_error_occurrence_index"
           )

    create_if_not_exists table(:upm_drift_windows, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid
      add :status, :text, null: false, default: "open"
      add :score_p95, :float, null: false, default: 0.0
      add :threshold, :float, null: false, default: 0.2
      add :sample_count, :bigint, null: false, default: 0
      add :window_started_at, :utc_datetime_usec
      add :window_closed_at, :utc_datetime_usec
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :snapshot_id,
          references(:upm_snapshots,
            column: :id,
            name: "upm_drift_windows_snapshot_id_fkey",
            type: :uuid
          ),
          null: false

      add :trainer_id, :uuid, null: false
    end

    create_if_not_exists table(:thunderlane_cross_lane_coupling, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :source_lane, :text, null: false
      add :target_lane, :text, null: false
      add :name, :text
      add :rule_set_id, :uuid
      add :alpha_gain, :float, null: false, default: 0.25
      add :coupling_type, :text, null: false, default: "symmetric"
      add :coupling_function, :text, null: false, default: "linear"
      add :coupling_params, :map, default: %{}
      add :spatial_kernel, :text, null: false, default: "cross_3x3"
      add :kernel_params, :map, default: %{}
      add :temporal_delay, :bigint, null: false, default: 0
      add :temporal_window, :bigint, null: false, default: 1
      add :adaptive_enabled, :boolean, null: false, default: false
      add :adaptation_rate, :float, default: 0.01
      add :adaptation_bounds, :map
      add :coupling_strength, :float
      add :mutual_information, :float
      add :phase_coherence, :float
      add :energy_transfer, :float
      add :stability_measure, :float
      add :status, :text, null: false, default: "inactive"
      add :buffer_size, :bigint, default: 0
      add :events_coupled, :bigint, default: 0
      add :coupling_latency_ms, :float
      add :error_count, :bigint, default: 0
      add :last_error, :text
      add :last_error_at, :utc_datetime_usec
      add :health_score, :float, default: 1.0
      add :tuning_history, :map, default: %{}
      add :performance_trend, :text
      add :config, :map, default: %{}
      add :metadata, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :ruleset_id,
          references(:thunderlane_rulesets,
            column: :id,
            name: "thunderlane_cross_lane_coupling_ruleset_id_fkey",
            type: :uuid
          )
    end

    create_if_not_exists unique_index(
             :thunderlane_cross_lane_coupling,
             [:source_lane, :target_lane, :ruleset_id],
             name: "thunderlane_cross_lane_coupling_unique_lane_coupling_index"
           )

    create_if_not_exists table(:ising_optimization_runs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :problem_id, :uuid, null: false
      add :name, :text
      add :algorithm, :text, null: false
      add :parameters, :map, null: false
      add :status, :text, default: "queued"
      add :result, :map
      add :energy_history, {:array, :float}, default: []
      add :magnetization_history, {:array, :float}, default: []
      add :final_energy, :float
      add :final_magnetization, :float
      add :steps_completed, :bigint, default: 0
      add :runtime_ms, :bigint
      add :converged, :boolean, default: false
      add :error_message, :text
      add :metrics, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime
    end

    create_if_not_exists table(:feature_windows, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid, null: false
      add :kind, :text, null: false
      add :key, :text, null: false
      add :window_start, :utc_datetime, null: false
      add :window_end, :utc_datetime, null: false
      add :status, :text, null: false, default: "open"
      add :features, :map, null: false, default: %{}
      add :label_spec, :map, null: false, default: %{}
      add :labels, :map
      add :feature_schema_version, :bigint, null: false
      add :provenance, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:lane_configurations, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :lane_type, :text, null: false, default: "ca"
      add :lane_family, :text, null: false
      add :rule_parameters, :map, default: %{}
      add :performance_target, :decimal, default: "0.85"
      add :max_concurrent_tasks, :bigint, default: 10
      add :priority_weight, :decimal, default: "1.0"
      add :adaptive_bounds, :map
      add :metadata, :map, default: %{}

      add :rule_oracle_id,
          references(:thunderlane_rule_oracles,
            column: :id,
            name: "lane_configurations_rule_oracle_id_fkey",
            type: :uuid
          )

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :state, :text, null: false, default: "initializing"
    end

    create_if_not_exists table(:thunderline_events, primary_key: false) do
      add :domain, :text, null: false, default: "unknown"
      add :operation_type, :text
      add :criticality, :text, default: "medium"
      add :replay_required, :boolean, null: false, default: false
      add :correlation_id, :text
      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :record_id, :uuid, null: false
      add :version, :bigint, null: false, default: 1
      add :metadata, :map, null: false, default: %{}
      add :data, :map, null: false, default: %{}
      add :occurred_at, :utc_datetime_usec, null: false
      add :resource, :text, null: false
      add :action, :text, null: false
      add :action_type, :text, null: false
      add :user_id, :uuid
      add :agent_id, :uuid
    end

    create_if_not_exists unique_index(:thunderline_events, [:correlation_id],
             name: "thunderline_events_correlation_events_index"
           )

    create_if_not_exists table(:thunderblock_zone_containers, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :zone_name, :string
      add :zone_type, :string
      add :status, :string
      add :coordinates, :map
      add :capacity_config, :map
      add :current_usage, :map
      add :zone_config, :map
      add :supervision_strategy, :string
      add :max_restarts, :integer
      add :max_seconds, :integer
      add :restart_count, :integer
      add :last_restart, :utc_datetime
      add :health_score, :decimal
      add :last_health_check, :utc_datetime
      add :neighbor_zones, {:array, :uuid}
      add :phase_assignment, :integer
      add :tags, {:array, :string}
      add :metadata, :map
      add :cluster_node_id, :uuid
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thunderblock_pac_homes
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_pac_homes_zone_container_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_pac_homes
            ADD CONSTRAINT thunderblock_pac_homes_zone_container_id_fkey
            FOREIGN KEY (zone_container_id)
            REFERENCES thunderblock_zone_containers(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:thunderblock_pac_homes, [:home_slug, :community_id],
             name: "thunderblock_pac_homes_unique_home_in_community_index"
           )

    create_if_not_exists unique_index(:thunderblock_pac_homes, [:owner_id, :home_name],
             name: "thunderblock_pac_homes_unique_owner_home_name_index"
           )

    # Foreign key constraints for thunderblock_communities
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_communities_execution_zone_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_communities
            ADD CONSTRAINT thunderblock_communities_execution_zone_id_fkey
            FOREIGN KEY (execution_zone_id)
            REFERENCES thunderblock_zone_containers(id);
          END IF;
        END $$;
        """


    create_if_not_exists index(:thunderblock_zone_containers, [:coordinates], using: :gin,
             name: "zone_containers_coords_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:tags], using: :gin,
             name: "zone_containers_tags_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:neighbor_zones], using: :gin,
             name: "zone_containers_neighbors_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:phase_assignment],
             name: "zone_containers_phase_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:cluster_node_id, :status],
             name: "zone_containers_node_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:zone_type, :status],
             name: "zone_containers_type_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:status, :health_score],
             name: "zone_containers_health_idx"
           )

    create_if_not_exists index(:thunderblock_zone_containers, [:zone_name],
             name: "zone_containers_name_idx",
             unique: true
           )

    create_if_not_exists table(:thundercore_system_policies, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :policy_name, :text, null: false
      add :policy_type, :text, null: false
      add :rule_definition, :map, null: false
      add :enforcement_level, :text, default: "warning"
      add :is_active, :boolean, default: true
      add :violation_count, :bigint, default: 0

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thundercore_system_policies, [:policy_name],
             name: "thundercore_system_policies_unique_policy_name_index"
           )

    create_if_not_exists table(:support_tickets, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :subject, :text, null: false
      add :status, :text, null: false, default: "open"
      add :escalated, :boolean, default: false
      add :processed_at, :utc_datetime_usec
      add :escalated_at, :utc_datetime_usec
      add :closed_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:cerebros_model_trials, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :trial_id, :text, null: false
      add :status, :text, null: false, default: "succeeded"
      add :metrics, :map, default: %{}
      add :parameters, :map, default: %{}
      add :spectral_norm, :boolean, null: false, default: false
      add :mlflow_run_id, :text
      add :artifact_uri, :text
      add :duration_ms, :bigint
      add :rank, :bigint
      add :warnings, {:array, :text}, default: []
      add :candidate_id, :text
      add :pulse_id, :text
      add :bridge_payload, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :model_run_id, :uuid, null: false
    end

    create_if_not_exists table(:ising_performance_metrics, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :benchmark_name, :text, null: false
      add :system_info, :map, null: false
      add :problem_size, :map, null: false
      add :algorithm_config, :map, null: false
      add :spins_per_second, :float
      add :energy_evaluations_per_second, :float
      add :memory_usage_mb, :float
      add :compilation_time_ms, :bigint
      add :execution_time_ms, :bigint
      add :total_time_ms, :bigint
      add :backend_info, :map, default: %{}
      add :scaling_factor, :float
      add :quality_metrics, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :environment_tags, {:array, :text}, default: []
    end

    create_if_not_exists table(:thunderblock_supervision_trees, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tree_name, :text, null: false
      add :tree_type, :text, null: false, default: "zone_supervisor"
      add :supervision_strategy, :text, null: false, default: "one_for_one"
      add :max_restarts, :bigint, null: false, default: 5
      add :max_seconds, :bigint, null: false, default: 60
      add :status, :text, null: false, default: "starting"
      add :restart_count, :bigint, null: false, default: 0
      add :last_restart, :utc_datetime
      add :child_specs, {:array, :map}, null: false, default: []
      add :running_children, {:array, :text}, null: false, default: []
      add :failed_children, {:array, :map}, null: false, default: []
      add :escalation_level, :bigint, null: false, default: 0
      add :health_score, :decimal, null: false, default: "1.0"
      add :recovery_strategy, :map, null: false
      add :monitoring_config, :map, null: false

      add :parent_tree_id,
          references(:thunderblock_supervision_trees,
            column: :id,
            name: "thunderblock_supervision_trees_parent_tree_id_fkey",
            type: :uuid,
            on_delete: :nilify_all,
            on_update: :update_all
          )

      add :depth_level, :bigint, null: false, default: 0
      add :process_info, :map, null: false, default: %{}
      add :tags, {:array, :text}, null: false, default: []
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :cluster_node_id, :uuid
      add :zone_container_id, :uuid
    end

    create_if_not_exists index(:thunderblock_supervision_trees, [:tags], using: :gin,
             name: "supervision_trees_tags_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:running_children], using: :gin,
             name: "supervision_trees_children_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:parent_tree_id, :depth_level],
             name: "supervision_trees_hierarchy_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:escalation_level, :status],
             name: "supervision_trees_escalation_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:zone_container_id, :depth_level],
             name: "supervision_trees_zone_depth_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:tree_type, :status],
             name: "supervision_trees_type_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:status, :health_score],
             name: "supervision_trees_health_idx"
           )

    create_if_not_exists index(:thunderblock_supervision_trees, [:tree_name, :zone_container_id],
             name: "supervision_trees_name_zone_idx",
             unique: true
           )

    create_if_not_exists table(:user_tokens, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :token, :binary, null: false
      add :context, :text, null: false
      add :sent_to, :text
      add :expires_at, :utc_datetime, null: false
      add :used_at, :utc_datetime

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :user_id, :uuid, null: false
    end

    create_if_not_exists table(:lineage_edges, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid, null: false
      add :from_id, :uuid, null: false
      add :to_id, :uuid, null: false
      add :edge_type, :text, null: false
      add :day_bucket, :date, null: false

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderlane_lane_metrics, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :metric_type, :text, null: false
      add :source_type, :text, null: false
      add :source_id, :uuid
      add :lane_coordinator_id, :uuid
      add :cross_lane_coupling_id, :uuid
      add :rule_set_id, :uuid
      add :cell_topology_id, :uuid
      add :timestamp, :utc_datetime_usec, null: false
      add :measurement_window_ms, :bigint
      add :sequence_number, :bigint
      add :lane_dimension, :text
      add :updates_per_second, :float
      add :coordination_latency_ms, :float
      add :cells_processed, :bigint
      add :events_processed, :bigint
      add :queue_depth, :bigint
      add :coupling_strength, :float
      add :coupling_latency_ms, :float
      add :mutual_information, :float
      add :phase_coherence, :float
      add :energy_transfer, :float
      add :alpha_effectiveness, :float
      add :throughput, :float
      add :latency_p50_ms, :float
      add :latency_p95_ms, :float
      add :latency_p99_ms, :float
      add :error_rate, :float
      add :success_rate, :float
      add :cpu_usage_percent, :float
      add :memory_usage_mb, :float
      add :memory_usage_percent, :float
      add :network_io_mbps, :float
      add :disk_io_mbps, :float
      add :stability_score, :float, default: 1.0
      add :health_score, :float, default: 1.0
      add :anomaly_score, :float, default: 0.0
      add :optimization_target, :text
      add :optimization_score, :float
      add :improvement_factor, :float
      add :convergence_rate, :float
      add :pathflow_accuracy, :float
      add :pattern_recognition_rate, :float
      add :emergence_detection_count, :bigint
      add :computation_efficiency, :float
      add :raw_metrics, :map, default: %{}
      add :aggregated_metrics, :map, default: %{}
      add :trend_indicators, :map, default: %{}
      add :tags, :map, default: %{}
      add :metadata, :map, default: %{}
      add :measurement_confidence, :float, default: 1.0
      add :data_quality_score, :float, default: 1.0

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :coordinator_id,
          references(:thunderlane_coordinators,
            column: :id,
            name: "thunderlane_lane_metrics_coordinator_id_fkey",
            type: :uuid
          )

      add :coupling_id,
          references(:thunderlane_cross_lane_coupling,
            column: :id,
            name: "thunderlane_lane_metrics_coupling_id_fkey",
            type: :uuid
          )

      add :topology_id, :uuid
      add :ruleset_id, :uuid
    end

    create_if_not_exists table(:experts, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid, null: false
      add :name, :text, null: false
      add :version, :text, null: false
      add :status, :text, null: false, default: "active"
      add :latency_budget_ms, :bigint
      add :metrics, :map, null: false, default: %{}
      add :model_artifact_ref, :text

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:rag_documents, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :content, :text, null: false
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :full_text_vector, :vector, size: 384
    end

    create_if_not_exists table(:thunderbit_monitors, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :agent_id, :uuid, null: false
      add :agent_name, :text
      add :status, :text
      add :behavior_type, :text
      add :energy_level, :bigint, default: 100
      add :position_x, :float
      add :position_y, :float
      add :position_z, :float
      add :velocity, :map, default: %{}
      add :last_tick, :utc_datetime
      add :tick_count, :bigint, default: 0
      add :processing_queue_size, :bigint, default: 0
      add :memory_usage_mb, :float
      add :cpu_usage_percent, :float
      add :error_count, :bigint, default: 0
      add :last_error, :text
      add :interactions_count, :bigint, default: 0
      add :performance_score, :float
      add :node_name, :text
      add :metadata, :map, default: %{}

      add :monitored_since, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :last_updated, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderbit_monitors, [:agent_id],
             name: "thunderbit_monitors_unique_agent_monitor_index"
           )

    create_if_not_exists table(:workflow_trackers, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :workflow_id, :text, null: false
      add :step_name, :text, null: false
      add :target_count, :bigint, null: false
      add :current_count, :bigint, default: 0
      add :status, :text, default: "pending"
      add :domain_context, :text, null: false
      add :next_step_config, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderflow_event_streams, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :stream_name, :text, null: false
      add :stream_type, :text, null: false
      add :source_domain, :text, null: false
      add :status, :text, null: false, default: "active"
      add :partition_count, :bigint, null: false, default: 1
      add :retention_hours, :bigint, null: false, default: 168
      add :throughput_config, :map, null: false
      add :event_count, :bigint, null: false, default: 0
      add :last_event_at, :utc_datetime
      add :performance_metrics, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thunderflow_event_streams, [:last_event_at])

    create_if_not_exists index(:thunderflow_event_streams, [:status])

    create_if_not_exists index(:thunderflow_event_streams, [:source_domain])

    create_if_not_exists index(:thunderflow_event_streams, [:stream_type])

    create_if_not_exists index(:thunderflow_event_streams, [:stream_name], unique: true)

    create_if_not_exists table(:actions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :type, :text, null: false
      add :name, :text, null: false
      add :parameters, :map, null: false, default: %{}
      add :result, :map
      add :status, :text, null: false, default: "pending"
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime
      add :duration_ms, :bigint
      add :success, :boolean
      add :error_message, :text
      add :confidence_score, :decimal
      add :cost, :decimal, null: false, default: "0.0"
      add :priority, :bigint, null: false, default: 100

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :agent_id, references(:agents, column: :id, name: "actions_agent_id_fkey", type: :uuid),
        null: false

      add :decision_id, :uuid
      add :parent_action_id, :uuid
    end

    create_if_not_exists table(:thundercore_task_nodes, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :node_name, :text, null: false
      add :task_type, :text, null: false
      add :task_config, :map, default: %{}
      add :status, :text, default: "pending"
      add :dependencies, {:array, :text}, default: []
      add :position_x, :bigint, default: 0
      add :position_y, :bigint, default: 0
      add :started_at, :utc_datetime_usec
      add :completed_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :workflow_dag_id, :uuid
    end

    create_if_not_exists table(:thundercom_federated_messages, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :source_realm_id, :uuid, null: false
      add :target_realm_id, :uuid
      add :message_type, :text, null: false
      add :message_content, :map, null: false, default: %{}
      add :signature, :text, null: false
      add :delivery_status, :text, null: false, default: "pending"
      add :delivery_attempts, :bigint, null: false, default: 0
      add :delivered_at, :utc_datetime

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:thundercom_federated_messages, [:inserted_at])

    create_if_not_exists index(:thundercom_federated_messages, [:message_type])

    create_if_not_exists index(:thundercom_federated_messages, [:delivery_status])

    create_if_not_exists index(:thundercom_federated_messages, [:target_realm_id])

    create_if_not_exists index(:thundercom_federated_messages, [:source_realm_id])

    create_if_not_exists table(:memory_nodes, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :title, :text, null: false
      add :content, :text, null: false
      add :content_type, :text, null: false, default: "observation"
      add :importance, :decimal, null: false, default: "0.5"
      add :emotional_valence, :decimal, null: false, default: "0.0"
      add :confidence, :decimal, null: false, default: "0.5"
      add :tags, {:array, :text}, null: false, default: []
      add :context, :map, null: false, default: %{}
      add :access_count, :bigint, null: false, default: 0
      add :last_accessed_at, :utc_datetime
      add :decay_rate, :decimal, null: false, default: "0.01"
      add :is_archived, :boolean, null: false, default: false
      add :content_embedding, {:array, :float}
      add :title_embedding, {:array, :float}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :agent_id,
          references(:agents, column: :id, name: "memory_nodes_agent_id_fkey", type: :uuid),
          null: false

      add :parent_memory_id,
          references(:memory_nodes,
            column: :id,
            name: "memory_nodes_parent_memory_id_fkey",
            type: :uuid
          )
    end

    create_if_not_exists table(:thunderblock_system_events, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :event_type, :text, null: false
      add :source_domain, :text, null: false
      add :target_domain, :text
      add :event_data, :map, default: %{}
      add :status, :text, default: "pending"
      add :priority, :bigint, default: 5
      add :correlation_id, :text
      add :processed_at, :utc_datetime_usec
      add :expires_at, :utc_datetime_usec
      add :target_resource_id, :uuid
      add :target_resource_type, :text

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderblock_system_events, [:correlation_id, :event_type],
             name: "thunderblock_system_events_unique_correlation_event_index",
             where: "(correlation_id IS NOT NULL)"
           )

    create_if_not_exists table(:thunderlane_performance_metrics, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :coordinator_id, :text
      add :metric_type, :text, null: false
      add :step_number, :bigint, null: false
      add :micro_latency_us, :bigint
      add :meso_latency_us, :bigint
      add :macro_latency_us, :bigint
      add :total_latency_us, :bigint
      add :patches_processed, :bigint, default: 0
      add :consensus_bursts, :bigint, default: 0
      add :fusion_operations, :bigint, default: 0
      add :system_energy, :float
      add :energy_drift, :float
      add :stability_score, :float
      add :convergence_rate, :float
      add :lane_x_energy, :float
      add :lane_y_energy, :float
      add :lane_z_energy, :float
      add :alpha_xy, :float
      add :alpha_xz, :float
      add :alpha_yz, :float
      add :oracle_batch_size, :bigint
      add :oracle_success_rate, :float
      add :oracle_latency_us, :bigint
      add :cpu_usage_percent, :float
      add :memory_usage_mb, :bigint
      add :gpu_usage_percent, :float

      add :lane_configuration_id,
          references(:lane_configurations,
            column: :id,
            name: "thunderlane_performance_metrics_lane_configuration_id_fkey",
            type: :uuid
          )

      add :rule_oracle_id,
          references(:thunderlane_rule_oracles,
            column: :id,
            name: "thunderlane_performance_metrics_rule_oracle_id_fkey",
            type: :uuid
          )

      add :telemetry_snapshot_id, :uuid
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:voice_participants, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :room_id,
          references(:voice_rooms,
            column: :id,
            name: "voice_participants_room_id_fkey",
            type: :uuid
          ),
          null: false

      add :principal_id, :uuid, null: false
      add :principal_type, :text, null: false, default: "user"
      add :role, :text, null: false, default: "listener"
      add :muted, :boolean, null: false, default: false
      add :speaking, :boolean, null: false, default: false
      add :last_active_at, :utc_datetime

      add :joined_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:voice_participants, [:room_id, :principal_id],
             name: "voice_participants_unique_room_principal_index"
           )

    create_if_not_exists table(:thunderblock_rate_limit_policies, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :policy_name, :text, null: false
      add :target_pattern, :text, null: false
      add :limit_count, :bigint, null: false
      add :limit_window_ms, :bigint, null: false
      add :violation_action, :text, default: "block"
      add :is_active, :boolean, default: true

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderblock_rate_limit_policies, [:policy_name],
             name: "thunderblock_rate_limit_policies_unique_policy_name_index"
           )

    create_if_not_exists table(:thunderlane_consensus_runs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :region_id, :text
      add :trigger_reason, :text
      add :matrix_size, :bigint, null: false
      add :coupling_strength, :float, default: 1.0
      add :initial_temperature, :float, default: 1.5
      add :final_temperature, :float, default: 0.1
      add :max_steps, :bigint, default: 50
      add :final_energy, :float
      add :convergence_steps, :bigint
      add :success, :boolean, default: false
      add :execution_time_ms, :bigint
      add :spin_configuration, :map, default: %{}

      add :lane_configuration_id,
          references(:lane_configurations,
            column: :id,
            name: "thunderlane_consensus_runs_lane_configuration_id_fkey",
            type: :uuid
          )

      add :rule_oracle_id,
          references(:thunderlane_rule_oracles,
            column: :id,
            name: "thunderlane_consensus_runs_rule_oracle_id_fkey",
            type: :uuid
          )

      add :metadata, :map, default: %{}

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:system_actions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :action_type, :text, null: false
      add :action_name, :text, null: false
      add :parameters, :map, default: %{}
      add :initiated_by, :text, null: false, default: "dashboard"
      add :status, :text, null: false, default: "pending"
      add :result, :map
      add :error_message, :text
      add :execution_time_ms, :bigint

      add :initiated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :completed_at, :utc_datetime_usec

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:system_actions, [:action_type, :initiated_by, :status],
             name: "system_actions_unique_pending_action_index",
             where: "(status = 'pending')"
           )

    create_if_not_exists table(:mlflow_experiments, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :mlflow_experiment_id, :text, null: false
      add :name, :text, null: false
      add :artifact_location, :text
      add :lifecycle_stage, :text, default: "active"
      add :tags, :map, default: %{}
      add :model_run_id, :uuid
      add :synced_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:embedding_vectors, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :vector, {:array, :float}, null: false
      add :vector_model, :text, null: false
      add :dimension, :bigint, null: false
      add :content_hash, :text, null: false
      add :embedding_type, :text, null: false
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :memory_record_id, :uuid
      add :memory_node_id, :uuid
      add :knowledge_node_id, :uuid
      add :experience_id, :uuid
    end

    create_if_not_exists table(:ml_model_versions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :version_id, :text, null: false

      add :spec_id,
          references(:ml_model_specs,
            column: :id,
            name: "ml_model_versions_spec_id_fkey",
            type: :uuid
          ),
          null: false

      add :artifact_id,
          references(:ml_model_artifacts,
            column: :id,
            name: "ml_model_versions_artifact_id_fkey",
            type: :uuid
          ),
          null: false

      add :dataset_id, :uuid, null: false
      add :metrics, :map, default: %{}
      add :notes, :text

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:mlflow_runs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :mlflow_run_id, :text, null: false

      add :mlflow_experiment_id,
          references(:mlflow_experiments,
            column: :mlflow_experiment_id,
            name: "mlflow_runs_mlflow_experiment_id_fkey",
            type: :text
          ),
          null: false

      add :run_name, :text
      add :status, :text, default: "running"
      add :start_time, :bigint
      add :end_time, :bigint
      add :lifecycle_stage, :text, default: "active"
      add :artifact_uri, :text
      add :params, :map, default: %{}
      add :metrics, :map, default: %{}
      add :tags, :map, default: %{}

      add :model_trial_id,
          references(:cerebros_model_trials,
            column: :id,
            name: "mlflow_runs_model_trial_id_fkey",
            type: :uuid
          )

      add :model_run_id, :uuid
      add :synced_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:decisions, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :type, :text
      add :context, :text
      add :input_data, :map
      add :selected_option, :map
      add :reasoning, :text
      add :confidence_score, :numeric
      add :risk_assessment, :numeric
      add :expected_outcome, :map
      add :actual_outcome, :map
      add :outcome_accuracy, :numeric
      add :decision_time_ms, :bigint
      add :was_successful, :boolean
    end

    # Foreign key constraints for experiences
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'experiences_decision_id_fkey'
          ) THEN
            ALTER TABLE experiences
            ADD CONSTRAINT experiences_decision_id_fkey
            FOREIGN KEY (decision_id)
            REFERENCES decisions(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'experiences_action_id_fkey'
          ) THEN
            ALTER TABLE experiences
            ADD CONSTRAINT experiences_action_id_fkey
            FOREIGN KEY (action_id)
            REFERENCES actions(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(
             :experiences,
             [:agent_id, :situation_context, :action_taken, :inserted_at],
             name: "experiences_unique_experience_per_context_index"
           )

    # Foreign key constraints for actions
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'actions_decision_id_fkey'
          ) THEN
            ALTER TABLE actions
            ADD CONSTRAINT actions_decision_id_fkey
            FOREIGN KEY (decision_id)
            REFERENCES decisions(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'actions_parent_action_id_fkey'
          ) THEN
            ALTER TABLE actions
            ADD CONSTRAINT actions_parent_action_id_fkey
            FOREIGN KEY (parent_action_id)
            REFERENCES actions(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:thunderblock_channels, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :channel_name, :string
      add :channel_slug, :string
      add :channel_type, :string
      add :channel_category, :string
      add :status, :string
      add :visibility, :string
      add :topic, :string
      add :channel_config, :map
      add :voice_config, :map
      add :permissions_override, :map
      add :message_count, :integer
      add :active_participants, :integer
      add :last_message_at, :utc_datetime
      add :created_by, :uuid
      add :pinned_message_ids, {:array, :uuid}
      add :channel_integrations, :map
      add :moderation_config, :map
      add :channel_metrics, :map
      add :position, :integer
      add :tags, {:array, :string}
      add :metadata, :map
      add :community_id, :uuid
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thunderblock_messages
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_messages_channel_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_messages
            ADD CONSTRAINT thunderblock_messages_channel_id_fkey
            FOREIGN KEY (channel_id)
            REFERENCES thunderblock_channels(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_messages_community_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_messages
            ADD CONSTRAINT thunderblock_messages_community_id_fkey
            FOREIGN KEY (community_id)
            REFERENCES thunderblock_communities(id);
          END IF;
        END $$;
        """


    create_if_not_exists index(:thunderblock_channels, [:channel_metrics], using: :gin,
             name: "channels_metrics_idx"
           )

    create_if_not_exists index(:thunderblock_channels, [:tags], using: :gin, name: "channels_tags_idx")

    create_if_not_exists index(:thunderblock_channels, [:pinned_message_ids], using: :gin,
             name: "channels_pinned_messages_idx"
           )

    create_if_not_exists index(:thunderblock_channels, [:visibility, :status], name: "channels_visibility_idx")

    create_if_not_exists index(:thunderblock_channels, [:status, :last_message_at],
             name: "channels_activity_idx"
           )

    create_if_not_exists index(:thunderblock_channels, [:channel_type, :status],
             name: "channels_type_status_idx"
           )

    create_if_not_exists index(:thunderblock_channels, [:community_id, :position],
             name: "channels_community_position_idx"
           )

    create_if_not_exists index(:thunderblock_channels, [:community_id, :channel_type],
             name: "channels_community_type_idx"
           )

    create_if_not_exists index(:thunderblock_channels, [:channel_slug, :community_id],
             name: "channels_slug_community_idx",
             unique: true
           )

    create_if_not_exists unique_index(:thunderblock_channels, [:channel_slug, :community_id],
             name: "thunderblock_channels_unique_channel_in_community_index"
           )

    create_if_not_exists table(:thunderlane_telemetry_snapshots, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :coordinator_id, :text
      add :snapshot_type, :text
      add :window_start_ms, :bigint
      add :window_end_ms, :bigint
      add :window_duration_ms, :bigint
      add :total_events, :bigint
      add :event_rate_per_second, :float
      add :burst_count, :bigint
      add :anti_bunching_effectiveness, :float
      add :displacement_mean, :float
      add :displacement_variance, :float
      add :tail_exponent, :float
      add :tail_fit_quality, :float
      add :latency_mean_us, :float
      add :latency_median_us, :float
      add :latency_p90_us, :bigint
      add :latency_p95_us, :bigint
      add :latency_p99_us, :bigint
      add :latency_p999_us, :bigint
      add :latency_max_us, :bigint
      add :queue_depth_mean, :float
      add :queue_depth_max, :bigint
      add :backpressure_events, :bigint
      add :dropped_events, :bigint
      add :cpu_usage_mean, :float
      add :memory_usage_mean_mb, :bigint
      add :memory_usage_max_mb, :bigint
      add :gc_count, :bigint
      add :gc_total_time_ms, :bigint
      add :network_bytes_in, :bigint
      add :network_bytes_out, :bigint
      add :coordination_messages, :bigint
      add :coordination_latency_us, :bigint
      add :error_count, :bigint
      add :anomaly_score, :float
      add :anomaly_features, :map
      add :lane_configuration_id, :uuid
      add :rule_oracle_id, :uuid
      add :metadata, :map
    end

    # Foreign key constraints for thunderlane_performance_metrics
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderlane_performance_metrics_telemetry_snapshot_id_fkey'
          ) THEN
            ALTER TABLE thunderlane_performance_metrics
            ADD CONSTRAINT thunderlane_performance_metrics_telemetry_snapshot_id_fkey
            FOREIGN KEY (telemetry_snapshot_id)
            REFERENCES thunderlane_telemetry_snapshots(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:thunderlane_cell_topology, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text
      add :description, :text
      add :lane_coordinator_id, :uuid
      add :width, :bigint
      add :height, :bigint
      add :depth, :bigint
      add :total_cells, :bigint
      add :cells_per_partition, :bigint
      add :partition_count, :bigint
      add :topology_type, :text
      add :boundary_x, :text
      add :boundary_y, :text
      add :boundary_z, :text
      add :neighborhood_type, :text
      add :neighborhood_radius, :bigint
      add :partitioning_strategy, :text
      add :partitioning_config, :map
      add :thundercell_nodes, :map
      add :partition_assignments, :map
      add :node_load_balance, :map
      add :average_neighbors_per_cell, :float
      add :max_partition_size, :bigint
      add :min_partition_size, :bigint
      add :load_variance, :float
      add :status, :text
      add :distribution_health, :float
      add :last_rebalance_at, :utc_datetime_usec
      add :locality_score, :float
      add :communication_overhead, :float
      add :memory_efficiency, :float
      add :initial_state_pattern, :text
      add :initial_state_config, :map
      add :initial_state_seed, :bigint
      add :config, :map
      add :metadata, :map
      add :created_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thunderlane_lane_metrics
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderlane_lane_metrics_topology_id_fkey'
          ) THEN
            ALTER TABLE thunderlane_lane_metrics
            ADD CONSTRAINT thunderlane_lane_metrics_topology_id_fkey
            FOREIGN KEY (topology_id)
            REFERENCES thunderlane_cell_topology(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderlane_lane_metrics_ruleset_id_fkey'
          ) THEN
            ALTER TABLE thunderlane_lane_metrics
            ADD CONSTRAINT thunderlane_lane_metrics_ruleset_id_fkey
            FOREIGN KEY (ruleset_id)
            REFERENCES thunderlane_rulesets(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:dag_workflows, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :source_domain, :text
      add :root_event_name, :text
      add :correlation_id, :text
      add :causation_id, :text
      add :status, :text
      add :metadata, :map
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for dag_edges
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'dag_edges_workflow_id_fkey'
          ) THEN
            ALTER TABLE dag_edges
            ADD CONSTRAINT dag_edges_workflow_id_fkey
            FOREIGN KEY (workflow_id)
            REFERENCES dag_workflows(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:dag_edges, [:workflow_id, :from_node_id, :to_node_id, :edge_type],
             name: "dag_edges_unique_edge_index"
           )

    # Foreign key constraints for dag_snapshots
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'dag_snapshots_workflow_id_fkey'
          ) THEN
            ALTER TABLE dag_snapshots
            ADD CONSTRAINT dag_snapshots_workflow_id_fkey
            FOREIGN KEY (workflow_id)
            REFERENCES dag_workflows(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:dag_workflows, [:correlation_id],
             name: "dag_workflows_unique_correlation_index"
           )

    create_if_not_exists table(:memories, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("uuid_generate_v7()"), primary_key: true
      add :summary, :text
      add :full_content, :text
      add :memory_type, :text
      add :context_data, :map
      add :sensory_data, :map
      add :emotional_data, :map
      add :vividness, :float
      add :accessibility, :float
      add :importance, :float
      add :times_accessed, :bigint
      add :last_accessed_at, :utc_datetime
    end

    # Foreign key constraints for embedding_vectors
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'embedding_vectors_memory_record_id_fkey'
          ) THEN
            ALTER TABLE embedding_vectors
            ADD CONSTRAINT embedding_vectors_memory_record_id_fkey
            FOREIGN KEY (memory_record_id)
            REFERENCES memories(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'embedding_vectors_memory_node_id_fkey'
          ) THEN
            ALTER TABLE embedding_vectors
            ADD CONSTRAINT embedding_vectors_memory_node_id_fkey
            FOREIGN KEY (memory_node_id)
            REFERENCES memory_nodes(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:execution_containers, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :status, :text
      add :container_type, :text
      add :resource_limits, :map
      add :environment, :map, default: %{}
      add :security_policy, :map
      add :execution_metadata, :map, default: %{}
      add :node_assignment, :text
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime

      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:execution_containers, [:name],
             name: "execution_containers_unique_container_name_index"
           )

    create_if_not_exists table(:cerebros_model_runs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :run_id, :text
      add :state, :text
      add :search_space_version, :bigint
      add :max_params, :bigint
      add :requested_trials, :bigint
      add :completed_trials, :bigint
      add :best_metric, :float
      add :error_message, :text
      add :metadata, :map
      add :bridge_payload, :map
      add :bridge_result, :map
      add :started_at, :utc_datetime_usec
      add :finished_at, :utc_datetime_usec
    end

    # Foreign key constraints for ml_model_artifacts
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ml_model_artifacts_model_run_id_fkey'
          ) THEN
            ALTER TABLE ml_model_artifacts
            ADD CONSTRAINT ml_model_artifacts_model_run_id_fkey
            FOREIGN KEY (model_run_id)
            REFERENCES cerebros_model_runs(id);
          END IF;
        END $$;
        """


    # Foreign key constraints for cerebros_model_trials
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'cerebros_model_trials_model_run_id_fkey'
          ) THEN
            ALTER TABLE cerebros_model_trials
            ADD CONSTRAINT cerebros_model_trials_model_run_id_fkey
            FOREIGN KEY (model_run_id)
            REFERENCES cerebros_model_runs(id);
          END IF;
        END $$;
        """


    # Foreign key constraints for mlflow_experiments
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'mlflow_experiments_model_run_id_fkey'
          ) THEN
            ALTER TABLE mlflow_experiments
            ADD CONSTRAINT mlflow_experiments_model_run_id_fkey
            FOREIGN KEY (model_run_id)
            REFERENCES cerebros_model_runs(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:mlflow_experiments, [:mlflow_experiment_id],
             name: "mlflow_experiments_unique_mlflow_experiment_id_index"
           )

    # Foreign key constraints for mlflow_runs
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'mlflow_runs_model_run_id_fkey'
          ) THEN
            ALTER TABLE mlflow_runs
            ADD CONSTRAINT mlflow_runs_model_run_id_fkey
            FOREIGN KEY (model_run_id)
            REFERENCES cerebros_model_runs(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:mlflow_runs, [:mlflow_run_id],
             name: "mlflow_runs_unique_mlflow_run_id_index"
           )

    create_if_not_exists table(:dag_nodes, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :workflow_id,
          references(:dag_workflows, column: :id, name: "dag_nodes_workflow_id_fkey", type: :uuid),
          null: false

      add :event_name, :text, null: false
      add :resource_ref, :text
      add :action_name, :text
      add :status, :text, null: false, default: "pending"
      add :correlation_id, :text, null: false
      add :causation_id, :text
      add :payload, :map, null: false, default: %{}
      add :started_at, :utc_datetime_usec
      add :completed_at, :utc_datetime_usec
      add :duration_ms, :bigint

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderbolt_monitors, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :service_name, :text, null: false
      add :service_type, :text
      add :status, :text
      add :region, :text
      add :node_name, :text
      add :load_percentage, :float, default: 0.0
      add :active_connections, :bigint, default: 0
      add :pending_tasks, :bigint, default: 0
      add :completed_tasks, :bigint, default: 0
      add :failed_tasks, :bigint, default: 0
      add :average_response_time_ms, :float
      add :throughput_per_minute, :float, default: 0.0
      add :memory_usage_mb, :float
      add :cpu_usage_percent, :float
      add :disk_usage_percent, :float
      add :network_bandwidth_mbps, :float
      add :chunk_count, :bigint, default: 0
      add :chunk_size_mb, :float, default: 0.0
      add :replication_factor, :bigint
      add :health_score, :float, default: 100.0
      add :last_heartbeat, :utc_datetime
      add :error_count, :bigint, default: 0
      add :last_error, :text
      add :configuration, :map, default: %{}
      add :metadata, :map, default: %{}

      add :registered_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :last_updated, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderbolt_monitors, [:service_name, :node_name],
             name: "thunderbolt_monitors_unique_service_index"
           )

    create_if_not_exists table(:thundercom_federated_realms, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :realm_name, :text
      add :federation_url, :text
      add :trust_level, :text
      add :connection_status, :text
      add :metadata, :map
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thundercom_realm_identities
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thundercom_realm_identities_realm_id_fkey'
          ) THEN
            ALTER TABLE thundercom_realm_identities
            ADD CONSTRAINT thundercom_realm_identities_realm_id_fkey
            FOREIGN KEY (realm_id)
            REFERENCES thundercom_federated_realms(id);
          END IF;
        END $$;
        """


    # Foreign key constraints for thundercom_federated_messages
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thundercom_federated_messages_source_realm_id_fkey'
          ) THEN
            ALTER TABLE thundercom_federated_messages
            ADD CONSTRAINT thundercom_federated_messages_source_realm_id_fkey
            FOREIGN KEY (source_realm_id)
            REFERENCES thundercom_federated_realms(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thundercom_federated_messages_target_realm_id_fkey'
          ) THEN
            ALTER TABLE thundercom_federated_messages
            ADD CONSTRAINT thundercom_federated_messages_target_realm_id_fkey
            FOREIGN KEY (target_realm_id)
            REFERENCES thundercom_federated_realms(id);
          END IF;
        END $$;
        """


    create_if_not_exists index(:thundercom_federated_realms, [:connection_status])

    create_if_not_exists index(:thundercom_federated_realms, [:trust_level])

    create_if_not_exists index(:thundercom_federated_realms, [:realm_name], unique: true)

    create_if_not_exists table(:thunderblock_roles, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :role_name, :text, null: false
      add :role_slug, :text, null: false
      add :role_type, :text, null: false, default: "member"
      add :position, :bigint, null: false, default: 0
      add :color, :text
      add :hoist, :boolean, null: false, default: false
      add :mentionable, :boolean, null: false, default: true
      add :permissions, :map, null: false
      add :channel_overrides, :map, null: false, default: %{}
      add :restrictions, :map, null: false
      add :member_count, :bigint, null: false, default: 0
      add :member_ids, {:array, :uuid}, null: false, default: []
      add :auto_assign, :boolean, null: false, default: false
      add :requires_approval, :boolean, null: false, default: false
      add :created_by, :uuid, null: false
      add :moderation_config, :map, null: false
      add :federation_config, :map, null: false
      add :role_flags, {:array, :text}, null: false, default: []
      add :expiry_config, :map, null: false
      add :tags, {:array, :text}, null: false, default: []
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :community_id,
          references(:thunderblock_communities,
            column: :id,
            name: "thunderblock_roles_community_id_fkey",
            type: :uuid,
            on_delete: :delete_all,
            on_update: :update_all
          )
    end

    create_if_not_exists index(:thunderblock_roles, [:tags], using: :gin, name: "roles_tags_idx")

    create_if_not_exists index(:thunderblock_roles, [:role_flags], using: :gin, name: "roles_flags_idx")

    create_if_not_exists index(:thunderblock_roles, [:channel_overrides], using: :gin,
             name: "roles_overrides_idx"
           )

    create_if_not_exists index(:thunderblock_roles, [:permissions], using: :gin, name: "roles_permissions_idx")

    create_if_not_exists index(:thunderblock_roles, [:member_ids], using: :gin, name: "roles_members_idx")

    create_if_not_exists index(:thunderblock_roles, [:mentionable], name: "roles_mentionable_idx")

    create_if_not_exists index(:thunderblock_roles, [:auto_assign, :community_id],
             name: "roles_auto_assign_idx"
           )

    create_if_not_exists index(:thunderblock_roles, [:position, :role_type], name: "roles_hierarchy_idx")

    create_if_not_exists index(:thunderblock_roles, [:community_id, :role_type],
             name: "roles_community_type_idx"
           )

    create_if_not_exists index(:thunderblock_roles, [:community_id, :position],
             name: "roles_community_position_idx"
           )

    create_if_not_exists index(:thunderblock_roles, [:role_slug, :community_id],
             name: "roles_slug_community_idx",
             unique: true
           )

    create_if_not_exists unique_index(:thunderblock_roles, [:role_slug, :community_id],
             name: "thunderblock_roles_unique_role_in_community_index"
           )

    create_if_not_exists table(:probe_attractor_summaries, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :run_id,
          references(:probe_runs,
            column: :id,
            name: "probe_attractor_summaries_run_id_fkey",
            type: :uuid
          ),
          null: false

      add :points, :bigint, null: false, default: 0
      add :delay_rows, :bigint, null: false, default: 0
      add :m, :bigint, null: false, default: 3
      add :tau, :bigint, null: false, default: 1
      add :corr_dim, :float, null: false, default: 0.0
      add :lyap, :float, null: false, default: 0.0
      add :lyap_canonical, :float
      add :lyap_r2, :float
      add :lyap_window, :text
      add :reliable, :boolean, null: false, default: false
      add :note, :text

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:probe_attractor_summaries, [:lyap])

    create_if_not_exists index(:probe_attractor_summaries, [:corr_dim])

    create_if_not_exists table(:upm_trainers, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text
      add :tenant_id, :uuid
      add :mode, :text
      add :status, :text
      add :last_window_id, :uuid
      add :last_window_fetched_at, :utc_datetime_usec
      add :last_loss, :float
      add :drift_score, :float
      add :metadata, :map
    end

    # Foreign key constraints for upm_snapshots
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'upm_snapshots_trainer_id_fkey'
          ) THEN
            ALTER TABLE upm_snapshots
            ADD CONSTRAINT upm_snapshots_trainer_id_fkey
            FOREIGN KEY (trainer_id)
            REFERENCES upm_trainers(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:upm_snapshots, [:trainer_id, :version],
             name: "upm_snapshots_unique_version_per_trainer_index"
           )

    # Foreign key constraints for upm_drift_windows
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'upm_drift_windows_trainer_id_fkey'
          ) THEN
            ALTER TABLE upm_drift_windows
            ADD CONSTRAINT upm_drift_windows_trainer_id_fkey
            FOREIGN KEY (trainer_id)
            REFERENCES upm_trainers(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:upm_trainers, [:name, :tenant_id],
             name: "upm_trainers_name_per_tenant_index"
           )

    create_if_not_exists table(:ising_optimization_problems, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text
      add :description, :text
      add :topology, :text
      add :dimensions, :map
      add :coupling_matrix, :map
      add :field_config, :map
      add :boundary_conditions, :text
      add :problem_type, :text
      add :metadata, :map
      add :created_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for ising_optimization_runs
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ising_optimization_runs_problem_id_fkey'
          ) THEN
            ALTER TABLE ising_optimization_runs
            ADD CONSTRAINT ising_optimization_runs_problem_id_fkey
            FOREIGN KEY (problem_id)
            REFERENCES ising_optimization_problems(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:thunderblock_cluster_nodes, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :node_name, :text
      add :node_type, :text
      add :status, :text
      add :load_score, :numeric
      add :capabilities, :map
      add :last_heartbeat, :utc_datetime_usec
      add :metadata, :map
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thunderblock_communities
    # NOTE: cluster_node_id FK removed - column doesn't exist in current schema


    create_if_not_exists unique_index(:thunderblock_communities, [:community_slug],
             name: "thunderblock_communities_unique_community_slug_index"
           )

    # Foreign key constraints for thunderblock_zone_containers
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_zone_containers_cluster_node_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_zone_containers
            ADD CONSTRAINT thunderblock_zone_containers_cluster_node_id_fkey
            FOREIGN KEY (cluster_node_id)
            REFERENCES thunderblock_cluster_nodes(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:thunderblock_zone_containers, [:zone_name],
             name: "thunderblock_zone_containers_unique_zone_name_index"
           )

    # Foreign key constraints for thunderblock_supervision_trees
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_supervision_trees_cluster_node_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_supervision_trees
            ADD CONSTRAINT thunderblock_supervision_trees_cluster_node_id_fkey
            FOREIGN KEY (cluster_node_id)
            REFERENCES thunderblock_cluster_nodes(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thunderblock_supervision_trees_zone_container_id_fkey'
          ) THEN
            ALTER TABLE thunderblock_supervision_trees
            ADD CONSTRAINT thunderblock_supervision_trees_zone_container_id_fkey
            FOREIGN KEY (zone_container_id)
            REFERENCES thunderblock_zone_containers(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:thunderblock_cluster_nodes, [:node_name],
             name: "thunderblock_cluster_nodes_unique_node_name_index"
           )

    create_if_not_exists table(:thundercore_workflow_dags, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text
      add :description, :text
      add :status, :text
      add :priority, :bigint
      add :metadata, :map
      add :started_at, :utc_datetime_usec
      add :completed_at, :utc_datetime_usec
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for thundercore_task_nodes
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'thundercore_task_nodes_workflow_dag_id_fkey'
          ) THEN
            ALTER TABLE thundercore_task_nodes
            ADD CONSTRAINT thundercore_task_nodes_workflow_dag_id_fkey
            FOREIGN KEY (workflow_dag_id)
            REFERENCES thundercore_workflow_dags(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:thundercore_workflow_dags, [:name],
             name: "thundercore_workflow_dags_unique_workflow_name_index"
           )

    create_if_not_exists table(:policy_rules, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :name, :text, null: false
      add :rule_type, :text, null: false
      add :scope, :text, null: false
      add :condition_expression, :text
      add :priority, :bigint, default: 100
      add :active, :boolean, default: true
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:policy_rules, [:name, :scope],
             name: "policy_rules_unique_name_per_scope_index"
           )

    create_if_not_exists table(:thundercore_timing_events, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :event_name, :text, null: false
      add :event_type, :text, null: false
      add :scheduled_at, :utc_datetime_usec, null: false
      add :executed_at, :utc_datetime_usec
      add :status, :text, default: "scheduled"
      add :metadata, :map, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists table(:thunderblock_federation_sockets, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :socket_name, :text, null: false
      add :socket_slug, :text, null: false
      add :socket_type, :text, null: false, default: "bidirectional"
      add :status, :text, null: false, default: "initializing"

      add :target_community_id,
          references(:thunderblock_communities,
            column: :id,
            name: "thunderblock_federation_sockets_target_community_id_fkey",
            type: :uuid,
            on_delete: :nilify_all,
            on_update: :update_all
          )

      add :target_realm_address, :text
      add :federation_protocol, :text, null: false, default: "thundercom_v1"
      add :trust_level, :text, null: false, default: "basic"
      add :connection_config, :map, null: false
      add :message_routing, :map, null: false
      add :sharing_policies, :map, null: false
      add :security_config, :map, null: false
      add :bandwidth_limits, :map, null: false
      add :federation_metrics, :map, null: false
      add :relay_config, :map, null: false
      add :authentication_data, :map, null: false
      add :last_heartbeat, :utc_datetime
      add :last_message_sent, :utc_datetime
      add :last_message_received, :utc_datetime
      add :connection_established_at, :utc_datetime
      add :error_log, {:array, :map}, null: false, default: []
      add :message_queue, {:array, :map}, null: false, default: []
      add :quarantine_queue, {:array, :map}, null: false, default: []
      add :tags, {:array, :text}, null: false, default: []
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :community_id,
          references(:thunderblock_communities,
            column: :id,
            name: "thunderblock_federation_sockets_community_id_fkey",
            type: :uuid,
            on_delete: :delete_all,
            on_update: :update_all
          )
    end

    create_if_not_exists index(:thunderblock_federation_sockets, [:tags], using: :gin,
             name: "federation_sockets_tags_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:error_log], using: :gin,
             name: "federation_sockets_errors_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:federation_metrics], using: :gin,
             name: "federation_sockets_metrics_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:quarantine_queue], using: :gin,
             name: "federation_sockets_quarantine_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:message_queue], using: :gin,
             name: "federation_sockets_queue_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:target_community_id],
             name: "federation_sockets_target_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:trust_level, :status],
             name: "federation_sockets_trust_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:federation_protocol, :status],
             name: "federation_sockets_protocol_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:status, :last_heartbeat],
             name: "federation_sockets_heartbeat_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:community_id, :status],
             name: "federation_sockets_community_status_idx"
           )

    create_if_not_exists index(:thunderblock_federation_sockets, [:socket_slug, :community_id],
             name: "federation_sockets_slug_community_idx",
             unique: true
           )

    create_if_not_exists unique_index(:thunderblock_federation_sockets, [:socket_slug, :community_id],
             name: "federation_socket_community_idx"
           )

    create_if_not_exists table(:probe_laps, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :run_id,
          references(:probe_runs, column: :id, name: "probe_laps_run_id_fkey", type: :uuid),
          null: false

      add :lap_index, :bigint, null: false
      add :response_preview, :text
      add :char_entropy, :float, null: false, default: 0.0
      add :lexical_diversity, :float, null: false, default: 0.0
      add :repetition_ratio, :float, null: false, default: 0.0
      add :cosine_to_prev, :float, null: false, default: 0.0
      add :elapsed_ms, :bigint, null: false, default: 0
      add :embedding, {:array, :float}, null: false, default: []
      add :js_divergence_vs_baseline, :float
      add :topk_overlap_vs_baseline, :float

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists index(:probe_laps, [:run_id, :lap_index], unique: true)

    create_if_not_exists table(:users, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :email, :citext
      add :password, :text
      add :hashed_password, :text
      add :confirmed_at, :utc_datetime
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for agents
    # Removed orphaned FK: agents_created_by_user_id_fkey (created_by_user_id column does not exist in agents table)


    # Foreign key constraints for user_tokens
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'user_tokens_user_id_fkey'
          ) THEN
            ALTER TABLE user_tokens
            ADD CONSTRAINT user_tokens_user_id_fkey
            FOREIGN KEY (user_id)
            REFERENCES users(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:users, [:email], name: "users_unique_email_index")

    create_if_not_exists table(:thunderblock_knowledge_nodes, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :tenant_id, :uuid
      add :node_type, :text
      add :title, :text
      add :description, :text
      add :knowledge_domain, :text
      add :confidence_level, :numeric
      add :evidence_strength, :numeric
      add :centrality_score, :numeric
      add :relationship_data, :map
      add :temporal_data, :map
      add :spatial_data, :map
      add :graph_metrics, :map
      add :knowledge_quality, :map
      add :consolidation_data, :map
      add :discovery_data, :map
      add :access_patterns, :map
      add :verification_status, :text
      add :indexing_status, :text
      add :metadata, :map
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for embedding_vectors
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'embedding_vectors_knowledge_node_id_fkey'
          ) THEN
            ALTER TABLE embedding_vectors
            ADD CONSTRAINT embedding_vectors_knowledge_node_id_fkey
            FOREIGN KEY (knowledge_node_id)
            REFERENCES thunderblock_knowledge_nodes(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'embedding_vectors_experience_id_fkey'
          ) THEN
            ALTER TABLE embedding_vectors
            ADD CONSTRAINT embedding_vectors_experience_id_fkey
            FOREIGN KEY (experience_id)
            REFERENCES experiences(id);
          END IF;
        END $$;
        """


    create_if_not_exists unique_index(:embedding_vectors, [:content_hash, :vector_model],
             name: "embedding_vectors_unique_content_hash_per_model_index"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :embedding_vector_ids], using: :gin,
             name: "knowledge_nodes_embeddings_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :memory_record_ids], using: :gin,
             name: "knowledge_nodes_memories_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :taxonomy_path], using: :gin,
             name: "knowledge_nodes_taxonomy_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :relationship_data], using: :gin,
             name: "knowledge_nodes_relationships_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :source_domains], using: :gin,
             name: "knowledge_nodes_sources_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :semantic_tags], using: :gin,
             name: "knowledge_nodes_tags_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :aliases], using: :gin,
             name: "knowledge_nodes_aliases_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :indexing_status],
             name: "knowledge_nodes_indexing_idx"
           )

    create_if_not_exists index(
             :thunderblock_knowledge_nodes,
             [:tenant_id, :confidence_level, :evidence_strength],
             name: "knowledge_nodes_quality_idx"
           )

    create_if_not_exists index(
             :thunderblock_knowledge_nodes,
             [:tenant_id, :verification_status, :centrality_score],
             name: "knowledge_nodes_verification_idx"
           )

    create_if_not_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :node_type, :knowledge_domain],
             name: "knowledge_nodes_type_domain_idx"
           )

    create_if_not_exists unique_index(:thunderblock_knowledge_nodes, [:tenant_id, :title, :knowledge_domain],
             name: "thunderblock_knowledge_nodes_unique_title_domain_index"
           )

    create_if_not_exists table(:thunderblock_distributed_state, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :state_key, :text, null: false
      add :state_scope, :text, default: "global"
      add :state_value, :map, null: false
      add :version, :bigint, default: 1
      add :last_updated_by, :text
      add :ttl_expires_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:thunderblock_distributed_state, [:state_key, :state_scope],
             name: "thunderblock_distributed_state_unique_state_key_scope_index"
           )

    create_if_not_exists table(:ml_training_datasets, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :dataset_id, :text
      add :tenant_id, :text
      add :name, :text
      add :purpose, :text
      add :description, :text
      add :version, :bigint
      add :status, :text
      add :bytes, :bigint
      add :records, :bigint
      add :checksum, :text
      add :sealed_at, :utc_datetime_usec
      add :inserted_at, :utc_datetime_usec
      add :updated_at, :utc_datetime_usec
    end

    # Foreign key constraints for ml_training_runs
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ml_training_runs_dataset_id_fkey'
          ) THEN
            ALTER TABLE ml_training_runs
            ADD CONSTRAINT ml_training_runs_dataset_id_fkey
            FOREIGN KEY (dataset_id)
            REFERENCES ml_training_datasets(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ml_training_runs_spec_id_fkey'
          ) THEN
            ALTER TABLE ml_training_runs
            ADD CONSTRAINT ml_training_runs_spec_id_fkey
            FOREIGN KEY (spec_id)
            REFERENCES ml_model_specs(id);
          END IF;
        END $$;
        """

    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ml_training_runs_artifact_id_fkey'
          ) THEN
            ALTER TABLE ml_training_runs
            ADD CONSTRAINT ml_training_runs_artifact_id_fkey
            FOREIGN KEY (artifact_id)
            REFERENCES ml_model_artifacts(id);
          END IF;
        END $$;
        """


    # Foreign key constraints for ml_feature_views
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ml_feature_views_dataset_id_fkey'
          ) THEN
            ALTER TABLE ml_feature_views
            ADD CONSTRAINT ml_feature_views_dataset_id_fkey
            FOREIGN KEY (dataset_id)
            REFERENCES ml_training_datasets(id);
          END IF;
        END $$;
        """


    # Foreign key constraints for ml_model_versions
    execute """
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_constraint
            WHERE conname = 'ml_model_versions_dataset_id_fkey'
          ) THEN
            ALTER TABLE ml_model_versions
            ADD CONSTRAINT ml_model_versions_dataset_id_fkey
            FOREIGN KEY (dataset_id)
            REFERENCES ml_training_datasets(id);
          END IF;
        END $$;
        """


    create_if_not_exists table(:voice_devices, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :principal_id, :uuid, null: false
      add :input_device_id, :text
      add :output_device_id, :text
      add :last_ice_ok, :boolean, null: false, default: false
      add :last_ice_ts, :utc_datetime
      add :metadata, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    create_if_not_exists unique_index(:voice_devices, [:principal_id],
             name: "voice_devices_unique_principal_index"
           )
  end

  def down do
    drop_if_exists unique_index(:voice_devices, [:principal_id],
                     name: "voice_devices_unique_principal_index"
                   )

    drop table(:voice_devices)


    drop constraint(:ml_model_versions, "ml_model_versions_dataset_id_fkey")

    alter table(:ml_model_versions) do
      modify :dataset_id, :uuid
    end

    drop constraint(:ml_feature_views, "ml_feature_views_dataset_id_fkey")

    alter table(:ml_feature_views) do
      modify :dataset_id, :uuid
    end

    drop constraint(:ml_training_runs, "ml_training_runs_dataset_id_fkey")

    drop constraint(:ml_training_runs, "ml_training_runs_spec_id_fkey")

    drop constraint(:ml_training_runs, "ml_training_runs_artifact_id_fkey")

    alter table(:ml_training_runs) do
      modify :artifact_id, :uuid
      modify :spec_id, :uuid
      modify :dataset_id, :uuid
    end

    drop table(:ml_training_datasets)

    drop_if_exists unique_index(:thunderblock_distributed_state, [:state_key, :state_scope],
                     name: "thunderblock_distributed_state_unique_state_key_scope_index"
                   )

    drop table(:thunderblock_distributed_state)

    drop_if_exists unique_index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :title, :knowledge_domain],
                     name: "thunderblock_knowledge_nodes_unique_title_domain_index"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :node_type, :knowledge_domain],
                     name: "knowledge_nodes_type_domain_idx"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :verification_status, :centrality_score],
                     name: "knowledge_nodes_verification_idx"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :confidence_level, :evidence_strength],
                     name: "knowledge_nodes_quality_idx"
                   )

    drop_if_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :indexing_status],
                     name: "knowledge_nodes_indexing_idx"
                   )

    drop_if_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :aliases], using: :gin,
                     name: "knowledge_nodes_aliases_idx"
                   )

    drop_if_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :semantic_tags], using: :gin,
                     name: "knowledge_nodes_tags_idx"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :source_domains], using: :gin,
                     name: "knowledge_nodes_sources_idx"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :relationship_data], using: :gin,
                     name: "knowledge_nodes_relationships_idx"
                   )

    drop_if_exists index(:thunderblock_knowledge_nodes, [:tenant_id, :taxonomy_path], using: :gin,
                     name: "knowledge_nodes_taxonomy_idx"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :memory_record_ids], using: :gin,
                     name: "knowledge_nodes_memories_idx"
                   )

    drop_if_exists index(
                     :thunderblock_knowledge_nodes,
                     [:tenant_id, :embedding_vector_ids], using: :gin,
                     name: "knowledge_nodes_embeddings_idx"
                   )


    drop_if_exists unique_index(:embedding_vectors, [:content_hash, :vector_model],
                     name: "embedding_vectors_unique_content_hash_per_model_index"
                   )

    drop constraint(:embedding_vectors, "embedding_vectors_knowledge_node_id_fkey")

    drop constraint(:embedding_vectors, "embedding_vectors_experience_id_fkey")

    alter table(:embedding_vectors) do
      modify :experience_id, :uuid
      modify :knowledge_node_id, :uuid
    end

    drop table(:thunderblock_knowledge_nodes)

    drop_if_exists unique_index(:users, [:email], name: "users_unique_email_index")


    drop constraint(:user_tokens, "user_tokens_user_id_fkey")

    alter table(:user_tokens) do
      modify :user_id, :uuid
    end

    drop constraint(:agents, "agents_created_by_user_id_fkey")


    drop table(:users)

    drop constraint(:probe_laps, "probe_laps_run_id_fkey")

    drop_if_exists index(:probe_laps, [:run_id, :lap_index])

    drop table(:probe_laps)

    drop_if_exists unique_index(:thunderblock_federation_sockets, [:socket_slug, :community_id],
                     name: "federation_socket_community_idx"
                   )

    drop constraint(
           :thunderblock_federation_sockets,
           "thunderblock_federation_sockets_target_community_id_fkey"
         )

    drop constraint(
           :thunderblock_federation_sockets,
           "thunderblock_federation_sockets_community_id_fkey"
         )

    drop_if_exists index(:thunderblock_federation_sockets, [:socket_slug, :community_id],
                     name: "federation_sockets_slug_community_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:community_id, :status],
                     name: "federation_sockets_community_status_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:status, :last_heartbeat],
                     name: "federation_sockets_heartbeat_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:federation_protocol, :status],
                     name: "federation_sockets_protocol_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:trust_level, :status],
                     name: "federation_sockets_trust_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:target_community_id],
                     name: "federation_sockets_target_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:message_queue], using: :gin,
                     name: "federation_sockets_queue_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:quarantine_queue], using: :gin,
                     name: "federation_sockets_quarantine_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:federation_metrics], using: :gin,
                     name: "federation_sockets_metrics_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:error_log], using: :gin,
                     name: "federation_sockets_errors_idx"
                   )

    drop_if_exists index(:thunderblock_federation_sockets, [:tags], using: :gin,
                     name: "federation_sockets_tags_idx"
                   )

    drop table(:thunderblock_federation_sockets)

    drop table(:thundercore_timing_events)

    drop_if_exists unique_index(:policy_rules, [:name, :scope],
                     name: "policy_rules_unique_name_per_scope_index"
                   )

    drop table(:policy_rules)

    drop_if_exists unique_index(:thundercore_workflow_dags, [:name],
                     name: "thundercore_workflow_dags_unique_workflow_name_index"
                   )


    drop constraint(:thundercore_task_nodes, "thundercore_task_nodes_workflow_dag_id_fkey")

    alter table(:thundercore_task_nodes) do
      modify :workflow_dag_id, :uuid
    end

    drop table(:thundercore_workflow_dags)

    drop_if_exists unique_index(:thunderblock_cluster_nodes, [:node_name],
                     name: "thunderblock_cluster_nodes_unique_node_name_index"
                   )


    drop constraint(
           :thunderblock_supervision_trees,
           "thunderblock_supervision_trees_cluster_node_id_fkey"
         )

    drop constraint(
           :thunderblock_supervision_trees,
           "thunderblock_supervision_trees_zone_container_id_fkey"
         )

    alter table(:thunderblock_supervision_trees) do
      modify :zone_container_id, :uuid
      modify :cluster_node_id, :uuid
    end

    drop_if_exists unique_index(:thunderblock_zone_containers, [:zone_name],
                     name: "thunderblock_zone_containers_unique_zone_name_index"
                   )

    drop constraint(
           :thunderblock_zone_containers,
           "thunderblock_zone_containers_cluster_node_id_fkey"
         )


    drop_if_exists unique_index(:thunderblock_communities, [:community_slug],
                     name: "thunderblock_communities_unique_community_slug_index"
                   )

    drop constraint(:thunderblock_communities, "thunderblock_communities_cluster_node_id_fkey")


    drop table(:thunderblock_cluster_nodes)


    drop constraint(:ising_optimization_runs, "ising_optimization_runs_problem_id_fkey")

    alter table(:ising_optimization_runs) do
      modify :problem_id, :uuid
    end

    drop table(:ising_optimization_problems)

    drop_if_exists unique_index(:upm_trainers, [:name, :tenant_id],
                     name: "upm_trainers_name_per_tenant_index"
                   )


    drop constraint(:upm_drift_windows, "upm_drift_windows_trainer_id_fkey")

    alter table(:upm_drift_windows) do
      modify :trainer_id, :uuid
    end

    drop_if_exists unique_index(:upm_snapshots, [:trainer_id, :version],
                     name: "upm_snapshots_unique_version_per_trainer_index"
                   )

    drop constraint(:upm_snapshots, "upm_snapshots_trainer_id_fkey")

    alter table(:upm_snapshots) do
      modify :trainer_id, :uuid
    end

    drop table(:upm_trainers)

    drop constraint(:probe_attractor_summaries, "probe_attractor_summaries_run_id_fkey")

    drop_if_exists index(:probe_attractor_summaries, [:corr_dim])

    drop_if_exists index(:probe_attractor_summaries, [:lyap])

    drop table(:probe_attractor_summaries)

    drop_if_exists unique_index(:thunderblock_roles, [:role_slug, :community_id],
                     name: "thunderblock_roles_unique_role_in_community_index"
                   )

    drop constraint(:thunderblock_roles, "thunderblock_roles_community_id_fkey")

    drop_if_exists index(:thunderblock_roles, [:role_slug, :community_id],
                     name: "roles_slug_community_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:community_id, :position],
                     name: "roles_community_position_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:community_id, :role_type],
                     name: "roles_community_type_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:position, :role_type],
                     name: "roles_hierarchy_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:auto_assign, :community_id],
                     name: "roles_auto_assign_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:mentionable], name: "roles_mentionable_idx")

    drop_if_exists index(:thunderblock_roles, [:member_ids], using: :gin,
                     name: "roles_members_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:permissions], using: :gin,
                     name: "roles_permissions_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:channel_overrides], using: :gin,
                     name: "roles_overrides_idx"
                   )

    drop_if_exists index(:thunderblock_roles, [:role_flags], using: :gin, name: "roles_flags_idx")

    drop_if_exists index(:thunderblock_roles, [:tags], using: :gin, name: "roles_tags_idx")

    drop table(:thunderblock_roles)

    drop_if_exists index(:thundercom_federated_realms, [:realm_name])

    drop_if_exists index(:thundercom_federated_realms, [:trust_level])

    drop_if_exists index(:thundercom_federated_realms, [:connection_status])


    drop constraint(
           :thundercom_federated_messages,
           "thundercom_federated_messages_source_realm_id_fkey"
         )

    drop constraint(
           :thundercom_federated_messages,
           "thundercom_federated_messages_target_realm_id_fkey"
         )

    alter table(:thundercom_federated_messages) do
      modify :target_realm_id, :uuid
      modify :source_realm_id, :uuid
    end

    drop constraint(:thundercom_realm_identities, "thundercom_realm_identities_realm_id_fkey")

    alter table(:thundercom_realm_identities) do
      modify :realm_id, :uuid
    end

    drop table(:thundercom_federated_realms)

    drop_if_exists unique_index(:thunderbolt_monitors, [:service_name, :node_name],
                     name: "thunderbolt_monitors_unique_service_index"
                   )

    drop table(:thunderbolt_monitors)

    drop constraint(:dag_nodes, "dag_nodes_workflow_id_fkey")

    drop table(:dag_nodes)


    drop_if_exists unique_index(:mlflow_runs, [:mlflow_run_id],
                     name: "mlflow_runs_unique_mlflow_run_id_index"
                   )

    drop constraint(:mlflow_runs, "mlflow_runs_model_run_id_fkey")

    alter table(:mlflow_runs) do
      modify :model_run_id, :uuid
    end

    drop_if_exists unique_index(:mlflow_experiments, [:mlflow_experiment_id],
                     name: "mlflow_experiments_unique_mlflow_experiment_id_index"
                   )

    drop constraint(:mlflow_experiments, "mlflow_experiments_model_run_id_fkey")

    alter table(:mlflow_experiments) do
      modify :model_run_id, :uuid
    end

    drop constraint(:cerebros_model_trials, "cerebros_model_trials_model_run_id_fkey")

    alter table(:cerebros_model_trials) do
      modify :model_run_id, :uuid
    end

    drop constraint(:ml_model_artifacts, "ml_model_artifacts_model_run_id_fkey")

    alter table(:ml_model_artifacts) do
      modify :model_run_id, :uuid
    end

    drop table(:cerebros_model_runs)

    drop_if_exists unique_index(:execution_containers, [:name],
                     name: "execution_containers_unique_container_name_index"
                   )

    drop table(:execution_containers)

    drop constraint(:memories, "memories_agent_id_fkey")

    drop constraint(:memories, "memories_memory_node_id_fkey")


    drop constraint(:embedding_vectors, "embedding_vectors_memory_record_id_fkey")

    drop constraint(:embedding_vectors, "embedding_vectors_memory_node_id_fkey")


    drop table(:memories)

    drop_if_exists unique_index(:dag_workflows, [:correlation_id],
                     name: "dag_workflows_unique_correlation_index"
                   )


    drop constraint(:dag_snapshots, "dag_snapshots_workflow_id_fkey")

    alter table(:dag_snapshots) do
      modify :workflow_id, :uuid
    end

    drop_if_exists unique_index(
                     :dag_edges,
                     [:workflow_id, :from_node_id, :to_node_id, :edge_type],
                     name: "dag_edges_unique_edge_index"
                   )

    drop constraint(:dag_edges, "dag_edges_workflow_id_fkey")

    alter table(:dag_edges) do
      modify :workflow_id, :uuid
    end

    drop table(:dag_workflows)

    drop constraint(:thunderlane_cell_topology, "thunderlane_cell_topology_coordinator_id_fkey")


    drop constraint(:thunderlane_lane_metrics, "thunderlane_lane_metrics_topology_id_fkey")

    drop constraint(:thunderlane_lane_metrics, "thunderlane_lane_metrics_ruleset_id_fkey")

    alter table(:thunderlane_lane_metrics) do
      modify :ruleset_id, :uuid
      modify :topology_id, :uuid
    end

    drop table(:thunderlane_cell_topology)

    drop constraint(
           :thunderlane_telemetry_snapshots,
           "thunderlane_telemetry_snapshots_lane_configuration_id_fkey"
         )

    drop constraint(
           :thunderlane_telemetry_snapshots,
           "thunderlane_telemetry_snapshots_rule_oracle_id_fkey"
         )


    drop constraint(
           :thunderlane_performance_metrics,
           "thunderlane_performance_metrics_telemetry_snapshot_id_fkey"
         )

    alter table(:thunderlane_performance_metrics) do
      modify :telemetry_snapshot_id, :uuid
    end

    drop table(:thunderlane_telemetry_snapshots)

    drop_if_exists unique_index(:thunderblock_channels, [:channel_slug, :community_id],
                     name: "thunderblock_channels_unique_channel_in_community_index"
                   )

    drop constraint(:thunderblock_channels, "thunderblock_channels_community_id_fkey")

    drop_if_exists index(:thunderblock_channels, [:channel_slug, :community_id],
                     name: "channels_slug_community_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:community_id, :channel_type],
                     name: "channels_community_type_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:community_id, :position],
                     name: "channels_community_position_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:channel_type, :status],
                     name: "channels_type_status_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:status, :last_message_at],
                     name: "channels_activity_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:visibility, :status],
                     name: "channels_visibility_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:pinned_message_ids], using: :gin,
                     name: "channels_pinned_messages_idx"
                   )

    drop_if_exists index(:thunderblock_channels, [:tags], using: :gin, name: "channels_tags_idx")

    drop_if_exists index(:thunderblock_channels, [:channel_metrics], using: :gin,
                     name: "channels_metrics_idx"
                   )


    drop constraint(:thunderblock_messages, "thunderblock_messages_channel_id_fkey")

    drop constraint(:thunderblock_messages, "thunderblock_messages_community_id_fkey")

    alter table(:thunderblock_messages) do
      modify :community_id, :uuid
      modify :channel_id, :uuid
    end

    drop table(:thunderblock_channels)

    drop constraint(:decisions, "decisions_agent_id_fkey")

    drop constraint(:decisions, "decisions_parent_decision_id_fkey")


    drop constraint(:actions, "actions_decision_id_fkey")

    drop constraint(:actions, "actions_parent_action_id_fkey")

    alter table(:actions) do
      modify :parent_action_id, :uuid
      modify :decision_id, :uuid
    end

    drop_if_exists unique_index(
                     :experiences,
                     [:agent_id, :situation_context, :action_taken, :inserted_at],
                     name: "experiences_unique_experience_per_context_index"
                   )

    drop constraint(:experiences, "experiences_decision_id_fkey")

    drop constraint(:experiences, "experiences_action_id_fkey")

    alter table(:experiences) do
      modify :action_id, :uuid
      modify :decision_id, :uuid
    end

    drop table(:decisions)

    drop constraint(:mlflow_runs, "mlflow_runs_mlflow_experiment_id_fkey")

    drop constraint(:mlflow_runs, "mlflow_runs_model_trial_id_fkey")

    drop table(:mlflow_runs)

    drop constraint(:ml_model_versions, "ml_model_versions_spec_id_fkey")

    drop constraint(:ml_model_versions, "ml_model_versions_artifact_id_fkey")

    drop table(:ml_model_versions)

    drop table(:embedding_vectors)

    drop table(:mlflow_experiments)

    drop_if_exists unique_index(:system_actions, [:action_type, :initiated_by, :status],
                     name: "system_actions_unique_pending_action_index"
                   )

    drop table(:system_actions)

    drop constraint(
           :thunderlane_consensus_runs,
           "thunderlane_consensus_runs_lane_configuration_id_fkey"
         )

    drop constraint(:thunderlane_consensus_runs, "thunderlane_consensus_runs_rule_oracle_id_fkey")

    drop table(:thunderlane_consensus_runs)

    drop_if_exists unique_index(:thunderblock_rate_limit_policies, [:policy_name],
                     name: "thunderblock_rate_limit_policies_unique_policy_name_index"
                   )

    drop table(:thunderblock_rate_limit_policies)

    drop_if_exists unique_index(:voice_participants, [:room_id, :principal_id],
                     name: "voice_participants_unique_room_principal_index"
                   )

    drop constraint(:voice_participants, "voice_participants_room_id_fkey")

    drop table(:voice_participants)

    drop constraint(
           :thunderlane_performance_metrics,
           "thunderlane_performance_metrics_lane_configuration_id_fkey"
         )

    drop constraint(
           :thunderlane_performance_metrics,
           "thunderlane_performance_metrics_rule_oracle_id_fkey"
         )

    drop table(:thunderlane_performance_metrics)

    drop_if_exists unique_index(:thunderblock_system_events, [:correlation_id, :event_type],
                     name: "thunderblock_system_events_unique_correlation_event_index"
                   )

    drop table(:thunderblock_system_events)

    drop constraint(:memory_nodes, "memory_nodes_agent_id_fkey")

    drop constraint(:memory_nodes, "memory_nodes_parent_memory_id_fkey")

    drop table(:memory_nodes)

    drop_if_exists index(:thundercom_federated_messages, [:source_realm_id])

    drop_if_exists index(:thundercom_federated_messages, [:target_realm_id])

    drop_if_exists index(:thundercom_federated_messages, [:delivery_status])

    drop_if_exists index(:thundercom_federated_messages, [:message_type])

    drop_if_exists index(:thundercom_federated_messages, [:inserted_at])

    drop table(:thundercom_federated_messages)

    drop table(:thundercore_task_nodes)

    drop constraint(:actions, "actions_agent_id_fkey")

    drop table(:actions)

    drop_if_exists index(:thunderflow_event_streams, [:stream_name])

    drop_if_exists index(:thunderflow_event_streams, [:stream_type])

    drop_if_exists index(:thunderflow_event_streams, [:source_domain])

    drop_if_exists index(:thunderflow_event_streams, [:status])

    drop_if_exists index(:thunderflow_event_streams, [:last_event_at])

    drop table(:thunderflow_event_streams)

    drop table(:workflow_trackers)

    drop_if_exists unique_index(:thunderbit_monitors, [:agent_id],
                     name: "thunderbit_monitors_unique_agent_monitor_index"
                   )

    drop table(:thunderbit_monitors)

    drop table(:rag_documents)

    drop table(:experts)

    drop constraint(:thunderlane_lane_metrics, "thunderlane_lane_metrics_coordinator_id_fkey")

    drop constraint(:thunderlane_lane_metrics, "thunderlane_lane_metrics_coupling_id_fkey")

    drop table(:thunderlane_lane_metrics)

    drop table(:lineage_edges)

    drop table(:user_tokens)

    drop constraint(
           :thunderblock_supervision_trees,
           "thunderblock_supervision_trees_parent_tree_id_fkey"
         )

    drop_if_exists index(:thunderblock_supervision_trees, [:tree_name, :zone_container_id],
                     name: "supervision_trees_name_zone_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:status, :health_score],
                     name: "supervision_trees_health_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:tree_type, :status],
                     name: "supervision_trees_type_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:zone_container_id, :depth_level],
                     name: "supervision_trees_zone_depth_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:escalation_level, :status],
                     name: "supervision_trees_escalation_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:parent_tree_id, :depth_level],
                     name: "supervision_trees_hierarchy_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:running_children], using: :gin,
                     name: "supervision_trees_children_idx"
                   )

    drop_if_exists index(:thunderblock_supervision_trees, [:tags], using: :gin,
                     name: "supervision_trees_tags_idx"
                   )

    drop table(:thunderblock_supervision_trees)

    drop table(:ising_performance_metrics)

    drop table(:cerebros_model_trials)

    drop table(:support_tickets)

    drop_if_exists unique_index(:thundercore_system_policies, [:policy_name],
                     name: "thundercore_system_policies_unique_policy_name_index"
                   )

    drop table(:thundercore_system_policies)

    drop_if_exists index(:thunderblock_zone_containers, [:zone_name],
                     name: "zone_containers_name_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:status, :health_score],
                     name: "zone_containers_health_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:zone_type, :status],
                     name: "zone_containers_type_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:cluster_node_id, :status],
                     name: "zone_containers_node_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:phase_assignment],
                     name: "zone_containers_phase_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:neighbor_zones], using: :gin,
                     name: "zone_containers_neighbors_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:tags], using: :gin,
                     name: "zone_containers_tags_idx"
                   )

    drop_if_exists index(:thunderblock_zone_containers, [:coordinates], using: :gin,
                     name: "zone_containers_coords_idx"
                   )


    drop constraint(:thunderblock_communities, "thunderblock_communities_execution_zone_id_fkey")


    drop_if_exists unique_index(:thunderblock_pac_homes, [:owner_id, :home_name],
                     name: "thunderblock_pac_homes_unique_owner_home_name_index"
                   )

    drop_if_exists unique_index(:thunderblock_pac_homes, [:home_slug, :community_id],
                     name: "thunderblock_pac_homes_unique_home_in_community_index"
                   )

    drop constraint(:thunderblock_pac_homes, "thunderblock_pac_homes_zone_container_id_fkey")

    alter table(:thunderblock_pac_homes) do
      modify :zone_container_id, :uuid
    end

    drop table(:thunderblock_zone_containers)

    drop_if_exists unique_index(:thunderline_events, [:correlation_id],
                     name: "thunderline_events_correlation_events_index"
                   )

    drop table(:thunderline_events)

    drop constraint(:lane_configurations, "lane_configurations_rule_oracle_id_fkey")

    drop table(:lane_configurations)

    drop table(:feature_windows)

    drop table(:ising_optimization_runs)

    drop_if_exists unique_index(
                     :thunderlane_cross_lane_coupling,
                     [:source_lane, :target_lane, :ruleset_id],
                     name: "thunderlane_cross_lane_coupling_unique_lane_coupling_index"
                   )

    drop constraint(
           :thunderlane_cross_lane_coupling,
           "thunderlane_cross_lane_coupling_ruleset_id_fkey"
         )

    drop table(:thunderlane_cross_lane_coupling)

    drop constraint(:upm_drift_windows, "upm_drift_windows_snapshot_id_fkey")

    drop table(:upm_drift_windows)

    drop_if_exists unique_index(:error_logs, [:domain, :error_type, :message, :occurred_at],
                     name: "error_logs_unique_error_occurrence_index"
                   )

    drop table(:error_logs)

    drop_if_exists unique_index(:thunderblock_query_optimizations, [:query_hash],
                     name: "thunderblock_query_optimizations_unique_query_hash_index"
                   )

    drop_if_exists index(:thunderblock_query_optimizations, [:query_hash],
                     name: "query_optimizations_hash_idx"
                   )

    drop_if_exists index(:thunderblock_query_optimizations, [:avg_execution_time],
                     name: "query_optimizations_avg_time_idx"
                   )

    drop_if_exists index(:thunderblock_query_optimizations, [:frequency],
                     name: "query_optimizations_frequency_idx"
                   )

    drop_if_exists index(
                     :thunderblock_query_optimizations,
                     [:optimization_suggestions], using: :gin,
                     name: "query_optimizations_suggestions_idx"
                   )

    drop table(:thunderblock_query_optimizations)

    drop_if_exists index(:thunderblock_communities, [:community_slug],
                     name: "communities_slug_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:owner_id, :status],
                     name: "communities_owner_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:status, :member_count],
                     name: "communities_activity_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:community_type, :governance_model],
                     name: "communities_type_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:member_ids], using: :gin,
                     name: "communities_members_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:moderator_ids], using: :gin,
                     name: "communities_moderators_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:tags], using: :gin,
                     name: "communities_tags_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:federation_config], using: :gin,
                     name: "communities_federation_idx"
                   )

    drop_if_exists index(:thunderblock_communities, [:community_metrics], using: :gin,
                     name: "communities_metrics_idx"
                   )


    drop constraint(:thunderblock_pac_homes, "thunderblock_pac_homes_community_id_fkey")


    drop table(:thunderblock_communities)

    drop_if_exists unique_index(:alert_rules, [:name], name: "alert_rules_unique_rule_name_index")

    drop_if_exists unique_index(:alert_rules, [:domain, :component, :metric_name, :condition],
                     name: "alert_rules_unique_metric_rule_index"
                   )

    drop table(:alert_rules)

    drop constraint(
           :thundermag_task_assignments,
           "thundermag_task_assignments_task_execution_id_fkey"
         )

    drop table(:thundermag_task_assignments)

    drop_if_exists unique_index(:external_services, [:base_url],
                     name: "external_services_unique_service_url_index"
                   )

    drop_if_exists unique_index(:external_services, [:name],
                     name: "external_services_unique_service_name_index"
                   )

    drop table(:external_services)


    drop constraint(:thunderlane_coordinators, "thunderlane_coordinators_active_ruleset_id_fkey")

    alter table(:thunderlane_coordinators) do
      modify :active_ruleset_id, :uuid
    end

    drop table(:thunderlane_rulesets)


    drop constraint(
           :thundermag_task_executions,
           "thundermag_task_executions_macro_command_id_fkey"
         )

    alter table(:thundermag_task_executions) do
      modify :macro_command_id, :uuid
    end

    drop table(:thundermag_macro_commands)

    drop_if_exists unique_index(
                     :thunderblock_retention_policies,
                     [:resource, :scope_type, :scope_id],
                     name: "thunderblock_retention_policies_policy_scope_index"
                   )

    drop table(:thunderblock_retention_policies)


    drop constraint(:messages, "messages_conversation_id_fkey")

    drop constraint(:messages, "messages_response_to_id_fkey")

    alter table(:messages) do
      modify :response_to_id, :uuid
      modify :conversation_id, :uuid
    end

    drop table(:conversations)

    drop_if_exists index(:thundercom_realm_identities, [:realm_id])

    drop_if_exists index(:thundercom_realm_identities, [:fingerprint])

    drop_if_exists index(:thundercom_realm_identities, [:verification_status])

    drop table(:thundercom_realm_identities)

    drop_if_exists unique_index(:task_orchestrators, [:workflow_name, :workflow_version],
                     name: "task_orchestrators_unique_workflow_index"
                   )

    drop table(:task_orchestrators)


    drop constraint(:experiences, "experiences_agent_id_fkey")


    drop table(:agents)

    drop_if_exists unique_index(:data_adapters, [:source_format, :target_format, :name],
                     name: "data_adapters_unique_transformation_path_index"
                   )

    drop_if_exists unique_index(:data_adapters, [:name],
                     name: "data_adapters_unique_adapter_name_index"
                   )

    drop table(:data_adapters)

    drop_if_exists unique_index(:thunderblock_load_balancing_rules, [:rule_name, :target_service],
                     name: "thunderblock_load_balancing_rules_unique_rule_service_index"
                   )

    drop table(:thunderblock_load_balancing_rules)

    drop_if_exists unique_index(:upm_adapters, [:adapter_key, :tenant_id],
                     name: "upm_adapters_adapter_key_per_tenant_index"
                   )

    drop constraint(:upm_adapters, "upm_adapters_snapshot_id_fkey")

    drop table(:upm_adapters)

    drop_if_exists unique_index(:health_checks, [:component, :domain, :checked_at],
                     name: "health_checks_unique_check_index"
                   )

    drop table(:health_checks)

    drop_if_exists unique_index(:decision_frameworks, [:name],
                     name: "decision_frameworks_unique_name_index"
                   )

    drop table(:decision_frameworks)

    drop table(:ml_feature_views)

    drop table(:thunderlane_coordinators)

    drop constraint(:ml_model_artifacts, "ml_model_artifacts_spec_id_fkey")

    drop table(:ml_model_artifacts)

    drop table(:dag_snapshots)

    drop table(:ml_model_specs)

    drop_if_exists index(:thunderflow_consciousness_flows, [:agent_id])

    drop_if_exists index(:thunderflow_consciousness_flows, [:consciousness_type])

    drop_if_exists index(:thunderflow_consciousness_flows, [:awareness_level])

    drop_if_exists index(:thunderflow_consciousness_flows, [:stream_position])

    drop_if_exists index(:thunderflow_consciousness_flows, [:inserted_at])

    drop_if_exists index(:thunderflow_consciousness_flows, [:active_goals], using: :gin,
                     name: "consciousness_flow_active_goals_gin_idx"
                   )

    drop_if_exists index(:thunderflow_consciousness_flows, [:memory_anchors], using: :gin,
                     name: "consciousness_flow_memory_anchors_gin_idx"
                   )

    drop table(:thunderflow_consciousness_flows)

    drop table(:export_jobs)

    drop_if_exists index(:thundereye_audit_logs, [:target_resource_type, :target_resource_id],
                     name: "audit_logs_target_idx"
                   )

    drop_if_exists index(:thundereye_audit_logs, [:actor_id, :action_type],
                     name: "audit_logs_actor_idx"
                   )

    drop_if_exists index(:thundereye_audit_logs, [:inserted_at], name: "audit_logs_time_idx")

    drop table(:thundereye_audit_logs)

    drop_if_exists index(:thunderblock_pac_homes, [:home_slug, :community_id],
                     name: "pac_homes_slug_community_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:owner_id, :status],
                     name: "pac_homes_owner_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:community_id, :status],
                     name: "pac_homes_community_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:status, :last_activity],
                     name: "pac_homes_activity_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:suspended_until],
                     name: "pac_homes_suspension_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:last_health_check],
                     name: "pac_homes_health_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:agent_registry], using: :gin,
                     name: "pac_homes_agents_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:current_usage], using: :gin,
                     name: "pac_homes_usage_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:health_metrics], using: :gin,
                     name: "pac_homes_health_metrics_idx"
                   )

    drop_if_exists index(:thunderblock_pac_homes, [:tags], using: :gin,
                     name: "pac_homes_tags_idx"
                   )

    drop table(:thunderblock_pac_homes)

    drop constraint(:thunderblock_messages, "thunderblock_messages_reply_to_id_fkey")

    drop constraint(:thunderblock_messages, "thunderblock_messages_thread_root_id_fkey")

    drop_if_exists index(:thunderblock_messages, [:channel_id, :inserted_at],
                     name: "messages_channel_time_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:sender_id, :inserted_at],
                     name: "messages_sender_time_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:thread_root_id, :inserted_at],
                     name: "messages_thread_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:reply_to_id], name: "messages_reply_idx")

    drop_if_exists index(:thunderblock_messages, [:status, :inserted_at],
                     name: "messages_status_time_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:message_type, :sender_type],
                     name: "messages_type_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:ephemeral_until],
                     name: "messages_ephemeral_idx"
                   )

    execute "DROP INDEX IF EXISTS messages_search_idx"

    drop_if_exists index(:thunderblock_messages, [:mentions], using: :gin,
                     name: "messages_mentions_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:message_flags], using: :gin,
                     name: "messages_flags_idx"
                   )

    drop_if_exists index(:thunderblock_messages, [:tags], using: :gin, name: "messages_tags_idx")

    drop_if_exists index(:thunderblock_messages, [:reactions], using: :gin,
                     name: "messages_reactions_idx"
                   )

    drop table(:thunderblock_messages)

    drop table(:upm_snapshots)

    drop_if_exists index(:probe_runs, [:status])

    drop_if_exists index(:probe_runs, [:provider])

    drop_if_exists index(:probe_runs, [:model])

    drop table(:probe_runs)

    drop table(:dag_edges)

    drop_if_exists unique_index(:thundercore_agents, [:agent_name],
                     name: "thundercore_agents_unique_agent_name_index"
                   )

    drop table(:thundercore_agents)

    drop table(:experiences)

    drop_if_exists unique_index(:thunderblock_cache_entries, [:cache_key],
                     name: "thunderblock_cache_entries_unique_cache_key_index"
                   )

    drop_if_exists index(:thunderblock_cache_entries, [:cache_key], name: "cache_entries_key_idx")

    drop_if_exists index(:thunderblock_cache_entries, [:expires_at],
                     name: "cache_entries_expires_idx"
                   )

    drop_if_exists index(:thunderblock_cache_entries, [:cache_tags],
                     name: "cache_entries_tags_idx"
                   )

    drop table(:thunderblock_cache_entries)

    drop table(:messages)

    drop table(:ml_training_runs)

    drop_if_exists unique_index(:ml_consent_records, [:user_id, :tenant_id, :purpose],
                     name: "ml_consent_records_unique_consent_index"
                   )

    drop table(:ml_consent_records)

    drop_if_exists unique_index(
                     :system_metrics,
                     [:domain, :metric_name, :collected_at, :node_name],
                     name: "system_metrics_unique_metric_point_index"
                   )

    drop table(:system_metrics)

    drop table(:thundermag_task_executions)

    drop table(:tokens)

    drop_if_exists index(:thundereye_system_actions, [:domain, :status],
                     name: "system_actions_domain_status_idx"
                   )

    drop_if_exists index(:thundereye_system_actions, [:action_name, :inserted_at],
                     name: "system_actions_name_time_idx"
                   )

    drop_if_exists index(:thundereye_system_actions, [:status, :inserted_at],
                     name: "system_actions_status_time_idx"
                   )

    drop table(:thundereye_system_actions)

    drop table(:voice_rooms)

    drop_if_exists unique_index(:performance_traces, [:trace_id, :span_name],
                     name: "performance_traces_unique_span_index"
                   )

    drop table(:performance_traces)

    drop table(:thunderlane_rule_oracles)

    drop table(:decision_traces)
  end
end
